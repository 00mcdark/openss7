/*****************************************************************************

 @(#) File: src/snmp/mtpMIB.c

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 *****************************************************************************/

static char const ident[] = "src/snmp/mtpMIB.c (" PACKAGE_ENVR ") " PACKAGE_DATE;

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NETSNMP_MEMDUP
#include "ucd_memdup.h"
#endif
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "mtpMIB.h"
#undef MASTER
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "mtpMIB";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int mtpMIB_refresh = 1;
volatile int mtpSapTable_refresh = 1;
volatile int mtpNaTable_refresh = 1;
volatile int mtpMsTable_refresh = 1;
volatile int mtpSpProfileTable_refresh = 1;
volatile int mtpSpTable_refresh = 1;
volatile int mtpL3Table_refresh = 1;
volatile int mtpGsTable_refresh = 1;
volatile int mtpGsLineTable_refresh = 1;
volatile int mtpGsLineContentTable_refresh = 1;
volatile int mtpRsProfileTable_refresh = 1;
volatile int mtpRsTable_refresh = 1;
volatile int mtpRtProfileTable_refresh = 1;
volatile int mtpRtTable_refresh = 1;
volatile int mtpRtLsaTable_refresh = 1;
volatile int mtpLsProfileTable_refresh = 1;
volatile int mtpLsTable_refresh = 1;
volatile int mtpSlL3ProfileTable_refresh = 1;
volatile int mtpSlL2ProfileTable_refresh = 1;
volatile int mtpSlTable_refresh = 1;
volatile int mtpSlSdlListTable_refresh = 1;
volatile int mtpSlSdtListTable_refresh = 1;
volatile int mtpNbTable_refresh = 1;
volatile int mtpSaalTable_refresh = 1;
volatile int mtpM2paTable_refresh = 1;
volatile int mtpSdtTable_refresh = 1;
volatile int mtpSdlTable_refresh = 1;
volatile int mtpSctpProfileTable_refresh = 1;
volatile int mtpSctpTable_refresh = 1;
volatile int mtpSctpLocalTable_refresh = 1;
volatile int mtpSctpRemoteTable_refresh = 1;
volatile int mtpM2uaAspTable_refresh = 1;
volatile int mtpM2uaAsTable_refresh = 1;
volatile int mtpM3uaAspTable_refresh = 1;
volatile int mtpM3uaAsTable_refresh = 1;

/*
 * mtpMIB_variables_oid: object identifier for mtpMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid mtpMIB_variables_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1 };
oid mtpSapTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 1, 1, 1 };
oid mtpNaTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 2, 1, 1 };
oid mtpMsTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 3, 1, 1 };
oid mtpSpProfileTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 1, 1 };
oid mtpSpTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 4, 2, 1 };
oid mtpL3Table_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 5, 1, 1 };
oid mtpGsTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 1, 1 };
oid mtpGsLineTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 2, 1 };
oid mtpGsLineContentTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 6, 3, 1 };
oid mtpRsProfileTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 7, 1, 1 };
oid mtpRsTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 7, 2, 1 };
oid mtpRtProfileTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 8, 1, 1 };
oid mtpRtTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 8, 2, 1 };
oid mtpLsProfileTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 9, 1, 1 };
oid mtpLsTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 9, 2, 1 };
oid mtpSlL3ProfileTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 1, 1 };
oid mtpSlL2ProfileTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 2, 1 };
oid mtpSlTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 3, 1 };
oid mtpSlSdlListTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 4, 1 };
oid mtpSlSdtListTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 10, 5, 1 };
oid mtpNbTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 1, 1 };
oid mtpSaalTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 2, 1 };
oid mtpM2paTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 3, 1 };
oid mtpSdtTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 11, 4, 1 };
oid mtpSdlTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 12, 1, 1 };
oid mtpSctpProfileTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 13, 1, 1 };
oid mtpSctpTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 13, 2, 1 };
oid mtpSctpLocalTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 13, 3, 1 };
oid mtpSctpRemoteTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 13, 4, 1 };
oid mtpM2uaAspTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 13, 5, 1 };
oid mtpM2uaAsTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 13, 6, 1 };
oid mtpM3uaAspTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 13, 7, 1 };
oid mtpM3uaAsTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 1, 13, 8, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid mtpRestarting_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 1 };
oid ss7OnOccEvent_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 2 };
oid sdlEventLostSync_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 3 };
oid sdlEventSuError_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 4 };
oid sdlEventTxFail_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 5 };
oid sdlEventRxFail_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 6 };
oid sdtEventLostSync_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 7 };
oid sdtEventSuError_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 8 };
oid sdtEventTxFail_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 9 };
oid sdtEventRxFail_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 10 };
oid sdtEventCarrier_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 11 };
oid slEventFailureAllReasons_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 12 };
oid slEventFailureAbnormalBsnrFibr_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 13 };
oid slEventFailureExcessiveDelayOfAck_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 14 };
oid slEventFailureExcessiveErrorRate_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 15 };
oid slEventFailureExcessiveDurationCongestion_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 16 };
oid slEventLocalAutomaticChangeover_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 17 };
oid slEventLocalAutomaticChangeback_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 18 };
oid slEventRestoration_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 19 };
oid slEventRpoStartEvent_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 20 };
oid slEventRpoStopEvent_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 21 };
oid slEventLocalInhibitionStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 22 };
oid slEventLocalInhibitionStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 23 };
oid slEventRemoteInhibitionStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 24 };
oid slEventRemoteInhibitionStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 25 };
oid slEventCongestionStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 26 };
oid slEventCongestionStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 27 };
oid slEventCongestionLoss_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 28 };
oid lkEventFailureStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 29 };
oid lkEventFailureStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 30 };
oid lkEventSendTFP_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 31 };
oid lkEventSendTFA_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 32 };
oid rsEventUnavailableStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 33 };
oid rsEventUnavailableStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 34 };
oid rsEventAdjSpLinkSetChange_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 35 };
oid rsEventAdjSPInaccessibleStart_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 36 };
oid rsEventAdjSpInaccessibleStop_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 37 };
oid rsEventRecvTFC_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 38 };
oid spEventMsuDiscard_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 39 };
oid spEventUpuSent_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 40 };
oid spEventUpuRecv_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 0, 41 };

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid changeInLsToAdjSp_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 3, 1 };
oid oldLs_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 3, 2 };
oid newLs_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 3, 3 };
oid inaccessibleSp_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 3, 4 };
oid remoteUnavailableUserPart_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 3, 5 };
oid congestionStatus_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 3, 6 };
oid networkPointCode_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 3, 7 };
oid userPart_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 3, 8 };
oid userPartStatus_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 3, 9 };
oid linkFailureReason_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 3, 10 };

/*
 * Other oids defined in this MIB.
 */
oid mtpProtocolItut_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 1, 1 };
oid mtpProtocolEtsi_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 1, 2 };
oid mtpProtocolAnsi_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 1, 3 };
oid mtpProtocolJttc_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 1, 4 };
oid mtpProtocolChin_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 1, 5 };
oid mtpProtocolPnoc_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 1, 6 };
oid mtpProtocolSing_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 1, 7 };
oid mtpProtocolSpan_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 1, 8 };
oid localUserPartUnavailable_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 1 };
oid remoteUserPartUnavailable_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 2 };
oid slFailure_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 102 };
oid localAutomaticChange_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 110 };
oid remoteProcOutage_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 210 };
oid localInhibition_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 216 };
oid remoteInhibition_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 218 };
oid linkCongestionIndications_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 306 };
oid linkCongestionDiscard_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 311 };
oid linkSetFailure_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 403 };
oid linkSetFailureTFPBroadcast_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 405 };
oid routesetUnavailability_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 411 };
oid linksetAdjSpChange_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 413 };
oid adjSpInaccessibility_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 501 };
oid routingDataError_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 505 };
oid userPartUnavailableSent_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 506 };
oid userPartUnavailableReceived_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 507 };
oid transferControlledReceived_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 2, 508 };
oid abnormalFIBRorBSNR_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 3, 3 };
oid excessiveAckDelay_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 3, 4 };
oid excessiveErrorRate_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 3, 5 };
oid excessiveCongDuration_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 3, 6 };
oid remoteUPUnknown_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 3, 7 };
oid remoteUPUnequipped_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 3, 8 };
oid remoteUPInaccessible_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 3, 9 };
oid defaultInLsLoadShareAlgorithm_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 4, 1 };
oid mtpLsProfileCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 1 };
oid mtpSapCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 2 };
oid mtpL2ProfocolProfileCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 3 };
oid mtpNbProfileCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 4 };
oid mtpSaalProfileCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 5 };
oid mtpM2paProfileCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 6 };
oid mtpL3Compliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 7 };
oid mtpSpCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 8 };
oid mtpSdlCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 9 };
oid mtpLsCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 10 };
oid mtpSlCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 11 };
oid mtpSlL3ProfileCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 12 };
oid mtpSpProfileCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 13 };
oid mtpRtCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 14 };
oid mtpSignRouteSetNetPartCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 15 };
oid mtpStCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 16 };
oid mtpGsCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 17 };
oid mtpGsLineCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 18 };
oid mtpAdditionalCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 1, 19 };
oid mtpLsProfilePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 1 };
oid mtpSapPkg_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 2 };
oid mtpSlL2ProfilePkg_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 3 };
oid mtpL3Package_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 4 };
oid mtpSpPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 5 };
oid mtpSdlPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 6 };
oid mtpLsPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 7 };
oid mtpSlPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 8 };
oid mtpSlL3ProfilePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 9 };
oid mtpSpProfilePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 10 };
oid mtpRtPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 11 };
oid mtpRsPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 12 };
oid mtpStPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 13 };
oid mtpGsPkg_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 14 };
oid mtpGsLinePkg_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 15 };
oid administrativeStatePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 16 };
oid bufferMechanismPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 17 };
oid cICPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 18 };
oid clsLoadsharingInformationPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 19 };
oid congestedStatePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 20 };
oid congestionHandlingPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 21 };
oid congestionLevelPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 22 };
oid getScreenedOpcsOrLinkSetsByDpcActionPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 23 };
oid fixedRouteNePartPriorityPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 24 };
oid flexibleRouteNePartPriorityPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 25 };
oid inLsLoadShareAlgorithmPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 26 };
oid linkCongestionLevelPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 27 };
oid loadsharingInformationRouteNePartPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 28 };
oid loadsharingInformationRouteSetNePartPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 29 };
oid loopDelayPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 30 };
oid mtpLsProfileNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 31 };
oid mtpLsProfilePointerPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 32 };
oid mtpSapNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 33 };
oid mtpSlL2ProfileNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 34 };
oid mtpL3NamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 35 };
oid mtpLoadsharingObjectForRouteNePartPointerPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 36 };
oid mtpLoadsharingObjectForRouteSetNePartPointerPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 37 };
oid mtpSpNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 38 };
oid multipleTransmissionCongestionLevelsPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 39 };
oid multipleTransmissionCongestionLevelsWithPrioPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 40 };
oid multipleTransmissionCongestionStatesPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 41 };
oid noBasicLinkAllocationPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 42 };
oid pCRPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 43 };
oid receiveCongestionLevelsPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 44 };
oid relatedLinkGroupNumberPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 45 };
oid remoteExchangeLabelPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 46 };
oid mtpSdlListPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 47 };
oid mtpSdlNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 48 };
oid mtpLsNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 49 };
oid mtpSignLinkTestPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 50 };
oid mtpSlNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 51 };
oid mtpRtNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 52 };
oid mtpRsNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 53 };
oid mtpStListPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 54 };
oid mtpStNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 55 };
oid slsCodeNormalListPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 56 };
oid slsListPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 57 };
oid mtpSlL3ProfileNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 58 };
oid mtpSlL3ProfilePointerPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 59 };
oid mtpRestartingNotification_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 60 };
oid mtpSpTimersPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 61 };
oid mtpSpProfileNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 62 };
oid mtpSpProfilePointerPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 63 };
oid ss7OnOccEventPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 64 };
oid stmChannelPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 65 };
oid mtpGsNamePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 66 };
oid usageStatePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 67 };
oid broadbandSpecificPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 68 };
oid egressTransmissionRateIntervalPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 69 };
oid longMessageSupportedPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 70 };
oid narrowbandSpecificPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 71 };
oid pollAfterRetransmissionPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 72 };
oid mtpSaalProfilePackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 73 };
oid saalSdlPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 74 };
oid m2paSctpDefaultsPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 75 };
oid mtpM2paProfilePkg_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 76 };
oid m2paProvingPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 77 };
oid providerEntityNamesPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 78 };
oid mtpRestartingParameters_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 79 };
oid ss7OnOccEventParameters_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 80 };
oid mtpSapAsaPointerPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 81 };
oid mtpL3AsaPointerPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 82 };
oid mtpSlAsaPointerPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 83 };
oid mtpRsAsaPointerPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 84 };
oid mtpLsAsaPointerPackage_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 85 };
oid mtpSapGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 86 };
oid mtpNaGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 87 };
oid mtpMsGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 88 };
oid mtpSpGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 89 };
oid mtpGsLineGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 90 };
oid mtpRsProfileGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 91 };
oid mtpRtProfileGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 92 };
oid mtpLsProfileGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 93 };
oid mtpSlL3ProfileGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 94 };
oid mtpSlL2ProfileGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 95 };
oid mtpNbGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 96 };
oid mtpSctpProfileGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 97 };
oid mtpSctpGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 98 };
oid mtpM2uaGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 99 };
oid mtpM3uaGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 100 };
oid mtpAlarmStatusGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 101 };
oid mtpSdlEventGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 102 };
oid mtpSdtEventGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 103 };
oid mtpSlEventGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 104 };
oid mtpLkEventGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 105 };
oid mtpRsEventGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 106 };
oid mtpSpEventGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 2, 2, 107 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 mtpMIB_variables: tree for mtpMIB
 * This variable defines function callbacks and type return information for the mtpMIB mib section
 */
struct variable7 mtpMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   MTPSAP2ADDRESS        1
	{(u_char) MTPSAP2ADDRESS, ASN_OCTET_STR, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 2}},
#define   MTPSAPUSERPART        2
	{(u_char) MTPSAPUSERPART, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 3}},
#define   MTPSAPUSERPARTSTATUS  3
	{(u_char) MTPSAPUSERPARTSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 4}},
#define   MTPSAPUSERENTITYNAMES  4
	{(u_char) MTPSAPUSERENTITYNAMES, ASN_OBJECT_ID, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 5}},
#define   MTPSAPPROVIDERENTITYNAMES  5
	{(u_char) MTPSAPPROVIDERENTITYNAMES, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 6}},
#define   MTPSAPUSAGESTATE      6
	{(u_char) MTPSAPUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 7}},
#define   MTPSAPASAPROFILEPOINTER  7
	{(u_char) MTPSAPASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 8}},
#define   MTPSAPNAME            8
	{(u_char) MTPSAPNAME, ASN_OCTET_STR, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 9}},
#define   MTPSAPLONGMESSAGESUPPORTED  9
	{(u_char) MTPSAPLONGMESSAGESUPPORTED, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 10}},
#define   MTPSAPROWSTATUS       10
	{(u_char) MTPSAPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSapTable, 6, {1, 1, 1, 1, 1, 11}},
#define   MTPNAPROTOCOLVARIANT  11
	{(u_char) MTPNAPROTOCOLVARIANT, ASN_OBJECT_ID, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 2}},
#define   MTPNAPROTOCOLYEAR     12
	{(u_char) MTPNAPROTOCOLYEAR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 3}},
#define   MTPNAPROTOCOLOPTIONS  13
	{(u_char) MTPNAPROTOCOLOPTIONS, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 4}},
#define   MTPNANETWORKINDICATOR  14
	{(u_char) MTPNANETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 5}},
#define   MTPNAPOINTCODEFORMAT  15
	{(u_char) MTPNAPOINTCODEFORMAT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 6}},
#define   MTPNASLSLENGTH        16
	{(u_char) MTPNASLSLENGTH, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 7}},
#define   MTPNASPDEFAULT        17
	{(u_char) MTPNASPDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 8}},
#define   MTPNANAME             18
	{(u_char) MTPNANAME, ASN_OCTET_STR, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 9}},
#define   MTPNAROWSTATUS        19
	{(u_char) MTPNAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNaTable, 6, {1, 1, 2, 1, 1, 10}},
#define   MTPMSNAME             20
	{(u_char) MTPMSNAME, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 2}},
#define   MTPMSALARMSTATUS      21
	{(u_char) MTPMSALARMSTATUS, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 3}},
#define   MTPMSOPERATIONALSTATE  22
	{(u_char) MTPMSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 4}},
#define   MTPMSUSAGESTATE       23
	{(u_char) MTPMSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 5}},
#define   MTPMSMANAGEDELEMENTTYPE  24
	{(u_char) MTPMSMANAGEDELEMENTTYPE, ASN_OCTET_STR, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 6}},
#define   MTPMSMODELCODE        25
	{(u_char) MTPMSMODELCODE, ASN_OCTET_STR, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 7}},
#define   MTPMSVENDORNAME       26
	{(u_char) MTPMSVENDORNAME, ASN_OCTET_STR, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 8}},
#define   MTPMSUSERLABEL        27
	{(u_char) MTPMSUSERLABEL, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 9}},
#define   MTPMSVERSION          28
	{(u_char) MTPMSVERSION, ASN_OCTET_STR, RONLY, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 10}},
#define   MTPMSASAPROFILEPOINTER  29
	{(u_char) MTPMSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 11}},
#define   MTPMSNETWORKELEMENTALIASES  30
	{(u_char) MTPMSNETWORKELEMENTALIASES, ASN_OCTET_STR, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 12}},
#define   MTPMSROWSTATUS        31
	{(u_char) MTPMSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpMsTable, 6, {1, 1, 3, 1, 1, 13}},
#define   MTPSPPROFILETIMERT1R  32
	{(u_char) MTPSPPROFILETIMERT1R, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 2}},
#define   MTPSPPROFILETIMERT2   33
	{(u_char) MTPSPPROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 3}},
#define   MTPSPPROFILETIMERT4   34
	{(u_char) MTPSPPROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 4}},
#define   MTPSPPROFILETIMERT5   35
	{(u_char) MTPSPPROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 5}},
#define   MTPSPPROFILETIMERT7   36
	{(u_char) MTPSPPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 6}},
#define   MTPSPPROFILETIMERT11  37
	{(u_char) MTPSPPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 7}},
#define   MTPSPPROFILETIMERT12  38
	{(u_char) MTPSPPROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 8}},
#define   MTPSPPROFILETIMERT13  39
	{(u_char) MTPSPPROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 9}},
#define   MTPSPPROFILETIMERT14  40
	{(u_char) MTPSPPROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 10}},
#define   MTPSPPROFILETIMERT15  41
	{(u_char) MTPSPPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 11}},
#define   MTPSPPROFILETIMERT16  42
	{(u_char) MTPSPPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 12}},
#define   MTPSPPROFILETIMERT18I  43
	{(u_char) MTPSPPROFILETIMERT18I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 13}},
#define   MTPSPPROFILETIMERT19I  44
	{(u_char) MTPSPPROFILETIMERT19I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 14}},
#define   MTPSPPROFILETIMERT20I  45
	{(u_char) MTPSPPROFILETIMERT20I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 15}},
#define   MTPSPPROFILETIMERT21I  46
	{(u_char) MTPSPPROFILETIMERT21I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 16}},
#define   MTPSPPROFILETIMERT22I  47
	{(u_char) MTPSPPROFILETIMERT22I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 17}},
#define   MTPSPPROFILETIMERT23I  48
	{(u_char) MTPSPPROFILETIMERT23I, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 18}},
#define   MTPSPPROFILETIMERT20A  49
	{(u_char) MTPSPPROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 19}},
#define   MTPSPPROFILETIMERT21A  50
	{(u_char) MTPSPPROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 20}},
#define   MTPSPPROFILETIMERT22A  51
	{(u_char) MTPSPPROFILETIMERT22A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 21}},
#define   MTPSPPROFILETIMERT23A  52
	{(u_char) MTPSPPROFILETIMERT23A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 22}},
#define   MTPSPPROFILETIMERT24A  53
	{(u_char) MTPSPPROFILETIMERT24A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 23}},
#define   MTPSPPROFILETIMERT26A  54
	{(u_char) MTPSPPROFILETIMERT26A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 24}},
#define   MTPSPPROFILETIMERT27A  55
	{(u_char) MTPSPPROFILETIMERT27A, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 25}},
#define   MTPSPPROFILETIMERT1T  56
	{(u_char) MTPSPPROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 26}},
#define   MTPSPPROFILETIMERT2T  57
	{(u_char) MTPSPPROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 27}},
#define   MTPSPPROFILENAME      58
	{(u_char) MTPSPPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 28}},
#define   MTPSPPROFILECIRCULARRTEDETECT  59
	{(u_char) MTPSPPROFILECIRCULARRTEDETECT, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 29}},
#define   MTPSPRSDEFAULT        60
	{(u_char) MTPSPRSDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 30}},
#define   MTPSPLSDEFAULT        61
	{(u_char) MTPSPLSDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 31}},
#define   MTPSPPROFILEROWSTATUS  62
	{(u_char) MTPSPPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpProfileTable, 6, {1, 1, 4, 1, 1, 32}},
#define   MTPSPPOINTCODE        63
	{(u_char) MTPSPPOINTCODE, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 2}},
#define   MTPSPTYPE             64
	{(u_char) MTPSPTYPE, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 3}},
#define   MTPSPOPERATIONALSTATE  65
	{(u_char) MTPSPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 4}},
#define   MTPSPPROCEDURALSTATUS  66
	{(u_char) MTPSPPROCEDURALSTATUS, ASN_OCTET_STR, RONLY, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 5}},
#define   MTPSPAVAILABILITYSTATUS  67
	{(u_char) MTPSPAVAILABILITYSTATUS, ASN_OCTET_STR, RONLY, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 6}},
#define   MTPSPVERSION          68
	{(u_char) MTPSPVERSION, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 7}},
#define   MTPSPNETWORKINDICATOR  69
	{(u_char) MTPSPNETWORKINDICATOR, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 8}},
#define   MTPSPNAME             70
	{(u_char) MTPSPNAME, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 9}},
#define   MTPSPPROFILEPOINTER   71
	{(u_char) MTPSPPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 10}},
#define   MTPSPNAPOINTER        72
	{(u_char) MTPSPNAPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 11}},
#define   MTPSPOPTIONS          73
	{(u_char) MTPSPOPTIONS, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 12}},
#define   MTPSPUSERS            74
	{(u_char) MTPSPUSERS, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 13}},
#define   MTPSPALARMSTATUS      75
	{(u_char) MTPSPALARMSTATUS, ASN_OCTET_STR, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 14}},
#define   MTPSPROWSTATUS        76
	{(u_char) MTPSPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSpTable, 6, {1, 1, 4, 2, 1, 15}},
#define   MTPL3ADMINISTRATIVESTATE  77
	{(u_char) MTPL3ADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 2}},
#define   MTPL3OPERATIONALSTATE  78
	{(u_char) MTPL3OPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 3}},
#define   MTPL3USAGESTATE       79
	{(u_char) MTPL3USAGESTATE, ASN_INTEGER, RONLY, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 4}},
#define   MTPL3PROCEDURALSTATUS  80
	{(u_char) MTPL3PROCEDURALSTATUS, ASN_OCTET_STR, RONLY, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 5}},
#define   MTPL3ASAPROFILEPOINTER  81
	{(u_char) MTPL3ASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 6}},
#define   MTPL3NAME             82
	{(u_char) MTPL3NAME, ASN_OCTET_STR, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 7}},
#define   MTPL3ROWSTATUS        83
	{(u_char) MTPL3ROWSTATUS, ASN_INTEGER, RWRITE, var_mtpL3Table, 6, {1, 1, 5, 1, 1, 8}},
#define   MTPGSADMINISTRATIVESTATE  84
	{(u_char) MTPGSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 2}},
#define   MTPGSTREATMENTOFOUTSIDERANGES  85
	{(u_char) MTPGSTREATMENTOFOUTSIDERANGES, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 3}},
#define   MTPGSLISTMODE         86
	{(u_char) MTPGSLISTMODE, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 4}},
#define   MTPGSSCREENINGBYLINKSETORBYOPC  87
	{(u_char) MTPGSSCREENINGBYLINKSETORBYOPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 5}},
#define   MTPGSGETSCREENEDOPCSORLINKSETSBYDPC  88
	{(u_char) MTPGSGETSCREENEDOPCSORLINKSETSBYDPC, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 6}},
#define   MTPGSNAME             89
	{(u_char) MTPGSNAME, ASN_OCTET_STR, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 7}},
#define   MTPGSROWSTATUS        90
	{(u_char) MTPGSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsTable, 6, {1, 1, 6, 1, 1, 8}},
#define   MTPGSLINEOBJECT       91
	{(u_char) MTPGSLINEOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpGsLineTable, 6, {1, 1, 6, 2, 1, 2}},
#define   MTPGSLINECONTENT      92
	{(u_char) MTPGSLINECONTENT, ASN_UNSIGNED, RWRITE, var_mtpGsLineTable, 6, {1, 1, 6, 2, 1, 3}},
#define   MTPGSLINEROWSTATUS    93
	{(u_char) MTPGSLINEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineTable, 6, {1, 1, 6, 2, 1, 4}},
#define   MTPGSLINECONTENTDESIGNATEDDPCFIRST  94
	{(u_char) MTPGSLINECONTENTDESIGNATEDDPCFIRST, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 2}},
#define   MTPGSLINECONTENTDESIGNATEDDPCLAST  95
	{(u_char) MTPGSLINECONTENTDESIGNATEDDPCLAST, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 3}},
#define   MTPGSLINECONTENTSIMASK  96
	{(u_char) MTPGSLINECONTENTSIMASK, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 4}},
#define   MTPGSLINECONTENTMESSAGETREATMENT  97
	{(u_char) MTPGSLINECONTENTMESSAGETREATMENT, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 5}},
#define   MTPGSLINECONTENTCOMMENT  98
	{(u_char) MTPGSLINECONTENTCOMMENT, ASN_OCTET_STR, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 6}},
#define   MTPGSLINECONTENTROWSTATUS  99
	{(u_char) MTPGSLINECONTENTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpGsLineContentTable, 6, {1, 1, 6, 3, 1, 7}},
#define   MTPRSPROFILENAME      100
	{(u_char) MTPRSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 2}},
#define   MTPRSPROFILETIMERT8   101
	{(u_char) MTPRSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 3}},
#define   MTPRSPROFILETIMERT11  102
	{(u_char) MTPRSPROFILETIMERT11, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 4}},
#define   MTPRSPROFILETIMERT15  103
	{(u_char) MTPRSPROFILETIMERT15, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 5}},
#define   MTPRSPROFILETIMERT16  104
	{(u_char) MTPRSPROFILETIMERT16, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 6}},
#define   MTPRSPROFILETIMERT18A  105
	{(u_char) MTPRSPROFILETIMERT18A, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 7}},
#define   MTPRSPROFILERTDEFAULT  106
	{(u_char) MTPRSPROFILERTDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 8}},
#define   MTPRSPROFILEROWSTATUS  107
	{(u_char) MTPRSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsProfileTable, 6, {1, 1, 7, 1, 1, 9}},
#define   MTPRSDEST             108
	{(u_char) MTPRSDEST, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 2}},
#define   MTPRSOPTIONS          109
	{(u_char) MTPRSOPTIONS, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 3}},
#define   MTPRSADMINISTRATIVESTATE  110
	{(u_char) MTPRSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 4}},
#define   MTPRSOPERATIONALSTATE  111
	{(u_char) MTPRSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 5}},
#define   MTPRSASAPROFILEPOINTER  112
	{(u_char) MTPRSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 6}},
#define   MTPRSCONGESTEDSTATE   113
	{(u_char) MTPRSCONGESTEDSTATE, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 7}},
#define   MTPRSCONGESTIONLEVEL  114
	{(u_char) MTPRSCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 8}},
#define   MTPRSLOADSHARINGINFORMATION  115
	{(u_char) MTPRSLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 9}},
#define   MTPRSLOADSHARINGOBJECT  116
	{(u_char) MTPRSLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 10}},
#define   MTPRSREMOTEEXCHANGELABEL  117
	{(u_char) MTPRSREMOTEEXCHANGELABEL, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 11}},
#define   MTPRSNAME             118
	{(u_char) MTPRSNAME, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 12}},
#define   MTPRSPROFILE          119
	{(u_char) MTPRSPROFILE, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 13}},
#define   MTPRSALARMSTATUS      120
	{(u_char) MTPRSALARMSTATUS, ASN_OCTET_STR, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 14}},
#define   MTPRSROWSTATUS        121
	{(u_char) MTPRSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRsTable, 6, {1, 1, 7, 2, 1, 15}},
#define   MTPRTPROFILETIMERT6   122
	{(u_char) MTPRTPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 2}},
#define   MTPRTPROFILETIMERT10  123
	{(u_char) MTPRTPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 3}},
#define   MTPRTPROFILEROWSTATUS  124
	{(u_char) MTPRTPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtProfileTable, 6, {1, 1, 8, 1, 1, 4}},
#define   MTPRTLSPOINTER        125
	{(u_char) MTPRTLSPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 2}},
#define   MTPRTADMINISTRATIVESTATE  126
	{(u_char) MTPRTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 3}},
#define   MTPRTOPERATIONALSTATE  127
	{(u_char) MTPRTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 4}},
#define   MTPRTAVAILABILITYSTATUS  128
	{(u_char) MTPRTAVAILABILITYSTATUS, ASN_OCTET_STR, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 5}},
#define   MTPRTINCLSLOADSHARINGALGORITHM  129
	{(u_char) MTPRTINCLSLOADSHARINGALGORITHM, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 6}},
#define   MTPRTFIXEDPRIORITY    130
	{(u_char) MTPRTFIXEDPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 7}},
#define   MTPRTFLEXIBLEPRIORITY  131
	{(u_char) MTPRTFLEXIBLEPRIORITY, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 8}},
#define   MTPRTPRIORITYMODE     132
	{(u_char) MTPRTPRIORITYMODE, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 9}},
#define   MTPRTLOADSHARINGINFORMATION  133
	{(u_char) MTPRTLOADSHARINGINFORMATION, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 10}},
#define   MTPRTLOADSHARINGOBJECT  134
	{(u_char) MTPRTLOADSHARINGOBJECT, ASN_OBJECT_ID, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 11}},
#define   MTPRTNAME             135
	{(u_char) MTPRTNAME, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 12}},
#define   MTPRTSLSLIST          136
	{(u_char) MTPRTSLSLIST, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 13}},
#define   MTPRTUSAGESTATE       137
	{(u_char) MTPRTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 14}},
#define   MTPRTRLSLOT           138
	{(u_char) MTPRTRLSLOT, ASN_UNSIGNED, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 15}},
#define   MTPRTPROFILE          139
	{(u_char) MTPRTPROFILE, ASN_OCTET_STR, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 16}},
#define   MTPRTROWSTATUS        140
	{(u_char) MTPRTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpRtTable, 6, {1, 1, 8, 2, 1, 17}},
#define   MTPRTLSANORMALSLCODE  141
	{(u_char) MTPRTLSANORMALSLCODE, ASN_INTEGER, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 8, 3, 1, 2}},
#define   MTPRTLSAALTERNATIVESLCODELIST  142
	{(u_char) MTPRTLSAALTERNATIVESLCODELIST, ASN_OCTET_STR, RWRITE, var_mtpRtLsaTable, 6, {1, 1, 8, 3, 1, 3}},
#define   MTPLSPROFILETIMERT6   143
	{(u_char) MTPLSPROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 2}},
#define   MTPLSPROFILETIMERT8   144
	{(u_char) MTPLSPROFILETIMERT8, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 3}},
#define   MTPLSPROFILETIMERT10  145
	{(u_char) MTPLSPROFILETIMERT10, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 4}},
#define   MTPLSPROFILETIMERT7   146
	{(u_char) MTPLSPROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 5}},
#define   MTPLSPROFILETIMERT19I  147
	{(u_char) MTPLSPROFILETIMERT19I, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 6}},
#define   MTPLSPROFILETIMERT21I  148
	{(u_char) MTPLSPROFILETIMERT21I, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 7}},
#define   MTPLSPROFILETIMERT25A  149
	{(u_char) MTPLSPROFILETIMERT25A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 8}},
#define   MTPLSPROFILETIMERT28A  150
	{(u_char) MTPLSPROFILETIMERT28A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 9}},
#define   MTPLSPROFILETIMERT29A  151
	{(u_char) MTPLSPROFILETIMERT29A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 10}},
#define   MTPLSPROFILETIMERT30A  152
	{(u_char) MTPLSPROFILETIMERT30A, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 11}},
#define   MTPLSPROFILEPARAMETERN  153
	{(u_char) MTPLSPROFILEPARAMETERN, ASN_UNSIGNED, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 12}},
#define   MTPLSPROFILEPARAMETERM  154
	{(u_char) MTPLSPROFILEPARAMETERM, ASN_UNSIGNED, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 13}},
#define   MTPLSPROFILENAME      155
	{(u_char) MTPLSPROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 14}},
#define   MTPLSPROFILESLDEFAULT  156
	{(u_char) MTPLSPROFILESLDEFAULT, ASN_OCTET_STR, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 15}},
#define   MTPLSPROFILEROWSTATUS  157
	{(u_char) MTPLSPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsProfileTable, 6, {1, 1, 9, 1, 1, 16}},
#define   MTPLSADJPC            158
	{(u_char) MTPLSADJPC, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 2}},
#define   MTPLSRSID             159
	{(u_char) MTPLSRSID, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 3}},
#define   MTPLSMAXCAPACITY      160
	{(u_char) MTPLSMAXCAPACITY, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 4}},
#define   MTPLSCURRENTCAPACITY  161
	{(u_char) MTPLSCURRENTCAPACITY, ASN_UNSIGNED, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 5}},
#define   MTPLSCONGESTIONCONTROLMETHOD  162
	{(u_char) MTPLSCONGESTIONCONTROLMETHOD, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 6}},
#define   MTPLSUSAGESTATE       163
	{(u_char) MTPLSUSAGESTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 7}},
#define   MTPLSOPERATIONALSTATE  164
	{(u_char) MTPLSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 8}},
#define   MTPLSAVAILABILITYSTATUS  165
	{(u_char) MTPLSAVAILABILITYSTATUS, ASN_OCTET_STR, RONLY, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 9}},
#define   MTPLSPERIODICLINKTESTFLAG  166
	{(u_char) MTPLSPERIODICLINKTESTFLAG, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 10}},
#define   MTPLSPERIODICLINKTESTFAIL  167
	{(u_char) MTPLSPERIODICLINKTESTFAIL, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 11}},
#define   MTPLSADMINISTRATIVESTATE  168
	{(u_char) MTPLSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 12}},
#define   MTPLSINLSLOADSHAREALGORITHM  169
	{(u_char) MTPLSINLSLOADSHAREALGORITHM, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 13}},
#define   MTPLSPROFILEPOINTER   170
	{(u_char) MTPLSPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 14}},
#define   MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS  171
	{(u_char) MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS, ASN_UNSIGNED, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 15}},
#define   MTPLSNAME             172
	{(u_char) MTPLSNAME, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 16}},
#define   MTPLSASAPROFILEPOINTER  173
	{(u_char) MTPLSASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 17}},
#define   MTPLSALARMSTATUS      174
	{(u_char) MTPLSALARMSTATUS, ASN_OCTET_STR, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 18}},
#define   MTPLSROWSTATUS        175
	{(u_char) MTPLSROWSTATUS, ASN_INTEGER, RWRITE, var_mtpLsTable, 6, {1, 1, 9, 2, 1, 19}},
#define   MTPSLL3PROFILETIMERT1  176
	{(u_char) MTPSLL3PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 2}},
#define   MTPSLL3PROFILETIMERT3  177
	{(u_char) MTPSLL3PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 3}},
#define   MTPSLL3PROFILETIMERT17  178
	{(u_char) MTPSLL3PROFILETIMERT17, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 4}},
#define   MTPSLL3PROFILETIMERT24I  179
	{(u_char) MTPSLL3PROFILETIMERT24I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 5}},
#define   MTPSLL3PROFILENAME    180
	{(u_char) MTPSLL3PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 6}},
#define   MTPSLL3PROFILETIMERT2  181
	{(u_char) MTPSLL3PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 7}},
#define   MTPSLL3PROFILETIMERT4  182
	{(u_char) MTPSLL3PROFILETIMERT4, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 8}},
#define   MTPSLL3PROFILETIMERT5  183
	{(u_char) MTPSLL3PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 9}},
#define   MTPSLL3PROFILETIMERT12  184
	{(u_char) MTPSLL3PROFILETIMERT12, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 10}},
#define   MTPSLL3PROFILETIMERT13  185
	{(u_char) MTPSLL3PROFILETIMERT13, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 11}},
#define   MTPSLL3PROFILETIMERT14  186
	{(u_char) MTPSLL3PROFILETIMERT14, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 12}},
#define   MTPSLL3PROFILETIMERT19A  187
	{(u_char) MTPSLL3PROFILETIMERT19A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 13}},
#define   MTPSLL3PROFILETIMERT20A  188
	{(u_char) MTPSLL3PROFILETIMERT20A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 14}},
#define   MTPSLL3PROFILETIMERT21A  189
	{(u_char) MTPSLL3PROFILETIMERT21A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 15}},
#define   MTPSLL3PROFILETIMERT22I  190
	{(u_char) MTPSLL3PROFILETIMERT22I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 16}},
#define   MTPSLL3PROFILETIMERT23I  191
	{(u_char) MTPSLL3PROFILETIMERT23I, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 17}},
#define   MTPSLL3PROFILETIMERT31A  192
	{(u_char) MTPSLL3PROFILETIMERT31A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 18}},
#define   MTPSLL3PROFILETIMERT32A  193
	{(u_char) MTPSLL3PROFILETIMERT32A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 19}},
#define   MTPSLL3PROFILETIMERT33A  194
	{(u_char) MTPSLL3PROFILETIMERT33A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 20}},
#define   MTPSLL3PROFILETIMERT34A  195
	{(u_char) MTPSLL3PROFILETIMERT34A, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 21}},
#define   MTPSLL3PROFILETIMERT1T  196
	{(u_char) MTPSLL3PROFILETIMERT1T, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 22}},
#define   MTPSLL3PROFILETIMERT2T  197
	{(u_char) MTPSLL3PROFILETIMERT2T, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 23}},
#define   MTPSLL3PROFILETIMERT1S  198
	{(u_char) MTPSLL3PROFILETIMERT1S, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 24}},
#define   MTPSLL3PROFILEL2DEFAULT  199
	{(u_char) MTPSLL3PROFILEL2DEFAULT, ASN_OCTET_STR, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 25}},
#define   MTPSLL3PROFILEROWSTATUS  200
	{(u_char) MTPSLL3PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlL3ProfileTable, 6, {1, 1, 10, 1, 1, 26}},
#define   MTPSLL2PROFILEERRORCORRECTIONMETHOD  201
	{(u_char) MTPSLL2PROFILEERRORCORRECTIONMETHOD, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 3}},
#define   MTPSLL2PROFILEPROTOCOLVARIANT  202
	{(u_char) MTPSLL2PROFILEPROTOCOLVARIANT, ASN_OBJECT_ID, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 4}},
#define   MTPSLL2PROFILETIMERT1  203
	{(u_char) MTPSLL2PROFILETIMERT1, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 5}},
#define   MTPSLL2PROFILETIMERT2  204
	{(u_char) MTPSLL2PROFILETIMERT2, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 6}},
#define   MTPSLL2PROFILETIMERT2L  205
	{(u_char) MTPSLL2PROFILETIMERT2L, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 7}},
#define   MTPSLL2PROFILETIMERT2H  206
	{(u_char) MTPSLL2PROFILETIMERT2H, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 8}},
#define   MTPSLL2PROFILETIMERT3  207
	{(u_char) MTPSLL2PROFILETIMERT3, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 9}},
#define   MTPSLL2PROFILETIMERT4N  208
	{(u_char) MTPSLL2PROFILETIMERT4N, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 10}},
#define   MTPSLL2PROFILETIMERT4E  209
	{(u_char) MTPSLL2PROFILETIMERT4E, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 11}},
#define   MTPSLL2PROFILETIMERT5  210
	{(u_char) MTPSLL2PROFILETIMERT5, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 12}},
#define   MTPSLL2PROFILETIMERT6  211
	{(u_char) MTPSLL2PROFILETIMERT6, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 13}},
#define   MTPSLL2PROFILETIMERT7  212
	{(u_char) MTPSLL2PROFILETIMERT7, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 14}},
#define   MTPSLL2PROFILETBONSET1  213
	{(u_char) MTPSLL2PROFILETBONSET1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 15}},
#define   MTPSLL2PROFILETBABATE1  214
	{(u_char) MTPSLL2PROFILETBABATE1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 16}},
#define   MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS  215
	{(u_char) MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 17}},
#define   MTPSLL2PROFILECONGESTIONCOUNTING  216
	{(u_char) MTPSLL2PROFILECONGESTIONCOUNTING, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 18}},
#define   MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT  217
	{(u_char) MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 19}},
#define   MTPSLL2PROFILELOOPDELAY  218
	{(u_char) MTPSLL2PROFILELOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 20}},
#define   MTPSLL2PROFILENAME    219
	{(u_char) MTPSLL2PROFILENAME, ASN_OCTET_STR, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 21}},
#define   MTPSLL2PROFILETBONSET2  220
	{(u_char) MTPSLL2PROFILETBONSET2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 22}},
#define   MTPSLL2PROFILETBABATE2  221
	{(u_char) MTPSLL2PROFILETBABATE2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 23}},
#define   MTPSLL2PROFILETBONSET3  222
	{(u_char) MTPSLL2PROFILETBONSET3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 24}},
#define   MTPSLL2PROFILETBABATE3  223
	{(u_char) MTPSLL2PROFILETBABATE3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 25}},
#define   MTPSLL2PROFILETBDISCARD1  224
	{(u_char) MTPSLL2PROFILETBDISCARD1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 26}},
#define   MTPSLL2PROFILETBDISCARD2  225
	{(u_char) MTPSLL2PROFILETBDISCARD2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 27}},
#define   MTPSLL2PROFILETBDISCARD3  226
	{(u_char) MTPSLL2PROFILETBDISCARD3, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 28}},
#define   MTPSLL2PROFILETIMERTX  227
	{(u_char) MTPSLL2PROFILETIMERTX, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 29}},
#define   MTPSLL2PROFILETIMERTY  228
	{(u_char) MTPSLL2PROFILETIMERTY, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 30}},
#define   MTPSLL2PROFILENUMBEROFCONGESTIONSTATES  229
	{(u_char) MTPSLL2PROFILENUMBEROFCONGESTIONSTATES, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 31}},
#define   MTPSLL2PROFILEINITIALLEVELOFCONGESTION  230
	{(u_char) MTPSLL2PROFILEINITIALLEVELOFCONGESTION, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 32}},
#define   MTPSLL2PROFILEMAXMSUSRETRANSN1  231
	{(u_char) MTPSLL2PROFILEMAXMSUSRETRANSN1, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 33}},
#define   MTPSLL2PROFILEMAXOCTRETRANSN2  232
	{(u_char) MTPSLL2PROFILEMAXOCTRETRANSN2, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 34}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET  233
	{(u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 35}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE  234
	{(u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 36}},
#define   MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD  235
	{(u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 37}},
#define   MTPSLL2PROFILEM       236
	{(u_char) MTPSLL2PROFILEM, ASN_UNSIGNED, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 38}},
#define   MTPSLL2PROFILEROWSTATUS  237
	{(u_char) MTPSLL2PROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlL2ProfileTable, 6, {1, 1, 10, 2, 1, 39}},
#define   MTPSLSLSCODECURRENTLIST  238
	{(u_char) MTPSLSLSCODECURRENTLIST, ASN_OCTET_STR, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 3}},
#define   MTPSLMAXCAPACITYSL    239
	{(u_char) MTPSLMAXCAPACITYSL, ASN_UNSIGNED, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 4}},
#define   MTPSLCURRENTCAPACITYSL  240
	{(u_char) MTPSLCURRENTCAPACITYSL, ASN_UNSIGNED, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 5}},
#define   MTPSLLINKTPSTATUS     241
	{(u_char) MTPSLLINKTPSTATUS, ASN_OCTET_STR, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 6}},
#define   MTPSLADMINISTRATIVESTATE  242
	{(u_char) MTPSLADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 7}},
#define   MTPSLOPERATIONALSTATE  243
	{(u_char) MTPSLOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 8}},
#define   MTPSLUSAGESTATE       244
	{(u_char) MTPSLUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 9}},
#define   MTPSLPROCEDURALSTATUS  245
	{(u_char) MTPSLPROCEDURALSTATUS, ASN_OCTET_STR, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 10}},
#define   MTPSLMTPL2PROTOCOLPROFILEPOINTER  246
	{(u_char) MTPSLMTPL2PROTOCOLPROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 11}},
#define   MTPSLSIGNTERMPOINTER  247
	{(u_char) MTPSLSIGNTERMPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 12}},
#define   MTPSLSIGNDATALINKTPPOINTER  248
	{(u_char) MTPSLSIGNDATALINKTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 13}},
#define   MTPSLLOCALINHIBIT     249
	{(u_char) MTPSLLOCALINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 14}},
#define   MTPSLLOCALUNINHIBIT   250
	{(u_char) MTPSLLOCALUNINHIBIT, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 15}},
#define   MTPSLREPLACEST        251
	{(u_char) MTPSLREPLACEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 16}},
#define   MTPSLASAPROFILEPOINTER  252
	{(u_char) MTPSLASAPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 17}},
#define   MTPSLCONGESTIONLEVEL  253
	{(u_char) MTPSLCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 18}},
#define   MTPSLRELATEDLINKGROUPNUMBER  254
	{(u_char) MTPSLRELATEDLINKGROUPNUMBER, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 19}},
#define   MTPSLSDLLIST          255
	{(u_char) MTPSLSDLLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 20}},
#define   MTPSLTEST             256
	{(u_char) MTPSLTEST, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 21}},
#define   MTPSLNAME             257
	{(u_char) MTPSLNAME, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 22}},
#define   MTPSLSDTLIST          258
	{(u_char) MTPSLSDTLIST, ASN_UNSIGNED, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 23}},
#define   MTPSLSLSCODENORMALLIST  259
	{(u_char) MTPSLSLSCODENORMALLIST, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 24}},
#define   MTPSLL3PROFILEPOINTER  260
	{(u_char) MTPSLL3PROFILEPOINTER, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 25}},
#define   MTPSLALARMSTATUS      261
	{(u_char) MTPSLALARMSTATUS, ASN_OCTET_STR, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 26}},
#define   MTPSLROWSTATUS        262
	{(u_char) MTPSLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlTable, 6, {1, 1, 10, 3, 1, 27}},
#define   MTPSLSDLLISTPOINTER   263
	{(u_char) MTPSLSDLLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 10, 4, 1, 2}},
#define   MTPSLSDLLISTROWSTATUS  264
	{(u_char) MTPSLSDLLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdlListTable, 6, {1, 1, 10, 4, 1, 3}},
#define   MTPSLSDTLISTPOINTER   265
	{(u_char) MTPSLSDTLISTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 10, 5, 1, 2}},
#define   MTPSLSDTLISTROWSTATUS  266
	{(u_char) MTPSLSDTLISTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSlSdtListTable, 6, {1, 1, 10, 5, 1, 3}},
#define   MTPNBTRANSMISSIONRATE  267
	{(u_char) MTPNBTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 2}},
#define   MTPNBTIMERT8          268
	{(u_char) MTPNBTIMERT8, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 3}},
#define   MTPNBTIN              269
	{(u_char) MTPNBTIN, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 4}},
#define   MTPNBTIE              270
	{(u_char) MTPNBTIE, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 5}},
#define   MTPNBT                271
	{(u_char) MTPNBT, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 6}},
#define   MTPNBD                272
	{(u_char) MTPNBD, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 7}},
#define   MTPNBTE               273
	{(u_char) MTPNBTE, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 8}},
#define   MTPNBDE               274
	{(u_char) MTPNBDE, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 9}},
#define   MTPNBUE               275
	{(u_char) MTPNBUE, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 10}},
#define   MTPNBN                276
	{(u_char) MTPNBN, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 11}},
#define   MTPNBM                277
	{(u_char) MTPNBM, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 12}},
#define   MTPNBB                278
	{(u_char) MTPNBB, ASN_UNSIGNED, RONLY, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 13}},
#define   MTPNBF                279
	{(u_char) MTPNBF, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 14}},
#define   MTPNBROWSTATUS        280
	{(u_char) MTPNBROWSTATUS, ASN_INTEGER, RWRITE, var_mtpNbTable, 6, {1, 1, 11, 1, 1, 15}},
#define   MTPSAALBUFFERRELEASE  281
	{(u_char) MTPSAALBUFFERRELEASE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 1}},
#define   MTPSAALMAXCC          282
	{(u_char) MTPSAALMAXCC, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 2}},
#define   MTPSAALMAXNRP         283
	{(u_char) MTPSAALMAXNRP, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 3}},
#define   MTPSAALMAXINFORMATIONFIELDLENGTH  284
	{(u_char) MTPSAALMAXINFORMATIONFIELDLENGTH, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 4}},
#define   MTPSAALMAXLENGTHSSCOPUUFIELD  285
	{(u_char) MTPSAALMAXLENGTHSSCOPUUFIELD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 5}},
#define   MTPSAALMAXPD          286
	{(u_char) MTPSAALMAXPD, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 6}},
#define   MTPSAALMAXSSCOPCREDITTOPEER  287
	{(u_char) MTPSAALMAXSSCOPCREDITTOPEER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 7}},
#define   MTPSAALMAXSTAT        288
	{(u_char) MTPSAALMAXSTAT, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 8}},
#define   MTPSAALN1             289
	{(u_char) MTPSAALN1, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 9}},
#define   MTPSAALNNILAYERMANAGEMENTPROVINGSTATE  290
	{(u_char) MTPSAALNNILAYERMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 10}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT  291
	{(u_char) MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 11}},
#define   MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC  292
	{(u_char) MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 12}},
#define   MTPSAALNNITIMERT1     293
	{(u_char) MTPSAALNNITIMERT1, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 13}},
#define   MTPSAALNNITIMERT2     294
	{(u_char) MTPSAALNNITIMERT2, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 14}},
#define   MTPSAALNNITIMERT3     295
	{(u_char) MTPSAALNNITIMERT3, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 15}},
#define   MTPSAALSSCOPTIMERCC   296
	{(u_char) MTPSAALSSCOPTIMERCC, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 16}},
#define   MTPSAALSSCOPTIMERIDLE  297
	{(u_char) MTPSAALSSCOPTIMERIDLE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 17}},
#define   MTPSAALSSCOPTIMERKEEPALIVE  298
	{(u_char) MTPSAALSSCOPTIMERKEEPALIVE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 18}},
#define   MTPSAALSSCOPTIMERNORESPONSE  299
	{(u_char) MTPSAALSSCOPTIMERNORESPONSE, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 19}},
#define   MTPSAALSSCOPTIMERPOLL  300
	{(u_char) MTPSAALSSCOPTIMERPOLL, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 20}},
#define   MTPSAALTRANSMISSIONRATEINTERVALLOWER  301
	{(u_char) MTPSAALTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 21}},
#define   MTPSAALTRANSMISSIONRATEINTERVALUPPER  302
	{(u_char) MTPSAALTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 22}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER  303
	{(u_char) MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 23}},
#define   MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER  304
	{(u_char) MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 24}},
#define   MTPSAALPOLLAFTERRETRANSMISSION  305
	{(u_char) MTPSAALPOLLAFTERRETRANSMISSION, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 25}},
#define   MTPSAALROWSTATUS      306
	{(u_char) MTPSAALROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSaalTable, 6, {1, 1, 11, 2, 1, 26}},
#define   MTPM2PAN1             307
	{(u_char) MTPM2PAN1, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 1}},
#define   MTPM2PAPROVING        308
	{(u_char) MTPM2PAPROVING, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 2}},
#define   MTPM2PAMANAGEMENTPROVINGSTATE  309
	{(u_char) MTPM2PAMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 3}},
#define   MTPM2PAPROVINGATTEMPTS  310
	{(u_char) MTPM2PAPROVINGATTEMPTS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 4}},
#define   MTPM2PASCTPNODELAY    311
	{(u_char) MTPM2PASCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 5}},
#define   MTPM2PASCTPMAXSEG     312
	{(u_char) MTPM2PASCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 6}},
#define   MTPM2PASCTPHEARTBEATITVL  313
	{(u_char) MTPM2PASCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 7}},
#define   MTPM2PASCTPHEARTBEAT  314
	{(u_char) MTPM2PASCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 8}},
#define   MTPM2PASCTPRTOINITIAL  315
	{(u_char) MTPM2PASCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 9}},
#define   MTPM2PASCTPRTOMIN     316
	{(u_char) MTPM2PASCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 10}},
#define   MTPM2PASCTPRTOMAX     317
	{(u_char) MTPM2PASCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 11}},
#define   MTPM2PASCTPPATHMAXRETRANS  318
	{(u_char) MTPM2PASCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 12}},
#define   MTPM2PASCTPCOOKIELIFE  319
	{(u_char) MTPM2PASCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 13}},
#define   MTPM2PASCTPCOOKIEINC  320
	{(u_char) MTPM2PASCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 14}},
#define   MTPM2PASCTPMAXINITRETRIES  321
	{(u_char) MTPM2PASCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 15}},
#define   MTPM2PASCTPMAXBURST   322
	{(u_char) MTPM2PASCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 16}},
#define   MTPM2PASCTPASSOCMAXRETRANS  323
	{(u_char) MTPM2PASCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 17}},
#define   MTPM2PASCTPSACKDELAY  324
	{(u_char) MTPM2PASCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 18}},
#define   MTPM2PASCTPLIFETIME   325
	{(u_char) MTPM2PASCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 19}},
#define   MTPM2PALOOPDELAYLOWER  326
	{(u_char) MTPM2PALOOPDELAYLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 20}},
#define   MTPM2PALOOPDELAYUPPER  327
	{(u_char) MTPM2PALOOPDELAYUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 21}},
#define   MTPM2PATRANSMISSIONRATEINTERVALLOWER  328
	{(u_char) MTPM2PATRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 22}},
#define   MTPM2PATRANSMISSIONRATEINTERVALUPPER  329
	{(u_char) MTPM2PATRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 23}},
#define   MTPM2PAROWSTATUS      330
	{(u_char) MTPM2PAROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM2paTable, 6, {1, 1, 11, 3, 1, 24}},
#define   MTPSDTADMINISTRATIVESTATE  331
	{(u_char) MTPSDTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 3}},
#define   MTPSDTOPERATIONALSTATE  332
	{(u_char) MTPSDTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 4}},
#define   MTPSDTUSAGESTATE      333
	{(u_char) MTPSDTUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 5}},
#define   MTPSDTPROCEDURALSTATUS  334
	{(u_char) MTPSDTPROCEDURALSTATUS, ASN_OCTET_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 6}},
#define   MTPSDTAVAILABILITYSTATUS  335
	{(u_char) MTPSDTAVAILABILITYSTATUS, ASN_OCTET_STR, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 7}},
#define   MTPSDTEQUIPMENTPOINTER  336
	{(u_char) MTPSDTEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 8}},
#define   MTPSDTNAME            337
	{(u_char) MTPSDTNAME, ASN_OCTET_STR, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 9}},
#define   MTPSDTSTANDBYSTATUS   338
	{(u_char) MTPSDTSTANDBYSTATUS, ASN_INTEGER, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 10}},
#define   MTPSDTPRIMARYID       339
	{(u_char) MTPSDTPRIMARYID, ASN_UNSIGNED, RONLY, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 11}},
#define   MTPSDTPROFILEPOINTER  340
	{(u_char) MTPSDTPROFILEPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 12}},
#define   MTPSDTROWSTATUS       341
	{(u_char) MTPSDTROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdtTable, 6, {1, 1, 11, 4, 1, 13}},
#define   MTPSDLTYPE            342
	{(u_char) MTPSDLTYPE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 2}},
#define   MTPSDLADJPC           343
	{(u_char) MTPSDLADJPC, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 3}},
#define   MTPSDLLOOPDELAY       344
	{(u_char) MTPSDLLOOPDELAY, ASN_UNSIGNED, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 4}},
#define   MTPSDLOPERATIONALSTATE  345
	{(u_char) MTPSDLOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 5}},
#define   MTPSDLEQUIPMENTPOINTER  346
	{(u_char) MTPSDLEQUIPMENTPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 6}},
#define   MTPSDLCIC             347
	{(u_char) MTPSDLCIC, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 7}},
#define   MTPSDLTRANSMISSIONRATE  348
	{(u_char) MTPSDLTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 8}},
#define   MTPSDLSTMCHANNEL      349
	{(u_char) MTPSDLSTMCHANNEL, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 9}},
#define   MTPSDLVCTTPPOINTER    350
	{(u_char) MTPSDLVCTTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 10}},
#define   MTPSDLSCTPPOINTER     351
	{(u_char) MTPSDLSCTPPOINTER, ASN_OBJECT_ID, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 11}},
#define   MTPSDLNAME            352
	{(u_char) MTPSDLNAME, ASN_OCTET_STR, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 12}},
#define   MTPSDLROWSTATUS       353
	{(u_char) MTPSDLROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSdlTable, 6, {1, 1, 12, 1, 1, 13}},
#define   MTPSCTPPROFILENODELAY  354
	{(u_char) MTPSCTPPROFILENODELAY, ASN_INTEGER, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 2}},
#define   MTPSCTPPROFILEMAXSEG  355
	{(u_char) MTPSCTPPROFILEMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 3}},
#define   MTPSCTPPROFILEHEARTBEATITVL  356
	{(u_char) MTPSCTPPROFILEHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 4}},
#define   MTPSCTPPROFILEHEARTBEAT  357
	{(u_char) MTPSCTPPROFILEHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 5}},
#define   MTPSCTPPROFILERTOINITIAL  358
	{(u_char) MTPSCTPPROFILERTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 6}},
#define   MTPSCTPPROFILERTOMIN  359
	{(u_char) MTPSCTPPROFILERTOMIN, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 7}},
#define   MTPSCTPPROFILERTOMAX  360
	{(u_char) MTPSCTPPROFILERTOMAX, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 8}},
#define   MTPSCTPPROFILEPATHMAXRETRANS  361
	{(u_char) MTPSCTPPROFILEPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 9}},
#define   MTPSCTPPROFILECOOKIELIFE  362
	{(u_char) MTPSCTPPROFILECOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 10}},
#define   MTPSCTPPROFILECOOKIEINC  363
	{(u_char) MTPSCTPPROFILECOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 11}},
#define   MTPSCTPPROFILEMAXINITRETRIES  364
	{(u_char) MTPSCTPPROFILEMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 12}},
#define   MTPSCTPPROFILEMAXBURST  365
	{(u_char) MTPSCTPPROFILEMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 13}},
#define   MTPSCTPPROFILEASSOCMAXRETRANS  366
	{(u_char) MTPSCTPPROFILEASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 14}},
#define   MTPSCTPPROFILESACKDELAY  367
	{(u_char) MTPSCTPPROFILESACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 15}},
#define   MTPSCTPPROFILELIFETIME  368
	{(u_char) MTPSCTPPROFILELIFETIME, ASN_UNSIGNED, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 16}},
#define   MTPSCTPPROFILEMINOSTREAMS  369
	{(u_char) MTPSCTPPROFILEMINOSTREAMS, ASN_INTEGER, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 17}},
#define   MTPSCTPPROFILEMAXISTREAMS  370
	{(u_char) MTPSCTPPROFILEMAXISTREAMS, ASN_INTEGER, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 18}},
#define   MTPSCTPPROFILEROWSTATUS  371
	{(u_char) MTPSCTPPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSctpProfileTable, 6, {1, 1, 13, 1, 1, 19}},
#define   MTPSCTPADMINISTRATIVESTATE  372
	{(u_char) MTPSCTPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 2}},
#define   MTPSCTPOPERATIONALSTATE  373
	{(u_char) MTPSCTPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 3}},
#define   MTPSCTPUSAGESTATE     374
	{(u_char) MTPSCTPUSAGESTATE, ASN_INTEGER, RONLY, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 4}},
#define   MTPSCTPPROCEDURALSTATUS  375
	{(u_char) MTPSCTPPROCEDURALSTATUS, ASN_OCTET_STR, RONLY, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 5}},
#define   MTPSCTPLOCALPORT      376
	{(u_char) MTPSCTPLOCALPORT, ASN_INTEGER, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 6}},
#define   MTPSCTPREMOTEPORT     377
	{(u_char) MTPSCTPREMOTEPORT, ASN_INTEGER, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 7}},
#define   MTPSCTPPROFILE        378
	{(u_char) MTPSCTPPROFILE, ASN_OCTET_STR, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 8}},
#define   MTPSCTPPROTOCOLPAYLOADID  379
	{(u_char) MTPSCTPPROTOCOLPAYLOADID, ASN_UNSIGNED, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 9}},
#define   MTPSCTPROWSTATUS      380
	{(u_char) MTPSCTPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSctpTable, 6, {1, 1, 13, 2, 1, 10}},
#define   MTPSCTPLOCALADDRESS   381
	{(u_char) MTPSCTPLOCALADDRESS, ASN_IPADDRESS, RWRITE, var_mtpSctpLocalTable, 6, {1, 1, 13, 3, 1, 2}},
#define   MTPSCTPLOCALROWSTATUS  382
	{(u_char) MTPSCTPLOCALROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSctpLocalTable, 6, {1, 1, 13, 3, 1, 3}},
#define   MTPSCTPREMOTEADDRESS  383
	{(u_char) MTPSCTPREMOTEADDRESS, ASN_IPADDRESS, RWRITE, var_mtpSctpRemoteTable, 6, {1, 1, 13, 4, 1, 2}},
#define   MTPSCTPREMOTEROWSTATUS  384
	{(u_char) MTPSCTPREMOTEROWSTATUS, ASN_INTEGER, RWRITE, var_mtpSctpRemoteTable, 6, {1, 1, 13, 4, 1, 3}},
#define   MTPM2UAASPSTATE       385
	{(u_char) MTPM2UAASPSTATE, ASN_INTEGER, RONLY, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 1}},
#define   MTPM2UAASPID          386
	{(u_char) MTPM2UAASPID, ASN_UNSIGNED, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 2}},
#define   MTPM2UAASPCAPABILITIES  387
	{(u_char) MTPM2UAASPCAPABILITIES, ASN_OCTET_STR, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 3}},
#define   MTPM2UAASPSGVERSION   388
	{(u_char) MTPM2UAASPSGVERSION, ASN_OBJECT_ID, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 4}},
#define   MTPM2UAASPSGOPTIONS   389
	{(u_char) MTPM2UAASPSGOPTIONS, ASN_OCTET_STR, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 5}},
#define   MTPM2UAASPSGREGISTRATIONPOLICY  390
	{(u_char) MTPM2UAASPSGREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 6}},
#define   MTPM2UAASPSGASPIDPOLICY  391
	{(u_char) MTPM2UAASPSGASPIDPOLICY, ASN_INTEGER, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 7}},
#define   MTPM2UAASPASSOCIATIONPOLICY  392
	{(u_char) MTPM2UAASPASSOCIATIONPOLICY, ASN_INTEGER, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 8}},
#define   MTPM2UAASPPROTOCOLPAYLOADID  393
	{(u_char) MTPM2UAASPPROTOCOLPAYLOADID, ASN_INTEGER, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 9}},
#define   MTPM2UAASPROWSTATUS   394
	{(u_char) MTPM2UAASPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM2uaAspTable, 6, {1, 1, 13, 5, 1, 10}},
#define   MTPM2UAASSTATE        395
	{(u_char) MTPM2UAASSTATE, ASN_INTEGER, RONLY, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 2}},
#define   MTPM2UAASINTERFACEIDENTIFIER  396
	{(u_char) MTPM2UAASINTERFACEIDENTIFIER, ASN_UNSIGNED, RWRITE, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 3}},
#define   MTPM2UAINTERFACEIDENTIFIERTEXT  397
	{(u_char) MTPM2UAINTERFACEIDENTIFIERTEXT, ASN_OCTET_STR, RWRITE, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 4}},
#define   MTPM2UAASSDTI         398
	{(u_char) MTPM2UAASSDTI, ASN_INTEGER, RWRITE, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 5}},
#define   MTPM2UAASTRAFFICMODE  399
	{(u_char) MTPM2UAASTRAFFICMODE, ASN_OBJECT_ID, RWRITE, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 6}},
#define   MTPM2UAASROWSTATUS    400
	{(u_char) MTPM2UAASROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM2uaAsTable, 6, {1, 1, 13, 6, 1, 7}},
#define   MTPM3UAASPSTATE       401
	{(u_char) MTPM3UAASPSTATE, ASN_INTEGER, RONLY, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 1}},
#define   MTPM3UAASTYPE         402
	{(u_char) MTPM3UAASTYPE, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 2}},
#define   MTPM3UAASPID          403
	{(u_char) MTPM3UAASPID, ASN_UNSIGNED, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 3}},
#define   MTPM3UAASPCAPABILITIES  404
	{(u_char) MTPM3UAASPCAPABILITIES, ASN_OCTET_STR, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 4}},
#define   MTPM3UAASPSGVERSION   405
	{(u_char) MTPM3UAASPSGVERSION, ASN_OBJECT_ID, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 5}},
#define   MTPM3UAASPSGOPTIONS   406
	{(u_char) MTPM3UAASPSGOPTIONS, ASN_OCTET_STR, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 6}},
#define   MTPM3UAASPSGREGISTRATIONPOLICY  407
	{(u_char) MTPM3UAASPSGREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 7}},
#define   MTPM3UAASPSGASPIDPOLICY  408
	{(u_char) MTPM3UAASPSGASPIDPOLICY, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 8}},
#define   MTPM3UAASPASSOCIATIONPOLICY  409
	{(u_char) MTPM3UAASPASSOCIATIONPOLICY, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 9}},
#define   MTPM3UAASPPROTOCOLPAYLOADID  410
	{(u_char) MTPM3UAASPPROTOCOLPAYLOADID, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 10}},
#define   MTPM3UAASPROWSTATUS   411
	{(u_char) MTPM3UAASPROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM3uaAspTable, 6, {1, 1, 13, 7, 1, 11}},
#define   MTPM3UAASSTATE        412
	{(u_char) MTPM3UAASSTATE, ASN_INTEGER, RONLY, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 2}},
#define   MTPM3UAASROUTINGCONTEXT  413
	{(u_char) MTPM3UAASROUTINGCONTEXT, ASN_UNSIGNED, RWRITE, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 3}},
#define   MTPM3UAASNETWORKAPPEARANCE  414
	{(u_char) MTPM3UAASNETWORKAPPEARANCE, ASN_UNSIGNED, RWRITE, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 4}},
#define   MTPM3UAASNETWORKPOINTCODE  415
	{(u_char) MTPM3UAASNETWORKPOINTCODE, ASN_OCTET_STR, RWRITE, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 5}},
#define   MTPM3UAASTRAFFICMODE  416
	{(u_char) MTPM3UAASTRAFFICMODE, ASN_OBJECT_ID, RWRITE, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 6}},
#define   MTPM3UAASROWSTATUS    417
	{(u_char) MTPM3UAASROWSTATUS, ASN_INTEGER, RWRITE, var_mtpM3uaAsTable, 6, {1, 1, 13, 8, 1, 7}},
#define   MTPDEFAULTSCTPNODELAY  418
	{(u_char) MTPDEFAULTSCTPNODELAY, ASN_INTEGER, RWRITE, var_mtpMIB, 4, {1, 2, 1, 1}},
#define   MTPDEFAULTSCTPMAXSEG  419
	{(u_char) MTPDEFAULTSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 2}},
#define   MTPDEFAULTSCTPHEARTBEATITVL  420
	{(u_char) MTPDEFAULTSCTPHEARTBEATITVL, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 3}},
#define   MTPDEFAULTSCTPHEARTBEAT  421
	{(u_char) MTPDEFAULTSCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_mtpMIB, 4, {1, 2, 1, 4}},
#define   MTPDEFAULTSCTPRTOINITIAL  422
	{(u_char) MTPDEFAULTSCTPRTOINITIAL, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 5}},
#define   MTPDEFAULTSCTPRTOMIN  423
	{(u_char) MTPDEFAULTSCTPRTOMIN, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 6}},
#define   MTPDEFAULTSCTPRTOMAX  424
	{(u_char) MTPDEFAULTSCTPRTOMAX, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 7}},
#define   MTPDEFAULTSCTPPATHMAXRETRANS  425
	{(u_char) MTPDEFAULTSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 8}},
#define   MTPDEFAULTSCTPCOOKIELIFE  426
	{(u_char) MTPDEFAULTSCTPCOOKIELIFE, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 9}},
#define   MTPDEFAULTSCTPCOOKIEINC  427
	{(u_char) MTPDEFAULTSCTPCOOKIEINC, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 10}},
#define   MTPDEFAULTSCTPMAXINITRETRIES  428
	{(u_char) MTPDEFAULTSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 11}},
#define   MTPDEFAULTSCTPMAXBURST  429
	{(u_char) MTPDEFAULTSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 12}},
#define   MTPDEFAULTSCTPASSOCMAXRETRANS  430
	{(u_char) MTPDEFAULTSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 13}},
#define   MTPDEFAULTSCTPSACKDELAY  431
	{(u_char) MTPDEFAULTSCTPSACKDELAY, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 14}},
#define   MTPDEFAULTSCTPLIFETIME  432
	{(u_char) MTPDEFAULTSCTPLIFETIME, ASN_UNSIGNED, RWRITE, var_mtpMIB, 4, {1, 2, 1, 15}},
};

/* (L = length of the oidsuffix) */
struct mtpMIB_data *mtpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *mtpSapTableStorage = NULL;
struct header_complex_index *mtpNaTableStorage = NULL;
struct header_complex_index *mtpMsTableStorage = NULL;
struct header_complex_index *mtpSpProfileTableStorage = NULL;
struct header_complex_index *mtpSpTableStorage = NULL;
struct header_complex_index *mtpL3TableStorage = NULL;
struct header_complex_index *mtpGsTableStorage = NULL;
struct header_complex_index *mtpGsLineTableStorage = NULL;
struct header_complex_index *mtpGsLineContentTableStorage = NULL;
struct header_complex_index *mtpRsProfileTableStorage = NULL;
struct header_complex_index *mtpRsTableStorage = NULL;
struct header_complex_index *mtpRtProfileTableStorage = NULL;
struct header_complex_index *mtpRtTableStorage = NULL;
struct header_complex_index *mtpRtLsaTableStorage = NULL;
struct header_complex_index *mtpLsProfileTableStorage = NULL;
struct header_complex_index *mtpLsTableStorage = NULL;
struct header_complex_index *mtpSlL3ProfileTableStorage = NULL;
struct header_complex_index *mtpSlL2ProfileTableStorage = NULL;
struct header_complex_index *mtpSlTableStorage = NULL;
struct header_complex_index *mtpSlSdlListTableStorage = NULL;
struct header_complex_index *mtpSlSdtListTableStorage = NULL;
struct header_complex_index *mtpNbTableStorage = NULL;
struct header_complex_index *mtpSaalTableStorage = NULL;
struct header_complex_index *mtpM2paTableStorage = NULL;
struct header_complex_index *mtpSdtTableStorage = NULL;
struct header_complex_index *mtpSdlTableStorage = NULL;
struct header_complex_index *mtpSctpProfileTableStorage = NULL;
struct header_complex_index *mtpSctpTableStorage = NULL;
struct header_complex_index *mtpSctpLocalTableStorage = NULL;
struct header_complex_index *mtpSctpRemoteTableStorage = NULL;
struct header_complex_index *mtpM2uaAspTableStorage = NULL;
struct header_complex_index *mtpM2uaAsTableStorage = NULL;
struct header_complex_index *mtpM3uaAspTableStorage = NULL;
struct header_complex_index *mtpM3uaAsTableStorage = NULL;

void (*mtpMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void mtpMIB_loop_handler(int);
void mtpMIB_fd_handler(int, void *);

/**
 * @fn void init_mtpMIB(void)
 * @brief mtpMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (mtpMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_mtpMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("mtpMIB", "init_mtpMIB: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpMIB", mtpMIB_variables, variable7, mtpMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpMIB", parse_mtpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSapTable", parse_mtpSapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNaTable", parse_mtpNaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpMsTable", parse_mtpMsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpProfileTable", parse_mtpSpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSpTable", parse_mtpSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpL3Table", parse_mtpL3Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsTable", parse_mtpGsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineTable", parse_mtpGsLineTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpGsLineContentTable", parse_mtpGsLineContentTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsProfileTable", parse_mtpRsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRsTable", parse_mtpRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtProfileTable", parse_mtpRtProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtTable", parse_mtpRtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpRtLsaTable", parse_mtpRtLsaTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsProfileTable", parse_mtpLsProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpLsTable", parse_mtpLsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL3ProfileTable", parse_mtpSlL3ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlL2ProfileTable", parse_mtpSlL2ProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlTable", parse_mtpSlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdlListTable", parse_mtpSlSdlListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSlSdtListTable", parse_mtpSlSdtListTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpNbTable", parse_mtpNbTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSaalTable", parse_mtpSaalTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2paTable", parse_mtpM2paTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdtTable", parse_mtpSdtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSdlTable", parse_mtpSdlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSctpProfileTable", parse_mtpSctpProfileTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSctpTable", parse_mtpSctpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSctpLocalTable", parse_mtpSctpLocalTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpSctpRemoteTable", parse_mtpSctpRemoteTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2uaAspTable", parse_mtpM2uaAspTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM2uaAsTable", parse_mtpM2uaAsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM3uaAspTable", parse_mtpM3uaAspTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpM3uaAsTable", parse_mtpM3uaAsTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpMsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpL3Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpGsLineContentTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpRtLsaTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpLsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL3ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlL2ProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdlListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSlSdtListTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpNbTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSaalTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2paTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSdlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSctpProfileTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSctpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSctpLocalTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpSctpRemoteTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2uaAspTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM2uaAsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM3uaAspTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpM3uaAsTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, mtpMIB_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, mtpMIB_fd_handler, (void *) 1);
	}
	mtpMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &mtpMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/**
 * @fn void deinit_mtpMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (mtpMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_mtpMIB(void)
{
	DEBUGMSGTL(("mtpMIB", "deinit_mtpMIB: deinitializating...  "));
	external_signal_handler[SIGCHLD] = mtpMIBold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(mtpMIB_variables_oid, sizeof(mtpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpMIB");
	snmpd_unregister_config_handler("mtpSapTable");
	snmpd_unregister_config_handler("mtpNaTable");
	snmpd_unregister_config_handler("mtpMsTable");
	snmpd_unregister_config_handler("mtpSpProfileTable");
	snmpd_unregister_config_handler("mtpSpTable");
	snmpd_unregister_config_handler("mtpL3Table");
	snmpd_unregister_config_handler("mtpGsTable");
	snmpd_unregister_config_handler("mtpGsLineTable");
	snmpd_unregister_config_handler("mtpGsLineContentTable");
	snmpd_unregister_config_handler("mtpRsProfileTable");
	snmpd_unregister_config_handler("mtpRsTable");
	snmpd_unregister_config_handler("mtpRtProfileTable");
	snmpd_unregister_config_handler("mtpRtTable");
	snmpd_unregister_config_handler("mtpRtLsaTable");
	snmpd_unregister_config_handler("mtpLsProfileTable");
	snmpd_unregister_config_handler("mtpLsTable");
	snmpd_unregister_config_handler("mtpSlL3ProfileTable");
	snmpd_unregister_config_handler("mtpSlL2ProfileTable");
	snmpd_unregister_config_handler("mtpSlTable");
	snmpd_unregister_config_handler("mtpSlSdlListTable");
	snmpd_unregister_config_handler("mtpSlSdtListTable");
	snmpd_unregister_config_handler("mtpNbTable");
	snmpd_unregister_config_handler("mtpSaalTable");
	snmpd_unregister_config_handler("mtpM2paTable");
	snmpd_unregister_config_handler("mtpSdtTable");
	snmpd_unregister_config_handler("mtpSdlTable");
	snmpd_unregister_config_handler("mtpSctpProfileTable");
	snmpd_unregister_config_handler("mtpSctpTable");
	snmpd_unregister_config_handler("mtpSctpLocalTable");
	snmpd_unregister_config_handler("mtpSctpRemoteTable");
	snmpd_unregister_config_handler("mtpM2uaAspTable");
	snmpd_unregister_config_handler("mtpM2uaAsTable");
	snmpd_unregister_config_handler("mtpM3uaAspTable");
	snmpd_unregister_config_handler("mtpM3uaAsTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

int
term_mtpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("mtpMIB", "term_mtpMIB: terminating...  "));
	deinit_mtpMIB();
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return 0;
}

/**
 * @fn struct mtpMIB_data *mtpMIB_create(void)
 * @brief create a fresh data structure representing scalars in mtpMIB.
 *
 * Creates a new mtpMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in mtpMIB.
 */
struct mtpMIB_data *
mtpMIB_create(void)
{
	struct mtpMIB_data *StorageNew = SNMP_MALLOC_STRUCT(mtpMIB_data);

	DEBUGMSGTL(("mtpMIB", "mtpMIB_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		StorageNew->mtpDefaultSctpNoDelay = TV_TRUE;
		StorageNew->mtpDefaultSctpMaxseg = 65536;
		StorageNew->mtpDefaultSctpHeartbeatItvl = 60000;
		StorageNew->mtpDefaultSctpHeartbeat = TV_TRUE;
		StorageNew->mtpDefaultSctpRtoInitial = 3000;
		StorageNew->mtpDefaultSctpRtoMin = 1000;
		StorageNew->mtpDefaultSctpRtoMax = 60000;
		StorageNew->mtpDefaultSctpPathMaxRetrans = 5;
		StorageNew->mtpDefaultSctpCookieLife = 60000;
		StorageNew->mtpDefaultSctpCookieInc = 1000;
		StorageNew->mtpDefaultSctpMaxInitRetries = 8;
		StorageNew->mtpDefaultSctpMaxBurst = 4;
		StorageNew->mtpDefaultSctpAssocMaxRetrans = 10;
		StorageNew->mtpDefaultSctpSackDelay = 200;
		StorageNew->mtpDefaultSctpLifetime = 0;

	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpMIB_data *mtpMIB_duplicate(struct mtpMIB_data *thedata)
 * @param thedata the mib structure to duplicate
 * @brief duplicate a mib structure for the mib
 *
 * Duplicates the specified mib structure @param thedata and returns a pointer to the newly
 * allocated mib structure on success, or NULL on failure.
 */
struct mtpMIB_data *
mtpMIB_duplicate(struct mtpMIB_data *thedata)
{
	struct mtpMIB_data *StorageNew = SNMP_MALLOC_STRUCT(mtpMIB_data);

	DEBUGMSGTL(("mtpMIB", "mtpMIB_duplicate: duplicating mib... "));
	if (StorageNew != NULL) {
		StorageNew->mtpDefaultSctpNoDelay = thedata->mtpDefaultSctpNoDelay;
		StorageNew->mtpDefaultSctpMaxseg = thedata->mtpDefaultSctpMaxseg;
		StorageNew->mtpDefaultSctpHeartbeatItvl = thedata->mtpDefaultSctpHeartbeatItvl;
		StorageNew->mtpDefaultSctpHeartbeat = thedata->mtpDefaultSctpHeartbeat;
		StorageNew->mtpDefaultSctpRtoInitial = thedata->mtpDefaultSctpRtoInitial;
		StorageNew->mtpDefaultSctpRtoMin = thedata->mtpDefaultSctpRtoMin;
		StorageNew->mtpDefaultSctpRtoMax = thedata->mtpDefaultSctpRtoMax;
		StorageNew->mtpDefaultSctpPathMaxRetrans = thedata->mtpDefaultSctpPathMaxRetrans;
		StorageNew->mtpDefaultSctpCookieLife = thedata->mtpDefaultSctpCookieLife;
		StorageNew->mtpDefaultSctpCookieInc = thedata->mtpDefaultSctpCookieInc;
		StorageNew->mtpDefaultSctpMaxInitRetries = thedata->mtpDefaultSctpMaxInitRetries;
		StorageNew->mtpDefaultSctpMaxBurst = thedata->mtpDefaultSctpMaxBurst;
		StorageNew->mtpDefaultSctpAssocMaxRetrans = thedata->mtpDefaultSctpAssocMaxRetrans;
		StorageNew->mtpDefaultSctpSackDelay = thedata->mtpDefaultSctpSackDelay;
		StorageNew->mtpDefaultSctpLifetime = thedata->mtpDefaultSctpLifetime;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpMIB_destroy(struct mtpMIB_data **thedata)
 * @param thedata pointer to the data structure in mtpMIB.
 * @brief delete a scalars structure from mtpMIB.
 *
 * Frees scalars that were previously removed from mtpMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpMIB_destroy(struct mtpMIB_data **thedata)
{
	struct mtpMIB_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpMIB_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpMIB_add(struct mtpMIB_data *thedata)
 * @param thedata the structure representing mtpMIB scalars.
 * @brief adds node to the mtpMIB scalar data set.
 *
 * Adds a scalar structure to the mtpMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
mtpMIB_add(struct mtpMIB_data *thedata)
{
	DEBUGMSGTL(("mtpMIB", "mtpMIB_add: adding data...  "));
	if (thedata)
		mtpMIBStorage = thedata;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpMIB entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_mtpMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpMIB_data *StorageTmp = mtpMIB_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpMIB: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpDefaultSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpDefaultSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpDefaultSctpLifetime, &tmpsize);
	mtpMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_mtpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpMIB_data *StorageTmp;

	DEBUGMSGTL(("mtpMIB", "store_mtpMIB: storing data...  "));
	refresh_mtpMIB(1);
	if ((StorageTmp = mtpMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "mtpMIB ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpDefaultSctpNoDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpMaxseg, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpHeartbeatItvl, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpDefaultSctpHeartbeat, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpRtoInitial, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpRtoMin, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpRtoMax, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpPathMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpCookieLife, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpCookieInc, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpMaxInitRetries, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpMaxBurst, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpAssocMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpSackDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpDefaultSctpLifetime, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int check_mtpMIB(struct mtpMIB_data *StorageTmp, struct mtpMIB_data *StorageOld)
 * @param StorageTmp the data as updated
 * @param StorageOld the data previous to update
 *
 * This function is used by mibs.  It is used to check, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the ACTION phase.  The COMMIT phase does not ensue unless this check passes.  This function can
 * return SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before
 * the varbinds on the mib were applied; the values in StorageTmp are the new values.  The function
 * is permitted to change the values in StorageTmp to correct them; however, preferences should be
 * made for setting values that were not in the varbinds.
 */
int
check_mtpMIB(struct mtpMIB_data *StorageTmp, struct mtpMIB_data *StorageOld)
{
	/* XXX: provide code to check the scalars for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpMIB(struct mtpMIB_data *StorageTmp, struct mtpMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase)
 *
 * This function is used by mibs.  It is used to update, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the COMMIT phase.  The start of the ACTION phase performs a consistency check on the mib before
 * allowing the request to proceed to the COMMIT phase.  The COMMIT phase then arrives here with
 * consistency already checked (see check_mtpMIB()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the mib were applied: the values in StorageTmp are the new values.
 */
int
update_mtpMIB(struct mtpMIB_data *StorageTmp, struct mtpMIB_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpMIB_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn revert_mtpMIB(struct 
 * @fn void revert_mtpMIB(struct mtpMIB_data *StorageTmp, struct mtpMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase)
 */
void
revert_mtpMIB(struct mtpMIB_data *StorageTmp, struct mtpMIB_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpMIB(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of mtpMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_mtpMIB(int force)
{
	if (mtpMIBStorage == NULL) {
		struct mtpMIB_data *StorageNew;

		if ((StorageNew = mtpMIB_create()) == NULL)
			return;
		mtpMIBStorage = StorageNew;
		mtpMIB_refresh = 1;
	}
	if (!force && mtpMIB_refresh == 0)
		return;
	DEBUGMSGTL(("mtpMIB", "refresh_mtpMIB: refreshing...  "));
	/* XXX: Update scalars as required here... */
	mtpMIB_refresh = 0;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/**
 * @fn u_char * var_mtpMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in mtpMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_mtpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMIB_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpMIB: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_mtpMIB(0);
	if ((StorageTmp = mtpMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpMIB", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPDEFAULTSCTPNODELAY:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpNoDelay);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpNoDelay;
		break;
	case (u_char) MTPDEFAULTSCTPMAXSEG:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpMaxseg);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpMaxseg;
		break;
	case (u_char) MTPDEFAULTSCTPHEARTBEATITVL:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpHeartbeatItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpHeartbeatItvl);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpHeartbeatItvl;
		break;
	case (u_char) MTPDEFAULTSCTPHEARTBEAT:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpHeartbeat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpHeartbeat);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpHeartbeat;
		break;
	case (u_char) MTPDEFAULTSCTPRTOINITIAL:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpRtoInitial;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpRtoInitial);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpRtoInitial;
		break;
	case (u_char) MTPDEFAULTSCTPRTOMIN:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpRtoMin);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpRtoMin;
		break;
	case (u_char) MTPDEFAULTSCTPRTOMAX:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpRtoMax);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpRtoMax;
		break;
	case (u_char) MTPDEFAULTSCTPPATHMAXRETRANS:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpPathMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpPathMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpPathMaxRetrans;
		break;
	case (u_char) MTPDEFAULTSCTPCOOKIELIFE:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpCookieLife;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpCookieLife);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpCookieLife;
		break;
	case (u_char) MTPDEFAULTSCTPCOOKIEINC:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpCookieInc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpCookieInc);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpCookieInc;
		break;
	case (u_char) MTPDEFAULTSCTPMAXINITRETRIES:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpMaxInitRetries;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpMaxInitRetries);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpMaxInitRetries;
		break;
	case (u_char) MTPDEFAULTSCTPMAXBURST:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpMaxBurst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpMaxBurst);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpMaxBurst;
		break;
	case (u_char) MTPDEFAULTSCTPASSOCMAXRETRANS:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpAssocMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpAssocMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpAssocMaxRetrans;
		break;
	case (u_char) MTPDEFAULTSCTPSACKDELAY:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpSackDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpSackDelay);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpSackDelay;
		break;
	case (u_char) MTPDEFAULTSCTPLIFETIME:	/* ReadWrite */
		*write_method = write_mtpDefaultSctpLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpDefaultSctpLifetime);
		rval = (u_char *) &StorageTmp->mtpDefaultSctpLifetime;
		break;
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("mtpMIB", "found.\n"));
	else
		DEBUGMSGTL(("mtpMIB", "not found.\n"));
	return (rval);
}

/**
 * @fn struct mtpSapTable_data *mtpSapTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSapTable table.
 *
 * Creates a new mtpSapTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSapTable_data *
mtpSapTable_create(void)
{
	struct mtpSapTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSapTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSapTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		if ((StorageNew->mtpSap2Address = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSap2AddressLen = 0;
		StorageNew->mtpSap2Address[StorageNew->mtpSap2AddressLen] = 0;
		StorageNew->mtpSapUserPart = 0;
		StorageNew->mtpSapUserPartStatus = 0;
		if ((StorageNew->mtpSapUserEntityNames = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->mtpSapUserEntityNamesLen = 2;
		if ((StorageNew->mtpSapProviderEntityNames = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->mtpSapProviderEntityNamesLen = 2;
		StorageNew->mtpSapUsageState = 0;
		if ((StorageNew->mtpSapAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
			StorageNew->mtpSapAsaProfilePointerLen = 2;
		if ((StorageNew->mtpSapName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSapNameLen = 0;
		StorageNew->mtpSapName[StorageNew->mtpSapNameLen] = 0;
		StorageNew->mtpSapLongMessageSupported = 0;
		StorageNew->mtpSapRowStatus = 0;
		StorageNew->mtpSapRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSapTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSapTable_data *mtpSapTable_duplicate(struct mtpSapTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSapTable_data *
mtpSapTable_duplicate(struct mtpSapTable_data *thedata)
{
	struct mtpSapTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSapTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSapTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSapTable_id = thedata->mtpSapTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpSapId = thedata->mtpSapId;
		if (!(StorageNew->mtpSap2Address = malloc(thedata->mtpSap2AddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSap2Address, thedata->mtpSap2Address, thedata->mtpSap2AddressLen);
		StorageNew->mtpSap2AddressLen = thedata->mtpSap2AddressLen;
		StorageNew->mtpSap2Address[StorageNew->mtpSap2AddressLen] = 0;
		StorageNew->mtpSapUserPart = thedata->mtpSapUserPart;
		StorageNew->mtpSapUserPartStatus = thedata->mtpSapUserPartStatus;
		if (!(StorageNew->mtpSapUserEntityNames = snmp_duplicate_objid(thedata->mtpSapUserEntityNames, thedata->mtpSapUserEntityNamesLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSapUserEntityNamesLen = thedata->mtpSapUserEntityNamesLen;
		if (!(StorageNew->mtpSapProviderEntityNames = snmp_duplicate_objid(thedata->mtpSapProviderEntityNames, thedata->mtpSapProviderEntityNamesLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSapProviderEntityNamesLen = thedata->mtpSapProviderEntityNamesLen;
		StorageNew->mtpSapUsageState = thedata->mtpSapUsageState;
		if (!(StorageNew->mtpSapAsaProfilePointer = snmp_duplicate_objid(thedata->mtpSapAsaProfilePointer, thedata->mtpSapAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSapAsaProfilePointerLen = thedata->mtpSapAsaProfilePointerLen;
		if (!(StorageNew->mtpSapName = malloc(thedata->mtpSapNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSapName, thedata->mtpSapName, thedata->mtpSapNameLen);
		StorageNew->mtpSapNameLen = thedata->mtpSapNameLen;
		StorageNew->mtpSapName[StorageNew->mtpSapNameLen] = 0;
		StorageNew->mtpSapLongMessageSupported = thedata->mtpSapLongMessageSupported;
		StorageNew->mtpSapRowStatus = thedata->mtpSapRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSapTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSapTable_destroy(struct mtpSapTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSapTable_destroy(struct mtpSapTable_data **thedata)
{
	struct mtpSapTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSapTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSap2Address);
		StorageDel->mtpSap2AddressLen = 0;
		SNMP_FREE(StorageDel->mtpSapUserEntityNames);
		StorageDel->mtpSapUserEntityNamesLen = 0;
		SNMP_FREE(StorageDel->mtpSapProviderEntityNames);
		StorageDel->mtpSapProviderEntityNamesLen = 0;
		SNMP_FREE(StorageDel->mtpSapAsaProfilePointer);
		StorageDel->mtpSapAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSapName);
		StorageDel->mtpSapNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSapTable_add(struct mtpSapTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSapTable table data set.
 *
 * Adds a table row structure to the mtpSapTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSapTable_add(struct mtpSapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSapTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpSapId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSapId, sizeof(thedata->mtpSapId));
		header_complex_add_data(&mtpSapTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSapTable_del(struct mtpSapTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSapTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSapTable_del(struct mtpSapTable_data *thedata)
{
	struct mtpSapTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSapTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSapTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSapTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSapTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSapTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSapTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSapTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSapTable_data *StorageTmp = mtpSapTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSapTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSapId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSap2Address);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSap2Address, &StorageTmp->mtpSap2AddressLen);
	if (StorageTmp->mtpSap2Address == NULL) {
		config_perror("invalid specification for mtpSap2Address");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUserPart, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUserPartStatus, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSapUserEntityNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapUserEntityNames, &StorageTmp->mtpSapUserEntityNamesLen);
	if (StorageTmp->mtpSapUserEntityNames == NULL) {
		config_perror("invalid specification for mtpSapUserEntityNames");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSapProviderEntityNames);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapProviderEntityNames, &StorageTmp->mtpSapProviderEntityNamesLen);
	if (StorageTmp->mtpSapProviderEntityNames == NULL) {
		config_perror("invalid specification for mtpSapProviderEntityNames");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSapAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSapAsaProfilePointer, &StorageTmp->mtpSapAsaProfilePointerLen);
	if (StorageTmp->mtpSapAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSapAsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSapName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSapName, &StorageTmp->mtpSapNameLen);
	if (StorageTmp->mtpSapName == NULL) {
		config_perror("invalid specification for mtpSapName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapLongMessageSupported, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSapRowStatus, &tmpsize);
	mtpSapTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSapTable(): store configuraiton file for mtpSapTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSapTable: storing data...  "));
	refresh_mtpSapTable(1);
	(void) tmpsize;
	for (hcindex = mtpSapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSapTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSapTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSapId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSap2Address, &StorageTmp->mtpSap2AddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUserPart, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUserPartStatus, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapUserEntityNames, &StorageTmp->mtpSapUserEntityNamesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapProviderEntityNames, &StorageTmp->mtpSapProviderEntityNamesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSapAsaProfilePointer, &StorageTmp->mtpSapAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSapName, &StorageTmp->mtpSapNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapLongMessageSupported, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSapRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpNaTable_data *mtpNaTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpNaTable table.
 *
 * Creates a new mtpNaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpNaTable_data *
mtpNaTable_create(void)
{
	struct mtpNaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNaTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpNaTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		{
			static oid tmpoid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 0, 1, 4, 1, 1 };
			if ((StorageNew->mtpNaProtocolVariant = snmp_duplicate_objid(tmpoid, 14)) == NULL)
				goto nomem;
			StorageNew->mtpNaProtocolVariantLen = 14;
		}
		StorageNew->mtpNaProtocolYear = MTPNAPROTOCOLYEAR_YCURRENT;
		if (memdup((u_char **) &StorageNew->mtpNaProtocolOptions, (u_char *) "\x81\x07\x00\x80", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpNaProtocolOptionsLen = 4;
		StorageNew->mtpNaNetworkIndicator = MTPNANETWORKINDICATOR_INTERNATIONALNETWORK1;
		if (memdup((u_char **) &StorageNew->mtpNaPointCodeFormat, (u_char *) "\x03\x08\x03", 3) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpNaPointCodeFormatLen = 3;
		StorageNew->mtpNaSlsLength = MTPNASLSLENGTH_SLS4BITS;
		if ((StorageNew->mtpNaSpDefault = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpNaSpDefaultLen = strlen("");
		if ((StorageNew->mtpNaName = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpNaNameLen = strlen("");
		StorageNew->mtpNaRowStatus = 0;
		StorageNew->mtpNaRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpNaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpNaTable_data *mtpNaTable_duplicate(struct mtpNaTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpNaTable_data *
mtpNaTable_duplicate(struct mtpNaTable_data *thedata)
{
	struct mtpNaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNaTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpNaTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpNaTable_id = thedata->mtpNaTable_id;
		StorageNew->mtpNaId = thedata->mtpNaId;
		if (!(StorageNew->mtpNaProtocolVariant = snmp_duplicate_objid(thedata->mtpNaProtocolVariant, thedata->mtpNaProtocolVariantLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpNaProtocolVariantLen = thedata->mtpNaProtocolVariantLen;
		StorageNew->mtpNaProtocolYear = thedata->mtpNaProtocolYear;
		if (!(StorageNew->mtpNaProtocolOptions = malloc(thedata->mtpNaProtocolOptionsLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpNaProtocolOptions, thedata->mtpNaProtocolOptions, thedata->mtpNaProtocolOptionsLen);
		StorageNew->mtpNaProtocolOptionsLen = thedata->mtpNaProtocolOptionsLen;
		StorageNew->mtpNaProtocolOptions[StorageNew->mtpNaProtocolOptionsLen] = 0;
		StorageNew->mtpNaNetworkIndicator = thedata->mtpNaNetworkIndicator;
		if (!(StorageNew->mtpNaPointCodeFormat = malloc(thedata->mtpNaPointCodeFormatLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpNaPointCodeFormat, thedata->mtpNaPointCodeFormat, thedata->mtpNaPointCodeFormatLen);
		StorageNew->mtpNaPointCodeFormatLen = thedata->mtpNaPointCodeFormatLen;
		StorageNew->mtpNaPointCodeFormat[StorageNew->mtpNaPointCodeFormatLen] = 0;
		StorageNew->mtpNaSlsLength = thedata->mtpNaSlsLength;
		if (!(StorageNew->mtpNaSpDefault = malloc(thedata->mtpNaSpDefaultLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpNaSpDefault, thedata->mtpNaSpDefault, thedata->mtpNaSpDefaultLen);
		StorageNew->mtpNaSpDefaultLen = thedata->mtpNaSpDefaultLen;
		StorageNew->mtpNaSpDefault[StorageNew->mtpNaSpDefaultLen] = 0;
		if (!(StorageNew->mtpNaName = malloc(thedata->mtpNaNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpNaName, thedata->mtpNaName, thedata->mtpNaNameLen);
		StorageNew->mtpNaNameLen = thedata->mtpNaNameLen;
		StorageNew->mtpNaName[StorageNew->mtpNaNameLen] = 0;
		StorageNew->mtpNaRowStatus = thedata->mtpNaRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpNaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpNaTable_destroy(struct mtpNaTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpNaTable_destroy(struct mtpNaTable_data **thedata)
{
	struct mtpNaTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpNaTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpNaProtocolVariant);
		StorageDel->mtpNaProtocolVariantLen = 0;
		SNMP_FREE(StorageDel->mtpNaProtocolOptions);
		StorageDel->mtpNaProtocolOptionsLen = 0;
		SNMP_FREE(StorageDel->mtpNaPointCodeFormat);
		StorageDel->mtpNaPointCodeFormatLen = 0;
		SNMP_FREE(StorageDel->mtpNaSpDefault);
		StorageDel->mtpNaSpDefaultLen = 0;
		SNMP_FREE(StorageDel->mtpNaName);
		StorageDel->mtpNaNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNaTable_add(struct mtpNaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpNaTable table data set.
 *
 * Adds a table row structure to the mtpNaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpNaTable_add(struct mtpNaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpNaTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpNaId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpNaId, sizeof(thedata->mtpNaId));
		header_complex_add_data(&mtpNaTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNaTable_del(struct mtpNaTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpNaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpNaTable_del(struct mtpNaTable_data *thedata)
{
	struct mtpNaTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpNaTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpNaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpNaTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpNaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpNaTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpNaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpNaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpNaTable_data *StorageTmp = mtpNaTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpNaTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpNaProtocolVariant);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
	if (StorageTmp->mtpNaProtocolVariant == NULL) {
		config_perror("invalid specification for mtpNaProtocolVariant");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaProtocolYear, &tmpsize);
	SNMP_FREE(StorageTmp->mtpNaProtocolOptions);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
	if (StorageTmp->mtpNaProtocolOptions == NULL) {
		config_perror("invalid specification for mtpNaProtocolOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaNetworkIndicator, &tmpsize);
	SNMP_FREE(StorageTmp->mtpNaPointCodeFormat);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
	if (StorageTmp->mtpNaPointCodeFormat == NULL) {
		config_perror("invalid specification for mtpNaPointCodeFormat");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaSlsLength, &tmpsize);
	SNMP_FREE(StorageTmp->mtpNaSpDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaSpDefault, &StorageTmp->mtpNaSpDefaultLen);
	if (StorageTmp->mtpNaSpDefault == NULL) {
		config_perror("invalid specification for mtpNaSpDefault");
		return;
	}
	SNMP_FREE(StorageTmp->mtpNaName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
	if (StorageTmp->mtpNaName == NULL) {
		config_perror("invalid specification for mtpNaName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNaRowStatus, &tmpsize);
	mtpNaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpNaTable(): store configuraiton file for mtpNaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpNaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpNaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpNaTable: storing data...  "));
	refresh_mtpNaTable(1);
	(void) tmpsize;
	for (hcindex = mtpNaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpNaTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpNaProtocolVariant, &StorageTmp->mtpNaProtocolVariantLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaProtocolYear, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaProtocolOptions, &StorageTmp->mtpNaProtocolOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaNetworkIndicator, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaPointCodeFormat, &StorageTmp->mtpNaPointCodeFormatLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaSlsLength, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaSpDefault, &StorageTmp->mtpNaSpDefaultLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpNaName, &StorageTmp->mtpNaNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNaRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpMsTable_data *mtpMsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpMsTable table.
 *
 * Creates a new mtpMsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpMsTable_data *
mtpMsTable_create(void)
{
	struct mtpMsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpMsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpMsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpMsName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpMsNameLen = 0;
		StorageNew->mtpMsName[StorageNew->mtpMsNameLen] = 0;
		if (memdup((u_char **) &StorageNew->mtpMsAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpMsAlarmStatusLen = 1;
		StorageNew->mtpMsOperationalState = MTPMSOPERATIONALSTATE_DISABLED;
		StorageNew->mtpMsUsageState = MTPMSUSAGESTATE_IDLE;
		if ((StorageNew->mtpMsManagedElementType = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpMsManagedElementTypeLen = 0;
		StorageNew->mtpMsManagedElementType[StorageNew->mtpMsManagedElementTypeLen] = 0;
		if ((StorageNew->mtpMsModelCode = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpMsModelCodeLen = 0;
		StorageNew->mtpMsModelCode[StorageNew->mtpMsModelCodeLen] = 0;
		if ((StorageNew->mtpMsVendorName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpMsVendorNameLen = 0;
		StorageNew->mtpMsVendorName[StorageNew->mtpMsVendorNameLen] = 0;
		if ((StorageNew->mtpMsUserLabel = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpMsUserLabelLen = 0;
		StorageNew->mtpMsUserLabel[StorageNew->mtpMsUserLabelLen] = 0;
		if ((StorageNew->mtpMsVersion = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpMsVersionLen = 0;
		StorageNew->mtpMsVersion[StorageNew->mtpMsVersionLen] = 0;
		if ((StorageNew->mtpMsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpMsAsaProfilePointerLen = 2;
		if ((StorageNew->mtpMsNetworkElementAliases = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpMsNetworkElementAliasesLen = 0;
		StorageNew->mtpMsNetworkElementAliases[StorageNew->mtpMsNetworkElementAliasesLen] = 0;
		StorageNew->mtpMsRowStatus = 0;
		StorageNew->mtpMsRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpMsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpMsTable_data *mtpMsTable_duplicate(struct mtpMsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpMsTable_data *
mtpMsTable_duplicate(struct mtpMsTable_data *thedata)
{
	struct mtpMsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpMsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpMsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpMsTable_id = thedata->mtpMsTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		if (!(StorageNew->mtpMsName = malloc(thedata->mtpMsNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpMsName, thedata->mtpMsName, thedata->mtpMsNameLen);
		StorageNew->mtpMsNameLen = thedata->mtpMsNameLen;
		StorageNew->mtpMsName[StorageNew->mtpMsNameLen] = 0;
		if (!(StorageNew->mtpMsAlarmStatus = malloc(thedata->mtpMsAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpMsAlarmStatus, thedata->mtpMsAlarmStatus, thedata->mtpMsAlarmStatusLen);
		StorageNew->mtpMsAlarmStatusLen = thedata->mtpMsAlarmStatusLen;
		StorageNew->mtpMsAlarmStatus[StorageNew->mtpMsAlarmStatusLen] = 0;
		StorageNew->mtpMsOperationalState = thedata->mtpMsOperationalState;
		StorageNew->mtpMsUsageState = thedata->mtpMsUsageState;
		if (!(StorageNew->mtpMsManagedElementType = malloc(thedata->mtpMsManagedElementTypeLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpMsManagedElementType, thedata->mtpMsManagedElementType, thedata->mtpMsManagedElementTypeLen);
		StorageNew->mtpMsManagedElementTypeLen = thedata->mtpMsManagedElementTypeLen;
		StorageNew->mtpMsManagedElementType[StorageNew->mtpMsManagedElementTypeLen] = 0;
		if (!(StorageNew->mtpMsModelCode = malloc(thedata->mtpMsModelCodeLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpMsModelCode, thedata->mtpMsModelCode, thedata->mtpMsModelCodeLen);
		StorageNew->mtpMsModelCodeLen = thedata->mtpMsModelCodeLen;
		StorageNew->mtpMsModelCode[StorageNew->mtpMsModelCodeLen] = 0;
		if (!(StorageNew->mtpMsVendorName = malloc(thedata->mtpMsVendorNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpMsVendorName, thedata->mtpMsVendorName, thedata->mtpMsVendorNameLen);
		StorageNew->mtpMsVendorNameLen = thedata->mtpMsVendorNameLen;
		StorageNew->mtpMsVendorName[StorageNew->mtpMsVendorNameLen] = 0;
		if (!(StorageNew->mtpMsUserLabel = malloc(thedata->mtpMsUserLabelLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpMsUserLabel, thedata->mtpMsUserLabel, thedata->mtpMsUserLabelLen);
		StorageNew->mtpMsUserLabelLen = thedata->mtpMsUserLabelLen;
		StorageNew->mtpMsUserLabel[StorageNew->mtpMsUserLabelLen] = 0;
		if (!(StorageNew->mtpMsVersion = malloc(thedata->mtpMsVersionLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpMsVersion, thedata->mtpMsVersion, thedata->mtpMsVersionLen);
		StorageNew->mtpMsVersionLen = thedata->mtpMsVersionLen;
		StorageNew->mtpMsVersion[StorageNew->mtpMsVersionLen] = 0;
		if (!(StorageNew->mtpMsAsaProfilePointer = snmp_duplicate_objid(thedata->mtpMsAsaProfilePointer, thedata->mtpMsAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpMsAsaProfilePointerLen = thedata->mtpMsAsaProfilePointerLen;
		if (!(StorageNew->mtpMsNetworkElementAliases = malloc(thedata->mtpMsNetworkElementAliasesLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpMsNetworkElementAliases, thedata->mtpMsNetworkElementAliases, thedata->mtpMsNetworkElementAliasesLen);
		StorageNew->mtpMsNetworkElementAliasesLen = thedata->mtpMsNetworkElementAliasesLen;
		StorageNew->mtpMsNetworkElementAliases[StorageNew->mtpMsNetworkElementAliasesLen] = 0;
		StorageNew->mtpMsRowStatus = thedata->mtpMsRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpMsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpMsTable_destroy(struct mtpMsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpMsTable_destroy(struct mtpMsTable_data **thedata)
{
	struct mtpMsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpMsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpMsName);
		StorageDel->mtpMsNameLen = 0;
		SNMP_FREE(StorageDel->mtpMsAlarmStatus);
		StorageDel->mtpMsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->mtpMsManagedElementType);
		StorageDel->mtpMsManagedElementTypeLen = 0;
		SNMP_FREE(StorageDel->mtpMsModelCode);
		StorageDel->mtpMsModelCodeLen = 0;
		SNMP_FREE(StorageDel->mtpMsVendorName);
		StorageDel->mtpMsVendorNameLen = 0;
		SNMP_FREE(StorageDel->mtpMsUserLabel);
		StorageDel->mtpMsUserLabelLen = 0;
		SNMP_FREE(StorageDel->mtpMsVersion);
		StorageDel->mtpMsVersionLen = 0;
		SNMP_FREE(StorageDel->mtpMsAsaProfilePointer);
		StorageDel->mtpMsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpMsNetworkElementAliases);
		StorageDel->mtpMsNetworkElementAliasesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpMsTable_add(struct mtpMsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpMsTable table data set.
 *
 * Adds a table row structure to the mtpMsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpMsTable_add(struct mtpMsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpMsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		header_complex_add_data(&mtpMsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpMsTable_del(struct mtpMsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpMsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpMsTable_del(struct mtpMsTable_data *thedata)
{
	struct mtpMsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpMsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpMsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpMsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpMsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpMsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpMsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpMsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpMsTable_data *StorageTmp = mtpMsTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpMsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpMsName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsName, &StorageTmp->mtpMsNameLen);
	if (StorageTmp->mtpMsName == NULL) {
		config_perror("invalid specification for mtpMsName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsAlarmStatus, &StorageTmp->mtpMsAlarmStatusLen);
	if (StorageTmp->mtpMsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpMsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpMsManagedElementType);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsManagedElementType, &StorageTmp->mtpMsManagedElementTypeLen);
	if (StorageTmp->mtpMsManagedElementType == NULL) {
		config_perror("invalid specification for mtpMsManagedElementType");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsModelCode);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsModelCode, &StorageTmp->mtpMsModelCodeLen);
	if (StorageTmp->mtpMsModelCode == NULL) {
		config_perror("invalid specification for mtpMsModelCode");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsVendorName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVendorName, &StorageTmp->mtpMsVendorNameLen);
	if (StorageTmp->mtpMsVendorName == NULL) {
		config_perror("invalid specification for mtpMsVendorName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsUserLabel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsUserLabel, &StorageTmp->mtpMsUserLabelLen);
	if (StorageTmp->mtpMsUserLabel == NULL) {
		config_perror("invalid specification for mtpMsUserLabel");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsVersion);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsVersion, &StorageTmp->mtpMsVersionLen);
	if (StorageTmp->mtpMsVersion == NULL) {
		config_perror("invalid specification for mtpMsVersion");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpMsAsaProfilePointer, &StorageTmp->mtpMsAsaProfilePointerLen);
	if (StorageTmp->mtpMsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpMsAsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpMsNetworkElementAliases);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpMsNetworkElementAliases, &StorageTmp->mtpMsNetworkElementAliasesLen);
	if (StorageTmp->mtpMsNetworkElementAliases == NULL) {
		config_perror("invalid specification for mtpMsNetworkElementAliases");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpMsRowStatus, &tmpsize);
	mtpMsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpMsTable(): store configuraiton file for mtpMsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpMsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpMsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpMsTable: storing data...  "));
	refresh_mtpMsTable(1);
	(void) tmpsize;
	for (hcindex = mtpMsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpMsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpMsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsName, &StorageTmp->mtpMsNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsAlarmStatus, &StorageTmp->mtpMsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsManagedElementType, &StorageTmp->mtpMsManagedElementTypeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsModelCode, &StorageTmp->mtpMsModelCodeLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVendorName, &StorageTmp->mtpMsVendorNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsUserLabel, &StorageTmp->mtpMsUserLabelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsVersion, &StorageTmp->mtpMsVersionLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpMsAsaProfilePointer, &StorageTmp->mtpMsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpMsNetworkElementAliases, &StorageTmp->mtpMsNetworkElementAliasesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpMsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSpProfileTable_data *mtpSpProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSpProfileTable table.
 *
 * Creates a new mtpSpProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSpProfileTable_data *
mtpSpProfileTable_create(void)
{
	struct mtpSpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSpProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpProfileTimerT1R = 80;
		StorageNew->mtpSpProfileTimerT2 = 140;
		StorageNew->mtpSpProfileTimerT4 = 80;
		StorageNew->mtpSpProfileTimerT5 = 80;
		StorageNew->mtpSpProfileTimerT7 = 150;
		StorageNew->mtpSpProfileTimerT11 = 6000;
		StorageNew->mtpSpProfileTimerT12 = 120;
		StorageNew->mtpSpProfileTimerT13 = 120;
		StorageNew->mtpSpProfileTimerT14 = 250;
		StorageNew->mtpSpProfileTimerT15 = 250;
		StorageNew->mtpSpProfileTimerT16 = 200;
		StorageNew->mtpSpProfileTimerT18I = 60000;
		StorageNew->mtpSpProfileTimerT19I = 6800;
		StorageNew->mtpSpProfileTimerT20I = 6000;
		StorageNew->mtpSpProfileTimerT21I = 6400;
		StorageNew->mtpSpProfileTimerT22I = 27000;
		StorageNew->mtpSpProfileTimerT23I = 27000;
		StorageNew->mtpSpProfileTimerT20A = 10000;
		StorageNew->mtpSpProfileTimerT21A = 10000;
		StorageNew->mtpSpProfileTimerT22A = 60000;
		StorageNew->mtpSpProfileTimerT23A = 60000;
		StorageNew->mtpSpProfileTimerT24A = 60000;
		StorageNew->mtpSpProfileTimerT26A = 1350;
		StorageNew->mtpSpProfileTimerT27A = 300;
		StorageNew->mtpSpProfileTimerT1T = 400;
		StorageNew->mtpSpProfileTimerT2T = 6000;
		if ((StorageNew->mtpSpProfileName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSpProfileNameLen = 0;
		StorageNew->mtpSpProfileName[StorageNew->mtpSpProfileNameLen] = 0;
		StorageNew->mtpSpProfileCircularRteDetect = MTPSPPROFILECIRCULARRTEDETECT_NONE;
		if ((StorageNew->mtpSpRsDefault = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpSpRsDefaultLen = strlen("");
		if ((StorageNew->mtpSpLsDefault = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpSpLsDefaultLen = strlen("");
		StorageNew->mtpSpProfileRowStatus = 0;
		StorageNew->mtpSpProfileRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSpProfileTable_data *mtpSpProfileTable_duplicate(struct mtpSpProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSpProfileTable_data *
mtpSpProfileTable_duplicate(struct mtpSpProfileTable_data *thedata)
{
	struct mtpSpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSpProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSpProfileTable_id = thedata->mtpSpProfileTable_id;
		if (!(StorageNew->mtpSpProfileId = malloc(thedata->mtpSpProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpProfileId, thedata->mtpSpProfileId, thedata->mtpSpProfileIdLen);
		StorageNew->mtpSpProfileIdLen = thedata->mtpSpProfileIdLen;
		StorageNew->mtpSpProfileId[StorageNew->mtpSpProfileIdLen] = 0;
		StorageNew->mtpSpProfileTimerT1R = thedata->mtpSpProfileTimerT1R;
		StorageNew->mtpSpProfileTimerT2 = thedata->mtpSpProfileTimerT2;
		StorageNew->mtpSpProfileTimerT4 = thedata->mtpSpProfileTimerT4;
		StorageNew->mtpSpProfileTimerT5 = thedata->mtpSpProfileTimerT5;
		StorageNew->mtpSpProfileTimerT7 = thedata->mtpSpProfileTimerT7;
		StorageNew->mtpSpProfileTimerT11 = thedata->mtpSpProfileTimerT11;
		StorageNew->mtpSpProfileTimerT12 = thedata->mtpSpProfileTimerT12;
		StorageNew->mtpSpProfileTimerT13 = thedata->mtpSpProfileTimerT13;
		StorageNew->mtpSpProfileTimerT14 = thedata->mtpSpProfileTimerT14;
		StorageNew->mtpSpProfileTimerT15 = thedata->mtpSpProfileTimerT15;
		StorageNew->mtpSpProfileTimerT16 = thedata->mtpSpProfileTimerT16;
		StorageNew->mtpSpProfileTimerT18I = thedata->mtpSpProfileTimerT18I;
		StorageNew->mtpSpProfileTimerT19I = thedata->mtpSpProfileTimerT19I;
		StorageNew->mtpSpProfileTimerT20I = thedata->mtpSpProfileTimerT20I;
		StorageNew->mtpSpProfileTimerT21I = thedata->mtpSpProfileTimerT21I;
		StorageNew->mtpSpProfileTimerT22I = thedata->mtpSpProfileTimerT22I;
		StorageNew->mtpSpProfileTimerT23I = thedata->mtpSpProfileTimerT23I;
		StorageNew->mtpSpProfileTimerT20A = thedata->mtpSpProfileTimerT20A;
		StorageNew->mtpSpProfileTimerT21A = thedata->mtpSpProfileTimerT21A;
		StorageNew->mtpSpProfileTimerT22A = thedata->mtpSpProfileTimerT22A;
		StorageNew->mtpSpProfileTimerT23A = thedata->mtpSpProfileTimerT23A;
		StorageNew->mtpSpProfileTimerT24A = thedata->mtpSpProfileTimerT24A;
		StorageNew->mtpSpProfileTimerT26A = thedata->mtpSpProfileTimerT26A;
		StorageNew->mtpSpProfileTimerT27A = thedata->mtpSpProfileTimerT27A;
		StorageNew->mtpSpProfileTimerT1T = thedata->mtpSpProfileTimerT1T;
		StorageNew->mtpSpProfileTimerT2T = thedata->mtpSpProfileTimerT2T;
		if (!(StorageNew->mtpSpProfileName = malloc(thedata->mtpSpProfileNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpProfileName, thedata->mtpSpProfileName, thedata->mtpSpProfileNameLen);
		StorageNew->mtpSpProfileNameLen = thedata->mtpSpProfileNameLen;
		StorageNew->mtpSpProfileName[StorageNew->mtpSpProfileNameLen] = 0;
		StorageNew->mtpSpProfileCircularRteDetect = thedata->mtpSpProfileCircularRteDetect;
		if (!(StorageNew->mtpSpRsDefault = malloc(thedata->mtpSpRsDefaultLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpRsDefault, thedata->mtpSpRsDefault, thedata->mtpSpRsDefaultLen);
		StorageNew->mtpSpRsDefaultLen = thedata->mtpSpRsDefaultLen;
		StorageNew->mtpSpRsDefault[StorageNew->mtpSpRsDefaultLen] = 0;
		if (!(StorageNew->mtpSpLsDefault = malloc(thedata->mtpSpLsDefaultLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpLsDefault, thedata->mtpSpLsDefault, thedata->mtpSpLsDefaultLen);
		StorageNew->mtpSpLsDefaultLen = thedata->mtpSpLsDefaultLen;
		StorageNew->mtpSpLsDefault[StorageNew->mtpSpLsDefaultLen] = 0;
		StorageNew->mtpSpProfileRowStatus = thedata->mtpSpProfileRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSpProfileTable_destroy(struct mtpSpProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSpProfileTable_destroy(struct mtpSpProfileTable_data **thedata)
{
	struct mtpSpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSpProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSpProfileId);
		StorageDel->mtpSpProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSpProfileName);
		StorageDel->mtpSpProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpSpRsDefault);
		StorageDel->mtpSpRsDefaultLen = 0;
		SNMP_FREE(StorageDel->mtpSpLsDefault);
		StorageDel->mtpSpLsDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpProfileTable_add(struct mtpSpProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSpProfileTable table data set.
 *
 * Adds a table row structure to the mtpSpProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSpProfileTable_add(struct mtpSpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSpProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSpProfileId, thedata->mtpSpProfileIdLen);
		header_complex_add_data(&mtpSpProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpProfileTable_del(struct mtpSpProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSpProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSpProfileTable_del(struct mtpSpProfileTable_data *thedata)
{
	struct mtpSpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSpProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSpProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSpProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSpProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSpProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSpProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSpProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpProfileTable_data *StorageTmp = mtpSpProfileTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSpProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSpProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileId, &StorageTmp->mtpSpProfileIdLen);
	if (StorageTmp->mtpSpProfileId == NULL) {
		config_perror("invalid specification for mtpSpProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1R, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT12, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT13, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT14, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT18I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT19I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT21I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT20A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT21A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT22A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT23A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT24A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT26A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT27A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileTimerT2T, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSpProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
	if (StorageTmp->mtpSpProfileName == NULL) {
		config_perror("invalid specification for mtpSpProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileCircularRteDetect, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSpRsDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpRsDefault, &StorageTmp->mtpSpRsDefaultLen);
	if (StorageTmp->mtpSpRsDefault == NULL) {
		config_perror("invalid specification for mtpSpRsDefault");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpLsDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpLsDefault, &StorageTmp->mtpSpLsDefaultLen);
	if (StorageTmp->mtpSpLsDefault == NULL) {
		config_perror("invalid specification for mtpSpLsDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpProfileRowStatus, &tmpsize);
	mtpSpProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSpProfileTable(): store configuraiton file for mtpSpProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSpProfileTable: storing data...  "));
	refresh_mtpSpProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpSpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSpProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileId, &StorageTmp->mtpSpProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1R, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT12, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT13, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT14, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT18I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT19I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT21I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT20A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT21A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT22A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT23A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT24A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT26A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT27A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileTimerT2T, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfileName, &StorageTmp->mtpSpProfileNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileCircularRteDetect, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpRsDefault, &StorageTmp->mtpSpRsDefaultLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpLsDefault, &StorageTmp->mtpSpLsDefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSpTable_data *mtpSpTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSpTable table.
 *
 * Creates a new mtpSpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSpTable_data *
mtpSpTable_create(void)
{
	struct mtpSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSpTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		if (memdup((u_char **) &StorageNew->mtpSpPointCode, (u_char *) "\x00\x00\x00\x00", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSpPointCodeLen = 4;
		StorageNew->mtpSpType = MTPSPTYPE_SEP;
		StorageNew->mtpSpOperationalState = MTPSPOPERATIONALSTATE_DISABLED;
		if (memdup((u_char **) &StorageNew->mtpSpProceduralStatus, (u_char *) "\x80", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSpProceduralStatusLen = 1;
		if (memdup((u_char **) &StorageNew->mtpSpAvailabilityStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSpAvailabilityStatusLen = 2;
		if ((StorageNew->mtpSpVersion = (uint8_t *) strdup("ITU-T Q.704 1996")) == NULL)
			goto nomem;
		StorageNew->mtpSpVersionLen = strlen("ITU-T Q.704 1996");
		StorageNew->mtpSpNetworkIndicator = MTPSPNETWORKINDICATOR_INTERNATIONALNETWORK1;
		if ((StorageNew->mtpSpName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSpNameLen = 0;
		StorageNew->mtpSpName[StorageNew->mtpSpNameLen] = 0;
		if ((StorageNew->mtpSpProfilePointer = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpSpProfilePointerLen = strlen("");
		if ((StorageNew->mtpSpNaPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSpNaPointerLen = 2;
		if (memdup((u_char **) &StorageNew->mtpSpOptions, (u_char *) "\x20", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSpOptionsLen = 1;
		if (memdup((u_char **) &StorageNew->mtpSpUsers, (u_char *) "\x14\x80", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSpUsersLen = 2;
		if (memdup((u_char **) &StorageNew->mtpSpAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSpAlarmStatusLen = 1;
		StorageNew->mtpSpRowStatus = 0;
		StorageNew->mtpSpRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSpTable_data *mtpSpTable_duplicate(struct mtpSpTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSpTable_data *
mtpSpTable_duplicate(struct mtpSpTable_data *thedata)
{
	struct mtpSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSpTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSpTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSpTable_id = thedata->mtpSpTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		if (!(StorageNew->mtpSpPointCode = malloc(thedata->mtpSpPointCodeLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpPointCode, thedata->mtpSpPointCode, thedata->mtpSpPointCodeLen);
		StorageNew->mtpSpPointCodeLen = thedata->mtpSpPointCodeLen;
		StorageNew->mtpSpPointCode[StorageNew->mtpSpPointCodeLen] = 0;
		StorageNew->mtpSpType = thedata->mtpSpType;
		StorageNew->mtpSpOperationalState = thedata->mtpSpOperationalState;
		if (!(StorageNew->mtpSpProceduralStatus = malloc(thedata->mtpSpProceduralStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpProceduralStatus, thedata->mtpSpProceduralStatus, thedata->mtpSpProceduralStatusLen);
		StorageNew->mtpSpProceduralStatusLen = thedata->mtpSpProceduralStatusLen;
		StorageNew->mtpSpProceduralStatus[StorageNew->mtpSpProceduralStatusLen] = 0;
		if (!(StorageNew->mtpSpAvailabilityStatus = malloc(thedata->mtpSpAvailabilityStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpAvailabilityStatus, thedata->mtpSpAvailabilityStatus, thedata->mtpSpAvailabilityStatusLen);
		StorageNew->mtpSpAvailabilityStatusLen = thedata->mtpSpAvailabilityStatusLen;
		StorageNew->mtpSpAvailabilityStatus[StorageNew->mtpSpAvailabilityStatusLen] = 0;
		if (!(StorageNew->mtpSpVersion = malloc(thedata->mtpSpVersionLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpVersion, thedata->mtpSpVersion, thedata->mtpSpVersionLen);
		StorageNew->mtpSpVersionLen = thedata->mtpSpVersionLen;
		StorageNew->mtpSpVersion[StorageNew->mtpSpVersionLen] = 0;
		StorageNew->mtpSpNetworkIndicator = thedata->mtpSpNetworkIndicator;
		if (!(StorageNew->mtpSpName = malloc(thedata->mtpSpNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpName, thedata->mtpSpName, thedata->mtpSpNameLen);
		StorageNew->mtpSpNameLen = thedata->mtpSpNameLen;
		StorageNew->mtpSpName[StorageNew->mtpSpNameLen] = 0;
		if (!(StorageNew->mtpSpProfilePointer = malloc(thedata->mtpSpProfilePointerLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpProfilePointer, thedata->mtpSpProfilePointer, thedata->mtpSpProfilePointerLen);
		StorageNew->mtpSpProfilePointerLen = thedata->mtpSpProfilePointerLen;
		StorageNew->mtpSpProfilePointer[StorageNew->mtpSpProfilePointerLen] = 0;
		if (!(StorageNew->mtpSpNaPointer = snmp_duplicate_objid(thedata->mtpSpNaPointer, thedata->mtpSpNaPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSpNaPointerLen = thedata->mtpSpNaPointerLen;
		if (!(StorageNew->mtpSpOptions = malloc(thedata->mtpSpOptionsLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpOptions, thedata->mtpSpOptions, thedata->mtpSpOptionsLen);
		StorageNew->mtpSpOptionsLen = thedata->mtpSpOptionsLen;
		StorageNew->mtpSpOptions[StorageNew->mtpSpOptionsLen] = 0;
		if (!(StorageNew->mtpSpUsers = malloc(thedata->mtpSpUsersLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpUsers, thedata->mtpSpUsers, thedata->mtpSpUsersLen);
		StorageNew->mtpSpUsersLen = thedata->mtpSpUsersLen;
		StorageNew->mtpSpUsers[StorageNew->mtpSpUsersLen] = 0;
		if (!(StorageNew->mtpSpAlarmStatus = malloc(thedata->mtpSpAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSpAlarmStatus, thedata->mtpSpAlarmStatus, thedata->mtpSpAlarmStatusLen);
		StorageNew->mtpSpAlarmStatusLen = thedata->mtpSpAlarmStatusLen;
		StorageNew->mtpSpAlarmStatus[StorageNew->mtpSpAlarmStatusLen] = 0;
		StorageNew->mtpSpRowStatus = thedata->mtpSpRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSpTable_destroy(struct mtpSpTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSpTable_destroy(struct mtpSpTable_data **thedata)
{
	struct mtpSpTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSpTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSpPointCode);
		StorageDel->mtpSpPointCodeLen = 0;
		SNMP_FREE(StorageDel->mtpSpProceduralStatus);
		StorageDel->mtpSpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSpAvailabilityStatus);
		StorageDel->mtpSpAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSpVersion);
		StorageDel->mtpSpVersionLen = 0;
		SNMP_FREE(StorageDel->mtpSpName);
		StorageDel->mtpSpNameLen = 0;
		SNMP_FREE(StorageDel->mtpSpProfilePointer);
		StorageDel->mtpSpProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSpNaPointer);
		StorageDel->mtpSpNaPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSpOptions);
		StorageDel->mtpSpOptionsLen = 0;
		SNMP_FREE(StorageDel->mtpSpUsers);
		StorageDel->mtpSpUsersLen = 0;
		SNMP_FREE(StorageDel->mtpSpAlarmStatus);
		StorageDel->mtpSpAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpTable_add(struct mtpSpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSpTable table data set.
 *
 * Adds a table row structure to the mtpSpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSpTable_add(struct mtpSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSpTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		header_complex_add_data(&mtpSpTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSpTable_del(struct mtpSpTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSpTable_del(struct mtpSpTable_data *thedata)
{
	struct mtpSpTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSpTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSpTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSpTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSpTable_data *StorageTmp = mtpSpTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSpTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSpPointCode);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpPointCode, &StorageTmp->mtpSpPointCodeLen);
	if (StorageTmp->mtpSpPointCode == NULL) {
		config_perror("invalid specification for mtpSpPointCode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSpProceduralStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
	if (StorageTmp->mtpSpProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSpProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpAvailabilityStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
	if (StorageTmp->mtpSpAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSpAvailabilityStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpVersion);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpVersion, &StorageTmp->mtpSpVersionLen);
	if (StorageTmp->mtpSpVersion == NULL) {
		config_perror("invalid specification for mtpSpVersion");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpNetworkIndicator, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSpName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
	if (StorageTmp->mtpSpName == NULL) {
		config_perror("invalid specification for mtpSpName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpProfilePointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpProfilePointer, &StorageTmp->mtpSpProfilePointerLen);
	if (StorageTmp->mtpSpProfilePointer == NULL) {
		config_perror("invalid specification for mtpSpProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpNaPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSpNaPointer, &StorageTmp->mtpSpNaPointerLen);
	if (StorageTmp->mtpSpNaPointer == NULL) {
		config_perror("invalid specification for mtpSpNaPointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpOptions);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpOptions, &StorageTmp->mtpSpOptionsLen);
	if (StorageTmp->mtpSpOptions == NULL) {
		config_perror("invalid specification for mtpSpOptions");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpUsers);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpUsers, &StorageTmp->mtpSpUsersLen);
	if (StorageTmp->mtpSpUsers == NULL) {
		config_perror("invalid specification for mtpSpUsers");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSpAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSpAlarmStatus, &StorageTmp->mtpSpAlarmStatusLen);
	if (StorageTmp->mtpSpAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSpAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSpRowStatus, &tmpsize);
	mtpSpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSpTable(): store configuraiton file for mtpSpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSpTable: storing data...  "));
	refresh_mtpSpTable(1);
	(void) tmpsize;
	for (hcindex = mtpSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSpTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpPointCode, &StorageTmp->mtpSpPointCodeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProceduralStatus, &StorageTmp->mtpSpProceduralStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpAvailabilityStatus, &StorageTmp->mtpSpAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpVersion, &StorageTmp->mtpSpVersionLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpNetworkIndicator, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpName, &StorageTmp->mtpSpNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpProfilePointer, &StorageTmp->mtpSpProfilePointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSpNaPointer, &StorageTmp->mtpSpNaPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpOptions, &StorageTmp->mtpSpOptionsLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpUsers, &StorageTmp->mtpSpUsersLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSpAlarmStatus, &StorageTmp->mtpSpAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpL3Table_data *mtpL3Table_create(void)
 * @brief create a fresh data structure representing a new row in the mtpL3Table table.
 *
 * Creates a new mtpL3Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpL3Table_data *
mtpL3Table_create(void)
{
	struct mtpL3Table_data *StorageNew = SNMP_MALLOC_STRUCT(mtpL3Table_data);

	DEBUGMSGTL(("mtpMIB", "mtpL3Table_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpL3AdministrativeState = MTPL3ADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpL3OperationalState = MTPL3OPERATIONALSTATE_DISABLED;
		StorageNew->mtpL3UsageState = MTPL3USAGESTATE_IDLE;
		if (memdup((u_char **) &StorageNew->mtpL3ProceduralStatus, (u_char *) "\x80", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpL3ProceduralStatusLen = 1;
		if ((StorageNew->mtpL3AsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpL3AsaProfilePointerLen = 2;
		if ((StorageNew->mtpL3Name = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpL3NameLen = strlen("");
		StorageNew->mtpL3RowStatus = 0;
		StorageNew->mtpL3RowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpL3Table_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpL3Table_data *mtpL3Table_duplicate(struct mtpL3Table_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpL3Table_data *
mtpL3Table_duplicate(struct mtpL3Table_data *thedata)
{
	struct mtpL3Table_data *StorageNew = SNMP_MALLOC_STRUCT(mtpL3Table_data);

	DEBUGMSGTL(("mtpMIB", "mtpL3Table_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpL3Table_id = thedata->mtpL3Table_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpL3Id = thedata->mtpL3Id;
		StorageNew->mtpL3AdministrativeState = thedata->mtpL3AdministrativeState;
		StorageNew->mtpL3OperationalState = thedata->mtpL3OperationalState;
		StorageNew->mtpL3UsageState = thedata->mtpL3UsageState;
		if (!(StorageNew->mtpL3ProceduralStatus = malloc(thedata->mtpL3ProceduralStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpL3ProceduralStatus, thedata->mtpL3ProceduralStatus, thedata->mtpL3ProceduralStatusLen);
		StorageNew->mtpL3ProceduralStatusLen = thedata->mtpL3ProceduralStatusLen;
		StorageNew->mtpL3ProceduralStatus[StorageNew->mtpL3ProceduralStatusLen] = 0;
		if (!(StorageNew->mtpL3AsaProfilePointer = snmp_duplicate_objid(thedata->mtpL3AsaProfilePointer, thedata->mtpL3AsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpL3AsaProfilePointerLen = thedata->mtpL3AsaProfilePointerLen;
		if (!(StorageNew->mtpL3Name = malloc(thedata->mtpL3NameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpL3Name, thedata->mtpL3Name, thedata->mtpL3NameLen);
		StorageNew->mtpL3NameLen = thedata->mtpL3NameLen;
		StorageNew->mtpL3Name[StorageNew->mtpL3NameLen] = 0;
		StorageNew->mtpL3RowStatus = thedata->mtpL3RowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpL3Table_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpL3Table_destroy(struct mtpL3Table_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpL3Table_destroy(struct mtpL3Table_data **thedata)
{
	struct mtpL3Table_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpL3Table_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpL3ProceduralStatus);
		StorageDel->mtpL3ProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpL3AsaProfilePointer);
		StorageDel->mtpL3AsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpL3Name);
		StorageDel->mtpL3NameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpL3Table_add(struct mtpL3Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpL3Table table data set.
 *
 * Adds a table row structure to the mtpL3Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpL3Table_add(struct mtpL3Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpL3Table_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpL3Id */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpL3Id, sizeof(thedata->mtpL3Id));
		header_complex_add_data(&mtpL3TableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpL3Table_del(struct mtpL3Table_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpL3Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpL3Table_del(struct mtpL3Table_data *thedata)
{
	struct mtpL3Table_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpL3Table_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpL3TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpL3TableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpL3Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpL3Table entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpL3Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpL3Table(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpL3Table_data *StorageTmp = mtpL3Table_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpL3Table: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpL3Id, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3AdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3OperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3UsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpL3ProceduralStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3ProceduralStatus, &StorageTmp->mtpL3ProceduralStatusLen);
	if (StorageTmp->mtpL3ProceduralStatus == NULL) {
		config_perror("invalid specification for mtpL3ProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpL3AsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpL3AsaProfilePointer, &StorageTmp->mtpL3AsaProfilePointerLen);
	if (StorageTmp->mtpL3AsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpL3AsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpL3Name);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpL3Name, &StorageTmp->mtpL3NameLen);
	if (StorageTmp->mtpL3Name == NULL) {
		config_perror("invalid specification for mtpL3Name");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpL3RowStatus, &tmpsize);
	mtpL3Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpL3Table(): store configuraiton file for mtpL3Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpL3Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpL3Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpL3Table: storing data...  "));
	refresh_mtpL3Table(1);
	(void) tmpsize;
	for (hcindex = mtpL3TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpL3Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpL3Table ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpL3Id, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3AdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3OperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3UsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3ProceduralStatus, &StorageTmp->mtpL3ProceduralStatusLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpL3AsaProfilePointer, &StorageTmp->mtpL3AsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpL3Name, &StorageTmp->mtpL3NameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpL3RowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpGsTable_data *mtpGsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpGsTable table.
 *
 * Creates a new mtpGsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpGsTable_data *
mtpGsTable_create(void)
{
	struct mtpGsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpGsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpGsAdministrativeState = MTPGSADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpGsTreatmentOfOutsideRanges = MTPGSTREATMENTOFOUTSIDERANGES_NORMAL;
		StorageNew->mtpGsListMode = TV_TRUE;
		StorageNew->mtpGsScreeningByLinkSetOrByOpc = MTPGSSCREENINGBYLINKSETORBYOPC_BYOPC;
		StorageNew->mtpGsGetScreenedOpcsOrLinkSetsByDpc = 0;
		if ((StorageNew->mtpGsName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpGsNameLen = 0;
		StorageNew->mtpGsName[StorageNew->mtpGsNameLen] = 0;
		StorageNew->mtpGsRowStatus = 0;
		StorageNew->mtpGsRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpGsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpGsTable_data *mtpGsTable_duplicate(struct mtpGsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpGsTable_data *
mtpGsTable_duplicate(struct mtpGsTable_data *thedata)
{
	struct mtpGsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpGsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpGsTable_id = thedata->mtpGsTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpGsId = thedata->mtpGsId;
		StorageNew->mtpGsAdministrativeState = thedata->mtpGsAdministrativeState;
		StorageNew->mtpGsTreatmentOfOutsideRanges = thedata->mtpGsTreatmentOfOutsideRanges;
		StorageNew->mtpGsListMode = thedata->mtpGsListMode;
		StorageNew->mtpGsScreeningByLinkSetOrByOpc = thedata->mtpGsScreeningByLinkSetOrByOpc;
		StorageNew->mtpGsGetScreenedOpcsOrLinkSetsByDpc = thedata->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		if (!(StorageNew->mtpGsName = malloc(thedata->mtpGsNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpGsName, thedata->mtpGsName, thedata->mtpGsNameLen);
		StorageNew->mtpGsNameLen = thedata->mtpGsNameLen;
		StorageNew->mtpGsName[StorageNew->mtpGsNameLen] = 0;
		StorageNew->mtpGsRowStatus = thedata->mtpGsRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpGsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpGsTable_destroy(struct mtpGsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpGsTable_destroy(struct mtpGsTable_data **thedata)
{
	struct mtpGsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpGsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsName);
		StorageDel->mtpGsNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsTable_add(struct mtpGsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpGsTable table data set.
 *
 * Adds a table row structure to the mtpGsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpGsTable_add(struct mtpGsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpGsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpGsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
		header_complex_add_data(&mtpGsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsTable_del(struct mtpGsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpGsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpGsTable_del(struct mtpGsTable_data *thedata)
{
	struct mtpGsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpGsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpGsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpGsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpGsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpGsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpGsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpGsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsTable_data *StorageTmp = mtpGsTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpGsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsListMode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpsize);
	SNMP_FREE(StorageTmp->mtpGsName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
	if (StorageTmp->mtpGsName == NULL) {
		config_perror("invalid specification for mtpGsName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsRowStatus, &tmpsize);
	mtpGsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpGsTable(): store configuraiton file for mtpGsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpGsTable: storing data...  "));
	refresh_mtpGsTable(1);
	(void) tmpsize;
	for (hcindex = mtpGsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsTreatmentOfOutsideRanges, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsListMode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsScreeningByLinkSetOrByOpc, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsName, &StorageTmp->mtpGsNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpGsLineTable_data *mtpGsLineTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpGsLineTable table.
 *
 * Creates a new mtpGsLineTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpGsLineTable_data *
mtpGsLineTable_create(void)
{
	struct mtpGsLineTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpGsLineTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpGsId = 0;
		if ((StorageNew->mtpGsLineObject = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpGsLineObjectLen = 2;
		StorageNew->mtpGsLineContent = 0;
		StorageNew->mtpGsLineRowStatus = 0;
		StorageNew->mtpGsLineRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpGsLineTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpGsLineTable_data *mtpGsLineTable_duplicate(struct mtpGsLineTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpGsLineTable_data *
mtpGsLineTable_duplicate(struct mtpGsLineTable_data *thedata)
{
	struct mtpGsLineTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpGsLineTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpGsLineTable_id = thedata->mtpGsLineTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpGsId = thedata->mtpGsId;
		StorageNew->mtpGsLineId = thedata->mtpGsLineId;
		if (!(StorageNew->mtpGsLineObject = snmp_duplicate_objid(thedata->mtpGsLineObject, thedata->mtpGsLineObjectLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpGsLineObjectLen = thedata->mtpGsLineObjectLen;
		StorageNew->mtpGsLineContent = thedata->mtpGsLineContent;
		StorageNew->mtpGsLineRowStatus = thedata->mtpGsLineRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpGsLineTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpGsLineTable_destroy(struct mtpGsLineTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpGsLineTable_destroy(struct mtpGsLineTable_data **thedata)
{
	struct mtpGsLineTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpGsLineTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsLineObject);
		StorageDel->mtpGsLineObjectLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineTable_add(struct mtpGsLineTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpGsLineTable table data set.
 *
 * Adds a table row structure to the mtpGsLineTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpGsLineTable_add(struct mtpGsLineTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpGsLineTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpGsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
		/* mtpGsLineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineId, sizeof(thedata->mtpGsLineId));
		header_complex_add_data(&mtpGsLineTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineTable_del(struct mtpGsLineTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpGsLineTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpGsLineTable_del(struct mtpGsLineTable_data *thedata)
{
	struct mtpGsLineTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpGsLineTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpGsLineTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpGsLineTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpGsLineTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpGsLineTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpGsLineTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpGsLineTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsLineTable_data *StorageTmp = mtpGsLineTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpGsLineTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpGsLineObject);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpGsLineObject, &StorageTmp->mtpGsLineObjectLen);
	if (StorageTmp->mtpGsLineObject == NULL) {
		config_perror("invalid specification for mtpGsLineObject");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContent, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineRowStatus, &tmpsize);
	mtpGsLineTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpGsLineTable(): store configuraiton file for mtpGsLineTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsLineTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpGsLineTable: storing data...  "));
	refresh_mtpGsLineTable(1);
	(void) tmpsize;
	for (hcindex = mtpGsLineTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsLineTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpGsLineObject, &StorageTmp->mtpGsLineObjectLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContent, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpGsLineContentTable_data *mtpGsLineContentTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpGsLineContentTable table.
 *
 * Creates a new mtpGsLineContentTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpGsLineContentTable_data *
mtpGsLineContentTable_create(void)
{
	struct mtpGsLineContentTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpGsLineContentTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpGsId = 0;
		StorageNew->mtpGsLineId = 0;
		if (memdup((u_char **) &StorageNew->mtpGsLineContentDesignatedDPCFirst, (u_char *) "\x00\x00\x00\x00", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpGsLineContentDesignatedDPCFirstLen = 4;
		if (memdup((u_char **) &StorageNew->mtpGsLineContentDesignatedDPCLast, (u_char *) "\x00\x00\x00\x00", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpGsLineContentDesignatedDPCLastLen = 4;
		if (memdup((u_char **) &StorageNew->mtpGsLineContentSiMask, (u_char *) "\x1F\xFF", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpGsLineContentSiMaskLen = 2;
		StorageNew->mtpGsLineContentMessageTreatment = MTPGSLINECONTENTMESSAGETREATMENT_NORMAL;
		if ((StorageNew->mtpGsLineContentComment = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpGsLineContentCommentLen = 0;
		StorageNew->mtpGsLineContentComment[StorageNew->mtpGsLineContentCommentLen] = 0;
		StorageNew->mtpGsLineContentRowStatus = 0;
		StorageNew->mtpGsLineContentRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpGsLineContentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpGsLineContentTable_data *mtpGsLineContentTable_duplicate(struct mtpGsLineContentTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpGsLineContentTable_data *
mtpGsLineContentTable_duplicate(struct mtpGsLineContentTable_data *thedata)
{
	struct mtpGsLineContentTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpGsLineContentTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpGsLineContentTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpGsLineContentTable_id = thedata->mtpGsLineContentTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpGsId = thedata->mtpGsId;
		StorageNew->mtpGsLineId = thedata->mtpGsLineId;
		StorageNew->mtpGsLineContentId = thedata->mtpGsLineContentId;
		if (!(StorageNew->mtpGsLineContentDesignatedDPCFirst = malloc(thedata->mtpGsLineContentDesignatedDPCFirstLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpGsLineContentDesignatedDPCFirst, thedata->mtpGsLineContentDesignatedDPCFirst, thedata->mtpGsLineContentDesignatedDPCFirstLen);
		StorageNew->mtpGsLineContentDesignatedDPCFirstLen = thedata->mtpGsLineContentDesignatedDPCFirstLen;
		StorageNew->mtpGsLineContentDesignatedDPCFirst[StorageNew->mtpGsLineContentDesignatedDPCFirstLen] = 0;
		if (!(StorageNew->mtpGsLineContentDesignatedDPCLast = malloc(thedata->mtpGsLineContentDesignatedDPCLastLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpGsLineContentDesignatedDPCLast, thedata->mtpGsLineContentDesignatedDPCLast, thedata->mtpGsLineContentDesignatedDPCLastLen);
		StorageNew->mtpGsLineContentDesignatedDPCLastLen = thedata->mtpGsLineContentDesignatedDPCLastLen;
		StorageNew->mtpGsLineContentDesignatedDPCLast[StorageNew->mtpGsLineContentDesignatedDPCLastLen] = 0;
		if (!(StorageNew->mtpGsLineContentSiMask = malloc(thedata->mtpGsLineContentSiMaskLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpGsLineContentSiMask, thedata->mtpGsLineContentSiMask, thedata->mtpGsLineContentSiMaskLen);
		StorageNew->mtpGsLineContentSiMaskLen = thedata->mtpGsLineContentSiMaskLen;
		StorageNew->mtpGsLineContentSiMask[StorageNew->mtpGsLineContentSiMaskLen] = 0;
		StorageNew->mtpGsLineContentMessageTreatment = thedata->mtpGsLineContentMessageTreatment;
		if (!(StorageNew->mtpGsLineContentComment = malloc(thedata->mtpGsLineContentCommentLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpGsLineContentComment, thedata->mtpGsLineContentComment, thedata->mtpGsLineContentCommentLen);
		StorageNew->mtpGsLineContentCommentLen = thedata->mtpGsLineContentCommentLen;
		StorageNew->mtpGsLineContentComment[StorageNew->mtpGsLineContentCommentLen] = 0;
		StorageNew->mtpGsLineContentRowStatus = thedata->mtpGsLineContentRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpGsLineContentTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpGsLineContentTable_destroy(struct mtpGsLineContentTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpGsLineContentTable_destroy(struct mtpGsLineContentTable_data **thedata)
{
	struct mtpGsLineContentTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpGsLineContentTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpGsLineContentDesignatedDPCFirst);
		StorageDel->mtpGsLineContentDesignatedDPCFirstLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentDesignatedDPCLast);
		StorageDel->mtpGsLineContentDesignatedDPCLastLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentSiMask);
		StorageDel->mtpGsLineContentSiMaskLen = 0;
		SNMP_FREE(StorageDel->mtpGsLineContentComment);
		StorageDel->mtpGsLineContentCommentLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineContentTable_add(struct mtpGsLineContentTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpGsLineContentTable table data set.
 *
 * Adds a table row structure to the mtpGsLineContentTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpGsLineContentTable_add(struct mtpGsLineContentTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpGsLineContentTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpGsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsId, sizeof(thedata->mtpGsId));
		/* mtpGsLineId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineId, sizeof(thedata->mtpGsLineId));
		/* mtpGsLineContentId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpGsLineContentId, sizeof(thedata->mtpGsLineContentId));
		header_complex_add_data(&mtpGsLineContentTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpGsLineContentTable_del(struct mtpGsLineContentTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpGsLineContentTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpGsLineContentTable_del(struct mtpGsLineContentTable_data *thedata)
{
	struct mtpGsLineContentTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpGsLineContentTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpGsLineContentTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpGsLineContentTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpGsLineContentTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpGsLineContentTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpGsLineContentTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpGsLineContentTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpGsLineContentTable_data *StorageTmp = mtpGsLineContentTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpGsLineContentTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpGsLineContentId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpGsLineContentDesignatedDPCFirst);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &StorageTmp->mtpGsLineContentDesignatedDPCFirstLen);
	if (StorageTmp->mtpGsLineContentDesignatedDPCFirst == NULL) {
		config_perror("invalid specification for mtpGsLineContentDesignatedDPCFirst");
		return;
	}
	SNMP_FREE(StorageTmp->mtpGsLineContentDesignatedDPCLast);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &StorageTmp->mtpGsLineContentDesignatedDPCLastLen);
	if (StorageTmp->mtpGsLineContentDesignatedDPCLast == NULL) {
		config_perror("invalid specification for mtpGsLineContentDesignatedDPCLast");
		return;
	}
	SNMP_FREE(StorageTmp->mtpGsLineContentSiMask);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentSiMask, &StorageTmp->mtpGsLineContentSiMaskLen);
	if (StorageTmp->mtpGsLineContentSiMask == NULL) {
		config_perror("invalid specification for mtpGsLineContentSiMask");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpsize);
	SNMP_FREE(StorageTmp->mtpGsLineContentComment);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpGsLineContentComment, &StorageTmp->mtpGsLineContentCommentLen);
	if (StorageTmp->mtpGsLineContentComment == NULL) {
		config_perror("invalid specification for mtpGsLineContentComment");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpGsLineContentRowStatus, &tmpsize);
	mtpGsLineContentTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpGsLineContentTable(): store configuraiton file for mtpGsLineContentTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpGsLineContentTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpGsLineContentTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpGsLineContentTable: storing data...  "));
	refresh_mtpGsLineContentTable(1);
	(void) tmpsize;
	for (hcindex = mtpGsLineContentTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpGsLineContentTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpGsLineContentTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpGsLineContentId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCFirst, &StorageTmp->mtpGsLineContentDesignatedDPCFirstLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentDesignatedDPCLast, &StorageTmp->mtpGsLineContentDesignatedDPCLastLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentSiMask, &StorageTmp->mtpGsLineContentSiMaskLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentMessageTreatment, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpGsLineContentComment, &StorageTmp->mtpGsLineContentCommentLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpGsLineContentRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRsProfileTable_data *mtpRsProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRsProfileTable table.
 *
 * Creates a new mtpRsProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRsProfileTable_data *
mtpRsProfileTable_create(void)
{
	struct mtpRsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpRsProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpRsProfileName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpRsProfileNameLen = 0;
		StorageNew->mtpRsProfileName[StorageNew->mtpRsProfileNameLen] = 0;
		StorageNew->mtpRsProfileTimerT8 = 100;
		StorageNew->mtpRsProfileTimerT11 = 6000;
		StorageNew->mtpRsProfileTimerT15 = 250;
		StorageNew->mtpRsProfileTimerT16 = 175;
		StorageNew->mtpRsProfileTimerT18A = 1200;
		if ((StorageNew->mtpRsProfileRtDefault = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpRsProfileRtDefaultLen = strlen("");
		StorageNew->mtpRsProfileRowStatus = 0;
		StorageNew->mtpRsProfileRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpRsProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpRsProfileTable_data *mtpRsProfileTable_duplicate(struct mtpRsProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRsProfileTable_data *
mtpRsProfileTable_duplicate(struct mtpRsProfileTable_data *thedata)
{
	struct mtpRsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpRsProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpRsProfileTable_id = thedata->mtpRsProfileTable_id;
		if (!(StorageNew->mtpRsProfileId = malloc(thedata->mtpRsProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRsProfileId, thedata->mtpRsProfileId, thedata->mtpRsProfileIdLen);
		StorageNew->mtpRsProfileIdLen = thedata->mtpRsProfileIdLen;
		StorageNew->mtpRsProfileId[StorageNew->mtpRsProfileIdLen] = 0;
		if (!(StorageNew->mtpRsProfileName = malloc(thedata->mtpRsProfileNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRsProfileName, thedata->mtpRsProfileName, thedata->mtpRsProfileNameLen);
		StorageNew->mtpRsProfileNameLen = thedata->mtpRsProfileNameLen;
		StorageNew->mtpRsProfileName[StorageNew->mtpRsProfileNameLen] = 0;
		StorageNew->mtpRsProfileTimerT8 = thedata->mtpRsProfileTimerT8;
		StorageNew->mtpRsProfileTimerT11 = thedata->mtpRsProfileTimerT11;
		StorageNew->mtpRsProfileTimerT15 = thedata->mtpRsProfileTimerT15;
		StorageNew->mtpRsProfileTimerT16 = thedata->mtpRsProfileTimerT16;
		StorageNew->mtpRsProfileTimerT18A = thedata->mtpRsProfileTimerT18A;
		if (!(StorageNew->mtpRsProfileRtDefault = malloc(thedata->mtpRsProfileRtDefaultLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRsProfileRtDefault, thedata->mtpRsProfileRtDefault, thedata->mtpRsProfileRtDefaultLen);
		StorageNew->mtpRsProfileRtDefaultLen = thedata->mtpRsProfileRtDefaultLen;
		StorageNew->mtpRsProfileRtDefault[StorageNew->mtpRsProfileRtDefaultLen] = 0;
		StorageNew->mtpRsProfileRowStatus = thedata->mtpRsProfileRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRsProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRsProfileTable_destroy(struct mtpRsProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRsProfileTable_destroy(struct mtpRsProfileTable_data **thedata)
{
	struct mtpRsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpRsProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRsProfileId);
		StorageDel->mtpRsProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfileName);
		StorageDel->mtpRsProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfileRtDefault);
		StorageDel->mtpRsProfileRtDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsProfileTable_add(struct mtpRsProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRsProfileTable table data set.
 *
 * Adds a table row structure to the mtpRsProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRsProfileTable_add(struct mtpRsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpRsProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpRsProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRsProfileId, thedata->mtpRsProfileIdLen);
		header_complex_add_data(&mtpRsProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsProfileTable_del(struct mtpRsProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpRsProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRsProfileTable_del(struct mtpRsProfileTable_data *thedata)
{
	struct mtpRsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpRsProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRsProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRsProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRsProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRsProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRsProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRsProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsProfileTable_data *StorageTmp = mtpRsProfileTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpRsProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpRsProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileId, &StorageTmp->mtpRsProfileIdLen);
	if (StorageTmp->mtpRsProfileId == NULL) {
		config_perror("invalid specification for mtpRsProfileId");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileName, &StorageTmp->mtpRsProfileNameLen);
	if (StorageTmp->mtpRsProfileName == NULL) {
		config_perror("invalid specification for mtpRsProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileTimerT18A, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRsProfileRtDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfileRtDefault, &StorageTmp->mtpRsProfileRtDefaultLen);
	if (StorageTmp->mtpRsProfileRtDefault == NULL) {
		config_perror("invalid specification for mtpRsProfileRtDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsProfileRowStatus, &tmpsize);
	mtpRsProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpRsProfileTable(): store configuraiton file for mtpRsProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpRsProfileTable: storing data...  "));
	refresh_mtpRsProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpRsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRsProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileId, &StorageTmp->mtpRsProfileIdLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileName, &StorageTmp->mtpRsProfileNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileTimerT18A, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfileRtDefault, &StorageTmp->mtpRsProfileRtDefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRsTable_data *mtpRsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRsTable table.
 *
 * Creates a new mtpRsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRsTable_data *
mtpRsTable_create(void)
{
	struct mtpRsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpRsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		if (memdup((u_char **) &StorageNew->mtpRsDest, (u_char *) "\x00\x00\x00\x00", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpRsDestLen = 4;
		if (memdup((u_char **) &StorageNew->mtpRsOptions, (u_char *) "\x20", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpRsOptionsLen = 1;
		StorageNew->mtpRsAdministrativeState = MTPRSADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpRsOperationalState = MTPRSOPERATIONALSTATE_DISABLED;
		if ((StorageNew->mtpRsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpRsAsaProfilePointerLen = 2;
		StorageNew->mtpRsCongestedState = MTPRSCONGESTEDSTATE_NOTCONGESTED;
		StorageNew->mtpRsCongestionLevel = MTPRSCONGESTIONLEVEL_NONE;
		if ((StorageNew->mtpRsLoadsharingInformation = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpRsLoadsharingInformationLen = 0;
		StorageNew->mtpRsLoadsharingInformation[StorageNew->mtpRsLoadsharingInformationLen] = 0;
		if ((StorageNew->mtpRsLoadsharingObject = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpRsLoadsharingObjectLen = 2;
		if ((StorageNew->mtpRsRemoteExchangeLabel = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpRsRemoteExchangeLabelLen = 0;
		StorageNew->mtpRsRemoteExchangeLabel[StorageNew->mtpRsRemoteExchangeLabelLen] = 0;
		if ((StorageNew->mtpRsName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpRsNameLen = 0;
		StorageNew->mtpRsName[StorageNew->mtpRsNameLen] = 0;
		if ((StorageNew->mtpRsProfile = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpRsProfileLen = strlen("");
		if (memdup((u_char **) &StorageNew->mtpRsAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpRsAlarmStatusLen = 1;
		StorageNew->mtpRsRowStatus = 0;
		StorageNew->mtpRsRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpRsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpRsTable_data *mtpRsTable_duplicate(struct mtpRsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRsTable_data *
mtpRsTable_duplicate(struct mtpRsTable_data *thedata)
{
	struct mtpRsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpRsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpRsTable_id = thedata->mtpRsTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpRsId = thedata->mtpRsId;
		if (!(StorageNew->mtpRsDest = malloc(thedata->mtpRsDestLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRsDest, thedata->mtpRsDest, thedata->mtpRsDestLen);
		StorageNew->mtpRsDestLen = thedata->mtpRsDestLen;
		StorageNew->mtpRsDest[StorageNew->mtpRsDestLen] = 0;
		if (!(StorageNew->mtpRsOptions = malloc(thedata->mtpRsOptionsLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRsOptions, thedata->mtpRsOptions, thedata->mtpRsOptionsLen);
		StorageNew->mtpRsOptionsLen = thedata->mtpRsOptionsLen;
		StorageNew->mtpRsOptions[StorageNew->mtpRsOptionsLen] = 0;
		StorageNew->mtpRsAdministrativeState = thedata->mtpRsAdministrativeState;
		StorageNew->mtpRsOperationalState = thedata->mtpRsOperationalState;
		if (!(StorageNew->mtpRsAsaProfilePointer = snmp_duplicate_objid(thedata->mtpRsAsaProfilePointer, thedata->mtpRsAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpRsAsaProfilePointerLen = thedata->mtpRsAsaProfilePointerLen;
		StorageNew->mtpRsCongestedState = thedata->mtpRsCongestedState;
		StorageNew->mtpRsCongestionLevel = thedata->mtpRsCongestionLevel;
		if (!(StorageNew->mtpRsLoadsharingInformation = malloc(thedata->mtpRsLoadsharingInformationLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRsLoadsharingInformation, thedata->mtpRsLoadsharingInformation, thedata->mtpRsLoadsharingInformationLen);
		StorageNew->mtpRsLoadsharingInformationLen = thedata->mtpRsLoadsharingInformationLen;
		StorageNew->mtpRsLoadsharingInformation[StorageNew->mtpRsLoadsharingInformationLen] = 0;
		if (!(StorageNew->mtpRsLoadsharingObject = snmp_duplicate_objid(thedata->mtpRsLoadsharingObject, thedata->mtpRsLoadsharingObjectLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpRsLoadsharingObjectLen = thedata->mtpRsLoadsharingObjectLen;
		if (!(StorageNew->mtpRsRemoteExchangeLabel = malloc(thedata->mtpRsRemoteExchangeLabelLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRsRemoteExchangeLabel, thedata->mtpRsRemoteExchangeLabel, thedata->mtpRsRemoteExchangeLabelLen);
		StorageNew->mtpRsRemoteExchangeLabelLen = thedata->mtpRsRemoteExchangeLabelLen;
		StorageNew->mtpRsRemoteExchangeLabel[StorageNew->mtpRsRemoteExchangeLabelLen] = 0;
		if (!(StorageNew->mtpRsName = malloc(thedata->mtpRsNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRsName, thedata->mtpRsName, thedata->mtpRsNameLen);
		StorageNew->mtpRsNameLen = thedata->mtpRsNameLen;
		StorageNew->mtpRsName[StorageNew->mtpRsNameLen] = 0;
		if (!(StorageNew->mtpRsProfile = malloc(thedata->mtpRsProfileLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRsProfile, thedata->mtpRsProfile, thedata->mtpRsProfileLen);
		StorageNew->mtpRsProfileLen = thedata->mtpRsProfileLen;
		StorageNew->mtpRsProfile[StorageNew->mtpRsProfileLen] = 0;
		if (!(StorageNew->mtpRsAlarmStatus = malloc(thedata->mtpRsAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRsAlarmStatus, thedata->mtpRsAlarmStatus, thedata->mtpRsAlarmStatusLen);
		StorageNew->mtpRsAlarmStatusLen = thedata->mtpRsAlarmStatusLen;
		StorageNew->mtpRsAlarmStatus[StorageNew->mtpRsAlarmStatusLen] = 0;
		StorageNew->mtpRsRowStatus = thedata->mtpRsRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRsTable_destroy(struct mtpRsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRsTable_destroy(struct mtpRsTable_data **thedata)
{
	struct mtpRsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpRsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRsDest);
		StorageDel->mtpRsDestLen = 0;
		SNMP_FREE(StorageDel->mtpRsOptions);
		StorageDel->mtpRsOptionsLen = 0;
		SNMP_FREE(StorageDel->mtpRsAsaProfilePointer);
		StorageDel->mtpRsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpRsLoadsharingInformation);
		StorageDel->mtpRsLoadsharingInformationLen = 0;
		SNMP_FREE(StorageDel->mtpRsLoadsharingObject);
		StorageDel->mtpRsLoadsharingObjectLen = 0;
		SNMP_FREE(StorageDel->mtpRsRemoteExchangeLabel);
		StorageDel->mtpRsRemoteExchangeLabelLen = 0;
		SNMP_FREE(StorageDel->mtpRsName);
		StorageDel->mtpRsNameLen = 0;
		SNMP_FREE(StorageDel->mtpRsProfile);
		StorageDel->mtpRsProfileLen = 0;
		SNMP_FREE(StorageDel->mtpRsAlarmStatus);
		StorageDel->mtpRsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsTable_add(struct mtpRsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRsTable table data set.
 *
 * Adds a table row structure to the mtpRsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRsTable_add(struct mtpRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpRsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
		header_complex_add_data(&mtpRsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRsTable_del(struct mtpRsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpRsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRsTable_del(struct mtpRsTable_data *thedata)
{
	struct mtpRsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpRsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRsTable_data *StorageTmp = mtpRsTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpRsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRsDest);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsDest, &StorageTmp->mtpRsDestLen);
	if (StorageTmp->mtpRsDest == NULL) {
		config_perror("invalid specification for mtpRsDest");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsOptions);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsOptions, &StorageTmp->mtpRsOptionsLen);
	if (StorageTmp->mtpRsOptions == NULL) {
		config_perror("invalid specification for mtpRsOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRsAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsAsaProfilePointer, &StorageTmp->mtpRsAsaProfilePointerLen);
	if (StorageTmp->mtpRsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpRsAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestedState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsCongestionLevel, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRsLoadsharingInformation);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
	if (StorageTmp->mtpRsLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingInformation");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsLoadsharingObject);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
	if (StorageTmp->mtpRsLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRsLoadsharingObject");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsRemoteExchangeLabel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
	if (StorageTmp->mtpRsRemoteExchangeLabel == NULL) {
		config_perror("invalid specification for mtpRsRemoteExchangeLabel");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
	if (StorageTmp->mtpRsName == NULL) {
		config_perror("invalid specification for mtpRsName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsProfile);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsProfile, &StorageTmp->mtpRsProfileLen);
	if (StorageTmp->mtpRsProfile == NULL) {
		config_perror("invalid specification for mtpRsProfile");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRsAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRsAlarmStatus, &StorageTmp->mtpRsAlarmStatusLen);
	if (StorageTmp->mtpRsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpRsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRsRowStatus, &tmpsize);
	mtpRsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpRsTable(): store configuraiton file for mtpRsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpRsTable: storing data...  "));
	refresh_mtpRsTable(1);
	(void) tmpsize;
	for (hcindex = mtpRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsDest, &StorageTmp->mtpRsDestLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsOptions, &StorageTmp->mtpRsOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsAsaProfilePointer, &StorageTmp->mtpRsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestedState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsLoadsharingInformation, &StorageTmp->mtpRsLoadsharingInformationLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRsLoadsharingObject, &StorageTmp->mtpRsLoadsharingObjectLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsRemoteExchangeLabel, &StorageTmp->mtpRsRemoteExchangeLabelLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsName, &StorageTmp->mtpRsNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsProfile, &StorageTmp->mtpRsProfileLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRsAlarmStatus, &StorageTmp->mtpRsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRtProfileTable_data *mtpRtProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRtProfileTable table.
 *
 * Creates a new mtpRtProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRtProfileTable_data *
mtpRtProfileTable_create(void)
{
	struct mtpRtProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpRtProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpRtProfileTimerT6 = 80;
		StorageNew->mtpRtProfileTimerT10 = 4500;
		StorageNew->mtpRtProfileRowStatus = 0;
		StorageNew->mtpRtProfileRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpRtProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpRtProfileTable_data *mtpRtProfileTable_duplicate(struct mtpRtProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRtProfileTable_data *
mtpRtProfileTable_duplicate(struct mtpRtProfileTable_data *thedata)
{
	struct mtpRtProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpRtProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpRtProfileTable_id = thedata->mtpRtProfileTable_id;
		if (!(StorageNew->mtpRtProfileId = malloc(thedata->mtpRtProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRtProfileId, thedata->mtpRtProfileId, thedata->mtpRtProfileIdLen);
		StorageNew->mtpRtProfileIdLen = thedata->mtpRtProfileIdLen;
		StorageNew->mtpRtProfileId[StorageNew->mtpRtProfileIdLen] = 0;
		StorageNew->mtpRtProfileTimerT6 = thedata->mtpRtProfileTimerT6;
		StorageNew->mtpRtProfileTimerT10 = thedata->mtpRtProfileTimerT10;
		StorageNew->mtpRtProfileRowStatus = thedata->mtpRtProfileRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRtProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRtProfileTable_destroy(struct mtpRtProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRtProfileTable_destroy(struct mtpRtProfileTable_data **thedata)
{
	struct mtpRtProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpRtProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtProfileId);
		StorageDel->mtpRtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtProfileTable_add(struct mtpRtProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRtProfileTable table data set.
 *
 * Adds a table row structure to the mtpRtProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRtProfileTable_add(struct mtpRtProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpRtProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpRtProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpRtProfileId, thedata->mtpRtProfileIdLen);
		header_complex_add_data(&mtpRtProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtProfileTable_del(struct mtpRtProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpRtProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRtProfileTable_del(struct mtpRtProfileTable_data *thedata)
{
	struct mtpRtProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpRtProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRtProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRtProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRtProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRtProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRtProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRtProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtProfileTable_data *StorageTmp = mtpRtProfileTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpRtProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpRtProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfileId, &StorageTmp->mtpRtProfileIdLen);
	if (StorageTmp->mtpRtProfileId == NULL) {
		config_perror("invalid specification for mtpRtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileTimerT10, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtProfileRowStatus, &tmpsize);
	mtpRtProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpRtProfileTable(): store configuraiton file for mtpRtProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpRtProfileTable: storing data...  "));
	refresh_mtpRtProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpRtProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfileId, &StorageTmp->mtpRtProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileTimerT10, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRtTable_data *mtpRtTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRtTable table.
 *
 * Creates a new mtpRtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRtTable_data *
mtpRtTable_create(void)
{
	struct mtpRtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpRtTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpRsId = 0;
		if ((StorageNew->mtpRtLsPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpRtLsPointerLen = 2;
		StorageNew->mtpRtAdministrativeState = MTPRTADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpRtOperationalState = MTPRTOPERATIONALSTATE_DISABLED;
		if (memdup((u_char **) &StorageNew->mtpRtAvailabilityStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpRtAvailabilityStatusLen = 2;
		StorageNew->mtpRtInClsLoadsharingAlgorithm = 16;
		StorageNew->mtpRtFixedPriority = 0;
		StorageNew->mtpRtFlexiblePriority = 0;
		StorageNew->mtpRtPriorityMode = 0;
		if ((StorageNew->mtpRtLoadsharingInformation = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpRtLoadsharingInformationLen = 0;
		StorageNew->mtpRtLoadsharingInformation[StorageNew->mtpRtLoadsharingInformationLen] = 0;
		if ((StorageNew->mtpRtLoadsharingObject = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpRtLoadsharingObjectLen = 2;
		if ((StorageNew->mtpRtName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpRtNameLen = 0;
		StorageNew->mtpRtName[StorageNew->mtpRtNameLen] = 0;
		if ((StorageNew->mtpRtSlsList = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpRtSlsListLen = 0;
		StorageNew->mtpRtSlsList[StorageNew->mtpRtSlsListLen] = 0;
		StorageNew->mtpRtUsageState = MTPRTUSAGESTATE_IDLE;
		StorageNew->mtpRtRlSlot = 0;
		if ((StorageNew->mtpRtProfile = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpRtProfileLen = strlen("");
		StorageNew->mtpRtRowStatus = 0;
		StorageNew->mtpRtRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpRtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpRtTable_data *mtpRtTable_duplicate(struct mtpRtTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRtTable_data *
mtpRtTable_duplicate(struct mtpRtTable_data *thedata)
{
	struct mtpRtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpRtTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpRtTable_id = thedata->mtpRtTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpRsId = thedata->mtpRsId;
		StorageNew->mtpRtId = thedata->mtpRtId;
		if (!(StorageNew->mtpRtLsPointer = snmp_duplicate_objid(thedata->mtpRtLsPointer, thedata->mtpRtLsPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpRtLsPointerLen = thedata->mtpRtLsPointerLen;
		StorageNew->mtpRtAdministrativeState = thedata->mtpRtAdministrativeState;
		StorageNew->mtpRtOperationalState = thedata->mtpRtOperationalState;
		if (!(StorageNew->mtpRtAvailabilityStatus = malloc(thedata->mtpRtAvailabilityStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRtAvailabilityStatus, thedata->mtpRtAvailabilityStatus, thedata->mtpRtAvailabilityStatusLen);
		StorageNew->mtpRtAvailabilityStatusLen = thedata->mtpRtAvailabilityStatusLen;
		StorageNew->mtpRtAvailabilityStatus[StorageNew->mtpRtAvailabilityStatusLen] = 0;
		StorageNew->mtpRtInClsLoadsharingAlgorithm = thedata->mtpRtInClsLoadsharingAlgorithm;
		StorageNew->mtpRtFixedPriority = thedata->mtpRtFixedPriority;
		StorageNew->mtpRtFlexiblePriority = thedata->mtpRtFlexiblePriority;
		StorageNew->mtpRtPriorityMode = thedata->mtpRtPriorityMode;
		if (!(StorageNew->mtpRtLoadsharingInformation = malloc(thedata->mtpRtLoadsharingInformationLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRtLoadsharingInformation, thedata->mtpRtLoadsharingInformation, thedata->mtpRtLoadsharingInformationLen);
		StorageNew->mtpRtLoadsharingInformationLen = thedata->mtpRtLoadsharingInformationLen;
		StorageNew->mtpRtLoadsharingInformation[StorageNew->mtpRtLoadsharingInformationLen] = 0;
		if (!(StorageNew->mtpRtLoadsharingObject = snmp_duplicate_objid(thedata->mtpRtLoadsharingObject, thedata->mtpRtLoadsharingObjectLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpRtLoadsharingObjectLen = thedata->mtpRtLoadsharingObjectLen;
		if (!(StorageNew->mtpRtName = malloc(thedata->mtpRtNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRtName, thedata->mtpRtName, thedata->mtpRtNameLen);
		StorageNew->mtpRtNameLen = thedata->mtpRtNameLen;
		StorageNew->mtpRtName[StorageNew->mtpRtNameLen] = 0;
		if (!(StorageNew->mtpRtSlsList = malloc(thedata->mtpRtSlsListLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRtSlsList, thedata->mtpRtSlsList, thedata->mtpRtSlsListLen);
		StorageNew->mtpRtSlsListLen = thedata->mtpRtSlsListLen;
		StorageNew->mtpRtSlsList[StorageNew->mtpRtSlsListLen] = 0;
		StorageNew->mtpRtUsageState = thedata->mtpRtUsageState;
		StorageNew->mtpRtRlSlot = thedata->mtpRtRlSlot;
		if (!(StorageNew->mtpRtProfile = malloc(thedata->mtpRtProfileLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRtProfile, thedata->mtpRtProfile, thedata->mtpRtProfileLen);
		StorageNew->mtpRtProfileLen = thedata->mtpRtProfileLen;
		StorageNew->mtpRtProfile[StorageNew->mtpRtProfileLen] = 0;
		StorageNew->mtpRtRowStatus = thedata->mtpRtRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRtTable_destroy(struct mtpRtTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRtTable_destroy(struct mtpRtTable_data **thedata)
{
	struct mtpRtTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpRtTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtLsPointer);
		StorageDel->mtpRtLsPointerLen = 0;
		SNMP_FREE(StorageDel->mtpRtAvailabilityStatus);
		StorageDel->mtpRtAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpRtLoadsharingInformation);
		StorageDel->mtpRtLoadsharingInformationLen = 0;
		SNMP_FREE(StorageDel->mtpRtLoadsharingObject);
		StorageDel->mtpRtLoadsharingObjectLen = 0;
		SNMP_FREE(StorageDel->mtpRtName);
		StorageDel->mtpRtNameLen = 0;
		SNMP_FREE(StorageDel->mtpRtSlsList);
		StorageDel->mtpRtSlsListLen = 0;
		SNMP_FREE(StorageDel->mtpRtProfile);
		StorageDel->mtpRtProfileLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtTable_add(struct mtpRtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRtTable table data set.
 *
 * Adds a table row structure to the mtpRtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRtTable_add(struct mtpRtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpRtTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
		/* mtpRtId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtId, sizeof(thedata->mtpRtId));
		header_complex_add_data(&mtpRtTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtTable_del(struct mtpRtTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpRtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRtTable_del(struct mtpRtTable_data *thedata)
{
	struct mtpRtTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpRtTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRtTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRtTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtTable_data *StorageTmp = mtpRtTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpRtTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRtLsPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRtLsPointer, &StorageTmp->mtpRtLsPointerLen);
	if (StorageTmp->mtpRtLsPointer == NULL) {
		config_perror("invalid specification for mtpRtLsPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRtAvailabilityStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
	if (StorageTmp->mtpRtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpRtAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFixedPriority, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtFlexiblePriority, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtPriorityMode, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRtLoadsharingInformation);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
	if (StorageTmp->mtpRtLoadsharingInformation == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingInformation");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRtLoadsharingObject);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
	if (StorageTmp->mtpRtLoadsharingObject == NULL) {
		config_perror("invalid specification for mtpRtLoadsharingObject");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRtName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
	if (StorageTmp->mtpRtName == NULL) {
		config_perror("invalid specification for mtpRtName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpRtSlsList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
	if (StorageTmp->mtpRtSlsList == NULL) {
		config_perror("invalid specification for mtpRtSlsList");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtUsageState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtRlSlot, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRtProfile);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtProfile, &StorageTmp->mtpRtProfileLen);
	if (StorageTmp->mtpRtProfile == NULL) {
		config_perror("invalid specification for mtpRtProfile");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtRowStatus, &tmpsize);
	mtpRtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpRtTable(): store configuraiton file for mtpRtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpRtTable: storing data...  "));
	refresh_mtpRtTable(1);
	(void) tmpsize;
	for (hcindex = mtpRtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRtLsPointer, &StorageTmp->mtpRtLsPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtAvailabilityStatus, &StorageTmp->mtpRtAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtInClsLoadsharingAlgorithm, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFixedPriority, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtFlexiblePriority, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtPriorityMode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLoadsharingInformation, &StorageTmp->mtpRtLoadsharingInformationLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpRtLoadsharingObject, &StorageTmp->mtpRtLoadsharingObjectLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtName, &StorageTmp->mtpRtNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtSlsList, &StorageTmp->mtpRtSlsListLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtRlSlot, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtProfile, &StorageTmp->mtpRtProfileLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpRtLsaTable_data *mtpRtLsaTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpRtLsaTable table.
 *
 * Creates a new mtpRtLsaTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpRtLsaTable_data *
mtpRtLsaTable_create(void)
{
	struct mtpRtLsaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtLsaTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpRtLsaTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpRsId = 0;
		StorageNew->mtpRtId = 0;
		StorageNew->mtpRtLsaNormalSlCode = 0;
		if ((StorageNew->mtpRtLsaAlternativeSlCodeList = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpRtLsaAlternativeSlCodeListLen = 0;
		StorageNew->mtpRtLsaAlternativeSlCodeList[StorageNew->mtpRtLsaAlternativeSlCodeListLen] = 0;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpRtLsaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpRtLsaTable_data *mtpRtLsaTable_duplicate(struct mtpRtLsaTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpRtLsaTable_data *
mtpRtLsaTable_duplicate(struct mtpRtLsaTable_data *thedata)
{
	struct mtpRtLsaTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpRtLsaTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpRtLsaTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpRtLsaTable_id = thedata->mtpRtLsaTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpRsId = thedata->mtpRsId;
		StorageNew->mtpRtId = thedata->mtpRtId;
		StorageNew->mtpRtLsaSlsCode = thedata->mtpRtLsaSlsCode;
		StorageNew->mtpRtLsaNormalSlCode = thedata->mtpRtLsaNormalSlCode;
		if (!(StorageNew->mtpRtLsaAlternativeSlCodeList = malloc(thedata->mtpRtLsaAlternativeSlCodeListLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpRtLsaAlternativeSlCodeList, thedata->mtpRtLsaAlternativeSlCodeList, thedata->mtpRtLsaAlternativeSlCodeListLen);
		StorageNew->mtpRtLsaAlternativeSlCodeListLen = thedata->mtpRtLsaAlternativeSlCodeListLen;
		StorageNew->mtpRtLsaAlternativeSlCodeList[StorageNew->mtpRtLsaAlternativeSlCodeListLen] = 0;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpRtLsaTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpRtLsaTable_destroy(struct mtpRtLsaTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpRtLsaTable_destroy(struct mtpRtLsaTable_data **thedata)
{
	struct mtpRtLsaTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpRtLsaTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpRtLsaAlternativeSlCodeList);
		StorageDel->mtpRtLsaAlternativeSlCodeListLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtLsaTable_add(struct mtpRtLsaTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpRtLsaTable table data set.
 *
 * Adds a table row structure to the mtpRtLsaTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpRtLsaTable_add(struct mtpRtLsaTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpRtLsaTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
		/* mtpRtId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRtId, sizeof(thedata->mtpRtId));
		/* mtpRtLsaSlsCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpRtLsaSlsCode, sizeof(thedata->mtpRtLsaSlsCode));
		header_complex_add_data(&mtpRtLsaTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpRtLsaTable_del(struct mtpRtLsaTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpRtLsaTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpRtLsaTable_del(struct mtpRtLsaTable_data *thedata)
{
	struct mtpRtLsaTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpRtLsaTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpRtLsaTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpRtLsaTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpRtLsaTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpRtLsaTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpRtLsaTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpRtLsaTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpRtLsaTable_data *StorageTmp = mtpRtLsaTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpRtLsaTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRtId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtLsaSlsCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpRtLsaNormalSlCode, &tmpsize);
	SNMP_FREE(StorageTmp->mtpRtLsaAlternativeSlCodeList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &StorageTmp->mtpRtLsaAlternativeSlCodeListLen);
	if (StorageTmp->mtpRtLsaAlternativeSlCodeList == NULL) {
		config_perror("invalid specification for mtpRtLsaAlternativeSlCodeList");
		return;
	}
	mtpRtLsaTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpRtLsaTable(): store configuraiton file for mtpRtLsaTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpRtLsaTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpRtLsaTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpRtLsaTable: storing data...  "));
	refresh_mtpRtLsaTable(1);
	(void) tmpsize;
	for (hcindex = mtpRtLsaTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpRtLsaTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpRtLsaTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRtId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtLsaSlsCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpRtLsaNormalSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpRtLsaAlternativeSlCodeList, &StorageTmp->mtpRtLsaAlternativeSlCodeListLen);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpLsProfileTable_data *mtpLsProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpLsProfileTable table.
 *
 * Creates a new mtpLsProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpLsProfileTable_data *
mtpLsProfileTable_create(void)
{
	struct mtpLsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpLsProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpLsProfileTimerT6 = 80;
		StorageNew->mtpLsProfileTimerT8 = 100;
		StorageNew->mtpLsProfileTimerT10 = 4500;
		StorageNew->mtpLsProfileTimerT7 = 150;
		StorageNew->mtpLsProfileTimerT19I = 6800;
		StorageNew->mtpLsProfileTimerT21I = 6400;
		StorageNew->mtpLsProfileTimerT25A = 3000;
		StorageNew->mtpLsProfileTimerT28A = 2000;
		StorageNew->mtpLsProfileTimerT29A = 6000;
		StorageNew->mtpLsProfileTimerT30A = 3000;
		StorageNew->mtpLsProfileParameterN = 50;
		StorageNew->mtpLsProfileParameterM = 3;
		if ((StorageNew->mtpLsProfileName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpLsProfileNameLen = 0;
		StorageNew->mtpLsProfileName[StorageNew->mtpLsProfileNameLen] = 0;
		if ((StorageNew->mtpLsProfileSlDefault = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpLsProfileSlDefaultLen = strlen("");
		StorageNew->mtpLsProfileRowStatus = 0;
		StorageNew->mtpLsProfileRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpLsProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpLsProfileTable_data *mtpLsProfileTable_duplicate(struct mtpLsProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpLsProfileTable_data *
mtpLsProfileTable_duplicate(struct mtpLsProfileTable_data *thedata)
{
	struct mtpLsProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpLsProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpLsProfileTable_id = thedata->mtpLsProfileTable_id;
		if (!(StorageNew->mtpLsProfileId = malloc(thedata->mtpLsProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpLsProfileId, thedata->mtpLsProfileId, thedata->mtpLsProfileIdLen);
		StorageNew->mtpLsProfileIdLen = thedata->mtpLsProfileIdLen;
		StorageNew->mtpLsProfileId[StorageNew->mtpLsProfileIdLen] = 0;
		StorageNew->mtpLsProfileTimerT6 = thedata->mtpLsProfileTimerT6;
		StorageNew->mtpLsProfileTimerT8 = thedata->mtpLsProfileTimerT8;
		StorageNew->mtpLsProfileTimerT10 = thedata->mtpLsProfileTimerT10;
		StorageNew->mtpLsProfileTimerT7 = thedata->mtpLsProfileTimerT7;
		StorageNew->mtpLsProfileTimerT19I = thedata->mtpLsProfileTimerT19I;
		StorageNew->mtpLsProfileTimerT21I = thedata->mtpLsProfileTimerT21I;
		StorageNew->mtpLsProfileTimerT25A = thedata->mtpLsProfileTimerT25A;
		StorageNew->mtpLsProfileTimerT28A = thedata->mtpLsProfileTimerT28A;
		StorageNew->mtpLsProfileTimerT29A = thedata->mtpLsProfileTimerT29A;
		StorageNew->mtpLsProfileTimerT30A = thedata->mtpLsProfileTimerT30A;
		StorageNew->mtpLsProfileParameterN = thedata->mtpLsProfileParameterN;
		StorageNew->mtpLsProfileParameterM = thedata->mtpLsProfileParameterM;
		if (!(StorageNew->mtpLsProfileName = malloc(thedata->mtpLsProfileNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpLsProfileName, thedata->mtpLsProfileName, thedata->mtpLsProfileNameLen);
		StorageNew->mtpLsProfileNameLen = thedata->mtpLsProfileNameLen;
		StorageNew->mtpLsProfileName[StorageNew->mtpLsProfileNameLen] = 0;
		if (!(StorageNew->mtpLsProfileSlDefault = malloc(thedata->mtpLsProfileSlDefaultLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpLsProfileSlDefault, thedata->mtpLsProfileSlDefault, thedata->mtpLsProfileSlDefaultLen);
		StorageNew->mtpLsProfileSlDefaultLen = thedata->mtpLsProfileSlDefaultLen;
		StorageNew->mtpLsProfileSlDefault[StorageNew->mtpLsProfileSlDefaultLen] = 0;
		StorageNew->mtpLsProfileRowStatus = thedata->mtpLsProfileRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpLsProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpLsProfileTable_destroy(struct mtpLsProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpLsProfileTable_destroy(struct mtpLsProfileTable_data **thedata)
{
	struct mtpLsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpLsProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpLsProfileId);
		StorageDel->mtpLsProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfileName);
		StorageDel->mtpLsProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfileSlDefault);
		StorageDel->mtpLsProfileSlDefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsProfileTable_add(struct mtpLsProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpLsProfileTable table data set.
 *
 * Adds a table row structure to the mtpLsProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpLsProfileTable_add(struct mtpLsProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpLsProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpLsProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpLsProfileId, thedata->mtpLsProfileIdLen);
		header_complex_add_data(&mtpLsProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsProfileTable_del(struct mtpLsProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpLsProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpLsProfileTable_del(struct mtpLsProfileTable_data *thedata)
{
	struct mtpLsProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpLsProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpLsProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpLsProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpLsProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpLsProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpLsProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpLsProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsProfileTable_data *StorageTmp = mtpLsProfileTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpLsProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpLsProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileId, &StorageTmp->mtpLsProfileIdLen);
	if (StorageTmp->mtpLsProfileId == NULL) {
		config_perror("invalid specification for mtpLsProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT10, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT19I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT21I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT25A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT28A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT29A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileTimerT30A, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsProfileParameterN, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsProfileParameterM, &tmpsize);
	SNMP_FREE(StorageTmp->mtpLsProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileName, &StorageTmp->mtpLsProfileNameLen);
	if (StorageTmp->mtpLsProfileName == NULL) {
		config_perror("invalid specification for mtpLsProfileName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpLsProfileSlDefault);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfileSlDefault, &StorageTmp->mtpLsProfileSlDefaultLen);
	if (StorageTmp->mtpLsProfileSlDefault == NULL) {
		config_perror("invalid specification for mtpLsProfileSlDefault");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsProfileRowStatus, &tmpsize);
	mtpLsProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpLsProfileTable(): store configuraiton file for mtpLsProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpLsProfileTable: storing data...  "));
	refresh_mtpLsProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpLsProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpLsProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileId, &StorageTmp->mtpLsProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT10, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT19I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT21I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT25A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT28A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT29A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileTimerT30A, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsProfileParameterN, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsProfileParameterM, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileName, &StorageTmp->mtpLsProfileNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfileSlDefault, &StorageTmp->mtpLsProfileSlDefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpLsTable_data *mtpLsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpLsTable table.
 *
 * Creates a new mtpLsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpLsTable_data *
mtpLsTable_create(void)
{
	struct mtpLsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpLsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		if (memdup((u_char **) &StorageNew->mtpLsAdjPc, (u_char *) "\x00\x00\x00\x00", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpLsAdjPcLen = 4;
		if ((StorageNew->mtpLsRsId = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpLsRsIdLen = 2;
		StorageNew->mtpLsMaxCapacity = 0;
		StorageNew->mtpLsCurrentCapacity = 0;
		StorageNew->mtpLsCongestionControlMethod = MTPLSCONGESTIONCONTROLMETHOD_CCMQ704INTERNATIONAL;
		StorageNew->mtpLsUsageState = MTPLSUSAGESTATE_IDLE;
		StorageNew->mtpLsOperationalState = MTPLSOPERATIONALSTATE_DISABLED;
		if (memdup((u_char **) &StorageNew->mtpLsAvailabilityStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpLsAvailabilityStatusLen = 2;
		StorageNew->mtpLsPeriodicLinkTestFlag = MTPLSPERIODICLINKTESTFLAG_ON;
		StorageNew->mtpLsPeriodicLinkTestFail = TV_FALSE;
		StorageNew->mtpLsAdministrativeState = MTPLSADMINISTRATIVESTATE_LOCKED;
		{
			static oid tmpoid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 1, 1, 4, 4, 1 };
			if ((StorageNew->mtpLsInLsLoadShareAlgorithm = snmp_duplicate_objid(tmpoid, 14)) == NULL)
				goto nomem;
			StorageNew->mtpLsInLsLoadShareAlgorithmLen = 14;
		}
		if ((StorageNew->mtpLsProfilePointer = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpLsProfilePointerLen = 0;
		StorageNew->mtpLsProfilePointer[StorageNew->mtpLsProfilePointerLen] = 0;
		StorageNew->mtpLsNumberOfNormallyActiveSignLinks = 2;
		if ((StorageNew->mtpLsName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpLsNameLen = 0;
		StorageNew->mtpLsName[StorageNew->mtpLsNameLen] = 0;
		if ((StorageNew->mtpLsAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpLsAsaProfilePointerLen = 2;
		if (memdup((u_char **) &StorageNew->mtpLsAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpLsAlarmStatusLen = 1;
		StorageNew->mtpLsRowStatus = 0;
		StorageNew->mtpLsRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpLsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpLsTable_data *mtpLsTable_duplicate(struct mtpLsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpLsTable_data *
mtpLsTable_duplicate(struct mtpLsTable_data *thedata)
{
	struct mtpLsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpLsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpLsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpLsTable_id = thedata->mtpLsTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpLsId = thedata->mtpLsId;
		if (!(StorageNew->mtpLsAdjPc = malloc(thedata->mtpLsAdjPcLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpLsAdjPc, thedata->mtpLsAdjPc, thedata->mtpLsAdjPcLen);
		StorageNew->mtpLsAdjPcLen = thedata->mtpLsAdjPcLen;
		StorageNew->mtpLsAdjPc[StorageNew->mtpLsAdjPcLen] = 0;
		if (!(StorageNew->mtpLsRsId = snmp_duplicate_objid(thedata->mtpLsRsId, thedata->mtpLsRsIdLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpLsRsIdLen = thedata->mtpLsRsIdLen;
		StorageNew->mtpLsMaxCapacity = thedata->mtpLsMaxCapacity;
		StorageNew->mtpLsCurrentCapacity = thedata->mtpLsCurrentCapacity;
		StorageNew->mtpLsCongestionControlMethod = thedata->mtpLsCongestionControlMethod;
		StorageNew->mtpLsUsageState = thedata->mtpLsUsageState;
		StorageNew->mtpLsOperationalState = thedata->mtpLsOperationalState;
		if (!(StorageNew->mtpLsAvailabilityStatus = malloc(thedata->mtpLsAvailabilityStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpLsAvailabilityStatus, thedata->mtpLsAvailabilityStatus, thedata->mtpLsAvailabilityStatusLen);
		StorageNew->mtpLsAvailabilityStatusLen = thedata->mtpLsAvailabilityStatusLen;
		StorageNew->mtpLsAvailabilityStatus[StorageNew->mtpLsAvailabilityStatusLen] = 0;
		StorageNew->mtpLsPeriodicLinkTestFlag = thedata->mtpLsPeriodicLinkTestFlag;
		StorageNew->mtpLsPeriodicLinkTestFail = thedata->mtpLsPeriodicLinkTestFail;
		StorageNew->mtpLsAdministrativeState = thedata->mtpLsAdministrativeState;
		if (!(StorageNew->mtpLsInLsLoadShareAlgorithm = snmp_duplicate_objid(thedata->mtpLsInLsLoadShareAlgorithm, thedata->mtpLsInLsLoadShareAlgorithmLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpLsInLsLoadShareAlgorithmLen = thedata->mtpLsInLsLoadShareAlgorithmLen;
		if (!(StorageNew->mtpLsProfilePointer = malloc(thedata->mtpLsProfilePointerLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpLsProfilePointer, thedata->mtpLsProfilePointer, thedata->mtpLsProfilePointerLen);
		StorageNew->mtpLsProfilePointerLen = thedata->mtpLsProfilePointerLen;
		StorageNew->mtpLsProfilePointer[StorageNew->mtpLsProfilePointerLen] = 0;
		StorageNew->mtpLsNumberOfNormallyActiveSignLinks = thedata->mtpLsNumberOfNormallyActiveSignLinks;
		if (!(StorageNew->mtpLsName = malloc(thedata->mtpLsNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpLsName, thedata->mtpLsName, thedata->mtpLsNameLen);
		StorageNew->mtpLsNameLen = thedata->mtpLsNameLen;
		StorageNew->mtpLsName[StorageNew->mtpLsNameLen] = 0;
		if (!(StorageNew->mtpLsAsaProfilePointer = snmp_duplicate_objid(thedata->mtpLsAsaProfilePointer, thedata->mtpLsAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpLsAsaProfilePointerLen = thedata->mtpLsAsaProfilePointerLen;
		if (!(StorageNew->mtpLsAlarmStatus = malloc(thedata->mtpLsAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpLsAlarmStatus, thedata->mtpLsAlarmStatus, thedata->mtpLsAlarmStatusLen);
		StorageNew->mtpLsAlarmStatusLen = thedata->mtpLsAlarmStatusLen;
		StorageNew->mtpLsAlarmStatus[StorageNew->mtpLsAlarmStatusLen] = 0;
		StorageNew->mtpLsRowStatus = thedata->mtpLsRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpLsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpLsTable_destroy(struct mtpLsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpLsTable_destroy(struct mtpLsTable_data **thedata)
{
	struct mtpLsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpLsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpLsAdjPc);
		StorageDel->mtpLsAdjPcLen = 0;
		SNMP_FREE(StorageDel->mtpLsRsId);
		StorageDel->mtpLsRsIdLen = 0;
		SNMP_FREE(StorageDel->mtpLsAvailabilityStatus);
		StorageDel->mtpLsAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpLsInLsLoadShareAlgorithm);
		StorageDel->mtpLsInLsLoadShareAlgorithmLen = 0;
		SNMP_FREE(StorageDel->mtpLsProfilePointer);
		StorageDel->mtpLsProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpLsName);
		StorageDel->mtpLsNameLen = 0;
		SNMP_FREE(StorageDel->mtpLsAsaProfilePointer);
		StorageDel->mtpLsAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpLsAlarmStatus);
		StorageDel->mtpLsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsTable_add(struct mtpLsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpLsTable table data set.
 *
 * Adds a table row structure to the mtpLsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpLsTable_add(struct mtpLsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpLsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		header_complex_add_data(&mtpLsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpLsTable_del(struct mtpLsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpLsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpLsTable_del(struct mtpLsTable_data *thedata)
{
	struct mtpLsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpLsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpLsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpLsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpLsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpLsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpLsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpLsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpLsTable_data *StorageTmp = mtpLsTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpLsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpLsAdjPc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
	if (StorageTmp->mtpLsAdjPc == NULL) {
		config_perror("invalid specification for mtpLsAdjPc");
		return;
	}
	SNMP_FREE(StorageTmp->mtpLsRsId);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsRsId, &StorageTmp->mtpLsRsIdLen);
	if (StorageTmp->mtpLsRsId == NULL) {
		config_perror("invalid specification for mtpLsRsId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsMaxCapacity, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsCurrentCapacity, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsCongestionControlMethod, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpLsAvailabilityStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
	if (StorageTmp->mtpLsAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpLsAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsPeriodicLinkTestFail, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsAdministrativeState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpLsInLsLoadShareAlgorithm);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
	if (StorageTmp->mtpLsInLsLoadShareAlgorithm == NULL) {
		config_perror("invalid specification for mtpLsInLsLoadShareAlgorithm");
		return;
	}
	SNMP_FREE(StorageTmp->mtpLsProfilePointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsProfilePointer, &StorageTmp->mtpLsProfilePointerLen);
	if (StorageTmp->mtpLsProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks, &tmpsize);
	SNMP_FREE(StorageTmp->mtpLsName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
	if (StorageTmp->mtpLsName == NULL) {
		config_perror("invalid specification for mtpLsName");
		return;
	}
	SNMP_FREE(StorageTmp->mtpLsAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpLsAsaProfilePointer, &StorageTmp->mtpLsAsaProfilePointerLen);
	if (StorageTmp->mtpLsAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpLsAsaProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpLsAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpLsAlarmStatus, &StorageTmp->mtpLsAlarmStatusLen);
	if (StorageTmp->mtpLsAlarmStatus == NULL) {
		config_perror("invalid specification for mtpLsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpLsRowStatus, &tmpsize);
	mtpLsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpLsTable(): store configuraiton file for mtpLsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpLsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpLsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpLsTable: storing data...  "));
	refresh_mtpLsTable(1);
	(void) tmpsize;
	for (hcindex = mtpLsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpLsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpLsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsAdjPc, &StorageTmp->mtpLsAdjPcLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsRsId, &StorageTmp->mtpLsRsIdLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsMaxCapacity, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsCurrentCapacity, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsCongestionControlMethod, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsAvailabilityStatus, &StorageTmp->mtpLsAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFlag, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsPeriodicLinkTestFail, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsInLsLoadShareAlgorithm, &StorageTmp->mtpLsInLsLoadShareAlgorithmLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsProfilePointer, &StorageTmp->mtpLsProfilePointerLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsName, &StorageTmp->mtpLsNameLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpLsAsaProfilePointer, &StorageTmp->mtpLsAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpLsAlarmStatus, &StorageTmp->mtpLsAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpLsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlL3ProfileTable_data *mtpSlL3ProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlL3ProfileTable table.
 *
 * Creates a new mtpSlL3ProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlL3ProfileTable_data *
mtpSlL3ProfileTable_create(void)
{
	struct mtpSlL3ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL3ProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSlL3ProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlL3ProfileTimerT1 = 80;
		StorageNew->mtpSlL3ProfileTimerT3 = 80;
		StorageNew->mtpSlL3ProfileTimerT17 = 120;
		StorageNew->mtpSlL3ProfileTimerT24I = 50;
		if ((StorageNew->mtpSlL3ProfileName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSlL3ProfileNameLen = 0;
		StorageNew->mtpSlL3ProfileName[StorageNew->mtpSlL3ProfileNameLen] = 0;
		StorageNew->mtpSlL3ProfileTimerT2 = 140;
		StorageNew->mtpSlL3ProfileTimerT4 = 80;
		StorageNew->mtpSlL3ProfileTimerT5 = 80;
		StorageNew->mtpSlL3ProfileTimerT12 = 120;
		StorageNew->mtpSlL3ProfileTimerT13 = 120;
		StorageNew->mtpSlL3ProfileTimerT14 = 250;
		StorageNew->mtpSlL3ProfileTimerT19A = 54000;
		StorageNew->mtpSlL3ProfileTimerT20A = 10000;
		StorageNew->mtpSlL3ProfileTimerT21A = 10000;
		StorageNew->mtpSlL3ProfileTimerT22I = 27000;
		StorageNew->mtpSlL3ProfileTimerT23I = 27000;
		StorageNew->mtpSlL3ProfileTimerT31A = 6000;
		StorageNew->mtpSlL3ProfileTimerT32A = 6000;
		StorageNew->mtpSlL3ProfileTimerT33A = 36000;
		StorageNew->mtpSlL3ProfileTimerT34A = 6000;
		StorageNew->mtpSlL3ProfileTimerT1T = 400;
		StorageNew->mtpSlL3ProfileTimerT2T = 6000;
		StorageNew->mtpSlL3ProfileTimerT1S = 400;
		if ((StorageNew->mtpSlL3ProfileL2Default = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpSlL3ProfileL2DefaultLen = strlen("");
		StorageNew->mtpSlL3ProfileRowStatus = 0;
		StorageNew->mtpSlL3ProfileRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSlL3ProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSlL3ProfileTable_data *mtpSlL3ProfileTable_duplicate(struct mtpSlL3ProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlL3ProfileTable_data *
mtpSlL3ProfileTable_duplicate(struct mtpSlL3ProfileTable_data *thedata)
{
	struct mtpSlL3ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL3ProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSlL3ProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSlL3ProfileTable_id = thedata->mtpSlL3ProfileTable_id;
		if (!(StorageNew->mtpSlL3ProfileId = malloc(thedata->mtpSlL3ProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlL3ProfileId, thedata->mtpSlL3ProfileId, thedata->mtpSlL3ProfileIdLen);
		StorageNew->mtpSlL3ProfileIdLen = thedata->mtpSlL3ProfileIdLen;
		StorageNew->mtpSlL3ProfileId[StorageNew->mtpSlL3ProfileIdLen] = 0;
		StorageNew->mtpSlL3ProfileTimerT1 = thedata->mtpSlL3ProfileTimerT1;
		StorageNew->mtpSlL3ProfileTimerT3 = thedata->mtpSlL3ProfileTimerT3;
		StorageNew->mtpSlL3ProfileTimerT17 = thedata->mtpSlL3ProfileTimerT17;
		StorageNew->mtpSlL3ProfileTimerT24I = thedata->mtpSlL3ProfileTimerT24I;
		if (!(StorageNew->mtpSlL3ProfileName = malloc(thedata->mtpSlL3ProfileNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlL3ProfileName, thedata->mtpSlL3ProfileName, thedata->mtpSlL3ProfileNameLen);
		StorageNew->mtpSlL3ProfileNameLen = thedata->mtpSlL3ProfileNameLen;
		StorageNew->mtpSlL3ProfileName[StorageNew->mtpSlL3ProfileNameLen] = 0;
		StorageNew->mtpSlL3ProfileTimerT2 = thedata->mtpSlL3ProfileTimerT2;
		StorageNew->mtpSlL3ProfileTimerT4 = thedata->mtpSlL3ProfileTimerT4;
		StorageNew->mtpSlL3ProfileTimerT5 = thedata->mtpSlL3ProfileTimerT5;
		StorageNew->mtpSlL3ProfileTimerT12 = thedata->mtpSlL3ProfileTimerT12;
		StorageNew->mtpSlL3ProfileTimerT13 = thedata->mtpSlL3ProfileTimerT13;
		StorageNew->mtpSlL3ProfileTimerT14 = thedata->mtpSlL3ProfileTimerT14;
		StorageNew->mtpSlL3ProfileTimerT19A = thedata->mtpSlL3ProfileTimerT19A;
		StorageNew->mtpSlL3ProfileTimerT20A = thedata->mtpSlL3ProfileTimerT20A;
		StorageNew->mtpSlL3ProfileTimerT21A = thedata->mtpSlL3ProfileTimerT21A;
		StorageNew->mtpSlL3ProfileTimerT22I = thedata->mtpSlL3ProfileTimerT22I;
		StorageNew->mtpSlL3ProfileTimerT23I = thedata->mtpSlL3ProfileTimerT23I;
		StorageNew->mtpSlL3ProfileTimerT31A = thedata->mtpSlL3ProfileTimerT31A;
		StorageNew->mtpSlL3ProfileTimerT32A = thedata->mtpSlL3ProfileTimerT32A;
		StorageNew->mtpSlL3ProfileTimerT33A = thedata->mtpSlL3ProfileTimerT33A;
		StorageNew->mtpSlL3ProfileTimerT34A = thedata->mtpSlL3ProfileTimerT34A;
		StorageNew->mtpSlL3ProfileTimerT1T = thedata->mtpSlL3ProfileTimerT1T;
		StorageNew->mtpSlL3ProfileTimerT2T = thedata->mtpSlL3ProfileTimerT2T;
		StorageNew->mtpSlL3ProfileTimerT1S = thedata->mtpSlL3ProfileTimerT1S;
		if (!(StorageNew->mtpSlL3ProfileL2Default = malloc(thedata->mtpSlL3ProfileL2DefaultLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlL3ProfileL2Default, thedata->mtpSlL3ProfileL2Default, thedata->mtpSlL3ProfileL2DefaultLen);
		StorageNew->mtpSlL3ProfileL2DefaultLen = thedata->mtpSlL3ProfileL2DefaultLen;
		StorageNew->mtpSlL3ProfileL2Default[StorageNew->mtpSlL3ProfileL2DefaultLen] = 0;
		StorageNew->mtpSlL3ProfileRowStatus = thedata->mtpSlL3ProfileRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlL3ProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlL3ProfileTable_destroy(struct mtpSlL3ProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlL3ProfileTable_destroy(struct mtpSlL3ProfileTable_data **thedata)
{
	struct mtpSlL3ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSlL3ProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlL3ProfileId);
		StorageDel->mtpSlL3ProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfileName);
		StorageDel->mtpSlL3ProfileNameLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfileL2Default);
		StorageDel->mtpSlL3ProfileL2DefaultLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL3ProfileTable_add(struct mtpSlL3ProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlL3ProfileTable table data set.
 *
 * Adds a table row structure to the mtpSlL3ProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlL3ProfileTable_add(struct mtpSlL3ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSlL3ProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSlL3ProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSlL3ProfileId, thedata->mtpSlL3ProfileIdLen);
		header_complex_add_data(&mtpSlL3ProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL3ProfileTable_del(struct mtpSlL3ProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSlL3ProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlL3ProfileTable_del(struct mtpSlL3ProfileTable_data *thedata)
{
	struct mtpSlL3ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSlL3ProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlL3ProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlL3ProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlL3ProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlL3ProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlL3ProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlL3ProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL3ProfileTable_data *StorageTmp = mtpSlL3ProfileTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSlL3ProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSlL3ProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileId, &StorageTmp->mtpSlL3ProfileIdLen);
	if (StorageTmp->mtpSlL3ProfileId == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT17, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT24I, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlL3ProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileName, &StorageTmp->mtpSlL3ProfileNameLen);
	if (StorageTmp->mtpSlL3ProfileName == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT12, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT13, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT14, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT19A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT20A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT21A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT22I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT23I, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT31A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT32A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT33A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT34A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT2T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileTimerT1S, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlL3ProfileL2Default);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfileL2Default, &StorageTmp->mtpSlL3ProfileL2DefaultLen);
	if (StorageTmp->mtpSlL3ProfileL2Default == NULL) {
		config_perror("invalid specification for mtpSlL3ProfileL2Default");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL3ProfileRowStatus, &tmpsize);
	mtpSlL3ProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSlL3ProfileTable(): store configuraiton file for mtpSlL3ProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL3ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL3ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSlL3ProfileTable: storing data...  "));
	refresh_mtpSlL3ProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpSlL3ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL3ProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlL3ProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileId, &StorageTmp->mtpSlL3ProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT17, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT24I, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileName, &StorageTmp->mtpSlL3ProfileNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT12, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT13, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT14, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT19A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT20A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT21A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT22I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT23I, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT31A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT32A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT33A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT34A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT2T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileTimerT1S, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfileL2Default, &StorageTmp->mtpSlL3ProfileL2DefaultLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL3ProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlL2ProfileTable_data *mtpSlL2ProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlL2ProfileTable table.
 *
 * Creates a new mtpSlL2ProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlL2ProfileTable_data *
mtpSlL2ProfileTable_create(void)
{
	struct mtpSlL2ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL2ProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSlL2ProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlL2ProfileErrorCorrectionMethod = MTPSLL2PROFILEERRORCORRECTIONMETHOD_BASICRETR;
		{
			static oid tmpoid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 751, 0, 1, 4, 1, 1 };
			if ((StorageNew->mtpSlL2ProfileProtocolVariant = snmp_duplicate_objid(tmpoid, 14)) == NULL)
				goto nomem;
			StorageNew->mtpSlL2ProfileProtocolVariantLen = 14;
		}
		StorageNew->mtpSlL2ProfileTimerT1 = 4500;
		StorageNew->mtpSlL2ProfileTimerT2 = 500;
		StorageNew->mtpSlL2ProfileTimerT2L = 2000;
		StorageNew->mtpSlL2ProfileTimerT2H = 10000;
		StorageNew->mtpSlL2ProfileTimerT3 = 100;
		StorageNew->mtpSlL2ProfileTimerT4N = 800;
		StorageNew->mtpSlL2ProfileTimerT4E = 50;
		StorageNew->mtpSlL2ProfileTimerT5 = 10;
		StorageNew->mtpSlL2ProfileTimerT6 = 400;
		StorageNew->mtpSlL2ProfileTimerT7 = 100;
		StorageNew->mtpSlL2ProfileTbOnset1 = 69632;
		StorageNew->mtpSlL2ProfileTbAbate1 = 34816;
		StorageNew->mtpSlL2ProfileNumberOfThresholdLevels = 1;
		StorageNew->mtpSlL2ProfileCongestionCounting = MTPSLL2PROFILECONGESTIONCOUNTING_OCTET;
		StorageNew->mtpSlL2ProfileCongestionReportingBaseObject = MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_ROUTESET;
		StorageNew->mtpSlL2ProfileLoopDelay = 0;
		if ((StorageNew->mtpSlL2ProfileName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSlL2ProfileNameLen = 0;
		StorageNew->mtpSlL2ProfileName[StorageNew->mtpSlL2ProfileNameLen] = 0;
		StorageNew->mtpSlL2ProfileTbOnset2 = 174080;
		StorageNew->mtpSlL2ProfileTbAbate2 = 139264;
		StorageNew->mtpSlL2ProfileTbOnset3 = 278528;
		StorageNew->mtpSlL2ProfileTbAbate3 = 243712;
		StorageNew->mtpSlL2ProfileTbDiscard1 = 104448;
		StorageNew->mtpSlL2ProfileTbDiscard2 = 208896;
		StorageNew->mtpSlL2ProfileTbDiscard3 = 313344;
		StorageNew->mtpSlL2ProfileTimerTx = 100;
		StorageNew->mtpSlL2ProfileTimerTy = 200;
		StorageNew->mtpSlL2ProfileNumberOfCongestionStates = 3;
		StorageNew->mtpSlL2ProfileInitialLevelOfCongestion = 1;
		StorageNew->mtpSlL2ProfileMaxMSUsRetransN1 = 127;
		StorageNew->mtpSlL2ProfileMaxOctRetransN2 = 8192;
		StorageNew->mtpSlL2ProfileReceiveCongestionThresholdOnset = 6;
		StorageNew->mtpSlL2ProfileReceiveCongestionThresholdAbate = 3;
		StorageNew->mtpSlL2ProfileReceiveCongestionThresholdDiscard = 9;
		StorageNew->mtpSlL2ProfileM = 5;
		StorageNew->mtpSlL2ProfileRowStatus = 0;
		StorageNew->mtpSlL2ProfileRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSlL2ProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSlL2ProfileTable_data *mtpSlL2ProfileTable_duplicate(struct mtpSlL2ProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlL2ProfileTable_data *
mtpSlL2ProfileTable_duplicate(struct mtpSlL2ProfileTable_data *thedata)
{
	struct mtpSlL2ProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlL2ProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSlL2ProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSlL2ProfileTable_id = thedata->mtpSlL2ProfileTable_id;
		if (!(StorageNew->mtpSlL2ProfileId = malloc(thedata->mtpSlL2ProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlL2ProfileId, thedata->mtpSlL2ProfileId, thedata->mtpSlL2ProfileIdLen);
		StorageNew->mtpSlL2ProfileIdLen = thedata->mtpSlL2ProfileIdLen;
		StorageNew->mtpSlL2ProfileId[StorageNew->mtpSlL2ProfileIdLen] = 0;
		StorageNew->mtpSlL2ProfileTransmissionRate = thedata->mtpSlL2ProfileTransmissionRate;
		StorageNew->mtpSlL2ProfileErrorCorrectionMethod = thedata->mtpSlL2ProfileErrorCorrectionMethod;
		if (!(StorageNew->mtpSlL2ProfileProtocolVariant = snmp_duplicate_objid(thedata->mtpSlL2ProfileProtocolVariant, thedata->mtpSlL2ProfileProtocolVariantLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSlL2ProfileProtocolVariantLen = thedata->mtpSlL2ProfileProtocolVariantLen;
		StorageNew->mtpSlL2ProfileTimerT1 = thedata->mtpSlL2ProfileTimerT1;
		StorageNew->mtpSlL2ProfileTimerT2 = thedata->mtpSlL2ProfileTimerT2;
		StorageNew->mtpSlL2ProfileTimerT2L = thedata->mtpSlL2ProfileTimerT2L;
		StorageNew->mtpSlL2ProfileTimerT2H = thedata->mtpSlL2ProfileTimerT2H;
		StorageNew->mtpSlL2ProfileTimerT3 = thedata->mtpSlL2ProfileTimerT3;
		StorageNew->mtpSlL2ProfileTimerT4N = thedata->mtpSlL2ProfileTimerT4N;
		StorageNew->mtpSlL2ProfileTimerT4E = thedata->mtpSlL2ProfileTimerT4E;
		StorageNew->mtpSlL2ProfileTimerT5 = thedata->mtpSlL2ProfileTimerT5;
		StorageNew->mtpSlL2ProfileTimerT6 = thedata->mtpSlL2ProfileTimerT6;
		StorageNew->mtpSlL2ProfileTimerT7 = thedata->mtpSlL2ProfileTimerT7;
		StorageNew->mtpSlL2ProfileTbOnset1 = thedata->mtpSlL2ProfileTbOnset1;
		StorageNew->mtpSlL2ProfileTbAbate1 = thedata->mtpSlL2ProfileTbAbate1;
		StorageNew->mtpSlL2ProfileNumberOfThresholdLevels = thedata->mtpSlL2ProfileNumberOfThresholdLevels;
		StorageNew->mtpSlL2ProfileCongestionCounting = thedata->mtpSlL2ProfileCongestionCounting;
		StorageNew->mtpSlL2ProfileCongestionReportingBaseObject = thedata->mtpSlL2ProfileCongestionReportingBaseObject;
		StorageNew->mtpSlL2ProfileLoopDelay = thedata->mtpSlL2ProfileLoopDelay;
		if (!(StorageNew->mtpSlL2ProfileName = malloc(thedata->mtpSlL2ProfileNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlL2ProfileName, thedata->mtpSlL2ProfileName, thedata->mtpSlL2ProfileNameLen);
		StorageNew->mtpSlL2ProfileNameLen = thedata->mtpSlL2ProfileNameLen;
		StorageNew->mtpSlL2ProfileName[StorageNew->mtpSlL2ProfileNameLen] = 0;
		StorageNew->mtpSlL2ProfileTbOnset2 = thedata->mtpSlL2ProfileTbOnset2;
		StorageNew->mtpSlL2ProfileTbAbate2 = thedata->mtpSlL2ProfileTbAbate2;
		StorageNew->mtpSlL2ProfileTbOnset3 = thedata->mtpSlL2ProfileTbOnset3;
		StorageNew->mtpSlL2ProfileTbAbate3 = thedata->mtpSlL2ProfileTbAbate3;
		StorageNew->mtpSlL2ProfileTbDiscard1 = thedata->mtpSlL2ProfileTbDiscard1;
		StorageNew->mtpSlL2ProfileTbDiscard2 = thedata->mtpSlL2ProfileTbDiscard2;
		StorageNew->mtpSlL2ProfileTbDiscard3 = thedata->mtpSlL2ProfileTbDiscard3;
		StorageNew->mtpSlL2ProfileTimerTx = thedata->mtpSlL2ProfileTimerTx;
		StorageNew->mtpSlL2ProfileTimerTy = thedata->mtpSlL2ProfileTimerTy;
		StorageNew->mtpSlL2ProfileNumberOfCongestionStates = thedata->mtpSlL2ProfileNumberOfCongestionStates;
		StorageNew->mtpSlL2ProfileInitialLevelOfCongestion = thedata->mtpSlL2ProfileInitialLevelOfCongestion;
		StorageNew->mtpSlL2ProfileMaxMSUsRetransN1 = thedata->mtpSlL2ProfileMaxMSUsRetransN1;
		StorageNew->mtpSlL2ProfileMaxOctRetransN2 = thedata->mtpSlL2ProfileMaxOctRetransN2;
		StorageNew->mtpSlL2ProfileReceiveCongestionThresholdOnset = thedata->mtpSlL2ProfileReceiveCongestionThresholdOnset;
		StorageNew->mtpSlL2ProfileReceiveCongestionThresholdAbate = thedata->mtpSlL2ProfileReceiveCongestionThresholdAbate;
		StorageNew->mtpSlL2ProfileReceiveCongestionThresholdDiscard = thedata->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		StorageNew->mtpSlL2ProfileM = thedata->mtpSlL2ProfileM;
		StorageNew->mtpSlL2ProfileRowStatus = thedata->mtpSlL2ProfileRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlL2ProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlL2ProfileTable_destroy(struct mtpSlL2ProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlL2ProfileTable_destroy(struct mtpSlL2ProfileTable_data **thedata)
{
	struct mtpSlL2ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSlL2ProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlL2ProfileId);
		StorageDel->mtpSlL2ProfileIdLen = 0;
		SNMP_FREE(StorageDel->mtpSlL2ProfileProtocolVariant);
		StorageDel->mtpSlL2ProfileProtocolVariantLen = 0;
		SNMP_FREE(StorageDel->mtpSlL2ProfileName);
		StorageDel->mtpSlL2ProfileNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL2ProfileTable_add(struct mtpSlL2ProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlL2ProfileTable table data set.
 *
 * Adds a table row structure to the mtpSlL2ProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlL2ProfileTable_add(struct mtpSlL2ProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSlL2ProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSlL2ProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSlL2ProfileId, thedata->mtpSlL2ProfileIdLen);
		/* mtpSlL2ProfileTransmissionRate */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpSlL2ProfileTransmissionRate, sizeof(thedata->mtpSlL2ProfileTransmissionRate));
		header_complex_add_data(&mtpSlL2ProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlL2ProfileTable_del(struct mtpSlL2ProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSlL2ProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlL2ProfileTable_del(struct mtpSlL2ProfileTable_data *thedata)
{
	struct mtpSlL2ProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSlL2ProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlL2ProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlL2ProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlL2ProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlL2ProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlL2ProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlL2ProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlL2ProfileTable_data *StorageTmp = mtpSlL2ProfileTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSlL2ProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSlL2ProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL2ProfileId, &StorageTmp->mtpSlL2ProfileIdLen);
	if (StorageTmp->mtpSlL2ProfileId == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTransmissionRate, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlL2ProfileProtocolVariant);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlL2ProfileProtocolVariant, &StorageTmp->mtpSlL2ProfileProtocolVariantLen);
	if (StorageTmp->mtpSlL2ProfileProtocolVariant == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileProtocolVariant");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2L, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT2H, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT4N, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT4E, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerT7, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileCongestionCounting, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileLoopDelay, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlL2ProfileName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL2ProfileName, &StorageTmp->mtpSlL2ProfileNameLen);
	if (StorageTmp->mtpSlL2ProfileName == NULL) {
		config_perror("invalid specification for mtpSlL2ProfileName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbOnset3, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbAbate3, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileTbDiscard3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerTx, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileTimerTy, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileMaxOctRetransN2, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlL2ProfileM, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlL2ProfileRowStatus, &tmpsize);
	mtpSlL2ProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSlL2ProfileTable(): store configuraiton file for mtpSlL2ProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlL2ProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlL2ProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSlL2ProfileTable: storing data...  "));
	refresh_mtpSlL2ProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpSlL2ProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlL2ProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlL2ProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL2ProfileId, &StorageTmp->mtpSlL2ProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlL2ProfileProtocolVariant, &StorageTmp->mtpSlL2ProfileProtocolVariantLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2L, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT2H, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT4N, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT4E, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileCongestionCounting, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileLoopDelay, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL2ProfileName, &StorageTmp->mtpSlL2ProfileNameLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbOnset3, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbAbate3, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileTbDiscard3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerTx, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileTimerTy, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileMaxOctRetransN2, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlL2ProfileM, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlL2ProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlTable_data *mtpSlTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlTable table.
 *
 * Creates a new mtpSlTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlTable_data *
mtpSlTable_create(void)
{
	struct mtpSlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSlTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlSlCode = 0;
		if ((StorageNew->mtpSlSlsCodeCurrentList = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSlSlsCodeCurrentListLen = 0;
		StorageNew->mtpSlSlsCodeCurrentList[StorageNew->mtpSlSlsCodeCurrentListLen] = 0;
		StorageNew->mtpSlMaxCapacitySL = 8000;
		StorageNew->mtpSlCurrentCapacitySL = 8000;
		if (memdup((u_char **) &StorageNew->mtpSlLinkTpStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSlLinkTpStatusLen = 1;
		StorageNew->mtpSlAdministrativeState = MTPSLADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpSlOperationalState = MTPSLOPERATIONALSTATE_DISABLED;
		StorageNew->mtpSlUsageState = MTPSLUSAGESTATE_IDLE;
		if (memdup((u_char **) &StorageNew->mtpSlProceduralStatus, (u_char *) "\x80", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSlProceduralStatusLen = 1;
		if ((StorageNew->mtpSlMtpL2ProtocolProfilePointer = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpSlMtpL2ProtocolProfilePointerLen = strlen("");
		if ((StorageNew->mtpSlSignTermPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSlSignTermPointerLen = 2;
		if ((StorageNew->mtpSlSignDataLinkTpPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSlSignDataLinkTpPointerLen = 2;
		StorageNew->mtpSlLocalInhibit = 0;
		StorageNew->mtpSlLocalUninhibit = 0;
		StorageNew->mtpSlReplaceSt = 0;
		if ((StorageNew->mtpSlAsaProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSlAsaProfilePointerLen = 2;
		StorageNew->mtpSlCongestionLevel = MTPSLCONGESTIONLEVEL_NONE;
		StorageNew->mtpSlRelatedLinkGroupNumber = 0;
		StorageNew->mtpSlSdlList = 0;
		StorageNew->mtpSlTest = 0;
		if ((StorageNew->mtpSlName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSlNameLen = 0;
		StorageNew->mtpSlName[StorageNew->mtpSlNameLen] = 0;
		StorageNew->mtpSlSdtList = 0;
		if (memdup((u_char **) &StorageNew->mtpSlSlsCodeNormalList, (u_char *) "\xFF\xFF", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSlSlsCodeNormalListLen = 2;
		if ((StorageNew->mtpSlL3ProfilePointer = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpSlL3ProfilePointerLen = strlen("");
		if (memdup((u_char **) &StorageNew->mtpSlAlarmStatus, (u_char *) "\x00", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSlAlarmStatusLen = 1;
		StorageNew->mtpSlRowStatus = 0;
		StorageNew->mtpSlRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSlTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSlTable_data *mtpSlTable_duplicate(struct mtpSlTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlTable_data *
mtpSlTable_duplicate(struct mtpSlTable_data *thedata)
{
	struct mtpSlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSlTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSlTable_id = thedata->mtpSlTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpLsId = thedata->mtpLsId;
		StorageNew->mtpSlId = thedata->mtpSlId;
		StorageNew->mtpSlSlCode = thedata->mtpSlSlCode;
		if (!(StorageNew->mtpSlSlsCodeCurrentList = malloc(thedata->mtpSlSlsCodeCurrentListLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlSlsCodeCurrentList, thedata->mtpSlSlsCodeCurrentList, thedata->mtpSlSlsCodeCurrentListLen);
		StorageNew->mtpSlSlsCodeCurrentListLen = thedata->mtpSlSlsCodeCurrentListLen;
		StorageNew->mtpSlSlsCodeCurrentList[StorageNew->mtpSlSlsCodeCurrentListLen] = 0;
		StorageNew->mtpSlMaxCapacitySL = thedata->mtpSlMaxCapacitySL;
		StorageNew->mtpSlCurrentCapacitySL = thedata->mtpSlCurrentCapacitySL;
		if (!(StorageNew->mtpSlLinkTpStatus = malloc(thedata->mtpSlLinkTpStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlLinkTpStatus, thedata->mtpSlLinkTpStatus, thedata->mtpSlLinkTpStatusLen);
		StorageNew->mtpSlLinkTpStatusLen = thedata->mtpSlLinkTpStatusLen;
		StorageNew->mtpSlLinkTpStatus[StorageNew->mtpSlLinkTpStatusLen] = 0;
		StorageNew->mtpSlAdministrativeState = thedata->mtpSlAdministrativeState;
		StorageNew->mtpSlOperationalState = thedata->mtpSlOperationalState;
		StorageNew->mtpSlUsageState = thedata->mtpSlUsageState;
		if (!(StorageNew->mtpSlProceduralStatus = malloc(thedata->mtpSlProceduralStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlProceduralStatus, thedata->mtpSlProceduralStatus, thedata->mtpSlProceduralStatusLen);
		StorageNew->mtpSlProceduralStatusLen = thedata->mtpSlProceduralStatusLen;
		StorageNew->mtpSlProceduralStatus[StorageNew->mtpSlProceduralStatusLen] = 0;
		if (!(StorageNew->mtpSlMtpL2ProtocolProfilePointer = malloc(thedata->mtpSlMtpL2ProtocolProfilePointerLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlMtpL2ProtocolProfilePointer, thedata->mtpSlMtpL2ProtocolProfilePointer, thedata->mtpSlMtpL2ProtocolProfilePointerLen);
		StorageNew->mtpSlMtpL2ProtocolProfilePointerLen = thedata->mtpSlMtpL2ProtocolProfilePointerLen;
		StorageNew->mtpSlMtpL2ProtocolProfilePointer[StorageNew->mtpSlMtpL2ProtocolProfilePointerLen] = 0;
		if (!(StorageNew->mtpSlSignTermPointer = snmp_duplicate_objid(thedata->mtpSlSignTermPointer, thedata->mtpSlSignTermPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSlSignTermPointerLen = thedata->mtpSlSignTermPointerLen;
		if (!(StorageNew->mtpSlSignDataLinkTpPointer = snmp_duplicate_objid(thedata->mtpSlSignDataLinkTpPointer, thedata->mtpSlSignDataLinkTpPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSlSignDataLinkTpPointerLen = thedata->mtpSlSignDataLinkTpPointerLen;
		StorageNew->mtpSlLocalInhibit = thedata->mtpSlLocalInhibit;
		StorageNew->mtpSlLocalUninhibit = thedata->mtpSlLocalUninhibit;
		StorageNew->mtpSlReplaceSt = thedata->mtpSlReplaceSt;
		if (!(StorageNew->mtpSlAsaProfilePointer = snmp_duplicate_objid(thedata->mtpSlAsaProfilePointer, thedata->mtpSlAsaProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSlAsaProfilePointerLen = thedata->mtpSlAsaProfilePointerLen;
		StorageNew->mtpSlCongestionLevel = thedata->mtpSlCongestionLevel;
		StorageNew->mtpSlRelatedLinkGroupNumber = thedata->mtpSlRelatedLinkGroupNumber;
		StorageNew->mtpSlSdlList = thedata->mtpSlSdlList;
		StorageNew->mtpSlTest = thedata->mtpSlTest;
		if (!(StorageNew->mtpSlName = malloc(thedata->mtpSlNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlName, thedata->mtpSlName, thedata->mtpSlNameLen);
		StorageNew->mtpSlNameLen = thedata->mtpSlNameLen;
		StorageNew->mtpSlName[StorageNew->mtpSlNameLen] = 0;
		StorageNew->mtpSlSdtList = thedata->mtpSlSdtList;
		if (!(StorageNew->mtpSlSlsCodeNormalList = malloc(thedata->mtpSlSlsCodeNormalListLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlSlsCodeNormalList, thedata->mtpSlSlsCodeNormalList, thedata->mtpSlSlsCodeNormalListLen);
		StorageNew->mtpSlSlsCodeNormalListLen = thedata->mtpSlSlsCodeNormalListLen;
		StorageNew->mtpSlSlsCodeNormalList[StorageNew->mtpSlSlsCodeNormalListLen] = 0;
		if (!(StorageNew->mtpSlL3ProfilePointer = malloc(thedata->mtpSlL3ProfilePointerLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlL3ProfilePointer, thedata->mtpSlL3ProfilePointer, thedata->mtpSlL3ProfilePointerLen);
		StorageNew->mtpSlL3ProfilePointerLen = thedata->mtpSlL3ProfilePointerLen;
		StorageNew->mtpSlL3ProfilePointer[StorageNew->mtpSlL3ProfilePointerLen] = 0;
		if (!(StorageNew->mtpSlAlarmStatus = malloc(thedata->mtpSlAlarmStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSlAlarmStatus, thedata->mtpSlAlarmStatus, thedata->mtpSlAlarmStatusLen);
		StorageNew->mtpSlAlarmStatusLen = thedata->mtpSlAlarmStatusLen;
		StorageNew->mtpSlAlarmStatus[StorageNew->mtpSlAlarmStatusLen] = 0;
		StorageNew->mtpSlRowStatus = thedata->mtpSlRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlTable_destroy(struct mtpSlTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlTable_destroy(struct mtpSlTable_data **thedata)
{
	struct mtpSlTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSlTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSlsCodeCurrentList);
		StorageDel->mtpSlSlsCodeCurrentListLen = 0;
		SNMP_FREE(StorageDel->mtpSlLinkTpStatus);
		StorageDel->mtpSlLinkTpStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSlProceduralStatus);
		StorageDel->mtpSlProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSlMtpL2ProtocolProfilePointer);
		StorageDel->mtpSlMtpL2ProtocolProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlSignTermPointer);
		StorageDel->mtpSlSignTermPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlSignDataLinkTpPointer);
		StorageDel->mtpSlSignDataLinkTpPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlAsaProfilePointer);
		StorageDel->mtpSlAsaProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlName);
		StorageDel->mtpSlNameLen = 0;
		SNMP_FREE(StorageDel->mtpSlSlsCodeNormalList);
		StorageDel->mtpSlSlsCodeNormalListLen = 0;
		SNMP_FREE(StorageDel->mtpSlL3ProfilePointer);
		StorageDel->mtpSlL3ProfilePointerLen = 0;
		SNMP_FREE(StorageDel->mtpSlAlarmStatus);
		StorageDel->mtpSlAlarmStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlTable_add(struct mtpSlTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlTable table data set.
 *
 * Adds a table row structure to the mtpSlTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlTable_add(struct mtpSlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSlTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpSlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
		header_complex_add_data(&mtpSlTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlTable_del(struct mtpSlTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSlTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlTable_del(struct mtpSlTable_data *thedata)
{
	struct mtpSlTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSlTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlTable_data *StorageTmp = mtpSlTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSlTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlSlsCodeCurrentList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
	if (StorageTmp->mtpSlSlsCodeCurrentList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeCurrentList");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlMaxCapacitySL, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlCurrentCapacitySL, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlLinkTpStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlLinkTpStatus, &StorageTmp->mtpSlLinkTpStatusLen);
	if (StorageTmp->mtpSlLinkTpStatus == NULL) {
		config_perror("invalid specification for mtpSlLinkTpStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlProceduralStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
	if (StorageTmp->mtpSlProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSlProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSlMtpL2ProtocolProfilePointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, &StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen);
	if (StorageTmp->mtpSlMtpL2ProtocolProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlMtpL2ProtocolProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSlSignTermPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSignTermPointer, &StorageTmp->mtpSlSignTermPointerLen);
	if (StorageTmp->mtpSlSignTermPointer == NULL) {
		config_perror("invalid specification for mtpSlSignTermPointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSlSignDataLinkTpPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSignDataLinkTpPointer, &StorageTmp->mtpSlSignDataLinkTpPointerLen);
	if (StorageTmp->mtpSlSignDataLinkTpPointer == NULL) {
		config_perror("invalid specification for mtpSlSignDataLinkTpPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalInhibit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlLocalUninhibit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlReplaceSt, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlAsaProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlAsaProfilePointer, &StorageTmp->mtpSlAsaProfilePointerLen);
	if (StorageTmp->mtpSlAsaProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlAsaProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlCongestionLevel, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlList, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlTest, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
	if (StorageTmp->mtpSlName == NULL) {
		config_perror("invalid specification for mtpSlName");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtList, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlSlsCodeNormalList);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
	if (StorageTmp->mtpSlSlsCodeNormalList == NULL) {
		config_perror("invalid specification for mtpSlSlsCodeNormalList");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSlL3ProfilePointer);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlL3ProfilePointer, &StorageTmp->mtpSlL3ProfilePointerLen);
	if (StorageTmp->mtpSlL3ProfilePointer == NULL) {
		config_perror("invalid specification for mtpSlL3ProfilePointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSlAlarmStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSlAlarmStatus, &StorageTmp->mtpSlAlarmStatusLen);
	if (StorageTmp->mtpSlAlarmStatus == NULL) {
		config_perror("invalid specification for mtpSlAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlRowStatus, &tmpsize);
	mtpSlTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSlTable(): store configuraiton file for mtpSlTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSlTable: storing data...  "));
	refresh_mtpSlTable(1);
	(void) tmpsize;
	for (hcindex = mtpSlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeCurrentList, &StorageTmp->mtpSlSlsCodeCurrentListLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlMaxCapacitySL, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlCurrentCapacitySL, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlLinkTpStatus, &StorageTmp->mtpSlLinkTpStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlProceduralStatus, &StorageTmp->mtpSlProceduralStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlMtpL2ProtocolProfilePointer, &StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSignTermPointer, &StorageTmp->mtpSlSignTermPointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSignDataLinkTpPointer, &StorageTmp->mtpSlSignDataLinkTpPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlLocalUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlReplaceSt, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlAsaProfilePointer, &StorageTmp->mtpSlAsaProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlRelatedLinkGroupNumber, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlList, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlTest, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlName, &StorageTmp->mtpSlNameLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtList, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlSlsCodeNormalList, &StorageTmp->mtpSlSlsCodeNormalListLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlL3ProfilePointer, &StorageTmp->mtpSlL3ProfilePointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSlAlarmStatus, &StorageTmp->mtpSlAlarmStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlSdlListTable_data *mtpSlSdlListTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlSdlListTable table.
 *
 * Creates a new mtpSlSdlListTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlSdlListTable_data *
mtpSlSdlListTable_create(void)
{
	struct mtpSlSdlListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSlSdlListTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlId = 0;
		if ((StorageNew->mtpSlSdlListPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSlSdlListPointerLen = 2;
		StorageNew->mtpSlSdlListRowStatus = 0;
		StorageNew->mtpSlSdlListRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSlSdlListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSlSdlListTable_data *mtpSlSdlListTable_duplicate(struct mtpSlSdlListTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlSdlListTable_data *
mtpSlSdlListTable_duplicate(struct mtpSlSdlListTable_data *thedata)
{
	struct mtpSlSdlListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdlListTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSlSdlListTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSlSdlListTable_id = thedata->mtpSlSdlListTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpLsId = thedata->mtpLsId;
		StorageNew->mtpSlId = thedata->mtpSlId;
		StorageNew->mtpSlSdlListId = thedata->mtpSlSdlListId;
		if (!(StorageNew->mtpSlSdlListPointer = snmp_duplicate_objid(thedata->mtpSlSdlListPointer, thedata->mtpSlSdlListPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSlSdlListPointerLen = thedata->mtpSlSdlListPointerLen;
		StorageNew->mtpSlSdlListRowStatus = thedata->mtpSlSdlListRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlSdlListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlSdlListTable_destroy(struct mtpSlSdlListTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlSdlListTable_destroy(struct mtpSlSdlListTable_data **thedata)
{
	struct mtpSlSdlListTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSlSdlListTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSdlListPointer);
		StorageDel->mtpSlSdlListPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdlListTable_add(struct mtpSlSdlListTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlSdlListTable table data set.
 *
 * Adds a table row structure to the mtpSlSdlListTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlSdlListTable_add(struct mtpSlSdlListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSlSdlListTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpSlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
		/* mtpSlSdlListId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdlListId, sizeof(thedata->mtpSlSdlListId));
		header_complex_add_data(&mtpSlSdlListTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdlListTable_del(struct mtpSlSdlListTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSlSdlListTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlSdlListTable_del(struct mtpSlSdlListTable_data *thedata)
{
	struct mtpSlSdlListTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSlSdlListTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlSdlListTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlSdlListTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlSdlListTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlSdlListTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlSdlListTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlSdlListTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlSdlListTable_data *StorageTmp = mtpSlSdlListTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSlSdlListTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdlListId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlSdlListPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
	if (StorageTmp->mtpSlSdlListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdlListPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdlListRowStatus, &tmpsize);
	mtpSlSdlListTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSlSdlListTable(): store configuraiton file for mtpSlSdlListTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdlListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlSdlListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSlSdlListTable: storing data...  "));
	refresh_mtpSlSdlListTable(1);
	(void) tmpsize;
	for (hcindex = mtpSlSdlListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdlListTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlSdlListTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdlListId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdlListPointer, &StorageTmp->mtpSlSdlListPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdlListRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSlSdtListTable_data *mtpSlSdtListTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSlSdtListTable table.
 *
 * Creates a new mtpSlSdtListTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSlSdtListTable_data *
mtpSlSdtListTable_create(void)
{
	struct mtpSlSdtListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSlSdtListTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlId = 0;
		if ((StorageNew->mtpSlSdtListPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSlSdtListPointerLen = 2;
		StorageNew->mtpSlSdtListRowStatus = 0;
		StorageNew->mtpSlSdtListRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSlSdtListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSlSdtListTable_data *mtpSlSdtListTable_duplicate(struct mtpSlSdtListTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSlSdtListTable_data *
mtpSlSdtListTable_duplicate(struct mtpSlSdtListTable_data *thedata)
{
	struct mtpSlSdtListTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSlSdtListTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSlSdtListTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSlSdtListTable_id = thedata->mtpSlSdtListTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpLsId = thedata->mtpLsId;
		StorageNew->mtpSlId = thedata->mtpSlId;
		StorageNew->mtpSlSdtListId = thedata->mtpSlSdtListId;
		if (!(StorageNew->mtpSlSdtListPointer = snmp_duplicate_objid(thedata->mtpSlSdtListPointer, thedata->mtpSlSdtListPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSlSdtListPointerLen = thedata->mtpSlSdtListPointerLen;
		StorageNew->mtpSlSdtListRowStatus = thedata->mtpSlSdtListRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSlSdtListTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSlSdtListTable_destroy(struct mtpSlSdtListTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSlSdtListTable_destroy(struct mtpSlSdtListTable_data **thedata)
{
	struct mtpSlSdtListTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSlSdtListTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSlSdtListPointer);
		StorageDel->mtpSlSdtListPointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdtListTable_add(struct mtpSlSdtListTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSlSdtListTable table data set.
 *
 * Adds a table row structure to the mtpSlSdtListTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSlSdtListTable_add(struct mtpSlSdtListTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSlSdtListTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpSlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
		/* mtpSlSdtListId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlSdtListId, sizeof(thedata->mtpSlSdtListId));
		header_complex_add_data(&mtpSlSdtListTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSlSdtListTable_del(struct mtpSlSdtListTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSlSdtListTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSlSdtListTable_del(struct mtpSlSdtListTable_data *thedata)
{
	struct mtpSlSdtListTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSlSdtListTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSlSdtListTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSlSdtListTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSlSdtListTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSlSdtListTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSlSdtListTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSlSdtListTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSlSdtListTable_data *StorageTmp = mtpSlSdtListTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSlSdtListTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlSdtListId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSlSdtListPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
	if (StorageTmp->mtpSlSdtListPointer == NULL) {
		config_perror("invalid specification for mtpSlSdtListPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSdtListRowStatus, &tmpsize);
	mtpSlSdtListTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSlSdtListTable(): store configuraiton file for mtpSlSdtListTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSlSdtListTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSlSdtListTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSlSdtListTable: storing data...  "));
	refresh_mtpSlSdtListTable(1);
	(void) tmpsize;
	for (hcindex = mtpSlSdtListTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSlSdtListTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSlSdtListTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlSdtListId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSlSdtListPointer, &StorageTmp->mtpSlSdtListPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSdtListRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpNbTable_data *mtpNbTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpNbTable table.
 *
 * Creates a new mtpNbTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpNbTable_data *
mtpNbTable_create(void)
{
	struct mtpNbTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNbTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpNbTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpNbTransmissionRate = MTPNBTRANSMISSIONRATE_KBITS64;
		StorageNew->mtpNbTimerT8 = 100;
		StorageNew->mtpNbTin = 4;
		StorageNew->mtpNbTie = 1;
		StorageNew->mtpNbT = 64;
		StorageNew->mtpNbD = 256;
		StorageNew->mtpNbTe = 793544;
		StorageNew->mtpNbDe = 11328;
		StorageNew->mtpNbUe = 198384;
		StorageNew->mtpNbN = 16;
		StorageNew->mtpNbm = 272;
		StorageNew->mtpNbb = 8;
		StorageNew->mtpNbf = MTPNBF_ONE;
		StorageNew->mtpNbRowStatus = 0;
		StorageNew->mtpNbRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpNbTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpNbTable_data *mtpNbTable_duplicate(struct mtpNbTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpNbTable_data *
mtpNbTable_duplicate(struct mtpNbTable_data *thedata)
{
	struct mtpNbTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpNbTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpNbTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpNbTable_id = thedata->mtpNbTable_id;
		if (!(StorageNew->mtpSdtProfileId = malloc(thedata->mtpSdtProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSdtProfileId, thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
		StorageNew->mtpSdtProfileIdLen = thedata->mtpSdtProfileIdLen;
		StorageNew->mtpSdtProfileId[StorageNew->mtpSdtProfileIdLen] = 0;
		StorageNew->mtpNbTransmissionRate = thedata->mtpNbTransmissionRate;
		StorageNew->mtpNbTimerT8 = thedata->mtpNbTimerT8;
		StorageNew->mtpNbTin = thedata->mtpNbTin;
		StorageNew->mtpNbTie = thedata->mtpNbTie;
		StorageNew->mtpNbT = thedata->mtpNbT;
		StorageNew->mtpNbD = thedata->mtpNbD;
		StorageNew->mtpNbTe = thedata->mtpNbTe;
		StorageNew->mtpNbDe = thedata->mtpNbDe;
		StorageNew->mtpNbUe = thedata->mtpNbUe;
		StorageNew->mtpNbN = thedata->mtpNbN;
		StorageNew->mtpNbm = thedata->mtpNbm;
		StorageNew->mtpNbb = thedata->mtpNbb;
		StorageNew->mtpNbf = thedata->mtpNbf;
		StorageNew->mtpNbRowStatus = thedata->mtpNbRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpNbTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpNbTable_destroy(struct mtpNbTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpNbTable_destroy(struct mtpNbTable_data **thedata)
{
	struct mtpNbTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpNbTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNbTable_add(struct mtpNbTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpNbTable table data set.
 *
 * Adds a table row structure to the mtpNbTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpNbTable_add(struct mtpNbTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpNbTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSdtProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
		header_complex_add_data(&mtpNbTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpNbTable_del(struct mtpNbTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpNbTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpNbTable_del(struct mtpNbTable_data *thedata)
{
	struct mtpNbTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpNbTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpNbTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpNbTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpNbTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpNbTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpNbTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpNbTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpNbTable_data *StorageTmp = mtpNbTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpNbTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSdtProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbTransmissionRate, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTimerT8, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTie, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbT, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbD, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbTe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbDe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbUe, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbN, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbm, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpNbb, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbf, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpNbRowStatus, &tmpsize);
	mtpNbTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpNbTable(): store configuraiton file for mtpNbTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpNbTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpNbTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpNbTable: storing data...  "));
	refresh_mtpNbTable(1);
	(void) tmpsize;
	for (hcindex = mtpNbTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpNbTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpNbTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTie, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbT, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbD, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbTe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbDe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbUe, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbN, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbm, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpNbb, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbf, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpNbRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSaalTable_data *mtpSaalTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSaalTable table.
 *
 * Creates a new mtpSaalTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSaalTable_data *
mtpSaalTable_create(void)
{
	struct mtpSaalTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSaalTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSaalTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpSdtProfileId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSdtProfileIdLen = 0;
		StorageNew->mtpSdtProfileId[StorageNew->mtpSdtProfileIdLen] = 0;
		StorageNew->mtpSaalBufferRelease = TV_FALSE;
		StorageNew->mtpSaalMaxCc = 4;
		StorageNew->mtpSaalMaxNrp = 1;
		StorageNew->mtpSaalMaxInformationFieldLength = 4096;
		StorageNew->mtpSaalMaxLengthSscopUuField = 4;
		StorageNew->mtpSaalMaxPd = 500;
		StorageNew->mtpSaalMaxSscopCreditToPeer = 128;
		StorageNew->mtpSaalMaxStat = 67;
		StorageNew->mtpSaalN1 = 1000;
		StorageNew->mtpSaalNniLayerManagementProvingState = MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_NEUTRAL;
		StorageNew->mtpSaalNniLayerManagementTimerNoCredit = 200;
		StorageNew->mtpSaalNniLayerManagementTimerRepeatSrec = 0;
		StorageNew->mtpSaalNniTimerT1 = 500;
		StorageNew->mtpSaalNniTimerT2 = 3000;
		StorageNew->mtpSaalNniTimerT3 = 10;
		StorageNew->mtpSaalSscopTimerCc = 20;
		StorageNew->mtpSaalSscopTimerIdle = 10;
		StorageNew->mtpSaalSscopTimerKeepAlive = 10;
		StorageNew->mtpSaalSscopTimerNoResponse = 150;
		StorageNew->mtpSaalSscopTimerPoll = 10;
		StorageNew->mtpSaalTransmissionRateIntervalLower = 129;
		StorageNew->mtpSaalTransmissionRateIntervalUpper = 256;
		StorageNew->mtpSaalEgressTransmissionRateIntervalLower = 129;
		StorageNew->mtpSaalEgressTransmissionRateIntervalUpper = 256;
		StorageNew->mtpSaalPollAfterRetransmission = TV_TRUE;
		StorageNew->mtpSaalRowStatus = 0;
		StorageNew->mtpSaalRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSaalTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSaalTable_data *mtpSaalTable_duplicate(struct mtpSaalTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSaalTable_data *
mtpSaalTable_duplicate(struct mtpSaalTable_data *thedata)
{
	struct mtpSaalTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSaalTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSaalTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSaalTable_id = thedata->mtpSaalTable_id;
		if (!(StorageNew->mtpSdtProfileId = malloc(thedata->mtpSdtProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSdtProfileId, thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
		StorageNew->mtpSdtProfileIdLen = thedata->mtpSdtProfileIdLen;
		StorageNew->mtpSdtProfileId[StorageNew->mtpSdtProfileIdLen] = 0;
		StorageNew->mtpSaalBufferRelease = thedata->mtpSaalBufferRelease;
		StorageNew->mtpSaalMaxCc = thedata->mtpSaalMaxCc;
		StorageNew->mtpSaalMaxNrp = thedata->mtpSaalMaxNrp;
		StorageNew->mtpSaalMaxInformationFieldLength = thedata->mtpSaalMaxInformationFieldLength;
		StorageNew->mtpSaalMaxLengthSscopUuField = thedata->mtpSaalMaxLengthSscopUuField;
		StorageNew->mtpSaalMaxPd = thedata->mtpSaalMaxPd;
		StorageNew->mtpSaalMaxSscopCreditToPeer = thedata->mtpSaalMaxSscopCreditToPeer;
		StorageNew->mtpSaalMaxStat = thedata->mtpSaalMaxStat;
		StorageNew->mtpSaalN1 = thedata->mtpSaalN1;
		StorageNew->mtpSaalNniLayerManagementProvingState = thedata->mtpSaalNniLayerManagementProvingState;
		StorageNew->mtpSaalNniLayerManagementTimerNoCredit = thedata->mtpSaalNniLayerManagementTimerNoCredit;
		StorageNew->mtpSaalNniLayerManagementTimerRepeatSrec = thedata->mtpSaalNniLayerManagementTimerRepeatSrec;
		StorageNew->mtpSaalNniTimerT1 = thedata->mtpSaalNniTimerT1;
		StorageNew->mtpSaalNniTimerT2 = thedata->mtpSaalNniTimerT2;
		StorageNew->mtpSaalNniTimerT3 = thedata->mtpSaalNniTimerT3;
		StorageNew->mtpSaalSscopTimerCc = thedata->mtpSaalSscopTimerCc;
		StorageNew->mtpSaalSscopTimerIdle = thedata->mtpSaalSscopTimerIdle;
		StorageNew->mtpSaalSscopTimerKeepAlive = thedata->mtpSaalSscopTimerKeepAlive;
		StorageNew->mtpSaalSscopTimerNoResponse = thedata->mtpSaalSscopTimerNoResponse;
		StorageNew->mtpSaalSscopTimerPoll = thedata->mtpSaalSscopTimerPoll;
		StorageNew->mtpSaalTransmissionRateIntervalLower = thedata->mtpSaalTransmissionRateIntervalLower;
		StorageNew->mtpSaalTransmissionRateIntervalUpper = thedata->mtpSaalTransmissionRateIntervalUpper;
		StorageNew->mtpSaalEgressTransmissionRateIntervalLower = thedata->mtpSaalEgressTransmissionRateIntervalLower;
		StorageNew->mtpSaalEgressTransmissionRateIntervalUpper = thedata->mtpSaalEgressTransmissionRateIntervalUpper;
		StorageNew->mtpSaalPollAfterRetransmission = thedata->mtpSaalPollAfterRetransmission;
		StorageNew->mtpSaalRowStatus = thedata->mtpSaalRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSaalTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSaalTable_destroy(struct mtpSaalTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSaalTable_destroy(struct mtpSaalTable_data **thedata)
{
	struct mtpSaalTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSaalTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSaalTable_add(struct mtpSaalTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSaalTable table data set.
 *
 * Adds a table row structure to the mtpSaalTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSaalTable_add(struct mtpSaalTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSaalTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSdtProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
		header_complex_add_data(&mtpSaalTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSaalTable_del(struct mtpSaalTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSaalTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSaalTable_del(struct mtpSaalTable_data *thedata)
{
	struct mtpSaalTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSaalTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSaalTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSaalTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSaalTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSaalTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSaalTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSaalTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSaalTable_data *StorageTmp = mtpSaalTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSaalTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSdtProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalBufferRelease, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxCc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxNrp, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxPd, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalMaxStat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalNniTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerCc, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerIdle, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalSscopTimerPoll, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSaalRowStatus, &tmpsize);
	mtpSaalTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSaalTable(): store configuraiton file for mtpSaalTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSaalTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSaalTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSaalTable: storing data...  "));
	refresh_mtpSaalTable(1);
	(void) tmpsize;
	for (hcindex = mtpSaalTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSaalTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSaalTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalBufferRelease, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxCc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxNrp, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxInformationFieldLength, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxLengthSscopUuField, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxPd, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxSscopCreditToPeer, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalMaxStat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementProvingState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalNniTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerCc, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerIdle, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerKeepAlive, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerNoResponse, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalSscopTimerPoll, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalPollAfterRetransmission, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSaalRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM2paTable_data *mtpM2paTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM2paTable table.
 *
 * Creates a new mtpM2paTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM2paTable_data *
mtpM2paTable_create(void)
{
	struct mtpM2paTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2paTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpM2paTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		if ((StorageNew->mtpSdtProfileId = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSdtProfileIdLen = 0;
		StorageNew->mtpSdtProfileId[StorageNew->mtpSdtProfileIdLen] = 0;
		StorageNew->mtpM2paN1 = 1000;
		StorageNew->mtpM2paProving = TV_TRUE;
		StorageNew->mtpM2paManagementProvingState = MTPM2PAMANAGEMENTPROVINGSTATE_NEUTRAL;
		StorageNew->mtpM2paProvingAttempts = 4;
		StorageNew->mtpM2paSctpNoDelay = TV_TRUE;
		StorageNew->mtpM2paSctpMaxseg = 65536;
		StorageNew->mtpM2paSctpHeartbeatItvl = 60000;
		StorageNew->mtpM2paSctpHeartbeat = TV_TRUE;
		StorageNew->mtpM2paSctpRtoInitial = 3000;
		StorageNew->mtpM2paSctpRtoMin = 1000;
		StorageNew->mtpM2paSctpRtoMax = 60000;
		StorageNew->mtpM2paSctpPathMaxRetrans = 5;
		StorageNew->mtpM2paSctpCookieLife = 60000;
		StorageNew->mtpM2paSctpCookieInc = 1000;
		StorageNew->mtpM2paSctpMaxInitRetries = 8;
		StorageNew->mtpM2paSctpMaxBurst = 4;
		StorageNew->mtpM2paSctpAssocMaxRetrans = 10;
		StorageNew->mtpM2paSctpSackDelay = 200;
		StorageNew->mtpM2paSctpLifetime = 0;
		StorageNew->mtpM2paLoopDelayLower = 0;
		StorageNew->mtpM2paLoopDelayUpper = 600;
		StorageNew->mtpM2paTransmissionRateIntervalLower = 1544000;
		StorageNew->mtpM2paTransmissionRateIntervalUpper = 155000000;
		StorageNew->mtpM2paRowStatus = 0;
		StorageNew->mtpM2paRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpM2paTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpM2paTable_data *mtpM2paTable_duplicate(struct mtpM2paTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM2paTable_data *
mtpM2paTable_duplicate(struct mtpM2paTable_data *thedata)
{
	struct mtpM2paTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2paTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpM2paTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpM2paTable_id = thedata->mtpM2paTable_id;
		if (!(StorageNew->mtpSdtProfileId = malloc(thedata->mtpSdtProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSdtProfileId, thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
		StorageNew->mtpSdtProfileIdLen = thedata->mtpSdtProfileIdLen;
		StorageNew->mtpSdtProfileId[StorageNew->mtpSdtProfileIdLen] = 0;
		StorageNew->mtpM2paN1 = thedata->mtpM2paN1;
		StorageNew->mtpM2paProving = thedata->mtpM2paProving;
		StorageNew->mtpM2paManagementProvingState = thedata->mtpM2paManagementProvingState;
		StorageNew->mtpM2paProvingAttempts = thedata->mtpM2paProvingAttempts;
		StorageNew->mtpM2paSctpNoDelay = thedata->mtpM2paSctpNoDelay;
		StorageNew->mtpM2paSctpMaxseg = thedata->mtpM2paSctpMaxseg;
		StorageNew->mtpM2paSctpHeartbeatItvl = thedata->mtpM2paSctpHeartbeatItvl;
		StorageNew->mtpM2paSctpHeartbeat = thedata->mtpM2paSctpHeartbeat;
		StorageNew->mtpM2paSctpRtoInitial = thedata->mtpM2paSctpRtoInitial;
		StorageNew->mtpM2paSctpRtoMin = thedata->mtpM2paSctpRtoMin;
		StorageNew->mtpM2paSctpRtoMax = thedata->mtpM2paSctpRtoMax;
		StorageNew->mtpM2paSctpPathMaxRetrans = thedata->mtpM2paSctpPathMaxRetrans;
		StorageNew->mtpM2paSctpCookieLife = thedata->mtpM2paSctpCookieLife;
		StorageNew->mtpM2paSctpCookieInc = thedata->mtpM2paSctpCookieInc;
		StorageNew->mtpM2paSctpMaxInitRetries = thedata->mtpM2paSctpMaxInitRetries;
		StorageNew->mtpM2paSctpMaxBurst = thedata->mtpM2paSctpMaxBurst;
		StorageNew->mtpM2paSctpAssocMaxRetrans = thedata->mtpM2paSctpAssocMaxRetrans;
		StorageNew->mtpM2paSctpSackDelay = thedata->mtpM2paSctpSackDelay;
		StorageNew->mtpM2paSctpLifetime = thedata->mtpM2paSctpLifetime;
		StorageNew->mtpM2paLoopDelayLower = thedata->mtpM2paLoopDelayLower;
		StorageNew->mtpM2paLoopDelayUpper = thedata->mtpM2paLoopDelayUpper;
		StorageNew->mtpM2paTransmissionRateIntervalLower = thedata->mtpM2paTransmissionRateIntervalLower;
		StorageNew->mtpM2paTransmissionRateIntervalUpper = thedata->mtpM2paTransmissionRateIntervalUpper;
		StorageNew->mtpM2paRowStatus = thedata->mtpM2paRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM2paTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM2paTable_destroy(struct mtpM2paTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM2paTable_destroy(struct mtpM2paTable_data **thedata)
{
	struct mtpM2paTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpM2paTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProfileId);
		StorageDel->mtpSdtProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2paTable_add(struct mtpM2paTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM2paTable table data set.
 *
 * Adds a table row structure to the mtpM2paTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM2paTable_add(struct mtpM2paTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpM2paTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSdtProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdtProfileId, thedata->mtpSdtProfileIdLen);
		header_complex_add_data(&mtpM2paTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2paTable_del(struct mtpM2paTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpM2paTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM2paTable_del(struct mtpM2paTable_data *thedata)
{
	struct mtpM2paTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpM2paTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM2paTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM2paTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM2paTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM2paTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM2paTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM2paTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM2paTable_data *StorageTmp = mtpM2paTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpM2paTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSdtProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
	if (StorageTmp->mtpSdtProfileId == NULL) {
		config_perror("invalid specification for mtpSdtProfileId");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paProving, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paManagementProvingState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paProvingAttempts, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paSctpLifetime, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paLoopDelayUpper, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2paRowStatus, &tmpsize);
	mtpM2paTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpM2paTable(): store configuraiton file for mtpM2paTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2paTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM2paTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpM2paTable: storing data...  "));
	refresh_mtpM2paTable(1);
	(void) tmpsize;
	for (hcindex = mtpM2paTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2paTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM2paTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProfileId, &StorageTmp->mtpSdtProfileIdLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paN1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paProving, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paManagementProvingState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paProvingAttempts, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpNoDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxseg, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpHeartbeatItvl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paSctpHeartbeat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoInitial, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpRtoMax, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpPathMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieLife, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpCookieInc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxInitRetries, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpMaxBurst, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpAssocMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpSackDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paSctpLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paLoopDelayUpper, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalLower, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2paTransmissionRateIntervalUpper, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2paRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSdtTable_data *mtpSdtTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSdtTable table.
 *
 * Creates a new mtpSdtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSdtTable_data *
mtpSdtTable_create(void)
{
	struct mtpSdtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdtTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSdtTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSdtType = 0;
		StorageNew->mtpSdtAdministrativeState = MTPSDTADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpSdtOperationalState = MTPSDTOPERATIONALSTATE_DISABLED;
		StorageNew->mtpSdtUsageState = MTPSDTUSAGESTATE_IDLE;
		if (memdup((u_char **) &StorageNew->mtpSdtProceduralStatus, (u_char *) "\x80", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSdtProceduralStatusLen = 1;
		if (memdup((u_char **) &StorageNew->mtpSdtAvailabilityStatus, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSdtAvailabilityStatusLen = 2;
		if ((StorageNew->mtpSdtEquipmentPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSdtEquipmentPointerLen = 2;
		if ((StorageNew->mtpSdtName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSdtNameLen = 0;
		StorageNew->mtpSdtName[StorageNew->mtpSdtNameLen] = 0;
		StorageNew->mtpSdtStandbyStatus = 0;
		StorageNew->mtpSdtPrimaryId = 0;
		if ((StorageNew->mtpSdtProfilePointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSdtProfilePointerLen = 2;
		StorageNew->mtpSdtRowStatus = 0;
		StorageNew->mtpSdtRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSdtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSdtTable_data *mtpSdtTable_duplicate(struct mtpSdtTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSdtTable_data *
mtpSdtTable_duplicate(struct mtpSdtTable_data *thedata)
{
	struct mtpSdtTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdtTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSdtTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSdtTable_id = thedata->mtpSdtTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSdtId = thedata->mtpSdtId;
		StorageNew->mtpSdtType = thedata->mtpSdtType;
		StorageNew->mtpSdtAdministrativeState = thedata->mtpSdtAdministrativeState;
		StorageNew->mtpSdtOperationalState = thedata->mtpSdtOperationalState;
		StorageNew->mtpSdtUsageState = thedata->mtpSdtUsageState;
		if (!(StorageNew->mtpSdtProceduralStatus = malloc(thedata->mtpSdtProceduralStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSdtProceduralStatus, thedata->mtpSdtProceduralStatus, thedata->mtpSdtProceduralStatusLen);
		StorageNew->mtpSdtProceduralStatusLen = thedata->mtpSdtProceduralStatusLen;
		StorageNew->mtpSdtProceduralStatus[StorageNew->mtpSdtProceduralStatusLen] = 0;
		if (!(StorageNew->mtpSdtAvailabilityStatus = malloc(thedata->mtpSdtAvailabilityStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSdtAvailabilityStatus, thedata->mtpSdtAvailabilityStatus, thedata->mtpSdtAvailabilityStatusLen);
		StorageNew->mtpSdtAvailabilityStatusLen = thedata->mtpSdtAvailabilityStatusLen;
		StorageNew->mtpSdtAvailabilityStatus[StorageNew->mtpSdtAvailabilityStatusLen] = 0;
		if (!(StorageNew->mtpSdtEquipmentPointer = snmp_duplicate_objid(thedata->mtpSdtEquipmentPointer, thedata->mtpSdtEquipmentPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSdtEquipmentPointerLen = thedata->mtpSdtEquipmentPointerLen;
		if (!(StorageNew->mtpSdtName = malloc(thedata->mtpSdtNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSdtName, thedata->mtpSdtName, thedata->mtpSdtNameLen);
		StorageNew->mtpSdtNameLen = thedata->mtpSdtNameLen;
		StorageNew->mtpSdtName[StorageNew->mtpSdtNameLen] = 0;
		StorageNew->mtpSdtStandbyStatus = thedata->mtpSdtStandbyStatus;
		StorageNew->mtpSdtPrimaryId = thedata->mtpSdtPrimaryId;
		if (!(StorageNew->mtpSdtProfilePointer = snmp_duplicate_objid(thedata->mtpSdtProfilePointer, thedata->mtpSdtProfilePointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSdtProfilePointerLen = thedata->mtpSdtProfilePointerLen;
		StorageNew->mtpSdtRowStatus = thedata->mtpSdtRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSdtTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSdtTable_destroy(struct mtpSdtTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSdtTable_destroy(struct mtpSdtTable_data **thedata)
{
	struct mtpSdtTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSdtTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdtProceduralStatus);
		StorageDel->mtpSdtProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSdtAvailabilityStatus);
		StorageDel->mtpSdtAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSdtEquipmentPointer);
		StorageDel->mtpSdtEquipmentPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdtName);
		StorageDel->mtpSdtNameLen = 0;
		SNMP_FREE(StorageDel->mtpSdtProfilePointer);
		StorageDel->mtpSdtProfilePointerLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdtTable_add(struct mtpSdtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSdtTable table data set.
 *
 * Adds a table row structure to the mtpSdtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSdtTable_add(struct mtpSdtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSdtTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSdtId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdtId, sizeof(thedata->mtpSdtId));
		header_complex_add_data(&mtpSdtTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdtTable_del(struct mtpSdtTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSdtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSdtTable_del(struct mtpSdtTable_data *thedata)
{
	struct mtpSdtTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSdtTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSdtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSdtTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSdtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSdtTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSdtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSdtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSdtTable_data *StorageTmp = mtpSdtTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSdtTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtType, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdtProceduralStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtProceduralStatus, &StorageTmp->mtpSdtProceduralStatusLen);
	if (StorageTmp->mtpSdtProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSdtProceduralStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdtAvailabilityStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtAvailabilityStatus, &StorageTmp->mtpSdtAvailabilityStatusLen);
	if (StorageTmp->mtpSdtAvailabilityStatus == NULL) {
		config_perror("invalid specification for mtpSdtAvailabilityStatus");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdtEquipmentPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
	if (StorageTmp->mtpSdtEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdtEquipmentPointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdtName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
	if (StorageTmp->mtpSdtName == NULL) {
		config_perror("invalid specification for mtpSdtName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtStandbyStatus, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtPrimaryId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdtProfilePointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdtProfilePointer, &StorageTmp->mtpSdtProfilePointerLen);
	if (StorageTmp->mtpSdtProfilePointer == NULL) {
		config_perror("invalid specification for mtpSdtProfilePointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdtRowStatus, &tmpsize);
	mtpSdtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSdtTable(): store configuraiton file for mtpSdtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSdtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSdtTable: storing data...  "));
	refresh_mtpSdtTable(1);
	(void) tmpsize;
	for (hcindex = mtpSdtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSdtTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtType, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtProceduralStatus, &StorageTmp->mtpSdtProceduralStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtAvailabilityStatus, &StorageTmp->mtpSdtAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtEquipmentPointer, &StorageTmp->mtpSdtEquipmentPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdtName, &StorageTmp->mtpSdtNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtStandbyStatus, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtPrimaryId, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdtProfilePointer, &StorageTmp->mtpSdtProfilePointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdtRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSdlTable_data *mtpSdlTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSdlTable table.
 *
 * Creates a new mtpSdlTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSdlTable_data *
mtpSdlTable_create(void)
{
	struct mtpSdlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdlTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSdlTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpSdlType = 0;
		if (memdup((u_char **) &StorageNew->mtpSdlAdjPc, (u_char *) "\x00\x00\x00\x00", 4) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSdlAdjPcLen = 4;
		StorageNew->mtpSdlLoopDelay = 0;
		StorageNew->mtpSdlOperationalState = MTPSDLOPERATIONALSTATE_DISABLED;
		if ((StorageNew->mtpSdlEquipmentPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSdlEquipmentPointerLen = 2;
		StorageNew->mtpSdlCIC = 0;
		StorageNew->mtpSdlTransmissionRate = MTPSDLTRANSMISSIONRATE_KBITS64;
		if (memdup((u_char **) &StorageNew->mtpSdlStmChannel, (u_char *) "\x13", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSdlStmChannelLen = 1;
		if ((StorageNew->mtpSdlVcTTpPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSdlVcTTpPointerLen = 2;
		if ((StorageNew->mtpSdlSctpPointer = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpSdlSctpPointerLen = 2;
		if ((StorageNew->mtpSdlName = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpSdlNameLen = 0;
		StorageNew->mtpSdlName[StorageNew->mtpSdlNameLen] = 0;
		StorageNew->mtpSdlRowStatus = 0;
		StorageNew->mtpSdlRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSdlTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSdlTable_data *mtpSdlTable_duplicate(struct mtpSdlTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSdlTable_data *
mtpSdlTable_duplicate(struct mtpSdlTable_data *thedata)
{
	struct mtpSdlTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSdlTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSdlTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSdlTable_id = thedata->mtpSdlTable_id;
		StorageNew->mtpMsId = thedata->mtpMsId;
		StorageNew->mtpSpId = thedata->mtpSpId;
		if (!(StorageNew->mtpSdlId = malloc(thedata->mtpSdlIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSdlId, thedata->mtpSdlId, thedata->mtpSdlIdLen);
		StorageNew->mtpSdlIdLen = thedata->mtpSdlIdLen;
		StorageNew->mtpSdlId[StorageNew->mtpSdlIdLen] = 0;
		StorageNew->mtpSdlType = thedata->mtpSdlType;
		if (!(StorageNew->mtpSdlAdjPc = malloc(thedata->mtpSdlAdjPcLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSdlAdjPc, thedata->mtpSdlAdjPc, thedata->mtpSdlAdjPcLen);
		StorageNew->mtpSdlAdjPcLen = thedata->mtpSdlAdjPcLen;
		StorageNew->mtpSdlAdjPc[StorageNew->mtpSdlAdjPcLen] = 0;
		StorageNew->mtpSdlLoopDelay = thedata->mtpSdlLoopDelay;
		StorageNew->mtpSdlOperationalState = thedata->mtpSdlOperationalState;
		if (!(StorageNew->mtpSdlEquipmentPointer = snmp_duplicate_objid(thedata->mtpSdlEquipmentPointer, thedata->mtpSdlEquipmentPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSdlEquipmentPointerLen = thedata->mtpSdlEquipmentPointerLen;
		StorageNew->mtpSdlCIC = thedata->mtpSdlCIC;
		StorageNew->mtpSdlTransmissionRate = thedata->mtpSdlTransmissionRate;
		if (!(StorageNew->mtpSdlStmChannel = malloc(thedata->mtpSdlStmChannelLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSdlStmChannel, thedata->mtpSdlStmChannel, thedata->mtpSdlStmChannelLen);
		StorageNew->mtpSdlStmChannelLen = thedata->mtpSdlStmChannelLen;
		StorageNew->mtpSdlStmChannel[StorageNew->mtpSdlStmChannelLen] = 0;
		if (!(StorageNew->mtpSdlVcTTpPointer = snmp_duplicate_objid(thedata->mtpSdlVcTTpPointer, thedata->mtpSdlVcTTpPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSdlVcTTpPointerLen = thedata->mtpSdlVcTTpPointerLen;
		if (!(StorageNew->mtpSdlSctpPointer = snmp_duplicate_objid(thedata->mtpSdlSctpPointer, thedata->mtpSdlSctpPointerLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpSdlSctpPointerLen = thedata->mtpSdlSctpPointerLen;
		if (!(StorageNew->mtpSdlName = malloc(thedata->mtpSdlNameLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSdlName, thedata->mtpSdlName, thedata->mtpSdlNameLen);
		StorageNew->mtpSdlNameLen = thedata->mtpSdlNameLen;
		StorageNew->mtpSdlName[StorageNew->mtpSdlNameLen] = 0;
		StorageNew->mtpSdlRowStatus = thedata->mtpSdlRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSdlTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSdlTable_destroy(struct mtpSdlTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSdlTable_destroy(struct mtpSdlTable_data **thedata)
{
	struct mtpSdlTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSdlTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdlId);
		StorageDel->mtpSdlIdLen = 0;
		SNMP_FREE(StorageDel->mtpSdlAdjPc);
		StorageDel->mtpSdlAdjPcLen = 0;
		SNMP_FREE(StorageDel->mtpSdlEquipmentPointer);
		StorageDel->mtpSdlEquipmentPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdlStmChannel);
		StorageDel->mtpSdlStmChannelLen = 0;
		SNMP_FREE(StorageDel->mtpSdlVcTTpPointer);
		StorageDel->mtpSdlVcTTpPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdlSctpPointer);
		StorageDel->mtpSdlSctpPointerLen = 0;
		SNMP_FREE(StorageDel->mtpSdlName);
		StorageDel->mtpSdlNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdlTable_add(struct mtpSdlTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSdlTable table data set.
 *
 * Adds a table row structure to the mtpSdlTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSdlTable_add(struct mtpSdlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSdlTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpSdlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdlId, thedata->mtpSdlIdLen);
		header_complex_add_data(&mtpSdlTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSdlTable_del(struct mtpSdlTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSdlTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSdlTable_del(struct mtpSdlTable_data *thedata)
{
	struct mtpSdlTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSdlTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSdlTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSdlTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSdlTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSdlTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSdlTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSdlTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSdlTable_data *StorageTmp = mtpSdlTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSdlTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdlId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlId, &StorageTmp->mtpSdlIdLen);
	if (StorageTmp->mtpSdlId == NULL) {
		config_perror("invalid specification for mtpSdlId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlType, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdlAdjPc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
	if (StorageTmp->mtpSdlAdjPc == NULL) {
		config_perror("invalid specification for mtpSdlAdjPc");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdlLoopDelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlOperationalState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdlEquipmentPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
	if (StorageTmp->mtpSdlEquipmentPointer == NULL) {
		config_perror("invalid specification for mtpSdlEquipmentPointer");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlCIC, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlTransmissionRate, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdlStmChannel);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlStmChannel, &StorageTmp->mtpSdlStmChannelLen);
	if (StorageTmp->mtpSdlStmChannel == NULL) {
		config_perror("invalid specification for mtpSdlStmChannel");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdlVcTTpPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
	if (StorageTmp->mtpSdlVcTTpPointer == NULL) {
		config_perror("invalid specification for mtpSdlVcTTpPointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdlSctpPointer);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpSdlSctpPointer, &StorageTmp->mtpSdlSctpPointerLen);
	if (StorageTmp->mtpSdlSctpPointer == NULL) {
		config_perror("invalid specification for mtpSdlSctpPointer");
		return;
	}
	SNMP_FREE(StorageTmp->mtpSdlName);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
	if (StorageTmp->mtpSdlName == NULL) {
		config_perror("invalid specification for mtpSdlName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSdlRowStatus, &tmpsize);
	mtpSdlTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSdlTable(): store configuraiton file for mtpSdlTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSdlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSdlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSdlTable: storing data...  "));
	refresh_mtpSdlTable(1);
	(void) tmpsize;
	for (hcindex = mtpSdlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSdlTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSdlTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlId, &StorageTmp->mtpSdlIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlType, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlAdjPc, &StorageTmp->mtpSdlAdjPcLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdlLoopDelay, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlEquipmentPointer, &StorageTmp->mtpSdlEquipmentPointerLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlCIC, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlTransmissionRate, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlStmChannel, &StorageTmp->mtpSdlStmChannelLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlVcTTpPointer, &StorageTmp->mtpSdlVcTTpPointerLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpSdlSctpPointer, &StorageTmp->mtpSdlSctpPointerLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlName, &StorageTmp->mtpSdlNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSdlRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSctpProfileTable_data *mtpSctpProfileTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSctpProfileTable table.
 *
 * Creates a new mtpSctpProfileTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSctpProfileTable_data *
mtpSctpProfileTable_create(void)
{
	struct mtpSctpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSctpProfileTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpProfileNoDelay = TV_TRUE;
		StorageNew->mtpSctpProfileMaxseg = 65536;
		StorageNew->mtpSctpProfileHeartbeatItvl = 60000;
		StorageNew->mtpSctpProfileHeartbeat = TV_TRUE;
		StorageNew->mtpSctpProfileRtoInitial = 3000;
		StorageNew->mtpSctpProfileRtoMin = 1000;
		StorageNew->mtpSctpProfileRtoMax = 60000;
		StorageNew->mtpSctpProfilePathMaxRetrans = 5;
		StorageNew->mtpSctpProfileCookieLife = 60000;
		StorageNew->mtpSctpProfileCookieInc = 1000;
		StorageNew->mtpSctpProfileMaxInitRetries = 8;
		StorageNew->mtpSctpProfileMaxBurst = 4;
		StorageNew->mtpSctpProfileAssocMaxRetrans = 10;
		StorageNew->mtpSctpProfileSackDelay = 200;
		StorageNew->mtpSctpProfileLifetime = 0;
		StorageNew->mtpSctpProfileMinOstreams = 2;
		StorageNew->mtpSctpProfileMaxIstreams = 4096;
		StorageNew->mtpSctpProfileRowStatus = 0;
		StorageNew->mtpSctpProfileRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSctpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSctpProfileTable_data *mtpSctpProfileTable_duplicate(struct mtpSctpProfileTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSctpProfileTable_data *
mtpSctpProfileTable_duplicate(struct mtpSctpProfileTable_data *thedata)
{
	struct mtpSctpProfileTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpProfileTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSctpProfileTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSctpProfileTable_id = thedata->mtpSctpProfileTable_id;
		if (!(StorageNew->mtpSctpProfileId = malloc(thedata->mtpSctpProfileIdLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSctpProfileId, thedata->mtpSctpProfileId, thedata->mtpSctpProfileIdLen);
		StorageNew->mtpSctpProfileIdLen = thedata->mtpSctpProfileIdLen;
		StorageNew->mtpSctpProfileId[StorageNew->mtpSctpProfileIdLen] = 0;
		StorageNew->mtpSctpProfileNoDelay = thedata->mtpSctpProfileNoDelay;
		StorageNew->mtpSctpProfileMaxseg = thedata->mtpSctpProfileMaxseg;
		StorageNew->mtpSctpProfileHeartbeatItvl = thedata->mtpSctpProfileHeartbeatItvl;
		StorageNew->mtpSctpProfileHeartbeat = thedata->mtpSctpProfileHeartbeat;
		StorageNew->mtpSctpProfileRtoInitial = thedata->mtpSctpProfileRtoInitial;
		StorageNew->mtpSctpProfileRtoMin = thedata->mtpSctpProfileRtoMin;
		StorageNew->mtpSctpProfileRtoMax = thedata->mtpSctpProfileRtoMax;
		StorageNew->mtpSctpProfilePathMaxRetrans = thedata->mtpSctpProfilePathMaxRetrans;
		StorageNew->mtpSctpProfileCookieLife = thedata->mtpSctpProfileCookieLife;
		StorageNew->mtpSctpProfileCookieInc = thedata->mtpSctpProfileCookieInc;
		StorageNew->mtpSctpProfileMaxInitRetries = thedata->mtpSctpProfileMaxInitRetries;
		StorageNew->mtpSctpProfileMaxBurst = thedata->mtpSctpProfileMaxBurst;
		StorageNew->mtpSctpProfileAssocMaxRetrans = thedata->mtpSctpProfileAssocMaxRetrans;
		StorageNew->mtpSctpProfileSackDelay = thedata->mtpSctpProfileSackDelay;
		StorageNew->mtpSctpProfileLifetime = thedata->mtpSctpProfileLifetime;
		StorageNew->mtpSctpProfileMinOstreams = thedata->mtpSctpProfileMinOstreams;
		StorageNew->mtpSctpProfileMaxIstreams = thedata->mtpSctpProfileMaxIstreams;
		StorageNew->mtpSctpProfileRowStatus = thedata->mtpSctpProfileRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSctpProfileTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSctpProfileTable_destroy(struct mtpSctpProfileTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSctpProfileTable_destroy(struct mtpSctpProfileTable_data **thedata)
{
	struct mtpSctpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSctpProfileTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSctpProfileId);
		StorageDel->mtpSctpProfileIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpProfileTable_add(struct mtpSctpProfileTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSctpProfileTable table data set.
 *
 * Adds a table row structure to the mtpSctpProfileTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSctpProfileTable_add(struct mtpSctpProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSctpProfileTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSctpProfileId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSctpProfileId, thedata->mtpSctpProfileIdLen);
		header_complex_add_data(&mtpSctpProfileTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpProfileTable_del(struct mtpSctpProfileTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSctpProfileTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSctpProfileTable_del(struct mtpSctpProfileTable_data *thedata)
{
	struct mtpSctpProfileTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSctpProfileTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSctpProfileTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSctpProfileTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSctpProfileTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSctpProfileTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSctpProfileTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSctpProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSctpProfileTable_data *StorageTmp = mtpSctpProfileTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSctpProfileTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	SNMP_FREE(StorageTmp->mtpSctpProfileId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSctpProfileId, &StorageTmp->mtpSctpProfileIdLen);
	if (StorageTmp->mtpSctpProfileId == NULL) {
		config_perror("invalid specification for mtpSctpProfileId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpProfileNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileMaxseg, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpProfileHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileRtoMin, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfilePathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileCookieLife, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileSackDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProfileLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpProfileMinOstreams, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpProfileMaxIstreams, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpProfileRowStatus, &tmpsize);
	mtpSctpProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSctpProfileTable(): store configuraiton file for mtpSctpProfileTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSctpProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSctpProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSctpProfileTable: storing data...  "));
	refresh_mtpSctpProfileTable(1);
	(void) tmpsize;
	for (hcindex = mtpSctpProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSctpProfileTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSctpProfileTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSctpProfileId, &StorageTmp->mtpSctpProfileIdLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpProfileNoDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileMaxseg, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileHeartbeatItvl, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpProfileHeartbeat, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileRtoInitial, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileRtoMax, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfilePathMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileCookieLife, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileCookieInc, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileMaxInitRetries, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileMaxBurst, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileAssocMaxRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileSackDelay, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProfileLifetime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpProfileMinOstreams, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpProfileMaxIstreams, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpProfileRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSctpTable_data *mtpSctpTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSctpTable table.
 *
 * Creates a new mtpSctpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSctpTable_data *
mtpSctpTable_create(void)
{
	struct mtpSctpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSctpTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpAdministrativeState = MTPSCTPADMINISTRATIVESTATE_LOCKED;
		StorageNew->mtpSctpOperationalState = MTPSCTPOPERATIONALSTATE_DISABLED;
		StorageNew->mtpSctpUsageState = MTPSCTPUSAGESTATE_IDLE;
		if (memdup((u_char **) &StorageNew->mtpSctpProceduralStatus, (u_char *) "\x80", 1) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpSctpProceduralStatusLen = 1;
		StorageNew->mtpSctpLocalPort = 0;
		StorageNew->mtpSctpRemotePort = 0;
		if ((StorageNew->mtpSctpProfile = (uint8_t *) strdup("")) == NULL)
			goto nomem;
		StorageNew->mtpSctpProfileLen = strlen("");
		StorageNew->mtpSctpProtocolPayloadId = 0;
		StorageNew->mtpSctpRowStatus = 0;
		StorageNew->mtpSctpRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSctpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSctpTable_data *mtpSctpTable_duplicate(struct mtpSctpTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSctpTable_data *
mtpSctpTable_duplicate(struct mtpSctpTable_data *thedata)
{
	struct mtpSctpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSctpTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSctpTable_id = thedata->mtpSctpTable_id;
		StorageNew->mtpSctpId = thedata->mtpSctpId;
		StorageNew->mtpSctpAdministrativeState = thedata->mtpSctpAdministrativeState;
		StorageNew->mtpSctpOperationalState = thedata->mtpSctpOperationalState;
		StorageNew->mtpSctpUsageState = thedata->mtpSctpUsageState;
		if (!(StorageNew->mtpSctpProceduralStatus = malloc(thedata->mtpSctpProceduralStatusLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSctpProceduralStatus, thedata->mtpSctpProceduralStatus, thedata->mtpSctpProceduralStatusLen);
		StorageNew->mtpSctpProceduralStatusLen = thedata->mtpSctpProceduralStatusLen;
		StorageNew->mtpSctpProceduralStatus[StorageNew->mtpSctpProceduralStatusLen] = 0;
		StorageNew->mtpSctpLocalPort = thedata->mtpSctpLocalPort;
		StorageNew->mtpSctpRemotePort = thedata->mtpSctpRemotePort;
		if (!(StorageNew->mtpSctpProfile = malloc(thedata->mtpSctpProfileLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSctpProfile, thedata->mtpSctpProfile, thedata->mtpSctpProfileLen);
		StorageNew->mtpSctpProfileLen = thedata->mtpSctpProfileLen;
		StorageNew->mtpSctpProfile[StorageNew->mtpSctpProfileLen] = 0;
		StorageNew->mtpSctpProtocolPayloadId = thedata->mtpSctpProtocolPayloadId;
		StorageNew->mtpSctpRowStatus = thedata->mtpSctpRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSctpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSctpTable_destroy(struct mtpSctpTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSctpTable_destroy(struct mtpSctpTable_data **thedata)
{
	struct mtpSctpTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSctpTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSctpProceduralStatus);
		StorageDel->mtpSctpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->mtpSctpProfile);
		StorageDel->mtpSctpProfileLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpTable_add(struct mtpSctpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSctpTable table data set.
 *
 * Adds a table row structure to the mtpSctpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSctpTable_add(struct mtpSctpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSctpTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSctpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
		header_complex_add_data(&mtpSctpTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpTable_del(struct mtpSctpTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSctpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSctpTable_del(struct mtpSctpTable_data *thedata)
{
	struct mtpSctpTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSctpTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSctpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSctpTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSctpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSctpTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSctpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSctpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSctpTable_data *StorageTmp = mtpSctpTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSctpTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpUsageState, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSctpProceduralStatus);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSctpProceduralStatus, &StorageTmp->mtpSctpProceduralStatusLen);
	if (StorageTmp->mtpSctpProceduralStatus == NULL) {
		config_perror("invalid specification for mtpSctpProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpLocalPort, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpRemotePort, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSctpProfile);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSctpProfile, &StorageTmp->mtpSctpProfileLen);
	if (StorageTmp->mtpSctpProfile == NULL) {
		config_perror("invalid specification for mtpSctpProfile");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpProtocolPayloadId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpRowStatus, &tmpsize);
	mtpSctpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSctpTable(): store configuraiton file for mtpSctpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSctpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSctpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSctpTable: storing data...  "));
	refresh_mtpSctpTable(1);
	(void) tmpsize;
	for (hcindex = mtpSctpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSctpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSctpTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSctpProceduralStatus, &StorageTmp->mtpSctpProceduralStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpLocalPort, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpRemotePort, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSctpProfile, &StorageTmp->mtpSctpProfileLen);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpProtocolPayloadId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSctpLocalTable_data *mtpSctpLocalTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSctpLocalTable table.
 *
 * Creates a new mtpSctpLocalTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSctpLocalTable_data *
mtpSctpLocalTable_create(void)
{
	struct mtpSctpLocalTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpLocalTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSctpLocalTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpSctpLocalAddress = (u_char *) "\x00\x00\x00\x00";
		StorageNew->mtpSctpLocalAddressLen = 4;
		StorageNew->mtpSctpLocalRowStatus = 0;
		StorageNew->mtpSctpLocalRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSctpLocalTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSctpLocalTable_data *mtpSctpLocalTable_duplicate(struct mtpSctpLocalTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSctpLocalTable_data *
mtpSctpLocalTable_duplicate(struct mtpSctpLocalTable_data *thedata)
{
	struct mtpSctpLocalTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpLocalTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSctpLocalTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSctpLocalTable_id = thedata->mtpSctpLocalTable_id;
		StorageNew->mtpSctpId = thedata->mtpSctpId;
		StorageNew->mtpSctpLocalId = thedata->mtpSctpLocalId;
		if (!(StorageNew->mtpSctpLocalAddress = malloc(thedata->mtpSctpLocalAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSctpLocalAddress, thedata->mtpSctpLocalAddress, thedata->mtpSctpLocalAddressLen);
		StorageNew->mtpSctpLocalAddressLen = thedata->mtpSctpLocalAddressLen;
		StorageNew->mtpSctpLocalAddress[StorageNew->mtpSctpLocalAddressLen] = 0;
		StorageNew->mtpSctpLocalRowStatus = thedata->mtpSctpLocalRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSctpLocalTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSctpLocalTable_destroy(struct mtpSctpLocalTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSctpLocalTable_destroy(struct mtpSctpLocalTable_data **thedata)
{
	struct mtpSctpLocalTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSctpLocalTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpLocalTable_add(struct mtpSctpLocalTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSctpLocalTable table data set.
 *
 * Adds a table row structure to the mtpSctpLocalTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSctpLocalTable_add(struct mtpSctpLocalTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSctpLocalTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSctpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
		/* mtpSctpLocalId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpLocalId, sizeof(thedata->mtpSctpLocalId));
		header_complex_add_data(&mtpSctpLocalTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpLocalTable_del(struct mtpSctpLocalTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSctpLocalTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSctpLocalTable_del(struct mtpSctpLocalTable_data *thedata)
{
	struct mtpSctpLocalTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSctpLocalTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSctpLocalTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSctpLocalTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSctpLocalTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSctpLocalTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSctpLocalTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSctpLocalTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSctpLocalTable_data *StorageTmp = mtpSctpLocalTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSctpLocalTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpLocalId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSctpLocalAddress);
	line = read_config_read_data(ASN_IPADDRESS, line, &StorageTmp->mtpSctpLocalAddress, &StorageTmp->mtpSctpLocalAddressLen);
	if (StorageTmp->mtpSctpLocalAddress == NULL) {
		config_perror("invalid specification for mtpSctpLocalAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpLocalRowStatus, &tmpsize);
	mtpSctpLocalTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSctpLocalTable(): store configuraiton file for mtpSctpLocalTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSctpLocalTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSctpLocalTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSctpLocalTable: storing data...  "));
	refresh_mtpSctpLocalTable(1);
	(void) tmpsize;
	for (hcindex = mtpSctpLocalTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSctpLocalTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSctpLocalTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpLocalId, &tmpsize);
			cptr = read_config_store_data(ASN_IPADDRESS, cptr, &StorageTmp->mtpSctpLocalAddress, &StorageTmp->mtpSctpLocalAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpLocalRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpSctpRemoteTable_data *mtpSctpRemoteTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpSctpRemoteTable table.
 *
 * Creates a new mtpSctpRemoteTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpSctpRemoteTable_data *
mtpSctpRemoteTable_create(void)
{
	struct mtpSctpRemoteTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpRemoteTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSctpRemoteTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpSctpRemoteAddress = (u_char *) "\x00\x00\x00\x00";
		StorageNew->mtpSctpRemoteAddressLen = 4;
		StorageNew->mtpSctpRemoteRowStatus = 0;
		StorageNew->mtpSctpRemoteRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpSctpRemoteTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpSctpRemoteTable_data *mtpSctpRemoteTable_duplicate(struct mtpSctpRemoteTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpSctpRemoteTable_data *
mtpSctpRemoteTable_duplicate(struct mtpSctpRemoteTable_data *thedata)
{
	struct mtpSctpRemoteTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpSctpRemoteTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpSctpRemoteTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpSctpRemoteTable_id = thedata->mtpSctpRemoteTable_id;
		StorageNew->mtpSctpId = thedata->mtpSctpId;
		StorageNew->mtpSctpRemoteId = thedata->mtpSctpRemoteId;
		if (!(StorageNew->mtpSctpRemoteAddress = malloc(thedata->mtpSctpRemoteAddressLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpSctpRemoteAddress, thedata->mtpSctpRemoteAddress, thedata->mtpSctpRemoteAddressLen);
		StorageNew->mtpSctpRemoteAddressLen = thedata->mtpSctpRemoteAddressLen;
		StorageNew->mtpSctpRemoteAddress[StorageNew->mtpSctpRemoteAddressLen] = 0;
		StorageNew->mtpSctpRemoteRowStatus = thedata->mtpSctpRemoteRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpSctpRemoteTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpSctpRemoteTable_destroy(struct mtpSctpRemoteTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpSctpRemoteTable_destroy(struct mtpSctpRemoteTable_data **thedata)
{
	struct mtpSctpRemoteTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSctpRemoteTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpRemoteTable_add(struct mtpSctpRemoteTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpSctpRemoteTable table data set.
 *
 * Adds a table row structure to the mtpSctpRemoteTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpSctpRemoteTable_add(struct mtpSctpRemoteTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpSctpRemoteTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSctpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
		/* mtpSctpRemoteId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpRemoteId, sizeof(thedata->mtpSctpRemoteId));
		header_complex_add_data(&mtpSctpRemoteTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpSctpRemoteTable_del(struct mtpSctpRemoteTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpSctpRemoteTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpSctpRemoteTable_del(struct mtpSctpRemoteTable_data *thedata)
{
	struct mtpSctpRemoteTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpSctpRemoteTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpSctpRemoteTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpSctpRemoteTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpSctpRemoteTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpSctpRemoteTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpSctpRemoteTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpSctpRemoteTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpSctpRemoteTable_data *StorageTmp = mtpSctpRemoteTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpSctpRemoteTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpRemoteId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSctpRemoteAddress);
	line = read_config_read_data(ASN_IPADDRESS, line, &StorageTmp->mtpSctpRemoteAddress, &StorageTmp->mtpSctpRemoteAddressLen);
	if (StorageTmp->mtpSctpRemoteAddress == NULL) {
		config_perror("invalid specification for mtpSctpRemoteAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSctpRemoteRowStatus, &tmpsize);
	mtpSctpRemoteTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpSctpRemoteTable(): store configuraiton file for mtpSctpRemoteTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpSctpRemoteTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpSctpRemoteTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpSctpRemoteTable: storing data...  "));
	refresh_mtpSctpRemoteTable(1);
	(void) tmpsize;
	for (hcindex = mtpSctpRemoteTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpSctpRemoteTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpSctpRemoteTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpRemoteId, &tmpsize);
			cptr = read_config_store_data(ASN_IPADDRESS, cptr, &StorageTmp->mtpSctpRemoteAddress, &StorageTmp->mtpSctpRemoteAddressLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSctpRemoteRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM2uaAspTable_data *mtpM2uaAspTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM2uaAspTable table.
 *
 * Creates a new mtpM2uaAspTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM2uaAspTable_data *
mtpM2uaAspTable_create(void)
{
	struct mtpM2uaAspTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2uaAspTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpM2uaAspTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpM2uaAspState = MTPM2UAASPSTATE_DOWN;
		StorageNew->mtpM2uaAspId = 0;
		if (memdup((u_char **) &StorageNew->mtpM2uaAspCapabilities, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpM2uaAspCapabilitiesLen = 2;
		{
			static oid tmpoid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 10, 2, 1 };
			if ((StorageNew->mtpM2uaAspSgVersion = snmp_duplicate_objid(tmpoid, 11)) == NULL)
				goto nomem;
			StorageNew->mtpM2uaAspSgVersionLen = 11;
		}
		if (memdup((u_char **) &StorageNew->mtpM2uaAspSgOptions, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpM2uaAspSgOptionsLen = 2;
		StorageNew->mtpM2uaAspSgRegistrationPolicy = 0;
		StorageNew->mtpM2uaAspSgAspIdPolicy = MTPM2UAASPSGASPIDPOLICY_UNKNOWN;
		StorageNew->mtpM2uaAspAssociationPolicy = MTPM2UAASPASSOCIATIONPOLICY_UNKNOWN;
		StorageNew->mtpM2uaAspProtocolPayloadId = 0;
		StorageNew->mtpM2uaAspRowStatus = 0;
		StorageNew->mtpM2uaAspRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpM2uaAspTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpM2uaAspTable_data *mtpM2uaAspTable_duplicate(struct mtpM2uaAspTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM2uaAspTable_data *
mtpM2uaAspTable_duplicate(struct mtpM2uaAspTable_data *thedata)
{
	struct mtpM2uaAspTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2uaAspTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpM2uaAspTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpM2uaAspTable_id = thedata->mtpM2uaAspTable_id;
		StorageNew->mtpSctpId = thedata->mtpSctpId;
		StorageNew->mtpM2uaAspState = thedata->mtpM2uaAspState;
		StorageNew->mtpM2uaAspId = thedata->mtpM2uaAspId;
		if (!(StorageNew->mtpM2uaAspCapabilities = malloc(thedata->mtpM2uaAspCapabilitiesLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpM2uaAspCapabilities, thedata->mtpM2uaAspCapabilities, thedata->mtpM2uaAspCapabilitiesLen);
		StorageNew->mtpM2uaAspCapabilitiesLen = thedata->mtpM2uaAspCapabilitiesLen;
		StorageNew->mtpM2uaAspCapabilities[StorageNew->mtpM2uaAspCapabilitiesLen] = 0;
		if (!(StorageNew->mtpM2uaAspSgVersion = snmp_duplicate_objid(thedata->mtpM2uaAspSgVersion, thedata->mtpM2uaAspSgVersionLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpM2uaAspSgVersionLen = thedata->mtpM2uaAspSgVersionLen;
		if (!(StorageNew->mtpM2uaAspSgOptions = malloc(thedata->mtpM2uaAspSgOptionsLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpM2uaAspSgOptions, thedata->mtpM2uaAspSgOptions, thedata->mtpM2uaAspSgOptionsLen);
		StorageNew->mtpM2uaAspSgOptionsLen = thedata->mtpM2uaAspSgOptionsLen;
		StorageNew->mtpM2uaAspSgOptions[StorageNew->mtpM2uaAspSgOptionsLen] = 0;
		StorageNew->mtpM2uaAspSgRegistrationPolicy = thedata->mtpM2uaAspSgRegistrationPolicy;
		StorageNew->mtpM2uaAspSgAspIdPolicy = thedata->mtpM2uaAspSgAspIdPolicy;
		StorageNew->mtpM2uaAspAssociationPolicy = thedata->mtpM2uaAspAssociationPolicy;
		StorageNew->mtpM2uaAspProtocolPayloadId = thedata->mtpM2uaAspProtocolPayloadId;
		StorageNew->mtpM2uaAspRowStatus = thedata->mtpM2uaAspRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM2uaAspTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM2uaAspTable_destroy(struct mtpM2uaAspTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM2uaAspTable_destroy(struct mtpM2uaAspTable_data **thedata)
{
	struct mtpM2uaAspTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpM2uaAspTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpM2uaAspCapabilities);
		StorageDel->mtpM2uaAspCapabilitiesLen = 0;
		SNMP_FREE(StorageDel->mtpM2uaAspSgVersion);
		StorageDel->mtpM2uaAspSgVersionLen = 0;
		SNMP_FREE(StorageDel->mtpM2uaAspSgOptions);
		StorageDel->mtpM2uaAspSgOptionsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2uaAspTable_add(struct mtpM2uaAspTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM2uaAspTable table data set.
 *
 * Adds a table row structure to the mtpM2uaAspTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM2uaAspTable_add(struct mtpM2uaAspTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpM2uaAspTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSctpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
		header_complex_add_data(&mtpM2uaAspTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2uaAspTable_del(struct mtpM2uaAspTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpM2uaAspTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM2uaAspTable_del(struct mtpM2uaAspTable_data *thedata)
{
	struct mtpM2uaAspTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpM2uaAspTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM2uaAspTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM2uaAspTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM2uaAspTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM2uaAspTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM2uaAspTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM2uaAspTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM2uaAspTable_data *StorageTmp = mtpM2uaAspTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpM2uaAspTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2uaAspId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpM2uaAspCapabilities);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpM2uaAspCapabilities, &StorageTmp->mtpM2uaAspCapabilitiesLen);
	if (StorageTmp->mtpM2uaAspCapabilities == NULL) {
		config_perror("invalid specification for mtpM2uaAspCapabilities");
		return;
	}
	SNMP_FREE(StorageTmp->mtpM2uaAspSgVersion);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpM2uaAspSgVersion, &StorageTmp->mtpM2uaAspSgVersionLen);
	if (StorageTmp->mtpM2uaAspSgVersion == NULL) {
		config_perror("invalid specification for mtpM2uaAspSgVersion");
		return;
	}
	SNMP_FREE(StorageTmp->mtpM2uaAspSgOptions);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpM2uaAspSgOptions, &StorageTmp->mtpM2uaAspSgOptionsLen);
	if (StorageTmp->mtpM2uaAspSgOptions == NULL) {
		config_perror("invalid specification for mtpM2uaAspSgOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspSgRegistrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspSgAspIdPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspAssociationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspProtocolPayloadId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAspRowStatus, &tmpsize);
	mtpM2uaAspTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpM2uaAspTable(): store configuraiton file for mtpM2uaAspTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2uaAspTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM2uaAspTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpM2uaAspTable: storing data...  "));
	refresh_mtpM2uaAspTable(1);
	(void) tmpsize;
	for (hcindex = mtpM2uaAspTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2uaAspTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM2uaAspTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2uaAspId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpM2uaAspCapabilities, &StorageTmp->mtpM2uaAspCapabilitiesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpM2uaAspSgVersion, &StorageTmp->mtpM2uaAspSgVersionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpM2uaAspSgOptions, &StorageTmp->mtpM2uaAspSgOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspSgRegistrationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspSgAspIdPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspAssociationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspProtocolPayloadId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAspRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM2uaAsTable_data *mtpM2uaAsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM2uaAsTable table.
 *
 * Creates a new mtpM2uaAsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM2uaAsTable_data *
mtpM2uaAsTable_create(void)
{
	struct mtpM2uaAsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2uaAsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpM2uaAsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpM3uaAsId = 0;
		StorageNew->mtpM2uaAsId = 0;
		StorageNew->mtpM2uaAsState = MTPM2UAASSTATE_DOWN;
		StorageNew->mtpM2uaAsInterfaceIdentifier = 0;
		if ((StorageNew->mtpM2uaInterfaceIdentifierText = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpM2uaInterfaceIdentifierTextLen = 0;
		StorageNew->mtpM2uaInterfaceIdentifierText[StorageNew->mtpM2uaInterfaceIdentifierTextLen] = 0;
		StorageNew->mtpM2uaAsSDTI = 0;
		{
			static oid tmpoid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 10, 1, 1 };
			if ((StorageNew->mtpM2uaAsTrafficMode = snmp_duplicate_objid(tmpoid, 11)) == NULL)
				goto nomem;
			StorageNew->mtpM2uaAsTrafficModeLen = 11;
		}
		StorageNew->mtpM2uaAsRowStatus = 0;
		StorageNew->mtpM2uaAsRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpM2uaAsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpM2uaAsTable_data *mtpM2uaAsTable_duplicate(struct mtpM2uaAsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM2uaAsTable_data *
mtpM2uaAsTable_duplicate(struct mtpM2uaAsTable_data *thedata)
{
	struct mtpM2uaAsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM2uaAsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpM2uaAsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpM2uaAsTable_id = thedata->mtpM2uaAsTable_id;
		StorageNew->mtpSctpId = thedata->mtpSctpId;
		StorageNew->mtpM3uaAsId = thedata->mtpM3uaAsId;
		StorageNew->mtpM2uaAsId = thedata->mtpM2uaAsId;
		StorageNew->mtpM2uaAsState = thedata->mtpM2uaAsState;
		StorageNew->mtpM2uaAsInterfaceIdentifier = thedata->mtpM2uaAsInterfaceIdentifier;
		if (!(StorageNew->mtpM2uaInterfaceIdentifierText = malloc(thedata->mtpM2uaInterfaceIdentifierTextLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpM2uaInterfaceIdentifierText, thedata->mtpM2uaInterfaceIdentifierText, thedata->mtpM2uaInterfaceIdentifierTextLen);
		StorageNew->mtpM2uaInterfaceIdentifierTextLen = thedata->mtpM2uaInterfaceIdentifierTextLen;
		StorageNew->mtpM2uaInterfaceIdentifierText[StorageNew->mtpM2uaInterfaceIdentifierTextLen] = 0;
		StorageNew->mtpM2uaAsSDTI = thedata->mtpM2uaAsSDTI;
		if (!(StorageNew->mtpM2uaAsTrafficMode = snmp_duplicate_objid(thedata->mtpM2uaAsTrafficMode, thedata->mtpM2uaAsTrafficModeLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpM2uaAsTrafficModeLen = thedata->mtpM2uaAsTrafficModeLen;
		StorageNew->mtpM2uaAsRowStatus = thedata->mtpM2uaAsRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM2uaAsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM2uaAsTable_destroy(struct mtpM2uaAsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM2uaAsTable_destroy(struct mtpM2uaAsTable_data **thedata)
{
	struct mtpM2uaAsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpM2uaAsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpM2uaInterfaceIdentifierText);
		StorageDel->mtpM2uaInterfaceIdentifierTextLen = 0;
		SNMP_FREE(StorageDel->mtpM2uaAsTrafficMode);
		StorageDel->mtpM2uaAsTrafficModeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2uaAsTable_add(struct mtpM2uaAsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM2uaAsTable table data set.
 *
 * Adds a table row structure to the mtpM2uaAsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM2uaAsTable_add(struct mtpM2uaAsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpM2uaAsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSctpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
		/* mtpM3uaAsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpM3uaAsId, sizeof(thedata->mtpM3uaAsId));
		header_complex_add_data(&mtpM2uaAsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM2uaAsTable_del(struct mtpM2uaAsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpM2uaAsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM2uaAsTable_del(struct mtpM2uaAsTable_data *thedata)
{
	struct mtpM2uaAsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpM2uaAsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM2uaAsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM2uaAsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM2uaAsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM2uaAsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM2uaAsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM2uaAsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM2uaAsTable_data *StorageTmp = mtpM2uaAsTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpM2uaAsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM3uaAsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2uaAsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAsState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM2uaAsInterfaceIdentifier, &tmpsize);
	SNMP_FREE(StorageTmp->mtpM2uaInterfaceIdentifierText);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpM2uaInterfaceIdentifierText, &StorageTmp->mtpM2uaInterfaceIdentifierTextLen);
	if (StorageTmp->mtpM2uaInterfaceIdentifierText == NULL) {
		config_perror("invalid specification for mtpM2uaInterfaceIdentifierText");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAsSDTI, &tmpsize);
	SNMP_FREE(StorageTmp->mtpM2uaAsTrafficMode);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpM2uaAsTrafficMode, &StorageTmp->mtpM2uaAsTrafficModeLen);
	if (StorageTmp->mtpM2uaAsTrafficMode == NULL) {
		config_perror("invalid specification for mtpM2uaAsTrafficMode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM2uaAsRowStatus, &tmpsize);
	mtpM2uaAsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpM2uaAsTable(): store configuraiton file for mtpM2uaAsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM2uaAsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM2uaAsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpM2uaAsTable: storing data...  "));
	refresh_mtpM2uaAsTable(1);
	(void) tmpsize;
	for (hcindex = mtpM2uaAsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM2uaAsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM2uaAsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM3uaAsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2uaAsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAsState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM2uaAsInterfaceIdentifier, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpM2uaInterfaceIdentifierText, &StorageTmp->mtpM2uaInterfaceIdentifierTextLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAsSDTI, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpM2uaAsTrafficMode, &StorageTmp->mtpM2uaAsTrafficModeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM2uaAsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM3uaAspTable_data *mtpM3uaAspTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM3uaAspTable table.
 *
 * Creates a new mtpM3uaAspTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM3uaAspTable_data *
mtpM3uaAspTable_create(void)
{
	struct mtpM3uaAspTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM3uaAspTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpM3uaAspTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpM3uaAspState = MTPM3UAASPSTATE_DOWN;
		StorageNew->mtpM3uaAsType = MTPM3UAASTYPE_IPSP;
		StorageNew->mtpM3uaAspId = 0;
		if (memdup((u_char **) &StorageNew->mtpM3uaAspCapabilities, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpM3uaAspCapabilitiesLen = 2;
		{
			static oid tmpoid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 10, 2, 1 };
			if ((StorageNew->mtpM3uaAspSgVersion = snmp_duplicate_objid(tmpoid, 11)) == NULL)
				goto nomem;
			StorageNew->mtpM3uaAspSgVersionLen = 11;
		}
		if (memdup((u_char **) &StorageNew->mtpM3uaAspSgOptions, (u_char *) "\x00\x00", 2) != SNMPERR_SUCCESS)
			goto nomem;
		StorageNew->mtpM3uaAspSgOptionsLen = 2;
		StorageNew->mtpM3uaAspSgRegistrationPolicy = 0;
		StorageNew->mtpM3uaAspSgAspIdPolicy = MTPM3UAASPSGASPIDPOLICY_UNKNOWN;
		StorageNew->mtpM3uaAspAssociationPolicy = MTPM3UAASPASSOCIATIONPOLICY_UNKNOWN;
		StorageNew->mtpM3uaAspProtocolPayloadId = 0;
		StorageNew->mtpM3uaAspRowStatus = 0;
		StorageNew->mtpM3uaAspRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpM3uaAspTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpM3uaAspTable_data *mtpM3uaAspTable_duplicate(struct mtpM3uaAspTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM3uaAspTable_data *
mtpM3uaAspTable_duplicate(struct mtpM3uaAspTable_data *thedata)
{
	struct mtpM3uaAspTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM3uaAspTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpM3uaAspTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpM3uaAspTable_id = thedata->mtpM3uaAspTable_id;
		StorageNew->mtpSctpId = thedata->mtpSctpId;
		StorageNew->mtpM3uaAspState = thedata->mtpM3uaAspState;
		StorageNew->mtpM3uaAsType = thedata->mtpM3uaAsType;
		StorageNew->mtpM3uaAspId = thedata->mtpM3uaAspId;
		if (!(StorageNew->mtpM3uaAspCapabilities = malloc(thedata->mtpM3uaAspCapabilitiesLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpM3uaAspCapabilities, thedata->mtpM3uaAspCapabilities, thedata->mtpM3uaAspCapabilitiesLen);
		StorageNew->mtpM3uaAspCapabilitiesLen = thedata->mtpM3uaAspCapabilitiesLen;
		StorageNew->mtpM3uaAspCapabilities[StorageNew->mtpM3uaAspCapabilitiesLen] = 0;
		if (!(StorageNew->mtpM3uaAspSgVersion = snmp_duplicate_objid(thedata->mtpM3uaAspSgVersion, thedata->mtpM3uaAspSgVersionLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpM3uaAspSgVersionLen = thedata->mtpM3uaAspSgVersionLen;
		if (!(StorageNew->mtpM3uaAspSgOptions = malloc(thedata->mtpM3uaAspSgOptionsLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpM3uaAspSgOptions, thedata->mtpM3uaAspSgOptions, thedata->mtpM3uaAspSgOptionsLen);
		StorageNew->mtpM3uaAspSgOptionsLen = thedata->mtpM3uaAspSgOptionsLen;
		StorageNew->mtpM3uaAspSgOptions[StorageNew->mtpM3uaAspSgOptionsLen] = 0;
		StorageNew->mtpM3uaAspSgRegistrationPolicy = thedata->mtpM3uaAspSgRegistrationPolicy;
		StorageNew->mtpM3uaAspSgAspIdPolicy = thedata->mtpM3uaAspSgAspIdPolicy;
		StorageNew->mtpM3uaAspAssociationPolicy = thedata->mtpM3uaAspAssociationPolicy;
		StorageNew->mtpM3uaAspProtocolPayloadId = thedata->mtpM3uaAspProtocolPayloadId;
		StorageNew->mtpM3uaAspRowStatus = thedata->mtpM3uaAspRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM3uaAspTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM3uaAspTable_destroy(struct mtpM3uaAspTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM3uaAspTable_destroy(struct mtpM3uaAspTable_data **thedata)
{
	struct mtpM3uaAspTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpM3uaAspTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpM3uaAspCapabilities);
		StorageDel->mtpM3uaAspCapabilitiesLen = 0;
		SNMP_FREE(StorageDel->mtpM3uaAspSgVersion);
		StorageDel->mtpM3uaAspSgVersionLen = 0;
		SNMP_FREE(StorageDel->mtpM3uaAspSgOptions);
		StorageDel->mtpM3uaAspSgOptionsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM3uaAspTable_add(struct mtpM3uaAspTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM3uaAspTable table data set.
 *
 * Adds a table row structure to the mtpM3uaAspTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM3uaAspTable_add(struct mtpM3uaAspTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpM3uaAspTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSctpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
		header_complex_add_data(&mtpM3uaAspTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM3uaAspTable_del(struct mtpM3uaAspTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpM3uaAspTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM3uaAspTable_del(struct mtpM3uaAspTable_data *thedata)
{
	struct mtpM3uaAspTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpM3uaAspTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM3uaAspTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM3uaAspTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM3uaAspTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM3uaAspTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM3uaAspTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM3uaAspTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM3uaAspTable_data *StorageTmp = mtpM3uaAspTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpM3uaAspTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAsType, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM3uaAspId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpM3uaAspCapabilities);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpM3uaAspCapabilities, &StorageTmp->mtpM3uaAspCapabilitiesLen);
	if (StorageTmp->mtpM3uaAspCapabilities == NULL) {
		config_perror("invalid specification for mtpM3uaAspCapabilities");
		return;
	}
	SNMP_FREE(StorageTmp->mtpM3uaAspSgVersion);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpM3uaAspSgVersion, &StorageTmp->mtpM3uaAspSgVersionLen);
	if (StorageTmp->mtpM3uaAspSgVersion == NULL) {
		config_perror("invalid specification for mtpM3uaAspSgVersion");
		return;
	}
	SNMP_FREE(StorageTmp->mtpM3uaAspSgOptions);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpM3uaAspSgOptions, &StorageTmp->mtpM3uaAspSgOptionsLen);
	if (StorageTmp->mtpM3uaAspSgOptions == NULL) {
		config_perror("invalid specification for mtpM3uaAspSgOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspSgRegistrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspSgAspIdPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspAssociationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspProtocolPayloadId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAspRowStatus, &tmpsize);
	mtpM3uaAspTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpM3uaAspTable(): store configuraiton file for mtpM3uaAspTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM3uaAspTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM3uaAspTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpM3uaAspTable: storing data...  "));
	refresh_mtpM3uaAspTable(1);
	(void) tmpsize;
	for (hcindex = mtpM3uaAspTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM3uaAspTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM3uaAspTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAsType, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM3uaAspId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpM3uaAspCapabilities, &StorageTmp->mtpM3uaAspCapabilitiesLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpM3uaAspSgVersion, &StorageTmp->mtpM3uaAspSgVersionLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpM3uaAspSgOptions, &StorageTmp->mtpM3uaAspSgOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspSgRegistrationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspSgAspIdPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspAssociationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspProtocolPayloadId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAspRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpM3uaAsTable_data *mtpM3uaAsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpM3uaAsTable table.
 *
 * Creates a new mtpM3uaAsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpM3uaAsTable_data *
mtpM3uaAsTable_create(void)
{
	struct mtpM3uaAsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM3uaAsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpM3uaAsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSctpId = 0;
		StorageNew->mtpM3uaAsState = MTPM3UAASSTATE_DOWN;
		StorageNew->mtpM3uaAsRoutingContext = 0;
		StorageNew->mtpM3uaAsNetworkAppearance = 0;
		if ((StorageNew->mtpM3uaAsNetworkPointCode = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpM3uaAsNetworkPointCodeLen = 0;
		StorageNew->mtpM3uaAsNetworkPointCode[StorageNew->mtpM3uaAsNetworkPointCodeLen] = 0;
		if ((StorageNew->mtpM3uaAsTrafficMode = snmp_duplicate_objid(zeroDotZero_oid, 2)) == NULL)
			goto nomem;
		StorageNew->mtpM3uaAsTrafficModeLen = 2;
		StorageNew->mtpM3uaAsRowStatus = 0;
		StorageNew->mtpM3uaAsRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpM3uaAsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpM3uaAsTable_data *mtpM3uaAsTable_duplicate(struct mtpM3uaAsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpM3uaAsTable_data *
mtpM3uaAsTable_duplicate(struct mtpM3uaAsTable_data *thedata)
{
	struct mtpM3uaAsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpM3uaAsTable_data);

	DEBUGMSGTL(("mtpMIB", "mtpM3uaAsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpM3uaAsTable_id = thedata->mtpM3uaAsTable_id;
		StorageNew->mtpSctpId = thedata->mtpSctpId;
		StorageNew->mtpM3uaAsId = thedata->mtpM3uaAsId;
		StorageNew->mtpM3uaAsState = thedata->mtpM3uaAsState;
		StorageNew->mtpM3uaAsRoutingContext = thedata->mtpM3uaAsRoutingContext;
		StorageNew->mtpM3uaAsNetworkAppearance = thedata->mtpM3uaAsNetworkAppearance;
		if (!(StorageNew->mtpM3uaAsNetworkPointCode = malloc(thedata->mtpM3uaAsNetworkPointCodeLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpM3uaAsNetworkPointCode, thedata->mtpM3uaAsNetworkPointCode, thedata->mtpM3uaAsNetworkPointCodeLen);
		StorageNew->mtpM3uaAsNetworkPointCodeLen = thedata->mtpM3uaAsNetworkPointCodeLen;
		StorageNew->mtpM3uaAsNetworkPointCode[StorageNew->mtpM3uaAsNetworkPointCodeLen] = 0;
		if (!(StorageNew->mtpM3uaAsTrafficMode = snmp_duplicate_objid(thedata->mtpM3uaAsTrafficMode, thedata->mtpM3uaAsTrafficModeLen / sizeof(oid))))
			goto destroy;
		StorageNew->mtpM3uaAsTrafficModeLen = thedata->mtpM3uaAsTrafficModeLen;
		StorageNew->mtpM3uaAsRowStatus = thedata->mtpM3uaAsRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpM3uaAsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpM3uaAsTable_destroy(struct mtpM3uaAsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpM3uaAsTable_destroy(struct mtpM3uaAsTable_data **thedata)
{
	struct mtpM3uaAsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpM3uaAsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpM3uaAsNetworkPointCode);
		StorageDel->mtpM3uaAsNetworkPointCodeLen = 0;
		SNMP_FREE(StorageDel->mtpM3uaAsTrafficMode);
		StorageDel->mtpM3uaAsTrafficModeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM3uaAsTable_add(struct mtpM3uaAsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpM3uaAsTable table data set.
 *
 * Adds a table row structure to the mtpM3uaAsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpM3uaAsTable_add(struct mtpM3uaAsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpMIB", "mtpM3uaAsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSctpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSctpId, sizeof(thedata->mtpSctpId));
		/* mtpM3uaAsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpM3uaAsId, sizeof(thedata->mtpM3uaAsId));
		header_complex_add_data(&mtpM3uaAsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpM3uaAsTable_del(struct mtpM3uaAsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpM3uaAsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpM3uaAsTable_del(struct mtpM3uaAsTable_data *thedata)
{
	struct mtpM3uaAsTable_data *StorageDel;

	DEBUGMSGTL(("mtpMIB", "mtpM3uaAsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpM3uaAsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpM3uaAsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpM3uaAsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpM3uaAsTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpM3uaAsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpM3uaAsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpM3uaAsTable_data *StorageTmp = mtpM3uaAsTable_create();

	DEBUGMSGTL(("mtpMIB", "parse_mtpM3uaAsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSctpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM3uaAsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAsState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM3uaAsRoutingContext, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpM3uaAsNetworkAppearance, &tmpsize);
	SNMP_FREE(StorageTmp->mtpM3uaAsNetworkPointCode);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpM3uaAsNetworkPointCode, &StorageTmp->mtpM3uaAsNetworkPointCodeLen);
	if (StorageTmp->mtpM3uaAsNetworkPointCode == NULL) {
		config_perror("invalid specification for mtpM3uaAsNetworkPointCode");
		return;
	}
	SNMP_FREE(StorageTmp->mtpM3uaAsTrafficMode);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpM3uaAsTrafficMode, &StorageTmp->mtpM3uaAsTrafficModeLen);
	if (StorageTmp->mtpM3uaAsTrafficMode == NULL) {
		config_perror("invalid specification for mtpM3uaAsTrafficMode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpM3uaAsRowStatus, &tmpsize);
	mtpM3uaAsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/*
 * store_mtpM3uaAsTable(): store configuraiton file for mtpM3uaAsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpM3uaAsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpM3uaAsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpMIB", "store_mtpM3uaAsTable: storing data...  "));
	refresh_mtpM3uaAsTable(1);
	(void) tmpsize;
	for (hcindex = mtpM3uaAsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpM3uaAsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpM3uaAsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSctpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM3uaAsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAsState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM3uaAsRoutingContext, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpM3uaAsNetworkAppearance, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpM3uaAsNetworkPointCode, &StorageTmp->mtpM3uaAsNetworkPointCodeLen);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpM3uaAsTrafficMode, &StorageTmp->mtpM3uaAsTrafficModeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpM3uaAsRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int activate_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int check_mtpSapTable_row(struct mtpSapTable_data *StorageTmp, struct mtpSapTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSapTable_row(struct mtpSapTable_data *StorageTmp, struct mtpSapTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSapTable_row(struct mtpSapTable_data *StorageTmp, struct mtpSapTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSapTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSapTable_row(struct mtpSapTable_data *StorageTmp, struct mtpSapTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSapTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSapTable_row(struct mtpSapTable_data *StorageTmp, struct mtpSapTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSapTable_row(struct mtpSapTable_data *StorageTmp, struct mtpSapTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSapTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSapTable_row(struct mtpSapTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSapTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSapTable_data *
refresh_mtpSapTable_row(struct mtpSapTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSapTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSapTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSapTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSapTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSapTable(int force)
{
	if (!force && mtpSapTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSapTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSapTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSapTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSapTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSapTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSapTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSapTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSAP2ADDRESS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSap2AddressLen;
		rval = (u_char *) StorageTmp->mtpSap2Address;
		break;
	case (u_char) MTPSAPUSERPART:	/* Create */
		*write_method = write_mtpSapUserPart;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSapUserPart);
		rval = (u_char *) &StorageTmp->mtpSapUserPart;
		break;
	case (u_char) MTPSAPUSERPARTSTATUS:	/* Create */
		*write_method = write_mtpSapUserPartStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSapUserPartStatus);
		rval = (u_char *) &StorageTmp->mtpSapUserPartStatus;
		break;
	case (u_char) MTPSAPUSERENTITYNAMES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSapUserEntityNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSapUserEntityNames;
		break;
	case (u_char) MTPSAPPROVIDERENTITYNAMES:	/* Create */
		*write_method = write_mtpSapProviderEntityNames;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSapProviderEntityNamesLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSapProviderEntityNames;
		break;
	case (u_char) MTPSAPUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSapUsageState);
		rval = (u_char *) &StorageTmp->mtpSapUsageState;
		break;
	case (u_char) MTPSAPASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpSapAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSapAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSapAsaProfilePointer;
		break;
	case (u_char) MTPSAPNAME:	/* Create */
		*write_method = write_mtpSapName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSapNameLen;
		rval = (u_char *) StorageTmp->mtpSapName;
		break;
	case (u_char) MTPSAPLONGMESSAGESUPPORTED:	/* Create */
		*write_method = write_mtpSapLongMessageSupported;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSapLongMessageSupported);
		rval = (u_char *) &StorageTmp->mtpSapLongMessageSupported;
		break;
	case (u_char) MTPSAPROWSTATUS:	/* Create */
		*write_method = write_mtpSapRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSapRowStatus);
		rval = (u_char *) &StorageTmp->mtpSapRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpNaTable_row(struct mtpNaTable_data *StorageTmp, struct mtpNaTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpNaTable_row(struct mtpNaTable_data *StorageTmp, struct mtpNaTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpNaTable_row(struct mtpNaTable_data *StorageTmp, struct mtpNaTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpNaTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpNaTable_row(struct mtpNaTable_data *StorageTmp, struct mtpNaTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpNaTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpNaTable_row(struct mtpNaTable_data *StorageTmp, struct mtpNaTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpNaTable_row(struct mtpNaTable_data *StorageTmp, struct mtpNaTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpNaTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpNaTable_row(struct mtpNaTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpNaTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpNaTable_data *
refresh_mtpNaTable_row(struct mtpNaTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpNaTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpNaTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpNaTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpNaTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpNaTable(int force)
{
	if (!force && mtpNaTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpNaTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpNaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpNaTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpNaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpNaTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpNaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpNaTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpNaTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpNaTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPNAPROTOCOLVARIANT:	/* Create */
		*write_method = write_mtpNaProtocolVariant;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpNaProtocolVariantLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpNaProtocolVariant;
		break;
	case (u_char) MTPNAPROTOCOLYEAR:	/* Create */
		*write_method = write_mtpNaProtocolYear;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNaProtocolYear);
		rval = (u_char *) &StorageTmp->mtpNaProtocolYear;
		break;
	case (u_char) MTPNAPROTOCOLOPTIONS:	/* Create */
		*write_method = write_mtpNaProtocolOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpNaProtocolOptionsLen;
		rval = (u_char *) StorageTmp->mtpNaProtocolOptions;
		break;
	case (u_char) MTPNANETWORKINDICATOR:	/* Create */
		*write_method = write_mtpNaNetworkIndicator;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNaNetworkIndicator);
		rval = (u_char *) &StorageTmp->mtpNaNetworkIndicator;
		break;
	case (u_char) MTPNAPOINTCODEFORMAT:	/* Create */
		*write_method = write_mtpNaPointCodeFormat;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpNaPointCodeFormatLen;
		rval = (u_char *) StorageTmp->mtpNaPointCodeFormat;
		break;
	case (u_char) MTPNASLSLENGTH:	/* Create */
		*write_method = write_mtpNaSlsLength;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNaSlsLength);
		rval = (u_char *) &StorageTmp->mtpNaSlsLength;
		break;
	case (u_char) MTPNASPDEFAULT:	/* Create */
		*write_method = write_mtpNaSpDefault;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpNaSpDefaultLen;
		rval = (u_char *) StorageTmp->mtpNaSpDefault;
		break;
	case (u_char) MTPNANAME:	/* Create */
		*write_method = write_mtpNaName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpNaNameLen;
		rval = (u_char *) StorageTmp->mtpNaName;
		break;
	case (u_char) MTPNAROWSTATUS:	/* Create */
		*write_method = write_mtpNaRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNaRowStatus);
		rval = (u_char *) &StorageTmp->mtpNaRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpMsTable_row(struct mtpMsTable_data *StorageTmp, struct mtpMsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpMsTable_row(struct mtpMsTable_data *StorageTmp, struct mtpMsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpMsTable_row(struct mtpMsTable_data *StorageTmp, struct mtpMsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpMsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpMsTable_row(struct mtpMsTable_data *StorageTmp, struct mtpMsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpMsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpMsTable_row(struct mtpMsTable_data *StorageTmp, struct mtpMsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpMsTable_row(struct mtpMsTable_data *StorageTmp, struct mtpMsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpMsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpMsTable_row(struct mtpMsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpMsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpMsTable_data *
refresh_mtpMsTable_row(struct mtpMsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpMsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpMsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpMsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpMsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpMsTable(int force)
{
	if (!force && mtpMsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpMsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpMsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpMsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpMsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpMsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpMsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpMsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpMsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpMsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPMSNAME:	/* Create */
		*write_method = write_mtpMsName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsNameLen;
		rval = (u_char *) StorageTmp->mtpMsName;
		break;
	case (u_char) MTPMSALARMSTATUS:	/* Create */
		*write_method = write_mtpMsAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsAlarmStatusLen;
		rval = (u_char *) StorageTmp->mtpMsAlarmStatus;
		break;
	case (u_char) MTPMSOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpMsOperationalState);
		rval = (u_char *) &StorageTmp->mtpMsOperationalState;
		break;
	case (u_char) MTPMSUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpMsUsageState);
		rval = (u_char *) &StorageTmp->mtpMsUsageState;
		break;
	case (u_char) MTPMSMANAGEDELEMENTTYPE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsManagedElementTypeLen;
		rval = (u_char *) StorageTmp->mtpMsManagedElementType;
		break;
	case (u_char) MTPMSMODELCODE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsModelCodeLen;
		rval = (u_char *) StorageTmp->mtpMsModelCode;
		break;
	case (u_char) MTPMSVENDORNAME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsVendorNameLen;
		rval = (u_char *) StorageTmp->mtpMsVendorName;
		break;
	case (u_char) MTPMSUSERLABEL:	/* Create */
		*write_method = write_mtpMsUserLabel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsUserLabelLen;
		rval = (u_char *) StorageTmp->mtpMsUserLabel;
		break;
	case (u_char) MTPMSVERSION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsVersionLen;
		rval = (u_char *) StorageTmp->mtpMsVersion;
		break;
	case (u_char) MTPMSASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpMsAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpMsAsaProfilePointer;
		break;
	case (u_char) MTPMSNETWORKELEMENTALIASES:	/* Create */
		*write_method = write_mtpMsNetworkElementAliases;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpMsNetworkElementAliasesLen;
		rval = (u_char *) StorageTmp->mtpMsNetworkElementAliases;
		break;
	case (u_char) MTPMSROWSTATUS:	/* Create */
		*write_method = write_mtpMsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpMsRowStatus);
		rval = (u_char *) &StorageTmp->mtpMsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp, struct mtpSpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp, struct mtpSpProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp, struct mtpSpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSpProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp, struct mtpSpProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSpProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp, struct mtpSpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp, struct mtpSpProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSpProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSpProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSpProfileTable_data *
refresh_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSpProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSpProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSpProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSpProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSpProfileTable(int force)
{
	if (!force && mtpSpProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSpProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSpProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSpProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSpProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSpProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSpProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSPPROFILETIMERT1R:	/* Create */
		*write_method = write_mtpSpProfileTimerT1R;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1R);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT1R;
		break;
	case (u_char) MTPSPPROFILETIMERT2:	/* Create */
		*write_method = write_mtpSpProfileTimerT2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT2);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT2;
		break;
	case (u_char) MTPSPPROFILETIMERT4:	/* Create */
		*write_method = write_mtpSpProfileTimerT4;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT4);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT4;
		break;
	case (u_char) MTPSPPROFILETIMERT5:	/* Create */
		*write_method = write_mtpSpProfileTimerT5;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT5);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT5;
		break;
	case (u_char) MTPSPPROFILETIMERT7:	/* Create */
		*write_method = write_mtpSpProfileTimerT7;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT7);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT7;
		break;
	case (u_char) MTPSPPROFILETIMERT11:	/* Create */
		*write_method = write_mtpSpProfileTimerT11;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT11);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT11;
		break;
	case (u_char) MTPSPPROFILETIMERT12:	/* Create */
		*write_method = write_mtpSpProfileTimerT12;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT12);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT12;
		break;
	case (u_char) MTPSPPROFILETIMERT13:	/* Create */
		*write_method = write_mtpSpProfileTimerT13;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT13);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT13;
		break;
	case (u_char) MTPSPPROFILETIMERT14:	/* Create */
		*write_method = write_mtpSpProfileTimerT14;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT14);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT14;
		break;
	case (u_char) MTPSPPROFILETIMERT15:	/* Create */
		*write_method = write_mtpSpProfileTimerT15;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT15);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT15;
		break;
	case (u_char) MTPSPPROFILETIMERT16:	/* Create */
		*write_method = write_mtpSpProfileTimerT16;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT16);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT16;
		break;
	case (u_char) MTPSPPROFILETIMERT18I:	/* Create */
		*write_method = write_mtpSpProfileTimerT18I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT18I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT18I;
		break;
	case (u_char) MTPSPPROFILETIMERT19I:	/* Create */
		*write_method = write_mtpSpProfileTimerT19I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT19I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT19I;
		break;
	case (u_char) MTPSPPROFILETIMERT20I:	/* Create */
		*write_method = write_mtpSpProfileTimerT20I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT20I;
		break;
	case (u_char) MTPSPPROFILETIMERT21I:	/* Create */
		*write_method = write_mtpSpProfileTimerT21I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT21I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT21I;
		break;
	case (u_char) MTPSPPROFILETIMERT22I:	/* Create */
		*write_method = write_mtpSpProfileTimerT22I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT22I;
		break;
	case (u_char) MTPSPPROFILETIMERT23I:	/* Create */
		*write_method = write_mtpSpProfileTimerT23I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23I);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT23I;
		break;
	case (u_char) MTPSPPROFILETIMERT20A:	/* Create */
		*write_method = write_mtpSpProfileTimerT20A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT20A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT20A;
		break;
	case (u_char) MTPSPPROFILETIMERT21A:	/* Create */
		*write_method = write_mtpSpProfileTimerT21A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT21A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT21A;
		break;
	case (u_char) MTPSPPROFILETIMERT22A:	/* Create */
		*write_method = write_mtpSpProfileTimerT22A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT22A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT22A;
		break;
	case (u_char) MTPSPPROFILETIMERT23A:	/* Create */
		*write_method = write_mtpSpProfileTimerT23A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT23A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT23A;
		break;
	case (u_char) MTPSPPROFILETIMERT24A:	/* Create */
		*write_method = write_mtpSpProfileTimerT24A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT24A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT24A;
		break;
	case (u_char) MTPSPPROFILETIMERT26A:	/* Create */
		*write_method = write_mtpSpProfileTimerT26A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT26A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT26A;
		break;
	case (u_char) MTPSPPROFILETIMERT27A:	/* Create */
		*write_method = write_mtpSpProfileTimerT27A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT27A);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT27A;
		break;
	case (u_char) MTPSPPROFILETIMERT1T:	/* Create */
		*write_method = write_mtpSpProfileTimerT1T;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT1T);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT1T;
		break;
	case (u_char) MTPSPPROFILETIMERT2T:	/* Create */
		*write_method = write_mtpSpProfileTimerT2T;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileTimerT2T);
		rval = (u_char *) &StorageTmp->mtpSpProfileTimerT2T;
		break;
	case (u_char) MTPSPPROFILENAME:	/* Create */
		*write_method = write_mtpSpProfileName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpProfileNameLen;
		rval = (u_char *) StorageTmp->mtpSpProfileName;
		break;
	case (u_char) MTPSPPROFILECIRCULARRTEDETECT:	/* Create */
		*write_method = write_mtpSpProfileCircularRteDetect;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileCircularRteDetect);
		rval = (u_char *) &StorageTmp->mtpSpProfileCircularRteDetect;
		break;
	case (u_char) MTPSPRSDEFAULT:	/* Create */
		*write_method = write_mtpSpRsDefault;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpRsDefaultLen;
		rval = (u_char *) StorageTmp->mtpSpRsDefault;
		break;
	case (u_char) MTPSPLSDEFAULT:	/* Create */
		*write_method = write_mtpSpLsDefault;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpLsDefaultLen;
		rval = (u_char *) StorageTmp->mtpSpLsDefault;
		break;
	case (u_char) MTPSPPROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpSpProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpSpProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSpTable_row(struct mtpSpTable_data *StorageTmp, struct mtpSpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSpTable_row(struct mtpSpTable_data *StorageTmp, struct mtpSpTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSpTable_row(struct mtpSpTable_data *StorageTmp, struct mtpSpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSpTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSpTable_row(struct mtpSpTable_data *StorageTmp, struct mtpSpTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSpTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSpTable_row(struct mtpSpTable_data *StorageTmp, struct mtpSpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSpTable_row(struct mtpSpTable_data *StorageTmp, struct mtpSpTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSpTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSpTable_row(struct mtpSpTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSpTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSpTable_data *
refresh_mtpSpTable_row(struct mtpSpTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSpTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSpTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSpTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSpTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSpTable(int force)
{
	if (!force && mtpSpTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSpTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSpTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSpTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSpTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSpTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSpTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSPPOINTCODE:	/* Create */
		*write_method = write_mtpSpPointCode;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpPointCodeLen;
		rval = (u_char *) StorageTmp->mtpSpPointCode;
		break;
	case (u_char) MTPSPTYPE:	/* Create */
		*write_method = write_mtpSpType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpType);
		rval = (u_char *) &StorageTmp->mtpSpType;
		break;
	case (u_char) MTPSPOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpOperationalState);
		rval = (u_char *) &StorageTmp->mtpSpOperationalState;
		break;
	case (u_char) MTPSPPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpProceduralStatusLen;
		rval = (u_char *) StorageTmp->mtpSpProceduralStatus;
		break;
	case (u_char) MTPSPAVAILABILITYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpAvailabilityStatusLen;
		rval = (u_char *) StorageTmp->mtpSpAvailabilityStatus;
		break;
	case (u_char) MTPSPVERSION:	/* Create */
		*write_method = write_mtpSpVersion;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpVersionLen;
		rval = (u_char *) StorageTmp->mtpSpVersion;
		break;
	case (u_char) MTPSPNETWORKINDICATOR:	/* Create */
		*write_method = write_mtpSpNetworkIndicator;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpNetworkIndicator);
		rval = (u_char *) &StorageTmp->mtpSpNetworkIndicator;
		break;
	case (u_char) MTPSPNAME:	/* Create */
		*write_method = write_mtpSpName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpNameLen;
		rval = (u_char *) StorageTmp->mtpSpName;
		break;
	case (u_char) MTPSPPROFILEPOINTER:	/* Create */
		*write_method = write_mtpSpProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpProfilePointerLen;
		rval = (u_char *) StorageTmp->mtpSpProfilePointer;
		break;
	case (u_char) MTPSPNAPOINTER:	/* Create */
		*write_method = write_mtpSpNaPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpNaPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSpNaPointer;
		break;
	case (u_char) MTPSPOPTIONS:	/* Create */
		*write_method = write_mtpSpOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpOptionsLen;
		rval = (u_char *) StorageTmp->mtpSpOptions;
		break;
	case (u_char) MTPSPUSERS:	/* Create */
		*write_method = write_mtpSpUsers;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpUsersLen;
		rval = (u_char *) StorageTmp->mtpSpUsers;
		break;
	case (u_char) MTPSPALARMSTATUS:	/* Create */
		*write_method = write_mtpSpAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSpAlarmStatusLen;
		rval = (u_char *) StorageTmp->mtpSpAlarmStatus;
		break;
	case (u_char) MTPSPROWSTATUS:	/* Create */
		*write_method = write_mtpSpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSpRowStatus);
		rval = (u_char *) &StorageTmp->mtpSpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpL3Table_row(struct mtpL3Table_data *StorageTmp, struct mtpL3Table_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpL3Table_row(struct mtpL3Table_data *StorageTmp, struct mtpL3Table_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpL3Table_row(struct mtpL3Table_data *StorageTmp, struct mtpL3Table_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpL3Table_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpL3Table_row(struct mtpL3Table_data *StorageTmp, struct mtpL3Table_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpL3Table_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpL3Table_row(struct mtpL3Table_data *StorageTmp, struct mtpL3Table_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpL3Table_row(struct mtpL3Table_data *StorageTmp, struct mtpL3Table_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpL3Table_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpL3Table_row(struct mtpL3Table_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpL3Table row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpL3Table_data *
refresh_mtpL3Table_row(struct mtpL3Table_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpL3Table_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpL3Table_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpL3Table(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpL3Table.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpL3Table(int force)
{
	if (!force && mtpL3Table_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpL3Table_refresh = 0;
}

/**
 * @fn u_char *var_mtpL3Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpL3Table.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpL3Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpL3Table_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpL3Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpL3Table(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpL3TableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpL3Table_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPL3ADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpL3AdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpL3AdministrativeState);
		rval = (u_char *) &StorageTmp->mtpL3AdministrativeState;
		break;
	case (u_char) MTPL3OPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpL3OperationalState);
		rval = (u_char *) &StorageTmp->mtpL3OperationalState;
		break;
	case (u_char) MTPL3USAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpL3UsageState);
		rval = (u_char *) &StorageTmp->mtpL3UsageState;
		break;
	case (u_char) MTPL3PROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpL3ProceduralStatusLen;
		rval = (u_char *) StorageTmp->mtpL3ProceduralStatus;
		break;
	case (u_char) MTPL3ASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpL3AsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpL3AsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpL3AsaProfilePointer;
		break;
	case (u_char) MTPL3NAME:	/* Create */
		*write_method = write_mtpL3Name;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpL3NameLen;
		rval = (u_char *) StorageTmp->mtpL3Name;
		break;
	case (u_char) MTPL3ROWSTATUS:	/* Create */
		*write_method = write_mtpL3RowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpL3RowStatus);
		rval = (u_char *) &StorageTmp->mtpL3RowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpGsTable_row(struct mtpGsTable_data *StorageTmp, struct mtpGsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpGsTable_row(struct mtpGsTable_data *StorageTmp, struct mtpGsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpGsTable_row(struct mtpGsTable_data *StorageTmp, struct mtpGsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpGsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpGsTable_row(struct mtpGsTable_data *StorageTmp, struct mtpGsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpGsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpGsTable_row(struct mtpGsTable_data *StorageTmp, struct mtpGsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpGsTable_row(struct mtpGsTable_data *StorageTmp, struct mtpGsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpGsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpGsTable_row(struct mtpGsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpGsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpGsTable_data *
refresh_mtpGsTable_row(struct mtpGsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpGsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpGsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpGsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpGsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsTable(int force)
{
	if (!force && mtpGsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpGsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpGsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpGsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpGsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpGsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpGsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPGSADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpGsAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpGsAdministrativeState;
		break;
	case (u_char) MTPGSTREATMENTOFOUTSIDERANGES:	/* Create */
		*write_method = write_mtpGsTreatmentOfOutsideRanges;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsTreatmentOfOutsideRanges);
		rval = (u_char *) &StorageTmp->mtpGsTreatmentOfOutsideRanges;
		break;
	case (u_char) MTPGSLISTMODE:	/* Create */
		*write_method = write_mtpGsListMode;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsListMode);
		rval = (u_char *) &StorageTmp->mtpGsListMode;
		break;
	case (u_char) MTPGSSCREENINGBYLINKSETORBYOPC:	/* Create */
		*write_method = write_mtpGsScreeningByLinkSetOrByOpc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsScreeningByLinkSetOrByOpc);
		rval = (u_char *) &StorageTmp->mtpGsScreeningByLinkSetOrByOpc;
		break;
	case (u_char) MTPGSGETSCREENEDOPCSORLINKSETSBYDPC:	/* Create */
		*write_method = write_mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc);
		rval = (u_char *) &StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		break;
	case (u_char) MTPGSNAME:	/* Create */
		*write_method = write_mtpGsName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsNameLen;
		rval = (u_char *) StorageTmp->mtpGsName;
		break;
	case (u_char) MTPGSROWSTATUS:	/* Create */
		*write_method = write_mtpGsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsRowStatus);
		rval = (u_char *) &StorageTmp->mtpGsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp, struct mtpGsLineTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp, struct mtpGsLineTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp, struct mtpGsLineTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpGsLineTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp, struct mtpGsLineTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpGsLineTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp, struct mtpGsLineTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp, struct mtpGsLineTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpGsLineTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpGsLineTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpGsLineTable_data *
refresh_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpGsLineTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpGsLineTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpGsLineTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpGsLineTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsLineTable(int force)
{
	if (!force && mtpGsLineTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpGsLineTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpGsLineTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpGsLineTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsLineTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsLineTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsLineTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpGsLineTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpGsLineTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpGsLineTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPGSLINEOBJECT:	/* Create */
		*write_method = write_mtpGsLineObject;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsLineObjectLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpGsLineObject;
		break;
	case (u_char) MTPGSLINECONTENT:	/* Create */
		*write_method = write_mtpGsLineContent;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsLineContent);
		rval = (u_char *) &StorageTmp->mtpGsLineContent;
		break;
	case (u_char) MTPGSLINEROWSTATUS:	/* Create */
		*write_method = write_mtpGsLineRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsLineRowStatus);
		rval = (u_char *) &StorageTmp->mtpGsLineRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp, struct mtpGsLineContentTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp, struct mtpGsLineContentTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp, struct mtpGsLineContentTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpGsLineContentTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp, struct mtpGsLineContentTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpGsLineContentTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp, struct mtpGsLineContentTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp, struct mtpGsLineContentTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpGsLineContentTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpGsLineContentTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpGsLineContentTable_data *
refresh_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpGsLineContentTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpGsLineContentTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpGsLineContentTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpGsLineContentTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpGsLineContentTable(int force)
{
	if (!force && mtpGsLineContentTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpGsLineContentTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpGsLineContentTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpGsLineContentTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpGsLineContentTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpGsLineContentTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpGsLineContentTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpGsLineContentTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpGsLineContentTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPGSLINECONTENTDESIGNATEDDPCFIRST:	/* Create */
		*write_method = write_mtpGsLineContentDesignatedDPCFirst;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsLineContentDesignatedDPCFirstLen;
		rval = (u_char *) StorageTmp->mtpGsLineContentDesignatedDPCFirst;
		break;
	case (u_char) MTPGSLINECONTENTDESIGNATEDDPCLAST:	/* Create */
		*write_method = write_mtpGsLineContentDesignatedDPCLast;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsLineContentDesignatedDPCLastLen;
		rval = (u_char *) StorageTmp->mtpGsLineContentDesignatedDPCLast;
		break;
	case (u_char) MTPGSLINECONTENTSIMASK:	/* Create */
		*write_method = write_mtpGsLineContentSiMask;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsLineContentSiMaskLen;
		rval = (u_char *) StorageTmp->mtpGsLineContentSiMask;
		break;
	case (u_char) MTPGSLINECONTENTMESSAGETREATMENT:	/* Create */
		*write_method = write_mtpGsLineContentMessageTreatment;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsLineContentMessageTreatment);
		rval = (u_char *) &StorageTmp->mtpGsLineContentMessageTreatment;
		break;
	case (u_char) MTPGSLINECONTENTCOMMENT:	/* Create */
		*write_method = write_mtpGsLineContentComment;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpGsLineContentCommentLen;
		rval = (u_char *) StorageTmp->mtpGsLineContentComment;
		break;
	case (u_char) MTPGSLINECONTENTROWSTATUS:	/* Create */
		*write_method = write_mtpGsLineContentRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpGsLineContentRowStatus);
		rval = (u_char *) &StorageTmp->mtpGsLineContentRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp, struct mtpRsProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp, struct mtpRsProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp, struct mtpRsProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpRsProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp, struct mtpRsProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpRsProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp, struct mtpRsProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp, struct mtpRsProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpRsProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpRsProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpRsProfileTable_data *
refresh_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpRsProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpRsProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpRsProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpRsProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRsProfileTable(int force)
{
	if (!force && mtpRsProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpRsProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpRsProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRsProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRsProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpRsProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpRsProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPRSPROFILENAME:	/* Create */
		*write_method = write_mtpRsProfileName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsProfileNameLen;
		rval = (u_char *) StorageTmp->mtpRsProfileName;
		break;
	case (u_char) MTPRSPROFILETIMERT8:	/* Create */
		*write_method = write_mtpRsProfileTimerT8;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT8);
		rval = (u_char *) &StorageTmp->mtpRsProfileTimerT8;
		break;
	case (u_char) MTPRSPROFILETIMERT11:	/* Create */
		*write_method = write_mtpRsProfileTimerT11;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT11);
		rval = (u_char *) &StorageTmp->mtpRsProfileTimerT11;
		break;
	case (u_char) MTPRSPROFILETIMERT15:	/* Create */
		*write_method = write_mtpRsProfileTimerT15;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT15);
		rval = (u_char *) &StorageTmp->mtpRsProfileTimerT15;
		break;
	case (u_char) MTPRSPROFILETIMERT16:	/* Create */
		*write_method = write_mtpRsProfileTimerT16;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT16);
		rval = (u_char *) &StorageTmp->mtpRsProfileTimerT16;
		break;
	case (u_char) MTPRSPROFILETIMERT18A:	/* Create */
		*write_method = write_mtpRsProfileTimerT18A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileTimerT18A);
		rval = (u_char *) &StorageTmp->mtpRsProfileTimerT18A;
		break;
	case (u_char) MTPRSPROFILERTDEFAULT:	/* Create */
		*write_method = write_mtpRsProfileRtDefault;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsProfileRtDefaultLen;
		rval = (u_char *) StorageTmp->mtpRsProfileRtDefault;
		break;
	case (u_char) MTPRSPROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpRsProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpRsProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpRsTable_row(struct mtpRsTable_data *StorageTmp, struct mtpRsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpRsTable_row(struct mtpRsTable_data *StorageTmp, struct mtpRsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpRsTable_row(struct mtpRsTable_data *StorageTmp, struct mtpRsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpRsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpRsTable_row(struct mtpRsTable_data *StorageTmp, struct mtpRsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpRsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpRsTable_row(struct mtpRsTable_data *StorageTmp, struct mtpRsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpRsTable_row(struct mtpRsTable_data *StorageTmp, struct mtpRsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpRsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpRsTable_row(struct mtpRsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpRsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpRsTable_data *
refresh_mtpRsTable_row(struct mtpRsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpRsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpRsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpRsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpRsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRsTable(int force)
{
	if (!force && mtpRsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpRsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpRsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpRsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpRsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpRsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPRSDEST:	/* Create */
		*write_method = write_mtpRsDest;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsDestLen;
		rval = (u_char *) StorageTmp->mtpRsDest;
		break;
	case (u_char) MTPRSOPTIONS:	/* Create */
		*write_method = write_mtpRsOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsOptionsLen;
		rval = (u_char *) StorageTmp->mtpRsOptions;
		break;
	case (u_char) MTPRSADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpRsAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpRsAdministrativeState;
		break;
	case (u_char) MTPRSOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsOperationalState);
		rval = (u_char *) &StorageTmp->mtpRsOperationalState;
		break;
	case (u_char) MTPRSASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpRsAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpRsAsaProfilePointer;
		break;
	case (u_char) MTPRSCONGESTEDSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsCongestedState);
		rval = (u_char *) &StorageTmp->mtpRsCongestedState;
		break;
	case (u_char) MTPRSCONGESTIONLEVEL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsCongestionLevel);
		rval = (u_char *) &StorageTmp->mtpRsCongestionLevel;
		break;
	case (u_char) MTPRSLOADSHARINGINFORMATION:	/* Create */
		*write_method = write_mtpRsLoadsharingInformation;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsLoadsharingInformationLen;
		rval = (u_char *) StorageTmp->mtpRsLoadsharingInformation;
		break;
	case (u_char) MTPRSLOADSHARINGOBJECT:	/* Create */
		*write_method = write_mtpRsLoadsharingObject;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsLoadsharingObjectLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpRsLoadsharingObject;
		break;
	case (u_char) MTPRSREMOTEEXCHANGELABEL:	/* Create */
		*write_method = write_mtpRsRemoteExchangeLabel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsRemoteExchangeLabelLen;
		rval = (u_char *) StorageTmp->mtpRsRemoteExchangeLabel;
		break;
	case (u_char) MTPRSNAME:	/* Create */
		*write_method = write_mtpRsName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsNameLen;
		rval = (u_char *) StorageTmp->mtpRsName;
		break;
	case (u_char) MTPRSPROFILE:	/* Create */
		*write_method = write_mtpRsProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsProfileLen;
		rval = (u_char *) StorageTmp->mtpRsProfile;
		break;
	case (u_char) MTPRSALARMSTATUS:	/* Create */
		*write_method = write_mtpRsAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRsAlarmStatusLen;
		rval = (u_char *) StorageTmp->mtpRsAlarmStatus;
		break;
	case (u_char) MTPRSROWSTATUS:	/* Create */
		*write_method = write_mtpRsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRsRowStatus);
		rval = (u_char *) &StorageTmp->mtpRsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp, struct mtpRtProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp, struct mtpRtProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp, struct mtpRtProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpRtProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp, struct mtpRtProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpRtProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp, struct mtpRtProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp, struct mtpRtProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpRtProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpRtProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpRtProfileTable_data *
refresh_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpRtProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpRtProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpRtProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpRtProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtProfileTable(int force)
{
	if (!force && mtpRtProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpRtProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpRtProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRtProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRtProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpRtProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpRtProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPRTPROFILETIMERT6:	/* Create */
		*write_method = write_mtpRtProfileTimerT6;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT6);
		rval = (u_char *) &StorageTmp->mtpRtProfileTimerT6;
		break;
	case (u_char) MTPRTPROFILETIMERT10:	/* Create */
		*write_method = write_mtpRtProfileTimerT10;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtProfileTimerT10);
		rval = (u_char *) &StorageTmp->mtpRtProfileTimerT10;
		break;
	case (u_char) MTPRTPROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpRtProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpRtProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpRtTable_row(struct mtpRtTable_data *StorageTmp, struct mtpRtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpRtTable_row(struct mtpRtTable_data *StorageTmp, struct mtpRtTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpRtTable_row(struct mtpRtTable_data *StorageTmp, struct mtpRtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpRtTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpRtTable_row(struct mtpRtTable_data *StorageTmp, struct mtpRtTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpRtTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpRtTable_row(struct mtpRtTable_data *StorageTmp, struct mtpRtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpRtTable_row(struct mtpRtTable_data *StorageTmp, struct mtpRtTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpRtTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpRtTable_row(struct mtpRtTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpRtTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpRtTable_data *
refresh_mtpRtTable_row(struct mtpRtTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpRtTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpRtTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpRtTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpRtTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtTable(int force)
{
	if (!force && mtpRtTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpRtTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpRtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRtTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRtTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpRtTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpRtTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPRTLSPOINTER:	/* Create */
		*write_method = write_mtpRtLsPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtLsPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpRtLsPointer;
		break;
	case (u_char) MTPRTADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpRtAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpRtAdministrativeState;
		break;
	case (u_char) MTPRTOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtOperationalState);
		rval = (u_char *) &StorageTmp->mtpRtOperationalState;
		break;
	case (u_char) MTPRTAVAILABILITYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtAvailabilityStatusLen;
		rval = (u_char *) StorageTmp->mtpRtAvailabilityStatus;
		break;
	case (u_char) MTPRTINCLSLOADSHARINGALGORITHM:	/* Create */
		*write_method = write_mtpRtInClsLoadsharingAlgorithm;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtInClsLoadsharingAlgorithm);
		rval = (u_char *) &StorageTmp->mtpRtInClsLoadsharingAlgorithm;
		break;
	case (u_char) MTPRTFIXEDPRIORITY:	/* Create */
		*write_method = write_mtpRtFixedPriority;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtFixedPriority);
		rval = (u_char *) &StorageTmp->mtpRtFixedPriority;
		break;
	case (u_char) MTPRTFLEXIBLEPRIORITY:	/* Create */
		*write_method = write_mtpRtFlexiblePriority;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtFlexiblePriority);
		rval = (u_char *) &StorageTmp->mtpRtFlexiblePriority;
		break;
	case (u_char) MTPRTPRIORITYMODE:	/* Create */
		*write_method = write_mtpRtPriorityMode;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtPriorityMode);
		rval = (u_char *) &StorageTmp->mtpRtPriorityMode;
		break;
	case (u_char) MTPRTLOADSHARINGINFORMATION:	/* Create */
		*write_method = write_mtpRtLoadsharingInformation;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtLoadsharingInformationLen;
		rval = (u_char *) StorageTmp->mtpRtLoadsharingInformation;
		break;
	case (u_char) MTPRTLOADSHARINGOBJECT:	/* Create */
		*write_method = write_mtpRtLoadsharingObject;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtLoadsharingObjectLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpRtLoadsharingObject;
		break;
	case (u_char) MTPRTNAME:	/* Create */
		*write_method = write_mtpRtName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtNameLen;
		rval = (u_char *) StorageTmp->mtpRtName;
		break;
	case (u_char) MTPRTSLSLIST:	/* Create */
		*write_method = write_mtpRtSlsList;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtSlsListLen;
		rval = (u_char *) StorageTmp->mtpRtSlsList;
		break;
	case (u_char) MTPRTUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtUsageState);
		rval = (u_char *) &StorageTmp->mtpRtUsageState;
		break;
	case (u_char) MTPRTRLSLOT:	/* Create */
		*write_method = write_mtpRtRlSlot;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtRlSlot);
		rval = (u_char *) &StorageTmp->mtpRtRlSlot;
		break;
	case (u_char) MTPRTPROFILE:	/* Create */
		*write_method = write_mtpRtProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtProfileLen;
		rval = (u_char *) StorageTmp->mtpRtProfile;
		break;
	case (u_char) MTPRTROWSTATUS:	/* Create */
		*write_method = write_mtpRtRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtRowStatus);
		rval = (u_char *) &StorageTmp->mtpRtRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp, struct mtpRtLsaTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp, struct mtpRtLsaTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp, struct mtpRtLsaTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpRtLsaTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp, struct mtpRtLsaTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpRtLsaTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp, struct mtpRtLsaTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp, struct mtpRtLsaTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpRtLsaTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpRtLsaTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpRtLsaTable_data *
refresh_mtpRtLsaTable_row(struct mtpRtLsaTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpRtLsaTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpRtLsaTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpRtLsaTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpRtLsaTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpRtLsaTable(int force)
{
	if (!force && mtpRtLsaTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpRtLsaTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpRtLsaTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpRtLsaTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpRtLsaTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpRtLsaTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpRtLsaTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpRtLsaTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpRtLsaTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpRtLsaTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPRTLSANORMALSLCODE:	/* ReadWrite */
		*write_method = write_mtpRtLsaNormalSlCode;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpRtLsaNormalSlCode);
		rval = (u_char *) &StorageTmp->mtpRtLsaNormalSlCode;
		break;
	case (u_char) MTPRTLSAALTERNATIVESLCODELIST:	/* ReadWrite */
		*write_method = write_mtpRtLsaAlternativeSlCodeList;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpRtLsaAlternativeSlCodeListLen;
		rval = (u_char *) StorageTmp->mtpRtLsaAlternativeSlCodeList;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp, struct mtpLsProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp, struct mtpLsProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp, struct mtpLsProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpLsProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp, struct mtpLsProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpLsProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp, struct mtpLsProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp, struct mtpLsProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpLsProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpLsProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpLsProfileTable_data *
refresh_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpLsProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpLsProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpLsProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpLsProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpLsProfileTable(int force)
{
	if (!force && mtpLsProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpLsProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpLsProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpLsProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpLsProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpLsProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpLsProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpLsProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPLSPROFILETIMERT6:	/* Create */
		*write_method = write_mtpLsProfileTimerT6;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT6);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT6;
		break;
	case (u_char) MTPLSPROFILETIMERT8:	/* Create */
		*write_method = write_mtpLsProfileTimerT8;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT8);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT8;
		break;
	case (u_char) MTPLSPROFILETIMERT10:	/* Create */
		*write_method = write_mtpLsProfileTimerT10;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT10);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT10;
		break;
	case (u_char) MTPLSPROFILETIMERT7:	/* Create */
		*write_method = write_mtpLsProfileTimerT7;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT7);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT7;
		break;
	case (u_char) MTPLSPROFILETIMERT19I:	/* Create */
		*write_method = write_mtpLsProfileTimerT19I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT19I);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT19I;
		break;
	case (u_char) MTPLSPROFILETIMERT21I:	/* Create */
		*write_method = write_mtpLsProfileTimerT21I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT21I);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT21I;
		break;
	case (u_char) MTPLSPROFILETIMERT25A:	/* Create */
		*write_method = write_mtpLsProfileTimerT25A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT25A);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT25A;
		break;
	case (u_char) MTPLSPROFILETIMERT28A:	/* Create */
		*write_method = write_mtpLsProfileTimerT28A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT28A);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT28A;
		break;
	case (u_char) MTPLSPROFILETIMERT29A:	/* Create */
		*write_method = write_mtpLsProfileTimerT29A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT29A);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT29A;
		break;
	case (u_char) MTPLSPROFILETIMERT30A:	/* Create */
		*write_method = write_mtpLsProfileTimerT30A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileTimerT30A);
		rval = (u_char *) &StorageTmp->mtpLsProfileTimerT30A;
		break;
	case (u_char) MTPLSPROFILEPARAMETERN:	/* Create */
		*write_method = write_mtpLsProfileParameterN;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileParameterN);
		rval = (u_char *) &StorageTmp->mtpLsProfileParameterN;
		break;
	case (u_char) MTPLSPROFILEPARAMETERM:	/* Create */
		*write_method = write_mtpLsProfileParameterM;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileParameterM);
		rval = (u_char *) &StorageTmp->mtpLsProfileParameterM;
		break;
	case (u_char) MTPLSPROFILENAME:	/* Create */
		*write_method = write_mtpLsProfileName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsProfileNameLen;
		rval = (u_char *) StorageTmp->mtpLsProfileName;
		break;
	case (u_char) MTPLSPROFILESLDEFAULT:	/* Create */
		*write_method = write_mtpLsProfileSlDefault;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsProfileSlDefaultLen;
		rval = (u_char *) StorageTmp->mtpLsProfileSlDefault;
		break;
	case (u_char) MTPLSPROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpLsProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpLsProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpLsTable_row(struct mtpLsTable_data *StorageTmp, struct mtpLsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpLsTable_row(struct mtpLsTable_data *StorageTmp, struct mtpLsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpLsTable_row(struct mtpLsTable_data *StorageTmp, struct mtpLsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpLsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpLsTable_row(struct mtpLsTable_data *StorageTmp, struct mtpLsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpLsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpLsTable_row(struct mtpLsTable_data *StorageTmp, struct mtpLsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpLsTable_row(struct mtpLsTable_data *StorageTmp, struct mtpLsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpLsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpLsTable_row(struct mtpLsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpLsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpLsTable_data *
refresh_mtpLsTable_row(struct mtpLsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpLsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpLsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpLsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpLsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpLsTable(int force)
{
	if (!force && mtpLsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpLsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpLsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpLsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpLsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpLsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpLsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpLsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpLsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpLsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPLSADJPC:	/* Create */
		*write_method = write_mtpLsAdjPc;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsAdjPcLen;
		rval = (u_char *) StorageTmp->mtpLsAdjPc;
		break;
	case (u_char) MTPLSRSID:	/* Create */
		*write_method = write_mtpLsRsId;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsRsIdLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpLsRsId;
		break;
	case (u_char) MTPLSMAXCAPACITY:	/* Create */
		*write_method = write_mtpLsMaxCapacity;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsMaxCapacity);
		rval = (u_char *) &StorageTmp->mtpLsMaxCapacity;
		break;
	case (u_char) MTPLSCURRENTCAPACITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsCurrentCapacity);
		rval = (u_char *) &StorageTmp->mtpLsCurrentCapacity;
		break;
	case (u_char) MTPLSCONGESTIONCONTROLMETHOD:	/* Create */
		*write_method = write_mtpLsCongestionControlMethod;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsCongestionControlMethod);
		rval = (u_char *) &StorageTmp->mtpLsCongestionControlMethod;
		break;
	case (u_char) MTPLSUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsUsageState);
		rval = (u_char *) &StorageTmp->mtpLsUsageState;
		break;
	case (u_char) MTPLSOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsOperationalState);
		rval = (u_char *) &StorageTmp->mtpLsOperationalState;
		break;
	case (u_char) MTPLSAVAILABILITYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsAvailabilityStatusLen;
		rval = (u_char *) StorageTmp->mtpLsAvailabilityStatus;
		break;
	case (u_char) MTPLSPERIODICLINKTESTFLAG:	/* Create */
		*write_method = write_mtpLsPeriodicLinkTestFlag;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFlag);
		rval = (u_char *) &StorageTmp->mtpLsPeriodicLinkTestFlag;
		break;
	case (u_char) MTPLSPERIODICLINKTESTFAIL:	/* Create */
		*write_method = write_mtpLsPeriodicLinkTestFail;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsPeriodicLinkTestFail);
		rval = (u_char *) &StorageTmp->mtpLsPeriodicLinkTestFail;
		break;
	case (u_char) MTPLSADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpLsAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpLsAdministrativeState;
		break;
	case (u_char) MTPLSINLSLOADSHAREALGORITHM:	/* Create */
		*write_method = write_mtpLsInLsLoadShareAlgorithm;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsInLsLoadShareAlgorithmLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpLsInLsLoadShareAlgorithm;
		break;
	case (u_char) MTPLSPROFILEPOINTER:	/* Create */
		*write_method = write_mtpLsProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsProfilePointerLen;
		rval = (u_char *) StorageTmp->mtpLsProfilePointer;
		break;
	case (u_char) MTPLSNUMBEROFNORMALLYACTIVESIGNLINKS:	/* Create */
		*write_method = write_mtpLsNumberOfNormallyActiveSignLinks;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsNumberOfNormallyActiveSignLinks);
		rval = (u_char *) &StorageTmp->mtpLsNumberOfNormallyActiveSignLinks;
		break;
	case (u_char) MTPLSNAME:	/* Create */
		*write_method = write_mtpLsName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsNameLen;
		rval = (u_char *) StorageTmp->mtpLsName;
		break;
	case (u_char) MTPLSASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpLsAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpLsAsaProfilePointer;
		break;
	case (u_char) MTPLSALARMSTATUS:	/* Create */
		*write_method = write_mtpLsAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpLsAlarmStatusLen;
		rval = (u_char *) StorageTmp->mtpLsAlarmStatus;
		break;
	case (u_char) MTPLSROWSTATUS:	/* Create */
		*write_method = write_mtpLsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpLsRowStatus);
		rval = (u_char *) &StorageTmp->mtpLsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp, struct mtpSlL3ProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp, struct mtpSlL3ProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp, struct mtpSlL3ProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSlL3ProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp, struct mtpSlL3ProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSlL3ProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp, struct mtpSlL3ProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp, struct mtpSlL3ProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSlL3ProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSlL3ProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSlL3ProfileTable_data *
refresh_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSlL3ProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSlL3ProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSlL3ProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSlL3ProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlL3ProfileTable(int force)
{
	if (!force && mtpSlL3ProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSlL3ProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSlL3ProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlL3ProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlL3ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlL3ProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlL3ProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSlL3ProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSlL3ProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSLL3PROFILETIMERT1:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1;
		break;
	case (u_char) MTPSLL3PROFILETIMERT3:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT3);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT3;
		break;
	case (u_char) MTPSLL3PROFILETIMERT17:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT17;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT17);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT17;
		break;
	case (u_char) MTPSLL3PROFILETIMERT24I:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT24I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT24I);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT24I;
		break;
	case (u_char) MTPSLL3PROFILENAME:	/* Create */
		*write_method = write_mtpSlL3ProfileName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlL3ProfileNameLen;
		rval = (u_char *) StorageTmp->mtpSlL3ProfileName;
		break;
	case (u_char) MTPSLL3PROFILETIMERT2:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT2);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT2;
		break;
	case (u_char) MTPSLL3PROFILETIMERT4:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT4;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT4);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT4;
		break;
	case (u_char) MTPSLL3PROFILETIMERT5:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT5;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT5);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT5;
		break;
	case (u_char) MTPSLL3PROFILETIMERT12:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT12;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT12);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT12;
		break;
	case (u_char) MTPSLL3PROFILETIMERT13:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT13;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT13);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT13;
		break;
	case (u_char) MTPSLL3PROFILETIMERT14:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT14;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT14);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT14;
		break;
	case (u_char) MTPSLL3PROFILETIMERT19A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT19A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT19A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT19A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT20A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT20A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT20A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT20A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT21A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT21A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT21A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT21A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT22I:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT22I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT22I);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT22I;
		break;
	case (u_char) MTPSLL3PROFILETIMERT23I:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT23I;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT23I);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT23I;
		break;
	case (u_char) MTPSLL3PROFILETIMERT31A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT31A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT31A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT31A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT32A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT32A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT32A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT32A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT33A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT33A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT33A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT33A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT34A:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT34A;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT34A);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT34A;
		break;
	case (u_char) MTPSLL3PROFILETIMERT1T:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT1T;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1T);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1T;
		break;
	case (u_char) MTPSLL3PROFILETIMERT2T:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT2T;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT2T);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT2T;
		break;
	case (u_char) MTPSLL3PROFILETIMERT1S:	/* Create */
		*write_method = write_mtpSlL3ProfileTimerT1S;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileTimerT1S);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileTimerT1S;
		break;
	case (u_char) MTPSLL3PROFILEL2DEFAULT:	/* Create */
		*write_method = write_mtpSlL3ProfileL2Default;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlL3ProfileL2DefaultLen;
		rval = (u_char *) StorageTmp->mtpSlL3ProfileL2Default;
		break;
	case (u_char) MTPSLL3PROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpSlL3ProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL3ProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpSlL3ProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp, struct mtpSlL2ProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp, struct mtpSlL2ProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp, struct mtpSlL2ProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSlL2ProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp, struct mtpSlL2ProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSlL2ProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp, struct mtpSlL2ProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp, struct mtpSlL2ProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSlL2ProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSlL2ProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSlL2ProfileTable_data *
refresh_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSlL2ProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSlL2ProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSlL2ProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSlL2ProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlL2ProfileTable(int force)
{
	if (!force && mtpSlL2ProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSlL2ProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSlL2ProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlL2ProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlL2ProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlL2ProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlL2ProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSlL2ProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSlL2ProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSLL2PROFILEERRORCORRECTIONMETHOD:	/* Create */
		*write_method = write_mtpSlL2ProfileErrorCorrectionMethod;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileErrorCorrectionMethod);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileErrorCorrectionMethod;
		break;
	case (u_char) MTPSLL2PROFILEPROTOCOLVARIANT:	/* Create */
		*write_method = write_mtpSlL2ProfileProtocolVariant;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlL2ProfileProtocolVariantLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlL2ProfileProtocolVariant;
		break;
	case (u_char) MTPSLL2PROFILETIMERT1:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT1);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT1;
		break;
	case (u_char) MTPSLL2PROFILETIMERT2:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2;
		break;
	case (u_char) MTPSLL2PROFILETIMERT2L:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT2L;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2L);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2L;
		break;
	case (u_char) MTPSLL2PROFILETIMERT2H:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT2H;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT2H);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT2H;
		break;
	case (u_char) MTPSLL2PROFILETIMERT3:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT3);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT3;
		break;
	case (u_char) MTPSLL2PROFILETIMERT4N:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT4N;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT4N);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT4N;
		break;
	case (u_char) MTPSLL2PROFILETIMERT4E:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT4E;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT4E);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT4E;
		break;
	case (u_char) MTPSLL2PROFILETIMERT5:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT5;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT5);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT5;
		break;
	case (u_char) MTPSLL2PROFILETIMERT6:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT6;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT6);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT6;
		break;
	case (u_char) MTPSLL2PROFILETIMERT7:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerT7;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerT7);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerT7;
		break;
	case (u_char) MTPSLL2PROFILETBONSET1:	/* Create */
		*write_method = write_mtpSlL2ProfileTbOnset1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset1);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset1;
		break;
	case (u_char) MTPSLL2PROFILETBABATE1:	/* Create */
		*write_method = write_mtpSlL2ProfileTbAbate1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate1);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate1;
		break;
	case (u_char) MTPSLL2PROFILENUMBEROFTHRESHOLDLEVELS:	/* Create */
		*write_method = write_mtpSlL2ProfileNumberOfThresholdLevels;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels;
		break;
	case (u_char) MTPSLL2PROFILECONGESTIONCOUNTING:	/* Create */
		*write_method = write_mtpSlL2ProfileCongestionCounting;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileCongestionCounting);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileCongestionCounting;
		break;
	case (u_char) MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT:	/* Create */
		*write_method = write_mtpSlL2ProfileCongestionReportingBaseObject;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject;
		break;
	case (u_char) MTPSLL2PROFILELOOPDELAY:	/* Create */
		*write_method = write_mtpSlL2ProfileLoopDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileLoopDelay);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileLoopDelay;
		break;
	case (u_char) MTPSLL2PROFILENAME:	/* Create */
		*write_method = write_mtpSlL2ProfileName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlL2ProfileNameLen;
		rval = (u_char *) StorageTmp->mtpSlL2ProfileName;
		break;
	case (u_char) MTPSLL2PROFILETBONSET2:	/* Create */
		*write_method = write_mtpSlL2ProfileTbOnset2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset2);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset2;
		break;
	case (u_char) MTPSLL2PROFILETBABATE2:	/* Create */
		*write_method = write_mtpSlL2ProfileTbAbate2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate2);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate2;
		break;
	case (u_char) MTPSLL2PROFILETBONSET3:	/* Create */
		*write_method = write_mtpSlL2ProfileTbOnset3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbOnset3);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbOnset3;
		break;
	case (u_char) MTPSLL2PROFILETBABATE3:	/* Create */
		*write_method = write_mtpSlL2ProfileTbAbate3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbAbate3);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbAbate3;
		break;
	case (u_char) MTPSLL2PROFILETBDISCARD1:	/* Create */
		*write_method = write_mtpSlL2ProfileTbDiscard1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard1);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard1;
		break;
	case (u_char) MTPSLL2PROFILETBDISCARD2:	/* Create */
		*write_method = write_mtpSlL2ProfileTbDiscard2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard2);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard2;
		break;
	case (u_char) MTPSLL2PROFILETBDISCARD3:	/* Create */
		*write_method = write_mtpSlL2ProfileTbDiscard3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTbDiscard3);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTbDiscard3;
		break;
	case (u_char) MTPSLL2PROFILETIMERTX:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerTx;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerTx);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerTx;
		break;
	case (u_char) MTPSLL2PROFILETIMERTY:	/* Create */
		*write_method = write_mtpSlL2ProfileTimerTy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileTimerTy);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileTimerTy;
		break;
	case (u_char) MTPSLL2PROFILENUMBEROFCONGESTIONSTATES:	/* Create */
		*write_method = write_mtpSlL2ProfileNumberOfCongestionStates;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileNumberOfCongestionStates);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileNumberOfCongestionStates;
		break;
	case (u_char) MTPSLL2PROFILEINITIALLEVELOFCONGESTION:	/* Create */
		*write_method = write_mtpSlL2ProfileInitialLevelOfCongestion;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion;
		break;
	case (u_char) MTPSLL2PROFILEMAXMSUSRETRANSN1:	/* Create */
		*write_method = write_mtpSlL2ProfileMaxMSUsRetransN1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1;
		break;
	case (u_char) MTPSLL2PROFILEMAXOCTRETRANSN2:	/* Create */
		*write_method = write_mtpSlL2ProfileMaxOctRetransN2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileMaxOctRetransN2);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileMaxOctRetransN2;
		break;
	case (u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDONSET:	/* Create */
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdOnset;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset;
		break;
	case (u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDABATE:	/* Create */
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdAbate;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate;
		break;
	case (u_char) MTPSLL2PROFILERECEIVECONGESTIONTHRESHOLDDISCARD:	/* Create */
		*write_method = write_mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		break;
	case (u_char) MTPSLL2PROFILEM:	/* Create */
		*write_method = write_mtpSlL2ProfileM;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileM);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileM;
		break;
	case (u_char) MTPSLL2PROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpSlL2ProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlL2ProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpSlL2ProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSlTable_row(struct mtpSlTable_data *StorageTmp, struct mtpSlTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSlTable_row(struct mtpSlTable_data *StorageTmp, struct mtpSlTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSlTable_row(struct mtpSlTable_data *StorageTmp, struct mtpSlTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSlTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSlTable_row(struct mtpSlTable_data *StorageTmp, struct mtpSlTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSlTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSlTable_row(struct mtpSlTable_data *StorageTmp, struct mtpSlTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSlTable_row(struct mtpSlTable_data *StorageTmp, struct mtpSlTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSlTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSlTable_row(struct mtpSlTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSlTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSlTable_data *
refresh_mtpSlTable_row(struct mtpSlTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSlTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSlTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSlTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSlTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlTable(int force)
{
	if (!force && mtpSlTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSlTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSlTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSlTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSlTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSLSLSCODECURRENTLIST:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSlsCodeCurrentListLen;
		rval = (u_char *) StorageTmp->mtpSlSlsCodeCurrentList;
		break;
	case (u_char) MTPSLMAXCAPACITYSL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlMaxCapacitySL);
		rval = (u_char *) &StorageTmp->mtpSlMaxCapacitySL;
		break;
	case (u_char) MTPSLCURRENTCAPACITYSL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlCurrentCapacitySL);
		rval = (u_char *) &StorageTmp->mtpSlCurrentCapacitySL;
		break;
	case (u_char) MTPSLLINKTPSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlLinkTpStatusLen;
		rval = (u_char *) StorageTmp->mtpSlLinkTpStatus;
		break;
	case (u_char) MTPSLADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpSlAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpSlAdministrativeState;
		break;
	case (u_char) MTPSLOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlOperationalState);
		rval = (u_char *) &StorageTmp->mtpSlOperationalState;
		break;
	case (u_char) MTPSLUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlUsageState);
		rval = (u_char *) &StorageTmp->mtpSlUsageState;
		break;
	case (u_char) MTPSLPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlProceduralStatusLen;
		rval = (u_char *) StorageTmp->mtpSlProceduralStatus;
		break;
	case (u_char) MTPSLMTPL2PROTOCOLPROFILEPOINTER:	/* Create */
		*write_method = write_mtpSlMtpL2ProtocolProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen;
		rval = (u_char *) StorageTmp->mtpSlMtpL2ProtocolProfilePointer;
		break;
	case (u_char) MTPSLSIGNTERMPOINTER:	/* Create */
		*write_method = write_mtpSlSignTermPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSignTermPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlSignTermPointer;
		break;
	case (u_char) MTPSLSIGNDATALINKTPPOINTER:	/* Create */
		*write_method = write_mtpSlSignDataLinkTpPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSignDataLinkTpPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlSignDataLinkTpPointer;
		break;
	case (u_char) MTPSLLOCALINHIBIT:	/* Create */
		*write_method = write_mtpSlLocalInhibit;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlLocalInhibit);
		rval = (u_char *) &StorageTmp->mtpSlLocalInhibit;
		break;
	case (u_char) MTPSLLOCALUNINHIBIT:	/* Create */
		*write_method = write_mtpSlLocalUninhibit;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlLocalUninhibit);
		rval = (u_char *) &StorageTmp->mtpSlLocalUninhibit;
		break;
	case (u_char) MTPSLREPLACEST:	/* Create */
		*write_method = write_mtpSlReplaceSt;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlReplaceSt);
		rval = (u_char *) &StorageTmp->mtpSlReplaceSt;
		break;
	case (u_char) MTPSLASAPROFILEPOINTER:	/* Create */
		*write_method = write_mtpSlAsaProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlAsaProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlAsaProfilePointer;
		break;
	case (u_char) MTPSLCONGESTIONLEVEL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlCongestionLevel);
		rval = (u_char *) &StorageTmp->mtpSlCongestionLevel;
		break;
	case (u_char) MTPSLRELATEDLINKGROUPNUMBER:	/* Create */
		*write_method = write_mtpSlRelatedLinkGroupNumber;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlRelatedLinkGroupNumber);
		rval = (u_char *) &StorageTmp->mtpSlRelatedLinkGroupNumber;
		break;
	case (u_char) MTPSLSDLLIST:	/* Create */
		*write_method = write_mtpSlSdlList;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlSdlList);
		rval = (u_char *) &StorageTmp->mtpSlSdlList;
		break;
	case (u_char) MTPSLTEST:	/* Create */
		*write_method = write_mtpSlTest;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlTest);
		rval = (u_char *) &StorageTmp->mtpSlTest;
		break;
	case (u_char) MTPSLNAME:	/* Create */
		*write_method = write_mtpSlName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlNameLen;
		rval = (u_char *) StorageTmp->mtpSlName;
		break;
	case (u_char) MTPSLSDTLIST:	/* Create */
		*write_method = write_mtpSlSdtList;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlSdtList);
		rval = (u_char *) &StorageTmp->mtpSlSdtList;
		break;
	case (u_char) MTPSLSLSCODENORMALLIST:	/* Create */
		*write_method = write_mtpSlSlsCodeNormalList;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSlsCodeNormalListLen;
		rval = (u_char *) StorageTmp->mtpSlSlsCodeNormalList;
		break;
	case (u_char) MTPSLL3PROFILEPOINTER:	/* Create */
		*write_method = write_mtpSlL3ProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlL3ProfilePointerLen;
		rval = (u_char *) StorageTmp->mtpSlL3ProfilePointer;
		break;
	case (u_char) MTPSLALARMSTATUS:	/* Create */
		*write_method = write_mtpSlAlarmStatus;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlAlarmStatusLen;
		rval = (u_char *) StorageTmp->mtpSlAlarmStatus;
		break;
	case (u_char) MTPSLROWSTATUS:	/* Create */
		*write_method = write_mtpSlRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlRowStatus);
		rval = (u_char *) &StorageTmp->mtpSlRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp, struct mtpSlSdlListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp, struct mtpSlSdlListTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp, struct mtpSlSdlListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSlSdlListTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp, struct mtpSlSdlListTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSlSdlListTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp, struct mtpSlSdlListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp, struct mtpSlSdlListTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSlSdlListTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSlSdlListTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSlSdlListTable_data *
refresh_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSlSdlListTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSlSdlListTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSlSdlListTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSlSdlListTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlSdlListTable(int force)
{
	if (!force && mtpSlSdlListTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSlSdlListTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSlSdlListTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlSdlListTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlSdlListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlSdlListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlSdlListTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSlSdlListTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSlSdlListTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSLSDLLISTPOINTER:	/* Create */
		*write_method = write_mtpSlSdlListPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSdlListPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlSdlListPointer;
		break;
	case (u_char) MTPSLSDLLISTROWSTATUS:	/* Create */
		*write_method = write_mtpSlSdlListRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlSdlListRowStatus);
		rval = (u_char *) &StorageTmp->mtpSlSdlListRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp, struct mtpSlSdtListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp, struct mtpSlSdtListTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp, struct mtpSlSdtListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSlSdtListTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp, struct mtpSlSdtListTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSlSdtListTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp, struct mtpSlSdtListTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp, struct mtpSlSdtListTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSlSdtListTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSlSdtListTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSlSdtListTable_data *
refresh_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSlSdtListTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSlSdtListTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSlSdtListTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSlSdtListTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSlSdtListTable(int force)
{
	if (!force && mtpSlSdtListTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSlSdtListTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSlSdtListTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSlSdtListTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSlSdtListTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSlSdtListTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSlSdtListTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSlSdtListTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSlSdtListTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSLSDTLISTPOINTER:	/* Create */
		*write_method = write_mtpSlSdtListPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSlSdtListPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSlSdtListPointer;
		break;
	case (u_char) MTPSLSDTLISTROWSTATUS:	/* Create */
		*write_method = write_mtpSlSdtListRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSlSdtListRowStatus);
		rval = (u_char *) &StorageTmp->mtpSlSdtListRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpNbTable_row(struct mtpNbTable_data *StorageTmp, struct mtpNbTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpNbTable_row(struct mtpNbTable_data *StorageTmp, struct mtpNbTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpNbTable_row(struct mtpNbTable_data *StorageTmp, struct mtpNbTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpNbTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpNbTable_row(struct mtpNbTable_data *StorageTmp, struct mtpNbTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpNbTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpNbTable_row(struct mtpNbTable_data *StorageTmp, struct mtpNbTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpNbTable_row(struct mtpNbTable_data *StorageTmp, struct mtpNbTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpNbTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpNbTable_row(struct mtpNbTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpNbTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpNbTable_data *
refresh_mtpNbTable_row(struct mtpNbTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpNbTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpNbTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpNbTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpNbTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpNbTable(int force)
{
	if (!force && mtpNbTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpNbTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpNbTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpNbTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpNbTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpNbTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpNbTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpNbTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpNbTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpNbTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPNBTRANSMISSIONRATE:	/* Create */
		*write_method = write_mtpNbTransmissionRate;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbTransmissionRate);
		rval = (u_char *) &StorageTmp->mtpNbTransmissionRate;
		break;
	case (u_char) MTPNBTIMERT8:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbTimerT8);
		rval = (u_char *) &StorageTmp->mtpNbTimerT8;
		break;
	case (u_char) MTPNBTIN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbTin);
		rval = (u_char *) &StorageTmp->mtpNbTin;
		break;
	case (u_char) MTPNBTIE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbTie);
		rval = (u_char *) &StorageTmp->mtpNbTie;
		break;
	case (u_char) MTPNBT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbT);
		rval = (u_char *) &StorageTmp->mtpNbT;
		break;
	case (u_char) MTPNBD:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbD);
		rval = (u_char *) &StorageTmp->mtpNbD;
		break;
	case (u_char) MTPNBTE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbTe);
		rval = (u_char *) &StorageTmp->mtpNbTe;
		break;
	case (u_char) MTPNBDE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbDe);
		rval = (u_char *) &StorageTmp->mtpNbDe;
		break;
	case (u_char) MTPNBUE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbUe);
		rval = (u_char *) &StorageTmp->mtpNbUe;
		break;
	case (u_char) MTPNBN:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbN);
		rval = (u_char *) &StorageTmp->mtpNbN;
		break;
	case (u_char) MTPNBM:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbm);
		rval = (u_char *) &StorageTmp->mtpNbm;
		break;
	case (u_char) MTPNBB:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbb);
		rval = (u_char *) &StorageTmp->mtpNbb;
		break;
	case (u_char) MTPNBF:	/* Create */
		*write_method = write_mtpNbf;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbf);
		rval = (u_char *) &StorageTmp->mtpNbf;
		break;
	case (u_char) MTPNBROWSTATUS:	/* Create */
		*write_method = write_mtpNbRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpNbRowStatus);
		rval = (u_char *) &StorageTmp->mtpNbRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp, struct mtpSaalTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp, struct mtpSaalTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp, struct mtpSaalTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSaalTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp, struct mtpSaalTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSaalTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp, struct mtpSaalTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp, struct mtpSaalTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSaalTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSaalTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSaalTable_data *
refresh_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSaalTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSaalTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSaalTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSaalTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSaalTable(int force)
{
	if (!force && mtpSaalTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSaalTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSaalTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSaalTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSaalTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSaalTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSaalTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSaalTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSaalTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSaalTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSAALBUFFERRELEASE:	/* Create */
		*write_method = write_mtpSaalBufferRelease;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalBufferRelease);
		rval = (u_char *) &StorageTmp->mtpSaalBufferRelease;
		break;
	case (u_char) MTPSAALMAXCC:	/* Create */
		*write_method = write_mtpSaalMaxCc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxCc);
		rval = (u_char *) &StorageTmp->mtpSaalMaxCc;
		break;
	case (u_char) MTPSAALMAXNRP:	/* Create */
		*write_method = write_mtpSaalMaxNrp;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxNrp);
		rval = (u_char *) &StorageTmp->mtpSaalMaxNrp;
		break;
	case (u_char) MTPSAALMAXINFORMATIONFIELDLENGTH:	/* Create */
		*write_method = write_mtpSaalMaxInformationFieldLength;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxInformationFieldLength);
		rval = (u_char *) &StorageTmp->mtpSaalMaxInformationFieldLength;
		break;
	case (u_char) MTPSAALMAXLENGTHSSCOPUUFIELD:	/* Create */
		*write_method = write_mtpSaalMaxLengthSscopUuField;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxLengthSscopUuField);
		rval = (u_char *) &StorageTmp->mtpSaalMaxLengthSscopUuField;
		break;
	case (u_char) MTPSAALMAXPD:	/* Create */
		*write_method = write_mtpSaalMaxPd;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxPd);
		rval = (u_char *) &StorageTmp->mtpSaalMaxPd;
		break;
	case (u_char) MTPSAALMAXSSCOPCREDITTOPEER:	/* Create */
		*write_method = write_mtpSaalMaxSscopCreditToPeer;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxSscopCreditToPeer);
		rval = (u_char *) &StorageTmp->mtpSaalMaxSscopCreditToPeer;
		break;
	case (u_char) MTPSAALMAXSTAT:	/* Create */
		*write_method = write_mtpSaalMaxStat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalMaxStat);
		rval = (u_char *) &StorageTmp->mtpSaalMaxStat;
		break;
	case (u_char) MTPSAALN1:	/* Create */
		*write_method = write_mtpSaalN1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalN1);
		rval = (u_char *) &StorageTmp->mtpSaalN1;
		break;
	case (u_char) MTPSAALNNILAYERMANAGEMENTPROVINGSTATE:	/* Create */
		*write_method = write_mtpSaalNniLayerManagementProvingState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementProvingState);
		rval = (u_char *) &StorageTmp->mtpSaalNniLayerManagementProvingState;
		break;
	case (u_char) MTPSAALNNILAYERMANAGEMENTTIMERNOCREDIT:	/* Create */
		*write_method = write_mtpSaalNniLayerManagementTimerNoCredit;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerNoCredit);
		rval = (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerNoCredit;
		break;
	case (u_char) MTPSAALNNILAYERMANAGEMENTTIMERREPEATSREC:	/* Create */
		*write_method = write_mtpSaalNniLayerManagementTimerRepeatSrec;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec);
		rval = (u_char *) &StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec;
		break;
	case (u_char) MTPSAALNNITIMERT1:	/* Create */
		*write_method = write_mtpSaalNniTimerT1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT1);
		rval = (u_char *) &StorageTmp->mtpSaalNniTimerT1;
		break;
	case (u_char) MTPSAALNNITIMERT2:	/* Create */
		*write_method = write_mtpSaalNniTimerT2;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT2);
		rval = (u_char *) &StorageTmp->mtpSaalNniTimerT2;
		break;
	case (u_char) MTPSAALNNITIMERT3:	/* Create */
		*write_method = write_mtpSaalNniTimerT3;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalNniTimerT3);
		rval = (u_char *) &StorageTmp->mtpSaalNniTimerT3;
		break;
	case (u_char) MTPSAALSSCOPTIMERCC:	/* Create */
		*write_method = write_mtpSaalSscopTimerCc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerCc);
		rval = (u_char *) &StorageTmp->mtpSaalSscopTimerCc;
		break;
	case (u_char) MTPSAALSSCOPTIMERIDLE:	/* Create */
		*write_method = write_mtpSaalSscopTimerIdle;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerIdle);
		rval = (u_char *) &StorageTmp->mtpSaalSscopTimerIdle;
		break;
	case (u_char) MTPSAALSSCOPTIMERKEEPALIVE:	/* Create */
		*write_method = write_mtpSaalSscopTimerKeepAlive;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerKeepAlive);
		rval = (u_char *) &StorageTmp->mtpSaalSscopTimerKeepAlive;
		break;
	case (u_char) MTPSAALSSCOPTIMERNORESPONSE:	/* Create */
		*write_method = write_mtpSaalSscopTimerNoResponse;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerNoResponse);
		rval = (u_char *) &StorageTmp->mtpSaalSscopTimerNoResponse;
		break;
	case (u_char) MTPSAALSSCOPTIMERPOLL:	/* Create */
		*write_method = write_mtpSaalSscopTimerPoll;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalSscopTimerPoll);
		rval = (u_char *) &StorageTmp->mtpSaalSscopTimerPoll;
		break;
	case (u_char) MTPSAALTRANSMISSIONRATEINTERVALLOWER:	/* Create */
		*write_method = write_mtpSaalTransmissionRateIntervalLower;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalLower);
		rval = (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalLower;
		break;
	case (u_char) MTPSAALTRANSMISSIONRATEINTERVALUPPER:	/* Create */
		*write_method = write_mtpSaalTransmissionRateIntervalUpper;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalTransmissionRateIntervalUpper);
		rval = (u_char *) &StorageTmp->mtpSaalTransmissionRateIntervalUpper;
		break;
	case (u_char) MTPSAALEGRESSTRANSMISSIONRATEINTERVALLOWER:	/* Create */
		*write_method = write_mtpSaalEgressTransmissionRateIntervalLower;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalLower);
		rval = (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalLower;
		break;
	case (u_char) MTPSAALEGRESSTRANSMISSIONRATEINTERVALUPPER:	/* Create */
		*write_method = write_mtpSaalEgressTransmissionRateIntervalUpper;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper);
		rval = (u_char *) &StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper;
		break;
	case (u_char) MTPSAALPOLLAFTERRETRANSMISSION:	/* Create */
		*write_method = write_mtpSaalPollAfterRetransmission;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalPollAfterRetransmission);
		rval = (u_char *) &StorageTmp->mtpSaalPollAfterRetransmission;
		break;
	case (u_char) MTPSAALROWSTATUS:	/* Create */
		*write_method = write_mtpSaalRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSaalRowStatus);
		rval = (u_char *) &StorageTmp->mtpSaalRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp, struct mtpM2paTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp, struct mtpM2paTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp, struct mtpM2paTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpM2paTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp, struct mtpM2paTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpM2paTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp, struct mtpM2paTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp, struct mtpM2paTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpM2paTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpM2paTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpM2paTable_data *
refresh_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpM2paTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpM2paTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpM2paTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpM2paTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM2paTable(int force)
{
	if (!force && mtpM2paTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpM2paTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpM2paTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM2paTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM2paTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM2paTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpM2paTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM2paTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpM2paTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpM2paTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPM2PAN1:	/* Create */
		*write_method = write_mtpM2paN1;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paN1);
		rval = (u_char *) &StorageTmp->mtpM2paN1;
		break;
	case (u_char) MTPM2PAPROVING:	/* Create */
		*write_method = write_mtpM2paProving;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paProving);
		rval = (u_char *) &StorageTmp->mtpM2paProving;
		break;
	case (u_char) MTPM2PAMANAGEMENTPROVINGSTATE:	/* Create */
		*write_method = write_mtpM2paManagementProvingState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paManagementProvingState);
		rval = (u_char *) &StorageTmp->mtpM2paManagementProvingState;
		break;
	case (u_char) MTPM2PAPROVINGATTEMPTS:	/* Create */
		*write_method = write_mtpM2paProvingAttempts;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paProvingAttempts);
		rval = (u_char *) &StorageTmp->mtpM2paProvingAttempts;
		break;
	case (u_char) MTPM2PASCTPNODELAY:	/* Create */
		*write_method = write_mtpM2paSctpNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpNoDelay);
		rval = (u_char *) &StorageTmp->mtpM2paSctpNoDelay;
		break;
	case (u_char) MTPM2PASCTPMAXSEG:	/* Create */
		*write_method = write_mtpM2paSctpMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxseg);
		rval = (u_char *) &StorageTmp->mtpM2paSctpMaxseg;
		break;
	case (u_char) MTPM2PASCTPHEARTBEATITVL:	/* Create */
		*write_method = write_mtpM2paSctpHeartbeatItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeatItvl);
		rval = (u_char *) &StorageTmp->mtpM2paSctpHeartbeatItvl;
		break;
	case (u_char) MTPM2PASCTPHEARTBEAT:	/* Create */
		*write_method = write_mtpM2paSctpHeartbeat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpHeartbeat);
		rval = (u_char *) &StorageTmp->mtpM2paSctpHeartbeat;
		break;
	case (u_char) MTPM2PASCTPRTOINITIAL:	/* Create */
		*write_method = write_mtpM2paSctpRtoInitial;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoInitial);
		rval = (u_char *) &StorageTmp->mtpM2paSctpRtoInitial;
		break;
	case (u_char) MTPM2PASCTPRTOMIN:	/* Create */
		*write_method = write_mtpM2paSctpRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMin);
		rval = (u_char *) &StorageTmp->mtpM2paSctpRtoMin;
		break;
	case (u_char) MTPM2PASCTPRTOMAX:	/* Create */
		*write_method = write_mtpM2paSctpRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpRtoMax);
		rval = (u_char *) &StorageTmp->mtpM2paSctpRtoMax;
		break;
	case (u_char) MTPM2PASCTPPATHMAXRETRANS:	/* Create */
		*write_method = write_mtpM2paSctpPathMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpPathMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpM2paSctpPathMaxRetrans;
		break;
	case (u_char) MTPM2PASCTPCOOKIELIFE:	/* Create */
		*write_method = write_mtpM2paSctpCookieLife;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieLife);
		rval = (u_char *) &StorageTmp->mtpM2paSctpCookieLife;
		break;
	case (u_char) MTPM2PASCTPCOOKIEINC:	/* Create */
		*write_method = write_mtpM2paSctpCookieInc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpCookieInc);
		rval = (u_char *) &StorageTmp->mtpM2paSctpCookieInc;
		break;
	case (u_char) MTPM2PASCTPMAXINITRETRIES:	/* Create */
		*write_method = write_mtpM2paSctpMaxInitRetries;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxInitRetries);
		rval = (u_char *) &StorageTmp->mtpM2paSctpMaxInitRetries;
		break;
	case (u_char) MTPM2PASCTPMAXBURST:	/* Create */
		*write_method = write_mtpM2paSctpMaxBurst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpMaxBurst);
		rval = (u_char *) &StorageTmp->mtpM2paSctpMaxBurst;
		break;
	case (u_char) MTPM2PASCTPASSOCMAXRETRANS:	/* Create */
		*write_method = write_mtpM2paSctpAssocMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpAssocMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpM2paSctpAssocMaxRetrans;
		break;
	case (u_char) MTPM2PASCTPSACKDELAY:	/* Create */
		*write_method = write_mtpM2paSctpSackDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpSackDelay);
		rval = (u_char *) &StorageTmp->mtpM2paSctpSackDelay;
		break;
	case (u_char) MTPM2PASCTPLIFETIME:	/* Create */
		*write_method = write_mtpM2paSctpLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paSctpLifetime);
		rval = (u_char *) &StorageTmp->mtpM2paSctpLifetime;
		break;
	case (u_char) MTPM2PALOOPDELAYLOWER:	/* Create */
		*write_method = write_mtpM2paLoopDelayLower;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayLower);
		rval = (u_char *) &StorageTmp->mtpM2paLoopDelayLower;
		break;
	case (u_char) MTPM2PALOOPDELAYUPPER:	/* Create */
		*write_method = write_mtpM2paLoopDelayUpper;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paLoopDelayUpper);
		rval = (u_char *) &StorageTmp->mtpM2paLoopDelayUpper;
		break;
	case (u_char) MTPM2PATRANSMISSIONRATEINTERVALLOWER:	/* Create */
		*write_method = write_mtpM2paTransmissionRateIntervalLower;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalLower);
		rval = (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalLower;
		break;
	case (u_char) MTPM2PATRANSMISSIONRATEINTERVALUPPER:	/* Create */
		*write_method = write_mtpM2paTransmissionRateIntervalUpper;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paTransmissionRateIntervalUpper);
		rval = (u_char *) &StorageTmp->mtpM2paTransmissionRateIntervalUpper;
		break;
	case (u_char) MTPM2PAROWSTATUS:	/* Create */
		*write_method = write_mtpM2paRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2paRowStatus);
		rval = (u_char *) &StorageTmp->mtpM2paRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp, struct mtpSdtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp, struct mtpSdtTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp, struct mtpSdtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSdtTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp, struct mtpSdtTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSdtTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp, struct mtpSdtTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp, struct mtpSdtTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSdtTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSdtTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSdtTable_data *
refresh_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSdtTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSdtTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSdtTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSdtTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSdtTable(int force)
{
	if (!force && mtpSdtTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSdtTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSdtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSdtTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSdtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdtTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSdtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSdtTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSdtTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSdtTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSDTADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpSdtAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpSdtAdministrativeState;
		break;
	case (u_char) MTPSDTOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtOperationalState);
		rval = (u_char *) &StorageTmp->mtpSdtOperationalState;
		break;
	case (u_char) MTPSDTUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtUsageState);
		rval = (u_char *) &StorageTmp->mtpSdtUsageState;
		break;
	case (u_char) MTPSDTPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdtProceduralStatusLen;
		rval = (u_char *) StorageTmp->mtpSdtProceduralStatus;
		break;
	case (u_char) MTPSDTAVAILABILITYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdtAvailabilityStatusLen;
		rval = (u_char *) StorageTmp->mtpSdtAvailabilityStatus;
		break;
	case (u_char) MTPSDTEQUIPMENTPOINTER:	/* Create */
		*write_method = write_mtpSdtEquipmentPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdtEquipmentPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSdtEquipmentPointer;
		break;
	case (u_char) MTPSDTNAME:	/* Create */
		*write_method = write_mtpSdtName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdtNameLen;
		rval = (u_char *) StorageTmp->mtpSdtName;
		break;
	case (u_char) MTPSDTSTANDBYSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtStandbyStatus);
		rval = (u_char *) &StorageTmp->mtpSdtStandbyStatus;
		break;
	case (u_char) MTPSDTPRIMARYID:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtPrimaryId);
		rval = (u_char *) &StorageTmp->mtpSdtPrimaryId;
		break;
	case (u_char) MTPSDTPROFILEPOINTER:	/* Create */
		*write_method = write_mtpSdtProfilePointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdtProfilePointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSdtProfilePointer;
		break;
	case (u_char) MTPSDTROWSTATUS:	/* Create */
		*write_method = write_mtpSdtRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdtRowStatus);
		rval = (u_char *) &StorageTmp->mtpSdtRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp, struct mtpSdlTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp, struct mtpSdlTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp, struct mtpSdlTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSdlTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp, struct mtpSdlTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSdlTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp, struct mtpSdlTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp, struct mtpSdlTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSdlTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSdlTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSdlTable_data *
refresh_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSdlTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSdlTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSdlTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSdlTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSdlTable(int force)
{
	if (!force && mtpSdlTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSdlTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSdlTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSdlTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSdlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSdlTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSdlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSdlTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSdlTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSdlTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSDLTYPE:	/* Create */
		*write_method = write_mtpSdlType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlType);
		rval = (u_char *) &StorageTmp->mtpSdlType;
		break;
	case (u_char) MTPSDLADJPC:	/* Create */
		*write_method = write_mtpSdlAdjPc;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlAdjPcLen;
		rval = (u_char *) StorageTmp->mtpSdlAdjPc;
		break;
	case (u_char) MTPSDLLOOPDELAY:	/* Create */
		*write_method = write_mtpSdlLoopDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlLoopDelay);
		rval = (u_char *) &StorageTmp->mtpSdlLoopDelay;
		break;
	case (u_char) MTPSDLOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlOperationalState);
		rval = (u_char *) &StorageTmp->mtpSdlOperationalState;
		break;
	case (u_char) MTPSDLEQUIPMENTPOINTER:	/* Create */
		*write_method = write_mtpSdlEquipmentPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlEquipmentPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSdlEquipmentPointer;
		break;
	case (u_char) MTPSDLCIC:	/* Create */
		*write_method = write_mtpSdlCIC;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlCIC);
		rval = (u_char *) &StorageTmp->mtpSdlCIC;
		break;
	case (u_char) MTPSDLTRANSMISSIONRATE:	/* Create */
		*write_method = write_mtpSdlTransmissionRate;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlTransmissionRate);
		rval = (u_char *) &StorageTmp->mtpSdlTransmissionRate;
		break;
	case (u_char) MTPSDLSTMCHANNEL:	/* Create */
		*write_method = write_mtpSdlStmChannel;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlStmChannelLen;
		rval = (u_char *) StorageTmp->mtpSdlStmChannel;
		break;
	case (u_char) MTPSDLVCTTPPOINTER:	/* Create */
		*write_method = write_mtpSdlVcTTpPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlVcTTpPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSdlVcTTpPointer;
		break;
	case (u_char) MTPSDLSCTPPOINTER:	/* Create */
		*write_method = write_mtpSdlSctpPointer;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlSctpPointerLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpSdlSctpPointer;
		break;
	case (u_char) MTPSDLNAME:	/* Create */
		*write_method = write_mtpSdlName;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSdlNameLen;
		rval = (u_char *) StorageTmp->mtpSdlName;
		break;
	case (u_char) MTPSDLROWSTATUS:	/* Create */
		*write_method = write_mtpSdlRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSdlRowStatus);
		rval = (u_char *) &StorageTmp->mtpSdlRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp, struct mtpSctpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp, struct mtpSctpProfileTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp, struct mtpSctpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSctpProfileTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp, struct mtpSctpProfileTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSctpProfileTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp, struct mtpSctpProfileTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp, struct mtpSctpProfileTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSctpProfileTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSctpProfileTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSctpProfileTable_data *
refresh_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSctpProfileTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSctpProfileTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSctpProfileTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSctpProfileTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSctpProfileTable(int force)
{
	if (!force && mtpSctpProfileTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSctpProfileTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSctpProfileTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSctpProfileTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSctpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSctpProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSctpProfileTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSctpProfileTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSctpProfileTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSCTPPROFILENODELAY:	/* Create */
		*write_method = write_mtpSctpProfileNoDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileNoDelay);
		rval = (u_char *) &StorageTmp->mtpSctpProfileNoDelay;
		break;
	case (u_char) MTPSCTPPROFILEMAXSEG:	/* Create */
		*write_method = write_mtpSctpProfileMaxseg;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileMaxseg);
		rval = (u_char *) &StorageTmp->mtpSctpProfileMaxseg;
		break;
	case (u_char) MTPSCTPPROFILEHEARTBEATITVL:	/* Create */
		*write_method = write_mtpSctpProfileHeartbeatItvl;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileHeartbeatItvl);
		rval = (u_char *) &StorageTmp->mtpSctpProfileHeartbeatItvl;
		break;
	case (u_char) MTPSCTPPROFILEHEARTBEAT:	/* Create */
		*write_method = write_mtpSctpProfileHeartbeat;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileHeartbeat);
		rval = (u_char *) &StorageTmp->mtpSctpProfileHeartbeat;
		break;
	case (u_char) MTPSCTPPROFILERTOINITIAL:	/* Create */
		*write_method = write_mtpSctpProfileRtoInitial;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileRtoInitial);
		rval = (u_char *) &StorageTmp->mtpSctpProfileRtoInitial;
		break;
	case (u_char) MTPSCTPPROFILERTOMIN:	/* Create */
		*write_method = write_mtpSctpProfileRtoMin;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileRtoMin);
		rval = (u_char *) &StorageTmp->mtpSctpProfileRtoMin;
		break;
	case (u_char) MTPSCTPPROFILERTOMAX:	/* Create */
		*write_method = write_mtpSctpProfileRtoMax;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileRtoMax);
		rval = (u_char *) &StorageTmp->mtpSctpProfileRtoMax;
		break;
	case (u_char) MTPSCTPPROFILEPATHMAXRETRANS:	/* Create */
		*write_method = write_mtpSctpProfilePathMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfilePathMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpSctpProfilePathMaxRetrans;
		break;
	case (u_char) MTPSCTPPROFILECOOKIELIFE:	/* Create */
		*write_method = write_mtpSctpProfileCookieLife;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileCookieLife);
		rval = (u_char *) &StorageTmp->mtpSctpProfileCookieLife;
		break;
	case (u_char) MTPSCTPPROFILECOOKIEINC:	/* Create */
		*write_method = write_mtpSctpProfileCookieInc;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileCookieInc);
		rval = (u_char *) &StorageTmp->mtpSctpProfileCookieInc;
		break;
	case (u_char) MTPSCTPPROFILEMAXINITRETRIES:	/* Create */
		*write_method = write_mtpSctpProfileMaxInitRetries;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileMaxInitRetries);
		rval = (u_char *) &StorageTmp->mtpSctpProfileMaxInitRetries;
		break;
	case (u_char) MTPSCTPPROFILEMAXBURST:	/* Create */
		*write_method = write_mtpSctpProfileMaxBurst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileMaxBurst);
		rval = (u_char *) &StorageTmp->mtpSctpProfileMaxBurst;
		break;
	case (u_char) MTPSCTPPROFILEASSOCMAXRETRANS:	/* Create */
		*write_method = write_mtpSctpProfileAssocMaxRetrans;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileAssocMaxRetrans);
		rval = (u_char *) &StorageTmp->mtpSctpProfileAssocMaxRetrans;
		break;
	case (u_char) MTPSCTPPROFILESACKDELAY:	/* Create */
		*write_method = write_mtpSctpProfileSackDelay;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileSackDelay);
		rval = (u_char *) &StorageTmp->mtpSctpProfileSackDelay;
		break;
	case (u_char) MTPSCTPPROFILELIFETIME:	/* Create */
		*write_method = write_mtpSctpProfileLifetime;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileLifetime);
		rval = (u_char *) &StorageTmp->mtpSctpProfileLifetime;
		break;
	case (u_char) MTPSCTPPROFILEMINOSTREAMS:	/* Create */
		*write_method = write_mtpSctpProfileMinOstreams;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileMinOstreams);
		rval = (u_char *) &StorageTmp->mtpSctpProfileMinOstreams;
		break;
	case (u_char) MTPSCTPPROFILEMAXISTREAMS:	/* Create */
		*write_method = write_mtpSctpProfileMaxIstreams;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileMaxIstreams);
		rval = (u_char *) &StorageTmp->mtpSctpProfileMaxIstreams;
		break;
	case (u_char) MTPSCTPPROFILEROWSTATUS:	/* Create */
		*write_method = write_mtpSctpProfileRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProfileRowStatus);
		rval = (u_char *) &StorageTmp->mtpSctpProfileRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp, struct mtpSctpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp, struct mtpSctpTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp, struct mtpSctpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSctpTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp, struct mtpSctpTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSctpTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp, struct mtpSctpTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp, struct mtpSctpTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSctpTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSctpTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSctpTable_data *
refresh_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSctpTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSctpTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSctpTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSctpTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSctpTable(int force)
{
	if (!force && mtpSctpTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSctpTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSctpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSctpTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSctpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSctpTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSctpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSctpTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSctpTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSctpTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSCTPADMINISTRATIVESTATE:	/* Create */
		*write_method = write_mtpSctpAdministrativeState;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpAdministrativeState);
		rval = (u_char *) &StorageTmp->mtpSctpAdministrativeState;
		break;
	case (u_char) MTPSCTPOPERATIONALSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpOperationalState);
		rval = (u_char *) &StorageTmp->mtpSctpOperationalState;
		break;
	case (u_char) MTPSCTPUSAGESTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpUsageState);
		rval = (u_char *) &StorageTmp->mtpSctpUsageState;
		break;
	case (u_char) MTPSCTPPROCEDURALSTATUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSctpProceduralStatusLen;
		rval = (u_char *) StorageTmp->mtpSctpProceduralStatus;
		break;
	case (u_char) MTPSCTPLOCALPORT:	/* Create */
		*write_method = write_mtpSctpLocalPort;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpLocalPort);
		rval = (u_char *) &StorageTmp->mtpSctpLocalPort;
		break;
	case (u_char) MTPSCTPREMOTEPORT:	/* Create */
		*write_method = write_mtpSctpRemotePort;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpRemotePort);
		rval = (u_char *) &StorageTmp->mtpSctpRemotePort;
		break;
	case (u_char) MTPSCTPPROFILE:	/* Create */
		*write_method = write_mtpSctpProfile;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSctpProfileLen;
		rval = (u_char *) StorageTmp->mtpSctpProfile;
		break;
	case (u_char) MTPSCTPPROTOCOLPAYLOADID:	/* Create */
		*write_method = write_mtpSctpProtocolPayloadId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpProtocolPayloadId);
		rval = (u_char *) &StorageTmp->mtpSctpProtocolPayloadId;
		break;
	case (u_char) MTPSCTPROWSTATUS:	/* Create */
		*write_method = write_mtpSctpRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpRowStatus);
		rval = (u_char *) &StorageTmp->mtpSctpRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp, struct mtpSctpLocalTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp, struct mtpSctpLocalTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp, struct mtpSctpLocalTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSctpLocalTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp, struct mtpSctpLocalTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSctpLocalTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp, struct mtpSctpLocalTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp, struct mtpSctpLocalTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSctpLocalTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSctpLocalTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSctpLocalTable_data *
refresh_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSctpLocalTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSctpLocalTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSctpLocalTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSctpLocalTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSctpLocalTable(int force)
{
	if (!force && mtpSctpLocalTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSctpLocalTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSctpLocalTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSctpLocalTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSctpLocalTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSctpLocalTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSctpLocalTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSctpLocalTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSctpLocalTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSctpLocalTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSCTPLOCALADDRESS:	/* Create */
		*write_method = write_mtpSctpLocalAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSctpLocalAddressLen;
		rval = (u_char *) StorageTmp->mtpSctpLocalAddress;
		break;
	case (u_char) MTPSCTPLOCALROWSTATUS:	/* Create */
		*write_method = write_mtpSctpLocalRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpLocalRowStatus);
		rval = (u_char *) &StorageTmp->mtpSctpLocalRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp, struct mtpSctpRemoteTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp, struct mtpSctpRemoteTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp, struct mtpSctpRemoteTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpSctpRemoteTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp, struct mtpSctpRemoteTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpSctpRemoteTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp, struct mtpSctpRemoteTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp, struct mtpSctpRemoteTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpSctpRemoteTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpSctpRemoteTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpSctpRemoteTable_data *
refresh_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpSctpRemoteTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpSctpRemoteTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpSctpRemoteTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpSctpRemoteTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpSctpRemoteTable(int force)
{
	if (!force && mtpSctpRemoteTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpSctpRemoteTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpSctpRemoteTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpSctpRemoteTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpSctpRemoteTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpSctpRemoteTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpSctpRemoteTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpSctpRemoteTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpSctpRemoteTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpSctpRemoteTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPSCTPREMOTEADDRESS:	/* Create */
		*write_method = write_mtpSctpRemoteAddress;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpSctpRemoteAddressLen;
		rval = (u_char *) StorageTmp->mtpSctpRemoteAddress;
		break;
	case (u_char) MTPSCTPREMOTEROWSTATUS:	/* Create */
		*write_method = write_mtpSctpRemoteRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpSctpRemoteRowStatus);
		rval = (u_char *) &StorageTmp->mtpSctpRemoteRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp, struct mtpM2uaAspTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp, struct mtpM2uaAspTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp, struct mtpM2uaAspTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpM2uaAspTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp, struct mtpM2uaAspTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpM2uaAspTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp, struct mtpM2uaAspTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp, struct mtpM2uaAspTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpM2uaAspTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpM2uaAspTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpM2uaAspTable_data *
refresh_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpM2uaAspTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpM2uaAspTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpM2uaAspTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpM2uaAspTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM2uaAspTable(int force)
{
	if (!force && mtpM2uaAspTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpM2uaAspTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpM2uaAspTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM2uaAspTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM2uaAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpM2uaAspTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM2uaAspTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpM2uaAspTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpM2uaAspTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPM2UAASPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspState);
		rval = (u_char *) &StorageTmp->mtpM2uaAspState;
		break;
	case (u_char) MTPM2UAASPID:	/* Create */
		*write_method = write_mtpM2uaAspId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspId);
		rval = (u_char *) &StorageTmp->mtpM2uaAspId;
		break;
	case (u_char) MTPM2UAASPCAPABILITIES:	/* Create */
		*write_method = write_mtpM2uaAspCapabilities;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM2uaAspCapabilitiesLen;
		rval = (u_char *) StorageTmp->mtpM2uaAspCapabilities;
		break;
	case (u_char) MTPM2UAASPSGVERSION:	/* Create */
		*write_method = write_mtpM2uaAspSgVersion;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM2uaAspSgVersionLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpM2uaAspSgVersion;
		break;
	case (u_char) MTPM2UAASPSGOPTIONS:	/* Create */
		*write_method = write_mtpM2uaAspSgOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM2uaAspSgOptionsLen;
		rval = (u_char *) StorageTmp->mtpM2uaAspSgOptions;
		break;
	case (u_char) MTPM2UAASPSGREGISTRATIONPOLICY:	/* Create */
		*write_method = write_mtpM2uaAspSgRegistrationPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspSgRegistrationPolicy);
		rval = (u_char *) &StorageTmp->mtpM2uaAspSgRegistrationPolicy;
		break;
	case (u_char) MTPM2UAASPSGASPIDPOLICY:	/* Create */
		*write_method = write_mtpM2uaAspSgAspIdPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspSgAspIdPolicy);
		rval = (u_char *) &StorageTmp->mtpM2uaAspSgAspIdPolicy;
		break;
	case (u_char) MTPM2UAASPASSOCIATIONPOLICY:	/* Create */
		*write_method = write_mtpM2uaAspAssociationPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspAssociationPolicy);
		rval = (u_char *) &StorageTmp->mtpM2uaAspAssociationPolicy;
		break;
	case (u_char) MTPM2UAASPPROTOCOLPAYLOADID:	/* Create */
		*write_method = write_mtpM2uaAspProtocolPayloadId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspProtocolPayloadId);
		rval = (u_char *) &StorageTmp->mtpM2uaAspProtocolPayloadId;
		break;
	case (u_char) MTPM2UAASPROWSTATUS:	/* Create */
		*write_method = write_mtpM2uaAspRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAspRowStatus);
		rval = (u_char *) &StorageTmp->mtpM2uaAspRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp, struct mtpM2uaAsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp, struct mtpM2uaAsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp, struct mtpM2uaAsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpM2uaAsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp, struct mtpM2uaAsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpM2uaAsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp, struct mtpM2uaAsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp, struct mtpM2uaAsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpM2uaAsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpM2uaAsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpM2uaAsTable_data *
refresh_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpM2uaAsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpM2uaAsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpM2uaAsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpM2uaAsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM2uaAsTable(int force)
{
	if (!force && mtpM2uaAsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpM2uaAsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpM2uaAsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM2uaAsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM2uaAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM2uaAsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpM2uaAsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM2uaAsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpM2uaAsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpM2uaAsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPM2UAASSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAsState);
		rval = (u_char *) &StorageTmp->mtpM2uaAsState;
		break;
	case (u_char) MTPM2UAASINTERFACEIDENTIFIER:	/* Create */
		*write_method = write_mtpM2uaAsInterfaceIdentifier;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAsInterfaceIdentifier);
		rval = (u_char *) &StorageTmp->mtpM2uaAsInterfaceIdentifier;
		break;
	case (u_char) MTPM2UAINTERFACEIDENTIFIERTEXT:	/* Create */
		*write_method = write_mtpM2uaInterfaceIdentifierText;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM2uaInterfaceIdentifierTextLen;
		rval = (u_char *) StorageTmp->mtpM2uaInterfaceIdentifierText;
		break;
	case (u_char) MTPM2UAASSDTI:	/* Create */
		*write_method = write_mtpM2uaAsSDTI;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAsSDTI);
		rval = (u_char *) &StorageTmp->mtpM2uaAsSDTI;
		break;
	case (u_char) MTPM2UAASTRAFFICMODE:	/* Create */
		*write_method = write_mtpM2uaAsTrafficMode;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM2uaAsTrafficModeLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpM2uaAsTrafficMode;
		break;
	case (u_char) MTPM2UAASROWSTATUS:	/* Create */
		*write_method = write_mtpM2uaAsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM2uaAsRowStatus);
		rval = (u_char *) &StorageTmp->mtpM2uaAsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp, struct mtpM3uaAspTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp, struct mtpM3uaAspTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp, struct mtpM3uaAspTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpM3uaAspTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp, struct mtpM3uaAspTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpM3uaAspTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp, struct mtpM3uaAspTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp, struct mtpM3uaAspTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpM3uaAspTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpM3uaAspTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpM3uaAspTable_data *
refresh_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpM3uaAspTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpM3uaAspTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpM3uaAspTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpM3uaAspTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM3uaAspTable(int force)
{
	if (!force && mtpM3uaAspTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpM3uaAspTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpM3uaAspTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM3uaAspTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM3uaAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpM3uaAspTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM3uaAspTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpM3uaAspTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpM3uaAspTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPM3UAASPSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspState);
		rval = (u_char *) &StorageTmp->mtpM3uaAspState;
		break;
	case (u_char) MTPM3UAASTYPE:	/* Create */
		*write_method = write_mtpM3uaAsType;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAsType);
		rval = (u_char *) &StorageTmp->mtpM3uaAsType;
		break;
	case (u_char) MTPM3UAASPID:	/* Create */
		*write_method = write_mtpM3uaAspId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspId);
		rval = (u_char *) &StorageTmp->mtpM3uaAspId;
		break;
	case (u_char) MTPM3UAASPCAPABILITIES:	/* Create */
		*write_method = write_mtpM3uaAspCapabilities;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM3uaAspCapabilitiesLen;
		rval = (u_char *) StorageTmp->mtpM3uaAspCapabilities;
		break;
	case (u_char) MTPM3UAASPSGVERSION:	/* Create */
		*write_method = write_mtpM3uaAspSgVersion;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM3uaAspSgVersionLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpM3uaAspSgVersion;
		break;
	case (u_char) MTPM3UAASPSGOPTIONS:	/* Create */
		*write_method = write_mtpM3uaAspSgOptions;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM3uaAspSgOptionsLen;
		rval = (u_char *) StorageTmp->mtpM3uaAspSgOptions;
		break;
	case (u_char) MTPM3UAASPSGREGISTRATIONPOLICY:	/* Create */
		*write_method = write_mtpM3uaAspSgRegistrationPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspSgRegistrationPolicy);
		rval = (u_char *) &StorageTmp->mtpM3uaAspSgRegistrationPolicy;
		break;
	case (u_char) MTPM3UAASPSGASPIDPOLICY:	/* Create */
		*write_method = write_mtpM3uaAspSgAspIdPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspSgAspIdPolicy);
		rval = (u_char *) &StorageTmp->mtpM3uaAspSgAspIdPolicy;
		break;
	case (u_char) MTPM3UAASPASSOCIATIONPOLICY:	/* Create */
		*write_method = write_mtpM3uaAspAssociationPolicy;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspAssociationPolicy);
		rval = (u_char *) &StorageTmp->mtpM3uaAspAssociationPolicy;
		break;
	case (u_char) MTPM3UAASPPROTOCOLPAYLOADID:	/* Create */
		*write_method = write_mtpM3uaAspProtocolPayloadId;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspProtocolPayloadId);
		rval = (u_char *) &StorageTmp->mtpM3uaAspProtocolPayloadId;
		break;
	case (u_char) MTPM3UAASPROWSTATUS:	/* Create */
		*write_method = write_mtpM3uaAspRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAspRowStatus);
		rval = (u_char *) &StorageTmp->mtpM3uaAspRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp, struct mtpM3uaAsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp, struct mtpM3uaAsTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp, struct mtpM3uaAsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpM3uaAsTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp, struct mtpM3uaAsTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpM3uaAsTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp, struct mtpM3uaAsTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp, struct mtpM3uaAsTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpM3uaAsTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpM3uaAsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpM3uaAsTable_data *
refresh_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpM3uaAsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpM3uaAsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpM3uaAsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpM3uaAsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpM3uaAsTable(int force)
{
	if (!force && mtpM3uaAsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpM3uaAsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpM3uaAsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpM3uaAsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpMIB above.
 */
u_char *
var_mtpM3uaAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpM3uaAsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpMIB", "var_mtpM3uaAsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpM3uaAsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpM3uaAsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpM3uaAsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPM3UAASSTATE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAsState);
		rval = (u_char *) &StorageTmp->mtpM3uaAsState;
		break;
	case (u_char) MTPM3UAASROUTINGCONTEXT:	/* Create */
		*write_method = write_mtpM3uaAsRoutingContext;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAsRoutingContext);
		rval = (u_char *) &StorageTmp->mtpM3uaAsRoutingContext;
		break;
	case (u_char) MTPM3UAASNETWORKAPPEARANCE:	/* Create */
		*write_method = write_mtpM3uaAsNetworkAppearance;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAsNetworkAppearance);
		rval = (u_char *) &StorageTmp->mtpM3uaAsNetworkAppearance;
		break;
	case (u_char) MTPM3UAASNETWORKPOINTCODE:	/* Create */
		*write_method = write_mtpM3uaAsNetworkPointCode;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM3uaAsNetworkPointCodeLen;
		rval = (u_char *) StorageTmp->mtpM3uaAsNetworkPointCode;
		break;
	case (u_char) MTPM3UAASTRAFFICMODE:	/* Create */
		*write_method = write_mtpM3uaAsTrafficMode;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpM3uaAsTrafficModeLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpM3uaAsTrafficMode;
		break;
	case (u_char) MTPM3UAASROWSTATUS:	/* Create */
		*write_method = write_mtpM3uaAsRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpM3uaAsRowStatus);
		rval = (u_char *) &StorageTmp->mtpM3uaAsRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_mtpSapUserPart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapUserPart(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapUserPart entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAPUSERPART_SNMM:
		case MTPSAPUSERPART_SNTM:
		case MTPSAPUSERPART_SNSM:
		case MTPSAPUSERPART_SCCP:
		case MTPSAPUSERPART_TUP:
		case MTPSAPUSERPART_ISUP:
		case MTPSAPUSERPART_DUP1:
		case MTPSAPUSERPART_DUP2:
		case MTPSAPUSERPART_MTUP:
		case MTPSAPUSERPART_BISUP:
		case MTPSAPUSERPART_SIUP:
		case MTPSAPUSERPART_SPNEUP:
		case MTPSAPUSERPART_STC:
		case MTPSAPUSERPART_USER13:
		case MTPSAPUSERPART_USER14:
		case MTPSAPUSERPART_USER15:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPart: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			if (StorageTmp->mtpSapTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSapTable_old = mtpSapTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSapTable_rsvs++;
		StorageTmp->mtpSapUserPart = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSapTable_tsts == 0)
				if ((ret = check_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapUserPart for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSapTable_sets == 0)
				if ((ret = update_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
			StorageTmp->mtpSapTable_rsvs = 0;
			StorageTmp->mtpSapTable_tsts = 0;
			StorageTmp->mtpSapTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSapTable_sets == 0)
			revert_mtpSapTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		StorageTmp->mtpSapUserPart = StorageOld->mtpSapUserPart;
		if (--StorageTmp->mtpSapTable_rsvs == 0)
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapUserPartStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapUserPartStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapUserPartStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSAPUSERPARTSTATUS_UNKNOWN:
		case MTPSAPUSERPARTSTATUS_INACCESSIBLE:
		case MTPSAPUSERPARTSTATUS_UNEQUIPPED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapUserPartStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			if (StorageTmp->mtpSapTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSapTable_old = mtpSapTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSapTable_rsvs++;
		StorageTmp->mtpSapUserPartStatus = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSapTable_tsts == 0)
				if ((ret = check_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapUserPartStatus for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSapTable_sets == 0)
				if ((ret = update_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
			StorageTmp->mtpSapTable_rsvs = 0;
			StorageTmp->mtpSapTable_tsts = 0;
			StorageTmp->mtpSapTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSapTable_sets == 0)
			revert_mtpSapTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		StorageTmp->mtpSapUserPartStatus = StorageOld->mtpSapUserPartStatus;
		if (--StorageTmp->mtpSapTable_rsvs == 0)
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapProviderEntityNames(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapProviderEntityNames entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapProviderEntityNames: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			if (StorageTmp->mtpSapTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSapTable_old = mtpSapTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSapTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSapProviderEntityNames);
		StorageTmp->mtpSapProviderEntityNames = objid;
		StorageTmp->mtpSapProviderEntityNamesLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSapTable_tsts == 0)
				if ((ret = check_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapProviderEntityNames for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSapTable_sets == 0)
				if ((ret = update_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
			StorageTmp->mtpSapTable_rsvs = 0;
			StorageTmp->mtpSapTable_tsts = 0;
			StorageTmp->mtpSapTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSapTable_sets == 0)
			revert_mtpSapTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		if (StorageOld->mtpSapProviderEntityNames != NULL) {
			SNMP_FREE(StorageTmp->mtpSapProviderEntityNames);
			StorageTmp->mtpSapProviderEntityNames = StorageOld->mtpSapProviderEntityNames;
			StorageTmp->mtpSapProviderEntityNamesLen = StorageOld->mtpSapProviderEntityNamesLen;
			StorageOld->mtpSapProviderEntityNames = NULL;
			StorageOld->mtpSapProviderEntityNamesLen = 0;
		}
		if (--StorageTmp->mtpSapTable_rsvs == 0)
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			if (StorageTmp->mtpSapTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSapTable_old = mtpSapTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSapTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSapAsaProfilePointer);
		StorageTmp->mtpSapAsaProfilePointer = objid;
		StorageTmp->mtpSapAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSapTable_tsts == 0)
				if ((ret = check_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSapTable_sets == 0)
				if ((ret = update_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
			StorageTmp->mtpSapTable_rsvs = 0;
			StorageTmp->mtpSapTable_tsts = 0;
			StorageTmp->mtpSapTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSapTable_sets == 0)
			revert_mtpSapTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		if (StorageOld->mtpSapAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSapAsaProfilePointer);
			StorageTmp->mtpSapAsaProfilePointer = StorageOld->mtpSapAsaProfilePointer;
			StorageTmp->mtpSapAsaProfilePointerLen = StorageOld->mtpSapAsaProfilePointerLen;
			StorageOld->mtpSapAsaProfilePointer = NULL;
			StorageOld->mtpSapAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpSapTable_rsvs == 0)
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			if (StorageTmp->mtpSapTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSapTable_old = mtpSapTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSapTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSapName);
		StorageTmp->mtpSapName = string;
		StorageTmp->mtpSapNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSapTable_tsts == 0)
				if ((ret = check_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSapTable_sets == 0)
				if ((ret = update_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
			StorageTmp->mtpSapTable_rsvs = 0;
			StorageTmp->mtpSapTable_tsts = 0;
			StorageTmp->mtpSapTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSapTable_sets == 0)
			revert_mtpSapTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		if (StorageOld->mtpSapName != NULL) {
			SNMP_FREE(StorageTmp->mtpSapName);
			StorageTmp->mtpSapName = StorageOld->mtpSapName;
			StorageTmp->mtpSapNameLen = StorageOld->mtpSapNameLen;
			StorageOld->mtpSapName = NULL;
			StorageOld->mtpSapNameLen = 0;
		}
		if (--StorageTmp->mtpSapTable_rsvs == 0)
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSapLongMessageSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapLongMessageSupported entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSapRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapLongMessageSupported: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			if (StorageTmp->mtpSapTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSapTable_old = mtpSapTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSapTable_rsvs++;
		StorageTmp->mtpSapLongMessageSupported = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSapTable_tsts == 0)
				if ((ret = check_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSapLongMessageSupported for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSapTable_sets == 0)
				if ((ret = update_mtpSapTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSapTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
			StorageTmp->mtpSapTable_rsvs = 0;
			StorageTmp->mtpSapTable_tsts = 0;
			StorageTmp->mtpSapTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSapTable_sets == 0)
			revert_mtpSapTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
			break;
		StorageTmp->mtpSapLongMessageSupported = StorageOld->mtpSapLongMessageSupported;
		if (--StorageTmp->mtpSapTable_rsvs == 0)
			mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolVariant entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolVariant: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value ss7ProtocolItut */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			if (StorageTmp->mtpNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpNaTable_old = mtpNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpNaTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpNaProtocolVariant);
		StorageTmp->mtpNaProtocolVariant = objid;
		StorageTmp->mtpNaProtocolVariantLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpNaTable_tsts == 0)
				if ((ret = check_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaProtocolVariant for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpNaTable_sets == 0)
				if ((ret = update_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
			StorageTmp->mtpNaTable_rsvs = 0;
			StorageTmp->mtpNaTable_tsts = 0;
			StorageTmp->mtpNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpNaTable_sets == 0)
			revert_mtpNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		if (StorageOld->mtpNaProtocolVariant != NULL) {
			SNMP_FREE(StorageTmp->mtpNaProtocolVariant);
			StorageTmp->mtpNaProtocolVariant = StorageOld->mtpNaProtocolVariant;
			StorageTmp->mtpNaProtocolVariantLen = StorageOld->mtpNaProtocolVariantLen;
			StorageOld->mtpNaProtocolVariant = NULL;
			StorageOld->mtpNaProtocolVariantLen = 0;
		}
		if (--StorageTmp->mtpNaTable_rsvs == 0)
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaProtocolYear(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolYear entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value yCurrent */
		switch (set_value) {
		case MTPNAPROTOCOLYEAR_YCURRENT:
		case MTPNAPROTOCOLYEAR_Y1980:
		case MTPNAPROTOCOLYEAR_Y1984:
		case MTPNAPROTOCOLYEAR_Y1988:
		case MTPNAPROTOCOLYEAR_Y1992:
		case MTPNAPROTOCOLYEAR_Y1996:
		case MTPNAPROTOCOLYEAR_Y2000:
		case MTPNAPROTOCOLYEAR_Y2004:
		case MTPNAPROTOCOLYEAR_Y2008:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolYear: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			if (StorageTmp->mtpNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpNaTable_old = mtpNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpNaTable_rsvs++;
		StorageTmp->mtpNaProtocolYear = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpNaTable_tsts == 0)
				if ((ret = check_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaProtocolYear for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpNaTable_sets == 0)
				if ((ret = update_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
			StorageTmp->mtpNaTable_rsvs = 0;
			StorageTmp->mtpNaTable_tsts = 0;
			StorageTmp->mtpNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpNaTable_sets == 0)
			revert_mtpNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		StorageTmp->mtpNaProtocolYear = StorageOld->mtpNaProtocolYear;
		if (--StorageTmp->mtpNaTable_rsvs == 0)
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaProtocolOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaProtocolOptions entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 5) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 4) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaProtocolOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { mtpfCongInt , mtpfLinkOsc , mtpfGws , mtpfEGws , mtpfBGws , mtpfLinkStAlloc } */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			if (StorageTmp->mtpNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpNaTable_old = mtpNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpNaTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpNaProtocolOptions);
		StorageTmp->mtpNaProtocolOptions = string;
		StorageTmp->mtpNaProtocolOptionsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpNaTable_tsts == 0)
				if ((ret = check_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaProtocolOptions for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpNaTable_sets == 0)
				if ((ret = update_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
			StorageTmp->mtpNaTable_rsvs = 0;
			StorageTmp->mtpNaTable_tsts = 0;
			StorageTmp->mtpNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpNaTable_sets == 0)
			revert_mtpNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		if (StorageOld->mtpNaProtocolOptions != NULL) {
			SNMP_FREE(StorageTmp->mtpNaProtocolOptions);
			StorageTmp->mtpNaProtocolOptions = StorageOld->mtpNaProtocolOptions;
			StorageTmp->mtpNaProtocolOptionsLen = StorageOld->mtpNaProtocolOptionsLen;
			StorageOld->mtpNaProtocolOptions = NULL;
			StorageOld->mtpNaProtocolOptionsLen = 0;
		}
		if (--StorageTmp->mtpNaTable_rsvs == 0)
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaNetworkIndicator entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internationalNetwork1 */
		switch (set_value) {
		case MTPNANETWORKINDICATOR_INTERNATIONALNETWORK1:
		case MTPNANETWORKINDICATOR_INTERNATIONALNETWORK2:
		case MTPNANETWORKINDICATOR_NATIONALNETWORK1:
		case MTPNANETWORKINDICATOR_NATIONALNETWORK2:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaNetworkIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			if (StorageTmp->mtpNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpNaTable_old = mtpNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpNaTable_rsvs++;
		StorageTmp->mtpNaNetworkIndicator = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpNaTable_tsts == 0)
				if ((ret = check_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaNetworkIndicator for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpNaTable_sets == 0)
				if ((ret = update_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
			StorageTmp->mtpNaTable_rsvs = 0;
			StorageTmp->mtpNaTable_tsts = 0;
			StorageTmp->mtpNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpNaTable_sets == 0)
			revert_mtpNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		StorageTmp->mtpNaNetworkIndicator = StorageOld->mtpNaNetworkIndicator;
		if (--StorageTmp->mtpNaTable_rsvs == 0)
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaPointCodeFormat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaPointCodeFormat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 3..3 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 3)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaPointCodeFormat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x03\x08\x03\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			if (StorageTmp->mtpNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpNaTable_old = mtpNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpNaTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpNaPointCodeFormat);
		StorageTmp->mtpNaPointCodeFormat = string;
		StorageTmp->mtpNaPointCodeFormatLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpNaTable_tsts == 0)
				if ((ret = check_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaPointCodeFormat for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpNaTable_sets == 0)
				if ((ret = update_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
			StorageTmp->mtpNaTable_rsvs = 0;
			StorageTmp->mtpNaTable_tsts = 0;
			StorageTmp->mtpNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpNaTable_sets == 0)
			revert_mtpNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		if (StorageOld->mtpNaPointCodeFormat != NULL) {
			SNMP_FREE(StorageTmp->mtpNaPointCodeFormat);
			StorageTmp->mtpNaPointCodeFormat = StorageOld->mtpNaPointCodeFormat;
			StorageTmp->mtpNaPointCodeFormatLen = StorageOld->mtpNaPointCodeFormatLen;
			StorageOld->mtpNaPointCodeFormat = NULL;
			StorageOld->mtpNaPointCodeFormatLen = 0;
		}
		if (--StorageTmp->mtpNaTable_rsvs == 0)
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaSlsLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaSlsLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaSlsLength entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sls4bits */
		switch (set_value) {
		case MTPNASLSLENGTH_SLS4BITS:
		case MTPNASLSLENGTH_SLS5BITS:
		case MTPNASLSLENGTH_SLS8BITS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSlsLength: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			if (StorageTmp->mtpNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpNaTable_old = mtpNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpNaTable_rsvs++;
		StorageTmp->mtpNaSlsLength = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpNaTable_tsts == 0)
				if ((ret = check_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaSlsLength for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpNaTable_sets == 0)
				if ((ret = update_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
			StorageTmp->mtpNaTable_rsvs = 0;
			StorageTmp->mtpNaTable_tsts = 0;
			StorageTmp->mtpNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpNaTable_sets == 0)
			revert_mtpNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		StorageTmp->mtpNaSlsLength = StorageOld->mtpNaSlsLength;
		if (--StorageTmp->mtpNaTable_rsvs == 0)
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaSpDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaSpDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaSpDefault entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaSpDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			if (StorageTmp->mtpNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpNaTable_old = mtpNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpNaTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpNaSpDefault);
		StorageTmp->mtpNaSpDefault = string;
		StorageTmp->mtpNaSpDefaultLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpNaTable_tsts == 0)
				if ((ret = check_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaSpDefault for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpNaTable_sets == 0)
				if ((ret = update_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
			StorageTmp->mtpNaTable_rsvs = 0;
			StorageTmp->mtpNaTable_tsts = 0;
			StorageTmp->mtpNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpNaTable_sets == 0)
			revert_mtpNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		if (StorageOld->mtpNaSpDefault != NULL) {
			SNMP_FREE(StorageTmp->mtpNaSpDefault);
			StorageTmp->mtpNaSpDefault = StorageOld->mtpNaSpDefault;
			StorageTmp->mtpNaSpDefaultLen = StorageOld->mtpNaSpDefaultLen;
			StorageOld->mtpNaSpDefault = NULL;
			StorageOld->mtpNaSpDefaultLen = 0;
		}
		if (--StorageTmp->mtpNaTable_rsvs == 0)
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNaName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNaRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			if (StorageTmp->mtpNaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpNaTable_old = mtpNaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpNaTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpNaName);
		StorageTmp->mtpNaName = string;
		StorageTmp->mtpNaNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpNaTable_tsts == 0)
				if ((ret = check_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNaName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpNaTable_sets == 0)
				if ((ret = update_mtpNaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
			StorageTmp->mtpNaTable_rsvs = 0;
			StorageTmp->mtpNaTable_tsts = 0;
			StorageTmp->mtpNaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpNaTable_sets == 0)
			revert_mtpNaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
			break;
		if (StorageOld->mtpNaName != NULL) {
			SNMP_FREE(StorageTmp->mtpNaName);
			StorageTmp->mtpNaName = StorageOld->mtpNaName;
			StorageTmp->mtpNaNameLen = StorageOld->mtpNaNameLen;
			StorageOld->mtpNaName = NULL;
			StorageOld->mtpNaNameLen = 0;
		}
		if (--StorageTmp->mtpNaTable_rsvs == 0)
			mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			if (StorageTmp->mtpMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMsTable_old = mtpMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpMsName);
		StorageTmp->mtpMsName = string;
		StorageTmp->mtpMsNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpMsTable_tsts == 0)
				if ((ret = check_mtpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpMsName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMsTable_sets == 0)
				if ((ret = update_mtpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
			StorageTmp->mtpMsTable_rsvs = 0;
			StorageTmp->mtpMsTable_tsts = 0;
			StorageTmp->mtpMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMsTable_sets == 0)
			revert_mtpMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			break;
		if (StorageOld->mtpMsName != NULL) {
			SNMP_FREE(StorageTmp->mtpMsName);
			StorageTmp->mtpMsName = StorageOld->mtpMsName;
			StorageTmp->mtpMsNameLen = StorageOld->mtpMsNameLen;
			StorageOld->mtpMsName = NULL;
			StorageOld->mtpMsNameLen = 0;
		}
		if (--StorageTmp->mtpMsTable_rsvs == 0)
			mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			if (StorageTmp->mtpMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMsTable_old = mtpMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpMsAlarmStatus);
		StorageTmp->mtpMsAlarmStatus = string;
		StorageTmp->mtpMsAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpMsTable_tsts == 0)
				if ((ret = check_mtpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpMsAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMsTable_sets == 0)
				if ((ret = update_mtpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
			StorageTmp->mtpMsTable_rsvs = 0;
			StorageTmp->mtpMsTable_tsts = 0;
			StorageTmp->mtpMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMsTable_sets == 0)
			revert_mtpMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			break;
		if (StorageOld->mtpMsAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->mtpMsAlarmStatus);
			StorageTmp->mtpMsAlarmStatus = StorageOld->mtpMsAlarmStatus;
			StorageTmp->mtpMsAlarmStatusLen = StorageOld->mtpMsAlarmStatusLen;
			StorageOld->mtpMsAlarmStatus = NULL;
			StorageOld->mtpMsAlarmStatusLen = 0;
		}
		if (--StorageTmp->mtpMsTable_rsvs == 0)
			mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsUserLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsUserLabel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsUserLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			if (StorageTmp->mtpMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMsTable_old = mtpMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpMsUserLabel);
		StorageTmp->mtpMsUserLabel = string;
		StorageTmp->mtpMsUserLabelLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpMsTable_tsts == 0)
				if ((ret = check_mtpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpMsUserLabel for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMsTable_sets == 0)
				if ((ret = update_mtpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
			StorageTmp->mtpMsTable_rsvs = 0;
			StorageTmp->mtpMsTable_tsts = 0;
			StorageTmp->mtpMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMsTable_sets == 0)
			revert_mtpMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			break;
		if (StorageOld->mtpMsUserLabel != NULL) {
			SNMP_FREE(StorageTmp->mtpMsUserLabel);
			StorageTmp->mtpMsUserLabel = StorageOld->mtpMsUserLabel;
			StorageTmp->mtpMsUserLabelLen = StorageOld->mtpMsUserLabelLen;
			StorageOld->mtpMsUserLabel = NULL;
			StorageOld->mtpMsUserLabelLen = 0;
		}
		if (--StorageTmp->mtpMsTable_rsvs == 0)
			mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			if (StorageTmp->mtpMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMsTable_old = mtpMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMsTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpMsAsaProfilePointer);
		StorageTmp->mtpMsAsaProfilePointer = objid;
		StorageTmp->mtpMsAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpMsTable_tsts == 0)
				if ((ret = check_mtpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpMsAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMsTable_sets == 0)
				if ((ret = update_mtpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
			StorageTmp->mtpMsTable_rsvs = 0;
			StorageTmp->mtpMsTable_tsts = 0;
			StorageTmp->mtpMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMsTable_sets == 0)
			revert_mtpMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			break;
		if (StorageOld->mtpMsAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpMsAsaProfilePointer);
			StorageTmp->mtpMsAsaProfilePointer = StorageOld->mtpMsAsaProfilePointer;
			StorageTmp->mtpMsAsaProfilePointerLen = StorageOld->mtpMsAsaProfilePointerLen;
			StorageOld->mtpMsAsaProfilePointer = NULL;
			StorageOld->mtpMsAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpMsTable_rsvs == 0)
			mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpMsNetworkElementAliases(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsNetworkElementAliases entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpMsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsNetworkElementAliases: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			if (StorageTmp->mtpMsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMsTable_old = mtpMsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpMsNetworkElementAliases);
		StorageTmp->mtpMsNetworkElementAliases = string;
		StorageTmp->mtpMsNetworkElementAliasesLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpMsTable_tsts == 0)
				if ((ret = check_mtpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpMsNetworkElementAliases for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMsTable_sets == 0)
				if ((ret = update_mtpMsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
			mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
			StorageTmp->mtpMsTable_rsvs = 0;
			StorageTmp->mtpMsTable_tsts = 0;
			StorageTmp->mtpMsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMsTable_sets == 0)
			revert_mtpMsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
			break;
		if (StorageOld->mtpMsNetworkElementAliases != NULL) {
			SNMP_FREE(StorageTmp->mtpMsNetworkElementAliases);
			StorageTmp->mtpMsNetworkElementAliases = StorageOld->mtpMsNetworkElementAliases;
			StorageTmp->mtpMsNetworkElementAliasesLen = StorageOld->mtpMsNetworkElementAliasesLen;
			StorageOld->mtpMsNetworkElementAliases = NULL;
			StorageOld->mtpMsNetworkElementAliasesLen = 0;
		}
		if (--StorageTmp->mtpMsTable_rsvs == 0)
			mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT1R(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT1R(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT1R entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1R: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT1R = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT1R for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT1R = StorageOld->mtpSpProfileTimerT1R;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT2 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 140 */
		/* Note: ranges 70..200 */
		if ((70 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT2 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT2 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT2 = StorageOld->mtpSpProfileTimerT2;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT4 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT4 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT4 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT4 = StorageOld->mtpSpProfileTimerT4;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT5 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT5 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT5 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT5 = StorageOld->mtpSpProfileTimerT5;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT7 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 150 */
		/* Note: ranges 100..200 */
		if ((100 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT7 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT7 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT7 = StorageOld->mtpSpProfileTimerT7;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT11 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 3000..9000 */
		if ((3000 > set_value || set_value > 9000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT11: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT11 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT11 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT11 = StorageOld->mtpSpProfileTimerT11;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT12 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 120 */
		/* Note: ranges 80..150 */
		if ((80 > set_value || set_value > 150)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT12: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT12 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT12 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT12 = StorageOld->mtpSpProfileTimerT12;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT13 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 120 */
		/* Note: ranges 80..150 */
		if ((80 > set_value || set_value > 150)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT13: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT13 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT13 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT13 = StorageOld->mtpSpProfileTimerT13;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT14 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 200..300 */
		if ((200 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT14: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT14 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT14 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT14 = StorageOld->mtpSpProfileTimerT14;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT15 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 200..300 */
		if ((200 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT15: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT15 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT15 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT15 = StorageOld->mtpSpProfileTimerT15;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT16 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 140..200 */
		if ((140 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT16: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT16 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT16 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT16 = StorageOld->mtpSpProfileTimerT16;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT18I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT18I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT18I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT18I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT18I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT18I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT18I = StorageOld->mtpSpProfileTimerT18I;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT19I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6800 */
		/* Note: ranges 6700..6900 */
		if ((6700 > set_value || set_value > 6900)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT19I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT19I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT19I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT19I = StorageOld->mtpSpProfileTimerT19I;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT20I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT20I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT20I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 5900..6100 */
		if ((5900 > set_value || set_value > 6100)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT20I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT20I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT20I = StorageOld->mtpSpProfileTimerT20I;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT21I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6400 */
		/* Note: ranges 6300..6500 */
		if ((6300 > set_value || set_value > 6500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT21I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT21I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT21I = StorageOld->mtpSpProfileTimerT21I;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT22I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT22I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT22I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT22I = StorageOld->mtpSpProfileTimerT22I;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT23I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT23I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT23I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT23I = StorageOld->mtpSpProfileTimerT23I;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT20A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT20A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT20A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT20A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT20A = StorageOld->mtpSpProfileTimerT20A;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT21A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT21A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT21A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT21A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT21A = StorageOld->mtpSpProfileTimerT21A;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT22A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT22A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT22A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT22A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT22A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT22A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT22A = StorageOld->mtpSpProfileTimerT22A;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT23A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT23A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT23A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT23A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT23A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT23A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT23A = StorageOld->mtpSpProfileTimerT23A;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT24A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT24A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT24A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT24A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT24A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT24A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT24A = StorageOld->mtpSpProfileTimerT24A;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT26A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT26A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT26A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1350 */
		/* Note: ranges 1200..1500 */
		if ((1200 > set_value || set_value > 1500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT26A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT26A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT26A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT26A = StorageOld->mtpSpProfileTimerT26A;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT27A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT27A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT27A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 300 */
		/* Note: ranges 200..500 */
		if ((200 > set_value || set_value > 500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT27A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT27A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT27A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT27A = StorageOld->mtpSpProfileTimerT27A;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT1T entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 400 */
		/* Note: ranges 400..1200 */
		if ((400 > set_value || set_value > 1200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT1T = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT1T for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT1T = StorageOld->mtpSpProfileTimerT1T;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileTimerT2T entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 3000..9000 */
		if ((3000 > set_value || set_value > 9000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileTimerT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileTimerT2T = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileTimerT2T for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileTimerT2T = StorageOld->mtpSpProfileTimerT2T;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSpProfileName);
		StorageTmp->mtpSpProfileName = string;
		StorageTmp->mtpSpProfileNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpSpProfileName != NULL) {
			SNMP_FREE(StorageTmp->mtpSpProfileName);
			StorageTmp->mtpSpProfileName = StorageOld->mtpSpProfileName;
			StorageTmp->mtpSpProfileNameLen = StorageOld->mtpSpProfileNameLen;
			StorageOld->mtpSpProfileName = NULL;
			StorageOld->mtpSpProfileNameLen = 0;
		}
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileCircularRteDetect(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfileCircularRteDetect(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileCircularRteDetect entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileCircularRteDetect: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileCircularRteDetect not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileCircularRteDetect: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value none */
		switch (set_value) {
		case MTPSPPROFILECIRCULARRTEDETECT_NONE:
		case MTPSPPROFILECIRCULARRTEDETECT_CONGESTEDLINKOFLINKSET:
		case MTPSPPROFILECIRCULARRTEDETECT_CONGESTEDLINKOFNONCLINKSET:
		case MTPSPPROFILECIRCULARRTEDETECT_NEWROUTEFORROUTESET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileCircularRteDetect: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		StorageTmp->mtpSpProfileCircularRteDetect = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfileCircularRteDetect for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSpProfileCircularRteDetect = StorageOld->mtpSpProfileCircularRteDetect;
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpRsDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpRsDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpRsDefault entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRsDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRsDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRsDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSpRsDefault);
		StorageTmp->mtpSpRsDefault = string;
		StorageTmp->mtpSpRsDefaultLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpRsDefault for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpSpRsDefault != NULL) {
			SNMP_FREE(StorageTmp->mtpSpRsDefault);
			StorageTmp->mtpSpRsDefault = StorageOld->mtpSpRsDefault;
			StorageTmp->mtpSpRsDefaultLen = StorageOld->mtpSpRsDefaultLen;
			StorageOld->mtpSpRsDefault = NULL;
			StorageOld->mtpSpRsDefaultLen = 0;
		}
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpLsDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpLsDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpLsDefault entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpLsDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpLsDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpLsDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			if (StorageTmp->mtpSpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpProfileTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSpLsDefault);
		StorageTmp->mtpSpLsDefault = string;
		StorageTmp->mtpSpLsDefaultLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpProfileTable_tsts == 0)
				if ((ret = check_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpLsDefault for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpProfileTable_sets == 0)
				if ((ret = update_mtpSpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			StorageTmp->mtpSpProfileTable_rsvs = 0;
			StorageTmp->mtpSpProfileTable_tsts = 0;
			StorageTmp->mtpSpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpProfileTable_sets == 0)
			revert_mtpSpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpSpLsDefault != NULL) {
			SNMP_FREE(StorageTmp->mtpSpLsDefault);
			StorageTmp->mtpSpLsDefault = StorageOld->mtpSpLsDefault;
			StorageTmp->mtpSpLsDefaultLen = StorageOld->mtpSpLsDefaultLen;
			StorageOld->mtpSpLsDefault = NULL;
			StorageOld->mtpSpLsDefaultLen = 0;
		}
		if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
			mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpPointCode entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpPointCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x00\x00\x00\x00\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			if (StorageTmp->mtpSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSpPointCode);
		StorageTmp->mtpSpPointCode = string;
		StorageTmp->mtpSpPointCodeLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpTable_tsts == 0)
				if ((ret = check_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpPointCode for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpTable_sets == 0)
				if ((ret = update_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			StorageTmp->mtpSpTable_rsvs = 0;
			StorageTmp->mtpSpTable_tsts = 0;
			StorageTmp->mtpSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpTable_sets == 0)
			revert_mtpSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		if (StorageOld->mtpSpPointCode != NULL) {
			SNMP_FREE(StorageTmp->mtpSpPointCode);
			StorageTmp->mtpSpPointCode = StorageOld->mtpSpPointCode;
			StorageTmp->mtpSpPointCodeLen = StorageOld->mtpSpPointCodeLen;
			StorageOld->mtpSpPointCode = NULL;
			StorageOld->mtpSpPointCodeLen = 0;
		}
		if (--StorageTmp->mtpSpTable_rsvs == 0)
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value sep */
		switch (set_value) {
		case MTPSPTYPE_SEP:
		case MTPSPTYPE_STEP:
		case MTPSPTYPE_STP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			if (StorageTmp->mtpSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpTable_rsvs++;
		StorageTmp->mtpSpType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpTable_tsts == 0)
				if ((ret = check_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpType for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpTable_sets == 0)
				if ((ret = update_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			StorageTmp->mtpSpTable_rsvs = 0;
			StorageTmp->mtpSpTable_tsts = 0;
			StorageTmp->mtpSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpTable_sets == 0)
			revert_mtpSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		StorageTmp->mtpSpType = StorageOld->mtpSpType;
		if (--StorageTmp->mtpSpTable_rsvs == 0)
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpVersion entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"ITU-T Q.704 1996\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			if (StorageTmp->mtpSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSpVersion);
		StorageTmp->mtpSpVersion = string;
		StorageTmp->mtpSpVersionLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpTable_tsts == 0)
				if ((ret = check_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpVersion for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpTable_sets == 0)
				if ((ret = update_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			StorageTmp->mtpSpTable_rsvs = 0;
			StorageTmp->mtpSpTable_tsts = 0;
			StorageTmp->mtpSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpTable_sets == 0)
			revert_mtpSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		if (StorageOld->mtpSpVersion != NULL) {
			SNMP_FREE(StorageTmp->mtpSpVersion);
			StorageTmp->mtpSpVersion = StorageOld->mtpSpVersion;
			StorageTmp->mtpSpVersionLen = StorageOld->mtpSpVersionLen;
			StorageOld->mtpSpVersion = NULL;
			StorageOld->mtpSpVersionLen = 0;
		}
		if (--StorageTmp->mtpSpTable_rsvs == 0)
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpNetworkIndicator(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpNetworkIndicator entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value internationalNetwork1 */
		switch (set_value) {
		case MTPSPNETWORKINDICATOR_INTERNATIONALNETWORK1:
		case MTPSPNETWORKINDICATOR_INTERNATIONALNETWORK2:
		case MTPSPNETWORKINDICATOR_NATIONALNETWORK1:
		case MTPSPNETWORKINDICATOR_NATIONALNETWORK2:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNetworkIndicator: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			if (StorageTmp->mtpSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpTable_rsvs++;
		StorageTmp->mtpSpNetworkIndicator = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpTable_tsts == 0)
				if ((ret = check_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpNetworkIndicator for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpTable_sets == 0)
				if ((ret = update_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			StorageTmp->mtpSpTable_rsvs = 0;
			StorageTmp->mtpSpTable_tsts = 0;
			StorageTmp->mtpSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpTable_sets == 0)
			revert_mtpSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		StorageTmp->mtpSpNetworkIndicator = StorageOld->mtpSpNetworkIndicator;
		if (--StorageTmp->mtpSpTable_rsvs == 0)
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			if (StorageTmp->mtpSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSpName);
		StorageTmp->mtpSpName = string;
		StorageTmp->mtpSpNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpTable_tsts == 0)
				if ((ret = check_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpTable_sets == 0)
				if ((ret = update_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			StorageTmp->mtpSpTable_rsvs = 0;
			StorageTmp->mtpSpTable_tsts = 0;
			StorageTmp->mtpSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpTable_sets == 0)
			revert_mtpSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		if (StorageOld->mtpSpName != NULL) {
			SNMP_FREE(StorageTmp->mtpSpName);
			StorageTmp->mtpSpName = StorageOld->mtpSpName;
			StorageTmp->mtpSpNameLen = StorageOld->mtpSpNameLen;
			StorageOld->mtpSpName = NULL;
			StorageOld->mtpSpNameLen = 0;
		}
		if (--StorageTmp->mtpSpTable_rsvs == 0)
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			if (StorageTmp->mtpSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSpProfilePointer);
		StorageTmp->mtpSpProfilePointer = string;
		StorageTmp->mtpSpProfilePointerLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpTable_tsts == 0)
				if ((ret = check_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpTable_sets == 0)
				if ((ret = update_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			StorageTmp->mtpSpTable_rsvs = 0;
			StorageTmp->mtpSpTable_tsts = 0;
			StorageTmp->mtpSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpTable_sets == 0)
			revert_mtpSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		if (StorageOld->mtpSpProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSpProfilePointer);
			StorageTmp->mtpSpProfilePointer = StorageOld->mtpSpProfilePointer;
			StorageTmp->mtpSpProfilePointerLen = StorageOld->mtpSpProfilePointerLen;
			StorageOld->mtpSpProfilePointer = NULL;
			StorageOld->mtpSpProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpSpTable_rsvs == 0)
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpNaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpNaPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpNaPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpNaPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			if (StorageTmp->mtpSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSpNaPointer);
		StorageTmp->mtpSpNaPointer = objid;
		StorageTmp->mtpSpNaPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpTable_tsts == 0)
				if ((ret = check_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpNaPointer for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpTable_sets == 0)
				if ((ret = update_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			StorageTmp->mtpSpTable_rsvs = 0;
			StorageTmp->mtpSpTable_tsts = 0;
			StorageTmp->mtpSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpTable_sets == 0)
			revert_mtpSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		if (StorageOld->mtpSpNaPointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSpNaPointer);
			StorageTmp->mtpSpNaPointer = StorageOld->mtpSpNaPointer;
			StorageTmp->mtpSpNaPointerLen = StorageOld->mtpSpNaPointerLen;
			StorageOld->mtpSpNaPointer = NULL;
			StorageOld->mtpSpNaPointerLen = 0;
		}
		if (--StorageTmp->mtpSpTable_rsvs == 0)
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpOptions entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpOptions not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { spfSecurity } */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			if (StorageTmp->mtpSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSpOptions);
		StorageTmp->mtpSpOptions = string;
		StorageTmp->mtpSpOptionsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpTable_tsts == 0)
				if ((ret = check_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpOptions for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpTable_sets == 0)
				if ((ret = update_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			StorageTmp->mtpSpTable_rsvs = 0;
			StorageTmp->mtpSpTable_tsts = 0;
			StorageTmp->mtpSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpTable_sets == 0)
			revert_mtpSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		if (StorageOld->mtpSpOptions != NULL) {
			SNMP_FREE(StorageTmp->mtpSpOptions);
			StorageTmp->mtpSpOptions = StorageOld->mtpSpOptions;
			StorageTmp->mtpSpOptionsLen = StorageOld->mtpSpOptionsLen;
			StorageOld->mtpSpOptions = NULL;
			StorageOld->mtpSpOptionsLen = 0;
		}
		if (--StorageTmp->mtpSpTable_rsvs == 0)
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpUsers(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpUsers(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpUsers entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 3) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpUsers: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { sccp , isup , mtup } */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			if (StorageTmp->mtpSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSpUsers);
		StorageTmp->mtpSpUsers = string;
		StorageTmp->mtpSpUsersLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpTable_tsts == 0)
				if ((ret = check_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpUsers for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpTable_sets == 0)
				if ((ret = update_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			StorageTmp->mtpSpTable_rsvs = 0;
			StorageTmp->mtpSpTable_tsts = 0;
			StorageTmp->mtpSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpTable_sets == 0)
			revert_mtpSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		if (StorageOld->mtpSpUsers != NULL) {
			SNMP_FREE(StorageTmp->mtpSpUsers);
			StorageTmp->mtpSpUsers = StorageOld->mtpSpUsers;
			StorageTmp->mtpSpUsersLen = StorageOld->mtpSpUsersLen;
			StorageOld->mtpSpUsers = NULL;
			StorageOld->mtpSpUsersLen = 0;
		}
		if (--StorageTmp->mtpSpTable_rsvs == 0)
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			if (StorageTmp->mtpSpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSpAlarmStatus);
		StorageTmp->mtpSpAlarmStatus = string;
		StorageTmp->mtpSpAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSpTable_tsts == 0)
				if ((ret = check_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSpAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSpTable_sets == 0)
				if ((ret = update_mtpSpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			StorageTmp->mtpSpTable_rsvs = 0;
			StorageTmp->mtpSpTable_tsts = 0;
			StorageTmp->mtpSpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSpTable_sets == 0)
			revert_mtpSpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
			break;
		if (StorageOld->mtpSpAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->mtpSpAlarmStatus);
			StorageTmp->mtpSpAlarmStatus = StorageOld->mtpSpAlarmStatus;
			StorageTmp->mtpSpAlarmStatusLen = StorageOld->mtpSpAlarmStatusLen;
			StorageOld->mtpSpAlarmStatus = NULL;
			StorageOld->mtpSpAlarmStatusLen = 0;
		}
		if (--StorageTmp->mtpSpTable_rsvs == 0)
			mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpL3AdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL3Table_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpL3AdministrativeState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpL3RowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPL3ADMINISTRATIVESTATE_LOCKED:
		case MTPL3ADMINISTRATIVESTATE_UNLOCKED:
		case MTPL3ADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
			if (StorageTmp->mtpL3Table_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpL3Table_old = mtpL3Table_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpL3Table_rsvs++;
		StorageTmp->mtpL3AdministrativeState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpL3Table_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpL3Table_tsts == 0)
				if ((ret = check_mtpL3Table_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpL3Table_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpL3AdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpL3Table_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpL3Table_sets == 0)
				if ((ret = update_mtpL3Table_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpL3Table_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpL3Table_old) != NULL) {
			mtpL3Table_destroy(&StorageTmp->mtpL3Table_old);
			StorageTmp->mtpL3Table_rsvs = 0;
			StorageTmp->mtpL3Table_tsts = 0;
			StorageTmp->mtpL3Table_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpL3Table_sets == 0)
			revert_mtpL3Table_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
			break;
		StorageTmp->mtpL3AdministrativeState = StorageOld->mtpL3AdministrativeState;
		if (--StorageTmp->mtpL3Table_rsvs == 0)
			mtpL3Table_destroy(&StorageTmp->mtpL3Table_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3AsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpL3AsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL3Table_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpL3AsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpL3RowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3AsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
			if (StorageTmp->mtpL3Table_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpL3Table_old = mtpL3Table_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpL3Table_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpL3AsaProfilePointer);
		StorageTmp->mtpL3AsaProfilePointer = objid;
		StorageTmp->mtpL3AsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpL3Table_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpL3Table_tsts == 0)
				if ((ret = check_mtpL3Table_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpL3Table_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpL3AsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpL3Table_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpL3Table_sets == 0)
				if ((ret = update_mtpL3Table_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpL3Table_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpL3Table_old) != NULL) {
			mtpL3Table_destroy(&StorageTmp->mtpL3Table_old);
			StorageTmp->mtpL3Table_rsvs = 0;
			StorageTmp->mtpL3Table_tsts = 0;
			StorageTmp->mtpL3Table_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpL3Table_sets == 0)
			revert_mtpL3Table_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
			break;
		if (StorageOld->mtpL3AsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpL3AsaProfilePointer);
			StorageTmp->mtpL3AsaProfilePointer = StorageOld->mtpL3AsaProfilePointer;
			StorageTmp->mtpL3AsaProfilePointerLen = StorageOld->mtpL3AsaProfilePointerLen;
			StorageOld->mtpL3AsaProfilePointer = NULL;
			StorageOld->mtpL3AsaProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpL3Table_rsvs == 0)
			mtpL3Table_destroy(&StorageTmp->mtpL3Table_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpL3Name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL3Table_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpL3Name entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpL3RowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3Name: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
			if (StorageTmp->mtpL3Table_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpL3Table_old = mtpL3Table_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpL3Table_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpL3Name);
		StorageTmp->mtpL3Name = string;
		StorageTmp->mtpL3NameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpL3Table_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpL3Table_tsts == 0)
				if ((ret = check_mtpL3Table_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpL3Table_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpL3Name for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpL3Table_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpL3Table_sets == 0)
				if ((ret = update_mtpL3Table_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpL3Table_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpL3Table_old) != NULL) {
			mtpL3Table_destroy(&StorageTmp->mtpL3Table_old);
			StorageTmp->mtpL3Table_rsvs = 0;
			StorageTmp->mtpL3Table_tsts = 0;
			StorageTmp->mtpL3Table_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpL3Table_sets == 0)
			revert_mtpL3Table_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
			break;
		if (StorageOld->mtpL3Name != NULL) {
			SNMP_FREE(StorageTmp->mtpL3Name);
			StorageTmp->mtpL3Name = StorageOld->mtpL3Name;
			StorageTmp->mtpL3NameLen = StorageOld->mtpL3NameLen;
			StorageOld->mtpL3Name = NULL;
			StorageOld->mtpL3NameLen = 0;
		}
		if (--StorageTmp->mtpL3Table_rsvs == 0)
			mtpL3Table_destroy(&StorageTmp->mtpL3Table_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsAdministrativeState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPGSADMINISTRATIVESTATE_LOCKED:
		case MTPGSADMINISTRATIVESTATE_UNLOCKED:
		case MTPGSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			if (StorageTmp->mtpGsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsTable_old = mtpGsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsTable_rsvs++;
		StorageTmp->mtpGsAdministrativeState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsTable_tsts == 0)
				if ((ret = check_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsTable_sets == 0)
				if ((ret = update_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
			StorageTmp->mtpGsTable_rsvs = 0;
			StorageTmp->mtpGsTable_tsts = 0;
			StorageTmp->mtpGsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsTable_sets == 0)
			revert_mtpGsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		StorageTmp->mtpGsAdministrativeState = StorageOld->mtpGsAdministrativeState;
		if (--StorageTmp->mtpGsTable_rsvs == 0)
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsTreatmentOfOutsideRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsTreatmentOfOutsideRanges(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsTreatmentOfOutsideRanges entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value normal */
		switch (set_value) {
		case MTPGSTREATMENTOFOUTSIDERANGES_NORMAL:
		case MTPGSTREATMENTOFOUTSIDERANGES_DISCARD:
		case MTPGSTREATMENTOFOUTSIDERANGES_PROHIBIT:
		case MTPGSTREATMENTOFOUTSIDERANGES_UNEQUIPPED:
		case MTPGSTREATMENTOFOUTSIDERANGES_INACCESSIBLE:
		case MTPGSTREATMENTOFOUTSIDERANGES_CONGEST:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsTreatmentOfOutsideRanges: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			if (StorageTmp->mtpGsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsTable_old = mtpGsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsTable_rsvs++;
		StorageTmp->mtpGsTreatmentOfOutsideRanges = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsTable_tsts == 0)
				if ((ret = check_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsTreatmentOfOutsideRanges for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsTable_sets == 0)
				if ((ret = update_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
			StorageTmp->mtpGsTable_rsvs = 0;
			StorageTmp->mtpGsTable_tsts = 0;
			StorageTmp->mtpGsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsTable_sets == 0)
			revert_mtpGsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		StorageTmp->mtpGsTreatmentOfOutsideRanges = StorageOld->mtpGsTreatmentOfOutsideRanges;
		if (--StorageTmp->mtpGsTable_rsvs == 0)
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsListMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsListMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsListMode entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsListMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			if (StorageTmp->mtpGsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsTable_old = mtpGsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsTable_rsvs++;
		StorageTmp->mtpGsListMode = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsTable_tsts == 0)
				if ((ret = check_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsListMode for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsTable_sets == 0)
				if ((ret = update_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
			StorageTmp->mtpGsTable_rsvs = 0;
			StorageTmp->mtpGsTable_tsts = 0;
			StorageTmp->mtpGsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsTable_sets == 0)
			revert_mtpGsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		StorageTmp->mtpGsListMode = StorageOld->mtpGsListMode;
		if (--StorageTmp->mtpGsTable_rsvs == 0)
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsScreeningByLinkSetOrByOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsScreeningByLinkSetOrByOpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsScreeningByLinkSetOrByOpc entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value byOpc */
		switch (set_value) {
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYOPC:
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYINCOMINGLINKSET:
		case MTPGSSCREENINGBYLINKSETORBYOPC_BYOUTGOINGLINKSET:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsScreeningByLinkSetOrByOpc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			if (StorageTmp->mtpGsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsTable_old = mtpGsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsTable_rsvs++;
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsTable_tsts == 0)
				if ((ret = check_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsScreeningByLinkSetOrByOpc for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsTable_sets == 0)
				if ((ret = update_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
			StorageTmp->mtpGsTable_rsvs = 0;
			StorageTmp->mtpGsTable_tsts = 0;
			StorageTmp->mtpGsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsTable_sets == 0)
			revert_mtpGsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		StorageTmp->mtpGsScreeningByLinkSetOrByOpc = StorageOld->mtpGsScreeningByLinkSetOrByOpc;
		if (--StorageTmp->mtpGsTable_rsvs == 0)
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsGetScreenedOpcsOrLinkSetsByDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsGetScreenedOpcsOrLinkSetsByDpc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsGetScreenedOpcsOrLinkSetsByDpc entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SUCCESS:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_UNSUCCESSFUL:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_NOTPERFORMED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_LINKALREADYINHIBITED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_LINKNOTINHIBITED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_WRONGCLASSREFERENCED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SIGNTERMNONEXISTING:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_SIGNTERMALREADYREFERENCED:
		case MTPGSGETSCREENEDOPCSORLINKSETSBYDPC_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsGetScreenedOpcsOrLinkSetsByDpc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			if (StorageTmp->mtpGsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsTable_old = mtpGsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsTable_rsvs++;
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsTable_tsts == 0)
				if ((ret = check_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsTable_sets == 0)
				if ((ret = update_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
			StorageTmp->mtpGsTable_rsvs = 0;
			StorageTmp->mtpGsTable_tsts = 0;
			StorageTmp->mtpGsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsTable_sets == 0)
			revert_mtpGsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		StorageTmp->mtpGsGetScreenedOpcsOrLinkSetsByDpc = StorageOld->mtpGsGetScreenedOpcsOrLinkSetsByDpc;
		if (--StorageTmp->mtpGsTable_rsvs == 0)
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			if (StorageTmp->mtpGsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsTable_old = mtpGsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpGsName);
		StorageTmp->mtpGsName = string;
		StorageTmp->mtpGsNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsTable_tsts == 0)
				if ((ret = check_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsTable_sets == 0)
				if ((ret = update_mtpGsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
			StorageTmp->mtpGsTable_rsvs = 0;
			StorageTmp->mtpGsTable_tsts = 0;
			StorageTmp->mtpGsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsTable_sets == 0)
			revert_mtpGsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
			break;
		if (StorageOld->mtpGsName != NULL) {
			SNMP_FREE(StorageTmp->mtpGsName);
			StorageTmp->mtpGsName = StorageOld->mtpGsName;
			StorageTmp->mtpGsNameLen = StorageOld->mtpGsNameLen;
			StorageOld->mtpGsName = NULL;
			StorageOld->mtpGsNameLen = 0;
		}
		if (--StorageTmp->mtpGsTable_rsvs == 0)
			mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineObject entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) == NULL)
			if (StorageTmp->mtpGsLineTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsLineTable_old = mtpGsLineTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsLineTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpGsLineObject);
		StorageTmp->mtpGsLineObject = objid;
		StorageTmp->mtpGsLineObjectLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsLineTable_tsts == 0)
				if ((ret = check_mtpGsLineTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineObject for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsLineTable_sets == 0)
				if ((ret = update_mtpGsLineTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) != NULL) {
			mtpGsLineTable_destroy(&StorageTmp->mtpGsLineTable_old);
			StorageTmp->mtpGsLineTable_rsvs = 0;
			StorageTmp->mtpGsLineTable_tsts = 0;
			StorageTmp->mtpGsLineTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsLineTable_sets == 0)
			revert_mtpGsLineTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) == NULL)
			break;
		if (StorageOld->mtpGsLineObject != NULL) {
			SNMP_FREE(StorageTmp->mtpGsLineObject);
			StorageTmp->mtpGsLineObject = StorageOld->mtpGsLineObject;
			StorageTmp->mtpGsLineObjectLen = StorageOld->mtpGsLineObjectLen;
			StorageOld->mtpGsLineObject = NULL;
			StorageOld->mtpGsLineObjectLen = 0;
		}
		if (--StorageTmp->mtpGsLineTable_rsvs == 0)
			mtpGsLineTable_destroy(&StorageTmp->mtpGsLineTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContent(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContent entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContent: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) == NULL)
			if (StorageTmp->mtpGsLineTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsLineTable_old = mtpGsLineTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsLineTable_rsvs++;
		StorageTmp->mtpGsLineContent = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsLineTable_tsts == 0)
				if ((ret = check_mtpGsLineTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContent for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsLineTable_sets == 0)
				if ((ret = update_mtpGsLineTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) != NULL) {
			mtpGsLineTable_destroy(&StorageTmp->mtpGsLineTable_old);
			StorageTmp->mtpGsLineTable_rsvs = 0;
			StorageTmp->mtpGsLineTable_tsts = 0;
			StorageTmp->mtpGsLineTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsLineTable_sets == 0)
			revert_mtpGsLineTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsLineTable_old) == NULL)
			break;
		StorageTmp->mtpGsLineContent = StorageOld->mtpGsLineContent;
		if (--StorageTmp->mtpGsLineTable_rsvs == 0)
			mtpGsLineTable_destroy(&StorageTmp->mtpGsLineTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentDesignatedDPCFirst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentDesignatedDPCFirst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentDesignatedDPCFirst entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCFirst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x00\x00\x00\x00\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			if (StorageTmp->mtpGsLineContentTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsLineContentTable_old = mtpGsLineContentTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsLineContentTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpGsLineContentDesignatedDPCFirst);
		StorageTmp->mtpGsLineContentDesignatedDPCFirst = string;
		StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsLineContentTable_tsts == 0)
				if ((ret = check_mtpGsLineContentTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineContentTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContentDesignatedDPCFirst for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsLineContentTable_sets == 0)
				if ((ret = update_mtpGsLineContentTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineContentTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
			StorageTmp->mtpGsLineContentTable_rsvs = 0;
			StorageTmp->mtpGsLineContentTable_tsts = 0;
			StorageTmp->mtpGsLineContentTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsLineContentTable_sets == 0)
			revert_mtpGsLineContentTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			break;
		if (StorageOld->mtpGsLineContentDesignatedDPCFirst != NULL) {
			SNMP_FREE(StorageTmp->mtpGsLineContentDesignatedDPCFirst);
			StorageTmp->mtpGsLineContentDesignatedDPCFirst = StorageOld->mtpGsLineContentDesignatedDPCFirst;
			StorageTmp->mtpGsLineContentDesignatedDPCFirstLen = StorageOld->mtpGsLineContentDesignatedDPCFirstLen;
			StorageOld->mtpGsLineContentDesignatedDPCFirst = NULL;
			StorageOld->mtpGsLineContentDesignatedDPCFirstLen = 0;
		}
		if (--StorageTmp->mtpGsLineContentTable_rsvs == 0)
			mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentDesignatedDPCLast(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentDesignatedDPCLast(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentDesignatedDPCLast entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentDesignatedDPCLast: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x00\x00\x00\x00\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			if (StorageTmp->mtpGsLineContentTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsLineContentTable_old = mtpGsLineContentTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsLineContentTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpGsLineContentDesignatedDPCLast);
		StorageTmp->mtpGsLineContentDesignatedDPCLast = string;
		StorageTmp->mtpGsLineContentDesignatedDPCLastLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsLineContentTable_tsts == 0)
				if ((ret = check_mtpGsLineContentTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineContentTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContentDesignatedDPCLast for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsLineContentTable_sets == 0)
				if ((ret = update_mtpGsLineContentTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineContentTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
			StorageTmp->mtpGsLineContentTable_rsvs = 0;
			StorageTmp->mtpGsLineContentTable_tsts = 0;
			StorageTmp->mtpGsLineContentTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsLineContentTable_sets == 0)
			revert_mtpGsLineContentTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			break;
		if (StorageOld->mtpGsLineContentDesignatedDPCLast != NULL) {
			SNMP_FREE(StorageTmp->mtpGsLineContentDesignatedDPCLast);
			StorageTmp->mtpGsLineContentDesignatedDPCLast = StorageOld->mtpGsLineContentDesignatedDPCLast;
			StorageTmp->mtpGsLineContentDesignatedDPCLastLen = StorageOld->mtpGsLineContentDesignatedDPCLastLen;
			StorageOld->mtpGsLineContentDesignatedDPCLast = NULL;
			StorageOld->mtpGsLineContentDesignatedDPCLastLen = 0;
		}
		if (--StorageTmp->mtpGsLineContentTable_rsvs == 0)
			mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentSiMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentSiMask(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentSiMask entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 3) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentSiMask: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { sccp , tup , isup , dup1 , dup2 , mtup , bisup , siup , spneup , stc , user13 , user14 , user15 } */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			if (StorageTmp->mtpGsLineContentTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsLineContentTable_old = mtpGsLineContentTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsLineContentTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpGsLineContentSiMask);
		StorageTmp->mtpGsLineContentSiMask = string;
		StorageTmp->mtpGsLineContentSiMaskLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsLineContentTable_tsts == 0)
				if ((ret = check_mtpGsLineContentTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineContentTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContentSiMask for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsLineContentTable_sets == 0)
				if ((ret = update_mtpGsLineContentTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineContentTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
			StorageTmp->mtpGsLineContentTable_rsvs = 0;
			StorageTmp->mtpGsLineContentTable_tsts = 0;
			StorageTmp->mtpGsLineContentTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsLineContentTable_sets == 0)
			revert_mtpGsLineContentTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			break;
		if (StorageOld->mtpGsLineContentSiMask != NULL) {
			SNMP_FREE(StorageTmp->mtpGsLineContentSiMask);
			StorageTmp->mtpGsLineContentSiMask = StorageOld->mtpGsLineContentSiMask;
			StorageTmp->mtpGsLineContentSiMaskLen = StorageOld->mtpGsLineContentSiMaskLen;
			StorageOld->mtpGsLineContentSiMask = NULL;
			StorageOld->mtpGsLineContentSiMaskLen = 0;
		}
		if (--StorageTmp->mtpGsLineContentTable_rsvs == 0)
			mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentMessageTreatment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentMessageTreatment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentMessageTreatment entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value normal */
		switch (set_value) {
		case MTPGSLINECONTENTMESSAGETREATMENT_NORMAL:
		case MTPGSLINECONTENTMESSAGETREATMENT_DISCARD:
		case MTPGSLINECONTENTMESSAGETREATMENT_PROHIBIT:
		case MTPGSLINECONTENTMESSAGETREATMENT_UNEQUIPPED:
		case MTPGSLINECONTENTMESSAGETREATMENT_INACCESSIBLE:
		case MTPGSLINECONTENTMESSAGETREATMENT_CONGEST:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentMessageTreatment: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			if (StorageTmp->mtpGsLineContentTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsLineContentTable_old = mtpGsLineContentTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsLineContentTable_rsvs++;
		StorageTmp->mtpGsLineContentMessageTreatment = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsLineContentTable_tsts == 0)
				if ((ret = check_mtpGsLineContentTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineContentTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContentMessageTreatment for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsLineContentTable_sets == 0)
				if ((ret = update_mtpGsLineContentTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineContentTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
			StorageTmp->mtpGsLineContentTable_rsvs = 0;
			StorageTmp->mtpGsLineContentTable_tsts = 0;
			StorageTmp->mtpGsLineContentTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsLineContentTable_sets == 0)
			revert_mtpGsLineContentTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			break;
		StorageTmp->mtpGsLineContentMessageTreatment = StorageOld->mtpGsLineContentMessageTreatment;
		if (--StorageTmp->mtpGsLineContentTable_rsvs == 0)
			mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentComment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpGsLineContentComment(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentComment entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpGsLineContentRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentComment: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			if (StorageTmp->mtpGsLineContentTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpGsLineContentTable_old = mtpGsLineContentTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpGsLineContentTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpGsLineContentComment);
		StorageTmp->mtpGsLineContentComment = string;
		StorageTmp->mtpGsLineContentCommentLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpGsLineContentTable_tsts == 0)
				if ((ret = check_mtpGsLineContentTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineContentTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpGsLineContentComment for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpGsLineContentTable_sets == 0)
				if ((ret = update_mtpGsLineContentTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpGsLineContentTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
			mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
			StorageTmp->mtpGsLineContentTable_rsvs = 0;
			StorageTmp->mtpGsLineContentTable_tsts = 0;
			StorageTmp->mtpGsLineContentTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpGsLineContentTable_sets == 0)
			revert_mtpGsLineContentTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
			break;
		if (StorageOld->mtpGsLineContentComment != NULL) {
			SNMP_FREE(StorageTmp->mtpGsLineContentComment);
			StorageTmp->mtpGsLineContentComment = StorageOld->mtpGsLineContentComment;
			StorageTmp->mtpGsLineContentCommentLen = StorageOld->mtpGsLineContentCommentLen;
			StorageOld->mtpGsLineContentComment = NULL;
			StorageOld->mtpGsLineContentCommentLen = 0;
		}
		if (--StorageTmp->mtpGsLineContentTable_rsvs == 0)
			mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			if (StorageTmp->mtpRsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsProfileTable_old = mtpRsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsProfileTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRsProfileName);
		StorageTmp->mtpRsProfileName = string;
		StorageTmp->mtpRsProfileNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsProfileTable_tsts == 0)
				if ((ret = check_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsProfileTable_sets == 0)
				if ((ret = update_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
			StorageTmp->mtpRsProfileTable_rsvs = 0;
			StorageTmp->mtpRsProfileTable_tsts = 0;
			StorageTmp->mtpRsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsProfileTable_sets == 0)
			revert_mtpRsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpRsProfileName != NULL) {
			SNMP_FREE(StorageTmp->mtpRsProfileName);
			StorageTmp->mtpRsProfileName = StorageOld->mtpRsProfileName;
			StorageTmp->mtpRsProfileNameLen = StorageOld->mtpRsProfileNameLen;
			StorageOld->mtpRsProfileName = NULL;
			StorageOld->mtpRsProfileNameLen = 0;
		}
		if (--StorageTmp->mtpRsProfileTable_rsvs == 0)
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT8 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 80..120 */
		if ((80 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT8: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			if (StorageTmp->mtpRsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsProfileTable_old = mtpRsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsProfileTable_rsvs++;
		StorageTmp->mtpRsProfileTimerT8 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsProfileTable_tsts == 0)
				if ((ret = check_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileTimerT8 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsProfileTable_sets == 0)
				if ((ret = update_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
			StorageTmp->mtpRsProfileTable_rsvs = 0;
			StorageTmp->mtpRsProfileTable_tsts = 0;
			StorageTmp->mtpRsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsProfileTable_sets == 0)
			revert_mtpRsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpRsProfileTimerT8 = StorageOld->mtpRsProfileTimerT8;
		if (--StorageTmp->mtpRsProfileTable_rsvs == 0)
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT11(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT11 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 3000..9000 */
		if ((3000 > set_value || set_value > 9000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT11: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			if (StorageTmp->mtpRsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsProfileTable_old = mtpRsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsProfileTable_rsvs++;
		StorageTmp->mtpRsProfileTimerT11 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsProfileTable_tsts == 0)
				if ((ret = check_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileTimerT11 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsProfileTable_sets == 0)
				if ((ret = update_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
			StorageTmp->mtpRsProfileTable_rsvs = 0;
			StorageTmp->mtpRsProfileTable_tsts = 0;
			StorageTmp->mtpRsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsProfileTable_sets == 0)
			revert_mtpRsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpRsProfileTimerT11 = StorageOld->mtpRsProfileTimerT11;
		if (--StorageTmp->mtpRsProfileTable_rsvs == 0)
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT15(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT15 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 200..300 */
		if ((200 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT15: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			if (StorageTmp->mtpRsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsProfileTable_old = mtpRsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsProfileTable_rsvs++;
		StorageTmp->mtpRsProfileTimerT15 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsProfileTable_tsts == 0)
				if ((ret = check_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileTimerT15 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsProfileTable_sets == 0)
				if ((ret = update_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
			StorageTmp->mtpRsProfileTable_rsvs = 0;
			StorageTmp->mtpRsProfileTable_tsts = 0;
			StorageTmp->mtpRsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsProfileTable_sets == 0)
			revert_mtpRsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpRsProfileTimerT15 = StorageOld->mtpRsProfileTimerT15;
		if (--StorageTmp->mtpRsProfileTable_rsvs == 0)
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT16(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT16 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 175 */
		/* Note: ranges 140..200 */
		if ((140 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT16: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			if (StorageTmp->mtpRsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsProfileTable_old = mtpRsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsProfileTable_rsvs++;
		StorageTmp->mtpRsProfileTimerT16 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsProfileTable_tsts == 0)
				if ((ret = check_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileTimerT16 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsProfileTable_sets == 0)
				if ((ret = update_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
			StorageTmp->mtpRsProfileTable_rsvs = 0;
			StorageTmp->mtpRsProfileTable_tsts = 0;
			StorageTmp->mtpRsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsProfileTable_sets == 0)
			revert_mtpRsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpRsProfileTimerT16 = StorageOld->mtpRsProfileTimerT16;
		if (--StorageTmp->mtpRsProfileTable_rsvs == 0)
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileTimerT18A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileTimerT18A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileTimerT18A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1200 */
		/* Note: ranges 200..2000 */
		if ((200 > set_value || set_value > 2000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileTimerT18A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			if (StorageTmp->mtpRsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsProfileTable_old = mtpRsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsProfileTable_rsvs++;
		StorageTmp->mtpRsProfileTimerT18A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsProfileTable_tsts == 0)
				if ((ret = check_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileTimerT18A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsProfileTable_sets == 0)
				if ((ret = update_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
			StorageTmp->mtpRsProfileTable_rsvs = 0;
			StorageTmp->mtpRsProfileTable_tsts = 0;
			StorageTmp->mtpRsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsProfileTable_sets == 0)
			revert_mtpRsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpRsProfileTimerT18A = StorageOld->mtpRsProfileTimerT18A;
		if (--StorageTmp->mtpRsProfileTable_rsvs == 0)
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileRtDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfileRtDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileRtDefault entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRtDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			if (StorageTmp->mtpRsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsProfileTable_old = mtpRsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsProfileTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRsProfileRtDefault);
		StorageTmp->mtpRsProfileRtDefault = string;
		StorageTmp->mtpRsProfileRtDefaultLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsProfileTable_tsts == 0)
				if ((ret = check_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfileRtDefault for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsProfileTable_sets == 0)
				if ((ret = update_mtpRsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
			StorageTmp->mtpRsProfileTable_rsvs = 0;
			StorageTmp->mtpRsProfileTable_tsts = 0;
			StorageTmp->mtpRsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsProfileTable_sets == 0)
			revert_mtpRsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpRsProfileRtDefault != NULL) {
			SNMP_FREE(StorageTmp->mtpRsProfileRtDefault);
			StorageTmp->mtpRsProfileRtDefault = StorageOld->mtpRsProfileRtDefault;
			StorageTmp->mtpRsProfileRtDefaultLen = StorageOld->mtpRsProfileRtDefaultLen;
			StorageOld->mtpRsProfileRtDefault = NULL;
			StorageOld->mtpRsProfileRtDefaultLen = 0;
		}
		if (--StorageTmp->mtpRsProfileTable_rsvs == 0)
			mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsDest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsDest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsDest entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsDest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x00\x00\x00\x00\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			if (StorageTmp->mtpRsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRsDest);
		StorageTmp->mtpRsDest = string;
		StorageTmp->mtpRsDestLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsTable_tsts == 0)
				if ((ret = check_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsDest for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsTable_sets == 0)
				if ((ret = update_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			StorageTmp->mtpRsTable_rsvs = 0;
			StorageTmp->mtpRsTable_tsts = 0;
			StorageTmp->mtpRsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsTable_sets == 0)
			revert_mtpRsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		if (StorageOld->mtpRsDest != NULL) {
			SNMP_FREE(StorageTmp->mtpRsDest);
			StorageTmp->mtpRsDest = StorageOld->mtpRsDest;
			StorageTmp->mtpRsDestLen = StorageOld->mtpRsDestLen;
			StorageOld->mtpRsDest = NULL;
			StorageOld->mtpRsDestLen = 0;
		}
		if (--StorageTmp->mtpRsTable_rsvs == 0)
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsOptions entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsOptions not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* Note: default value { rsfSecurity } */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			if (StorageTmp->mtpRsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRsOptions);
		StorageTmp->mtpRsOptions = string;
		StorageTmp->mtpRsOptionsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsTable_tsts == 0)
				if ((ret = check_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsOptions for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsTable_sets == 0)
				if ((ret = update_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			StorageTmp->mtpRsTable_rsvs = 0;
			StorageTmp->mtpRsTable_tsts = 0;
			StorageTmp->mtpRsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsTable_sets == 0)
			revert_mtpRsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		if (StorageOld->mtpRsOptions != NULL) {
			SNMP_FREE(StorageTmp->mtpRsOptions);
			StorageTmp->mtpRsOptions = StorageOld->mtpRsOptions;
			StorageTmp->mtpRsOptionsLen = StorageOld->mtpRsOptionsLen;
			StorageOld->mtpRsOptions = NULL;
			StorageOld->mtpRsOptionsLen = 0;
		}
		if (--StorageTmp->mtpRsTable_rsvs == 0)
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAdministrativeState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPRSADMINISTRATIVESTATE_LOCKED:
		case MTPRSADMINISTRATIVESTATE_UNLOCKED:
		case MTPRSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			if (StorageTmp->mtpRsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsTable_rsvs++;
		StorageTmp->mtpRsAdministrativeState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsTable_tsts == 0)
				if ((ret = check_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsTable_sets == 0)
				if ((ret = update_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			StorageTmp->mtpRsTable_rsvs = 0;
			StorageTmp->mtpRsTable_tsts = 0;
			StorageTmp->mtpRsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsTable_sets == 0)
			revert_mtpRsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		StorageTmp->mtpRsAdministrativeState = StorageOld->mtpRsAdministrativeState;
		if (--StorageTmp->mtpRsTable_rsvs == 0)
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			if (StorageTmp->mtpRsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpRsAsaProfilePointer);
		StorageTmp->mtpRsAsaProfilePointer = objid;
		StorageTmp->mtpRsAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsTable_tsts == 0)
				if ((ret = check_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsTable_sets == 0)
				if ((ret = update_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			StorageTmp->mtpRsTable_rsvs = 0;
			StorageTmp->mtpRsTable_tsts = 0;
			StorageTmp->mtpRsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsTable_sets == 0)
			revert_mtpRsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		if (StorageOld->mtpRsAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpRsAsaProfilePointer);
			StorageTmp->mtpRsAsaProfilePointer = StorageOld->mtpRsAsaProfilePointer;
			StorageTmp->mtpRsAsaProfilePointerLen = StorageOld->mtpRsAsaProfilePointerLen;
			StorageOld->mtpRsAsaProfilePointer = NULL;
			StorageOld->mtpRsAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpRsTable_rsvs == 0)
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsLoadsharingInformation entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			if (StorageTmp->mtpRsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRsLoadsharingInformation);
		StorageTmp->mtpRsLoadsharingInformation = string;
		StorageTmp->mtpRsLoadsharingInformationLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsTable_tsts == 0)
				if ((ret = check_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsLoadsharingInformation for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsTable_sets == 0)
				if ((ret = update_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			StorageTmp->mtpRsTable_rsvs = 0;
			StorageTmp->mtpRsTable_tsts = 0;
			StorageTmp->mtpRsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsTable_sets == 0)
			revert_mtpRsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		if (StorageOld->mtpRsLoadsharingInformation != NULL) {
			SNMP_FREE(StorageTmp->mtpRsLoadsharingInformation);
			StorageTmp->mtpRsLoadsharingInformation = StorageOld->mtpRsLoadsharingInformation;
			StorageTmp->mtpRsLoadsharingInformationLen = StorageOld->mtpRsLoadsharingInformationLen;
			StorageOld->mtpRsLoadsharingInformation = NULL;
			StorageOld->mtpRsLoadsharingInformationLen = 0;
		}
		if (--StorageTmp->mtpRsTable_rsvs == 0)
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsLoadsharingObject entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsLoadsharingObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			if (StorageTmp->mtpRsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpRsLoadsharingObject);
		StorageTmp->mtpRsLoadsharingObject = objid;
		StorageTmp->mtpRsLoadsharingObjectLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsTable_tsts == 0)
				if ((ret = check_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsLoadsharingObject for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsTable_sets == 0)
				if ((ret = update_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			StorageTmp->mtpRsTable_rsvs = 0;
			StorageTmp->mtpRsTable_tsts = 0;
			StorageTmp->mtpRsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsTable_sets == 0)
			revert_mtpRsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		if (StorageOld->mtpRsLoadsharingObject != NULL) {
			SNMP_FREE(StorageTmp->mtpRsLoadsharingObject);
			StorageTmp->mtpRsLoadsharingObject = StorageOld->mtpRsLoadsharingObject;
			StorageTmp->mtpRsLoadsharingObjectLen = StorageOld->mtpRsLoadsharingObjectLen;
			StorageOld->mtpRsLoadsharingObject = NULL;
			StorageOld->mtpRsLoadsharingObjectLen = 0;
		}
		if (--StorageTmp->mtpRsTable_rsvs == 0)
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsRemoteExchangeLabel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsRemoteExchangeLabel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRemoteExchangeLabel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			if (StorageTmp->mtpRsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRsRemoteExchangeLabel);
		StorageTmp->mtpRsRemoteExchangeLabel = string;
		StorageTmp->mtpRsRemoteExchangeLabelLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsTable_tsts == 0)
				if ((ret = check_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsRemoteExchangeLabel for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsTable_sets == 0)
				if ((ret = update_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			StorageTmp->mtpRsTable_rsvs = 0;
			StorageTmp->mtpRsTable_tsts = 0;
			StorageTmp->mtpRsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsTable_sets == 0)
			revert_mtpRsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		if (StorageOld->mtpRsRemoteExchangeLabel != NULL) {
			SNMP_FREE(StorageTmp->mtpRsRemoteExchangeLabel);
			StorageTmp->mtpRsRemoteExchangeLabel = StorageOld->mtpRsRemoteExchangeLabel;
			StorageTmp->mtpRsRemoteExchangeLabelLen = StorageOld->mtpRsRemoteExchangeLabelLen;
			StorageOld->mtpRsRemoteExchangeLabel = NULL;
			StorageOld->mtpRsRemoteExchangeLabelLen = 0;
		}
		if (--StorageTmp->mtpRsTable_rsvs == 0)
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			if (StorageTmp->mtpRsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRsName);
		StorageTmp->mtpRsName = string;
		StorageTmp->mtpRsNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsTable_tsts == 0)
				if ((ret = check_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsTable_sets == 0)
				if ((ret = update_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			StorageTmp->mtpRsTable_rsvs = 0;
			StorageTmp->mtpRsTable_tsts = 0;
			StorageTmp->mtpRsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsTable_sets == 0)
			revert_mtpRsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		if (StorageOld->mtpRsName != NULL) {
			SNMP_FREE(StorageTmp->mtpRsName);
			StorageTmp->mtpRsName = StorageOld->mtpRsName;
			StorageTmp->mtpRsNameLen = StorageOld->mtpRsNameLen;
			StorageOld->mtpRsName = NULL;
			StorageOld->mtpRsNameLen = 0;
		}
		if (--StorageTmp->mtpRsTable_rsvs == 0)
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfile entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			if (StorageTmp->mtpRsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRsProfile);
		StorageTmp->mtpRsProfile = string;
		StorageTmp->mtpRsProfileLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsTable_tsts == 0)
				if ((ret = check_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsProfile for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsTable_sets == 0)
				if ((ret = update_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			StorageTmp->mtpRsTable_rsvs = 0;
			StorageTmp->mtpRsTable_tsts = 0;
			StorageTmp->mtpRsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsTable_sets == 0)
			revert_mtpRsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		if (StorageOld->mtpRsProfile != NULL) {
			SNMP_FREE(StorageTmp->mtpRsProfile);
			StorageTmp->mtpRsProfile = StorageOld->mtpRsProfile;
			StorageTmp->mtpRsProfileLen = StorageOld->mtpRsProfileLen;
			StorageOld->mtpRsProfile = NULL;
			StorageOld->mtpRsProfileLen = 0;
		}
		if (--StorageTmp->mtpRsTable_rsvs == 0)
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			if (StorageTmp->mtpRsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRsAlarmStatus);
		StorageTmp->mtpRsAlarmStatus = string;
		StorageTmp->mtpRsAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRsTable_tsts == 0)
				if ((ret = check_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRsAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRsTable_sets == 0)
				if ((ret = update_mtpRsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			StorageTmp->mtpRsTable_rsvs = 0;
			StorageTmp->mtpRsTable_tsts = 0;
			StorageTmp->mtpRsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRsTable_sets == 0)
			revert_mtpRsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
			break;
		if (StorageOld->mtpRsAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->mtpRsAlarmStatus);
			StorageTmp->mtpRsAlarmStatus = StorageOld->mtpRsAlarmStatus;
			StorageTmp->mtpRsAlarmStatusLen = StorageOld->mtpRsAlarmStatusLen;
			StorageOld->mtpRsAlarmStatus = NULL;
			StorageOld->mtpRsAlarmStatusLen = 0;
		}
		if (--StorageTmp->mtpRsTable_rsvs == 0)
			mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfileTimerT6 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) == NULL)
			if (StorageTmp->mtpRtProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtProfileTable_old = mtpRtProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtProfileTable_rsvs++;
		StorageTmp->mtpRtProfileTimerT6 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtProfileTable_tsts == 0)
				if ((ret = check_mtpRtProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtProfileTimerT6 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtProfileTable_sets == 0)
				if ((ret = update_mtpRtProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) != NULL) {
			mtpRtProfileTable_destroy(&StorageTmp->mtpRtProfileTable_old);
			StorageTmp->mtpRtProfileTable_rsvs = 0;
			StorageTmp->mtpRtProfileTable_tsts = 0;
			StorageTmp->mtpRtProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtProfileTable_sets == 0)
			revert_mtpRtProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) == NULL)
			break;
		StorageTmp->mtpRtProfileTimerT6 = StorageOld->mtpRtProfileTimerT6;
		if (--StorageTmp->mtpRtProfileTable_rsvs == 0)
			mtpRtProfileTable_destroy(&StorageTmp->mtpRtProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfileTimerT10 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4500 */
		/* Note: ranges 3000..6000 */
		if ((3000 > set_value || set_value > 6000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileTimerT10: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) == NULL)
			if (StorageTmp->mtpRtProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtProfileTable_old = mtpRtProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtProfileTable_rsvs++;
		StorageTmp->mtpRtProfileTimerT10 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtProfileTable_tsts == 0)
				if ((ret = check_mtpRtProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtProfileTimerT10 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtProfileTable_sets == 0)
				if ((ret = update_mtpRtProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) != NULL) {
			mtpRtProfileTable_destroy(&StorageTmp->mtpRtProfileTable_old);
			StorageTmp->mtpRtProfileTable_rsvs = 0;
			StorageTmp->mtpRtProfileTable_tsts = 0;
			StorageTmp->mtpRtProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtProfileTable_sets == 0)
			revert_mtpRtProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtProfileTable_old) == NULL)
			break;
		StorageTmp->mtpRtProfileTimerT10 = StorageOld->mtpRtProfileTimerT10;
		if (--StorageTmp->mtpRtProfileTable_rsvs == 0)
			mtpRtProfileTable_destroy(&StorageTmp->mtpRtProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLsPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLsPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpRtLsPointer);
		StorageTmp->mtpRtLsPointer = objid;
		StorageTmp->mtpRtLsPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtLsPointer for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		if (StorageOld->mtpRtLsPointer != NULL) {
			SNMP_FREE(StorageTmp->mtpRtLsPointer);
			StorageTmp->mtpRtLsPointer = StorageOld->mtpRtLsPointer;
			StorageTmp->mtpRtLsPointerLen = StorageOld->mtpRtLsPointerLen;
			StorageOld->mtpRtLsPointer = NULL;
			StorageOld->mtpRtLsPointerLen = 0;
		}
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtAdministrativeState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPRTADMINISTRATIVESTATE_LOCKED:
		case MTPRTADMINISTRATIVESTATE_UNLOCKED:
		case MTPRTADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		StorageTmp->mtpRtAdministrativeState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		StorageTmp->mtpRtAdministrativeState = StorageOld->mtpRtAdministrativeState;
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtInClsLoadsharingAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtInClsLoadsharingAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtInClsLoadsharingAlgorithm entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 16 */
		/* Note: ranges 0..0 16..16 32..32 256..256 */
		if (set_value != 0 && set_value != 16 && set_value != 32 && set_value != 256) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtInClsLoadsharingAlgorithm: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtInClsLoadsharingAlgorithm for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		StorageTmp->mtpRtInClsLoadsharingAlgorithm = StorageOld->mtpRtInClsLoadsharingAlgorithm;
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtFixedPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtFixedPriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtFixedPriority entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFixedPriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		StorageTmp->mtpRtFixedPriority = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtFixedPriority for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		StorageTmp->mtpRtFixedPriority = StorageOld->mtpRtFixedPriority;
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtFlexiblePriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtFlexiblePriority(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtFlexiblePriority entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtFlexiblePriority: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		StorageTmp->mtpRtFlexiblePriority = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtFlexiblePriority for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		StorageTmp->mtpRtFlexiblePriority = StorageOld->mtpRtFlexiblePriority;
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtPriorityMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtPriorityMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtPriorityMode entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPRTPRIORITYMODE_INSERT:
		case MTPRTPRIORITYMODE_EQUAL:
		case MTPRTPRIORITYMODE_EXCHANGESINGLE:
		case MTPRTPRIORITYMODE_EXCHANGEGROUP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtPriorityMode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		StorageTmp->mtpRtPriorityMode = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtPriorityMode for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		StorageTmp->mtpRtPriorityMode = StorageOld->mtpRtPriorityMode;
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLoadsharingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLoadsharingInformation entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRtLoadsharingInformation);
		StorageTmp->mtpRtLoadsharingInformation = string;
		StorageTmp->mtpRtLoadsharingInformationLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtLoadsharingInformation for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		if (StorageOld->mtpRtLoadsharingInformation != NULL) {
			SNMP_FREE(StorageTmp->mtpRtLoadsharingInformation);
			StorageTmp->mtpRtLoadsharingInformation = StorageOld->mtpRtLoadsharingInformation;
			StorageTmp->mtpRtLoadsharingInformationLen = StorageOld->mtpRtLoadsharingInformationLen;
			StorageOld->mtpRtLoadsharingInformation = NULL;
			StorageOld->mtpRtLoadsharingInformationLen = 0;
		}
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLoadsharingObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLoadsharingObject entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLoadsharingObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpRtLoadsharingObject);
		StorageTmp->mtpRtLoadsharingObject = objid;
		StorageTmp->mtpRtLoadsharingObjectLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtLoadsharingObject for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		if (StorageOld->mtpRtLoadsharingObject != NULL) {
			SNMP_FREE(StorageTmp->mtpRtLoadsharingObject);
			StorageTmp->mtpRtLoadsharingObject = StorageOld->mtpRtLoadsharingObject;
			StorageTmp->mtpRtLoadsharingObjectLen = StorageOld->mtpRtLoadsharingObjectLen;
			StorageOld->mtpRtLoadsharingObject = NULL;
			StorageOld->mtpRtLoadsharingObjectLen = 0;
		}
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRtName);
		StorageTmp->mtpRtName = string;
		StorageTmp->mtpRtNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		if (StorageOld->mtpRtName != NULL) {
			SNMP_FREE(StorageTmp->mtpRtName);
			StorageTmp->mtpRtName = StorageOld->mtpRtName;
			StorageTmp->mtpRtNameLen = StorageOld->mtpRtNameLen;
			StorageOld->mtpRtName = NULL;
			StorageOld->mtpRtNameLen = 0;
		}
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtSlsList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtSlsList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtSlsList entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..0 2..2 4..4 32..32 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 0 && var_val_len != 2 && var_val_len != 4 && var_val_len != 32)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtSlsList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRtSlsList);
		StorageTmp->mtpRtSlsList = string;
		StorageTmp->mtpRtSlsListLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtSlsList for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		if (StorageOld->mtpRtSlsList != NULL) {
			SNMP_FREE(StorageTmp->mtpRtSlsList);
			StorageTmp->mtpRtSlsList = StorageOld->mtpRtSlsList;
			StorageTmp->mtpRtSlsListLen = StorageOld->mtpRtSlsListLen;
			StorageOld->mtpRtSlsList = NULL;
			StorageOld->mtpRtSlsListLen = 0;
		}
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtRlSlot(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtRlSlot(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtRlSlot entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..3 */
		if ((0 > set_value || set_value > 3)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRlSlot: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		StorageTmp->mtpRtRlSlot = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtRlSlot for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		StorageTmp->mtpRtRlSlot = StorageOld->mtpRtRlSlot;
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfile entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpRtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			if (StorageTmp->mtpRtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRtProfile);
		StorageTmp->mtpRtProfile = string;
		StorageTmp->mtpRtProfileLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtTable_tsts == 0)
				if ((ret = check_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtProfile for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtTable_sets == 0)
				if ((ret = update_mtpRtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			StorageTmp->mtpRtTable_rsvs = 0;
			StorageTmp->mtpRtTable_tsts = 0;
			StorageTmp->mtpRtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtTable_sets == 0)
			revert_mtpRtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
			break;
		if (StorageOld->mtpRtProfile != NULL) {
			SNMP_FREE(StorageTmp->mtpRtProfile);
			StorageTmp->mtpRtProfile = StorageOld->mtpRtProfile;
			StorageTmp->mtpRtProfileLen = StorageOld->mtpRtProfileLen;
			StorageOld->mtpRtProfile = NULL;
			StorageOld->mtpRtProfileLen = 0;
		}
		if (--StorageTmp->mtpRtTable_rsvs == 0)
			mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLsaNormalSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLsaNormalSlCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtLsaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsaNormalSlCode entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..15 */
		if ((0 > set_value || set_value > 15)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaNormalSlCode: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) == NULL)
			if (StorageTmp->mtpRtLsaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtLsaTable_old = mtpRtLsaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtLsaTable_rsvs++;
		StorageTmp->mtpRtLsaNormalSlCode = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtLsaTable_tsts == 0)
				if ((ret = check_mtpRtLsaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtLsaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtLsaNormalSlCode for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtLsaTable_sets == 0)
				if ((ret = update_mtpRtLsaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtLsaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) != NULL) {
			mtpRtLsaTable_destroy(&StorageTmp->mtpRtLsaTable_old);
			StorageTmp->mtpRtLsaTable_rsvs = 0;
			StorageTmp->mtpRtLsaTable_tsts = 0;
			StorageTmp->mtpRtLsaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtLsaTable_sets == 0)
			revert_mtpRtLsaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) == NULL)
			break;
		StorageTmp->mtpRtLsaNormalSlCode = StorageOld->mtpRtLsaNormalSlCode;
		if (--StorageTmp->mtpRtLsaTable_rsvs == 0)
			mtpRtLsaTable_destroy(&StorageTmp->mtpRtLsaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtLsaAlternativeSlCodeList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpRtLsaAlternativeSlCodeList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtLsaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtLsaAlternativeSlCodeList entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpRtLsaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaAlternativeSlCodeList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..15 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 15))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtLsaAlternativeSlCodeList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) == NULL)
			if (StorageTmp->mtpRtLsaTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpRtLsaTable_old = mtpRtLsaTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpRtLsaTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpRtLsaAlternativeSlCodeList);
		StorageTmp->mtpRtLsaAlternativeSlCodeList = string;
		StorageTmp->mtpRtLsaAlternativeSlCodeListLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpRtLsaTable_tsts == 0)
				if ((ret = check_mtpRtLsaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtLsaTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpRtLsaAlternativeSlCodeList for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpRtLsaTable_sets == 0)
				if ((ret = update_mtpRtLsaTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpRtLsaTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) != NULL) {
			mtpRtLsaTable_destroy(&StorageTmp->mtpRtLsaTable_old);
			StorageTmp->mtpRtLsaTable_rsvs = 0;
			StorageTmp->mtpRtLsaTable_tsts = 0;
			StorageTmp->mtpRtLsaTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpRtLsaTable_sets == 0)
			revert_mtpRtLsaTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpRtLsaTable_old) == NULL)
			break;
		if (StorageOld->mtpRtLsaAlternativeSlCodeList != NULL) {
			SNMP_FREE(StorageTmp->mtpRtLsaAlternativeSlCodeList);
			StorageTmp->mtpRtLsaAlternativeSlCodeList = StorageOld->mtpRtLsaAlternativeSlCodeList;
			StorageTmp->mtpRtLsaAlternativeSlCodeListLen = StorageOld->mtpRtLsaAlternativeSlCodeListLen;
			StorageOld->mtpRtLsaAlternativeSlCodeList = NULL;
			StorageOld->mtpRtLsaAlternativeSlCodeListLen = 0;
		}
		if (--StorageTmp->mtpRtLsaTable_rsvs == 0)
			mtpRtLsaTable_destroy(&StorageTmp->mtpRtLsaTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT6 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileTimerT6 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT6 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileTimerT6 = StorageOld->mtpLsProfileTimerT6;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT8(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT8 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 80..120 */
		if ((80 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT8: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileTimerT8 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT8 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileTimerT8 = StorageOld->mtpLsProfileTimerT8;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT10(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT10 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4500 */
		/* Note: ranges 3000..6000 */
		if ((3000 > set_value || set_value > 6000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT10: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileTimerT10 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT10 for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileTimerT10 = StorageOld->mtpLsProfileTimerT10;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT7 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 150 */
		/* Note: ranges 100..200 */
		if ((100 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileTimerT7 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT7 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileTimerT7 = StorageOld->mtpLsProfileTimerT7;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT19I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT19I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6800 */
		/* Note: ranges 6700..6900 */
		if ((6700 > set_value || set_value > 6900)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT19I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileTimerT19I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT19I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileTimerT19I = StorageOld->mtpLsProfileTimerT19I;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT21I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT21I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6400 */
		/* Note: ranges 6300..6500 */
		if ((6300 > set_value || set_value > 6500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT21I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileTimerT21I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT21I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileTimerT21I = StorageOld->mtpLsProfileTimerT21I;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT25A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT25A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT25A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges 3000..3500 */
		if ((3000 > set_value || set_value > 3500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT25A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileTimerT25A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT25A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileTimerT25A = StorageOld->mtpLsProfileTimerT25A;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT28A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT28A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT28A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2000 */
		/* Note: ranges 300..3500 */
		if ((300 > set_value || set_value > 3500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT28A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileTimerT28A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT28A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileTimerT28A = StorageOld->mtpLsProfileTimerT28A;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT29A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT29A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT29A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 6000..6500 */
		if ((6000 > set_value || set_value > 6500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT29A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileTimerT29A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT29A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileTimerT29A = StorageOld->mtpLsProfileTimerT29A;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileTimerT30A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileTimerT30A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileTimerT30A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges 3000..3500 */
		if ((3000 > set_value || set_value > 3500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileTimerT30A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileTimerT30A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileTimerT30A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileTimerT30A = StorageOld->mtpLsProfileTimerT30A;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileParameterN(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileParameterN(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileParameterN entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterN: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterN not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterN: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 50 */
		/* Note: ranges 50..200 */
		if ((50 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterN: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileParameterN = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileParameterN for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileParameterN = StorageOld->mtpLsProfileParameterN;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileParameterM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileParameterM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileParameterM entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterM: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterM not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3 */
		/* Note: ranges 3..10 */
		if ((3 > set_value || set_value > 10)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileParameterM: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		StorageTmp->mtpLsProfileParameterM = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileParameterM for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		StorageTmp->mtpLsProfileParameterM = StorageOld->mtpLsProfileParameterM;
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpLsProfileName);
		StorageTmp->mtpLsProfileName = string;
		StorageTmp->mtpLsProfileNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpLsProfileName != NULL) {
			SNMP_FREE(StorageTmp->mtpLsProfileName);
			StorageTmp->mtpLsProfileName = StorageOld->mtpLsProfileName;
			StorageTmp->mtpLsProfileNameLen = StorageOld->mtpLsProfileNameLen;
			StorageOld->mtpLsProfileName = NULL;
			StorageOld->mtpLsProfileNameLen = 0;
		}
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileSlDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfileSlDefault(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileSlDefault entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileSlDefault: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			if (StorageTmp->mtpLsProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsProfileTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpLsProfileSlDefault);
		StorageTmp->mtpLsProfileSlDefault = string;
		StorageTmp->mtpLsProfileSlDefaultLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsProfileTable_tsts == 0)
				if ((ret = check_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfileSlDefault for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsProfileTable_sets == 0)
				if ((ret = update_mtpLsProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			StorageTmp->mtpLsProfileTable_rsvs = 0;
			StorageTmp->mtpLsProfileTable_tsts = 0;
			StorageTmp->mtpLsProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsProfileTable_sets == 0)
			revert_mtpLsProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpLsProfileSlDefault != NULL) {
			SNMP_FREE(StorageTmp->mtpLsProfileSlDefault);
			StorageTmp->mtpLsProfileSlDefault = StorageOld->mtpLsProfileSlDefault;
			StorageTmp->mtpLsProfileSlDefaultLen = StorageOld->mtpLsProfileSlDefaultLen;
			StorageOld->mtpLsProfileSlDefault = NULL;
			StorageOld->mtpLsProfileSlDefaultLen = 0;
		}
		if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
			mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAdjPc entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdjPc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x00\x00\x00\x00\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpLsAdjPc);
		StorageTmp->mtpLsAdjPc = string;
		StorageTmp->mtpLsAdjPcLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsAdjPc for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		if (StorageOld->mtpLsAdjPc != NULL) {
			SNMP_FREE(StorageTmp->mtpLsAdjPc);
			StorageTmp->mtpLsAdjPc = StorageOld->mtpLsAdjPc;
			StorageTmp->mtpLsAdjPcLen = StorageOld->mtpLsAdjPcLen;
			StorageOld->mtpLsAdjPc = NULL;
			StorageOld->mtpLsAdjPcLen = 0;
		}
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsRsId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsRsId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsRsId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRsId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpLsRsId);
		StorageTmp->mtpLsRsId = objid;
		StorageTmp->mtpLsRsIdLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsRsId for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		if (StorageOld->mtpLsRsId != NULL) {
			SNMP_FREE(StorageTmp->mtpLsRsId);
			StorageTmp->mtpLsRsId = StorageOld->mtpLsRsId;
			StorageTmp->mtpLsRsIdLen = StorageOld->mtpLsRsIdLen;
			StorageOld->mtpLsRsId = NULL;
			StorageOld->mtpLsRsIdLen = 0;
		}
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsMaxCapacity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsMaxCapacity entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..128000 */
		if ((0 > set_value || set_value > 128000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsMaxCapacity: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		StorageTmp->mtpLsMaxCapacity = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsMaxCapacity for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		StorageTmp->mtpLsMaxCapacity = StorageOld->mtpLsMaxCapacity;
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsCongestionControlMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsCongestionControlMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsCongestionControlMethod entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value ccmQ704International */
		switch (set_value) {
		case MTPLSCONGESTIONCONTROLMETHOD_UNKNOWN:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704INTERNATIONAL:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALWITHPRIO:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALNOPRIOBUFFERMECHANISM:
		case MTPLSCONGESTIONCONTROLMETHOD_CCMQ704NATIONALNOPRIOTIMERMECHANISM:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsCongestionControlMethod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		StorageTmp->mtpLsCongestionControlMethod = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsCongestionControlMethod for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		StorageTmp->mtpLsCongestionControlMethod = StorageOld->mtpLsCongestionControlMethod;
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsPeriodicLinkTestFlag(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsPeriodicLinkTestFlag(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsPeriodicLinkTestFlag entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value on */
		switch (set_value) {
		case MTPLSPERIODICLINKTESTFLAG_ON:
		case MTPLSPERIODICLINKTESTFLAG_OFF:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFlag: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		StorageTmp->mtpLsPeriodicLinkTestFlag = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsPeriodicLinkTestFlag for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		StorageTmp->mtpLsPeriodicLinkTestFlag = StorageOld->mtpLsPeriodicLinkTestFlag;
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsPeriodicLinkTestFail(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsPeriodicLinkTestFail(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsPeriodicLinkTestFail entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsPeriodicLinkTestFail: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		StorageTmp->mtpLsPeriodicLinkTestFail = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsPeriodicLinkTestFail for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		StorageTmp->mtpLsPeriodicLinkTestFail = StorageOld->mtpLsPeriodicLinkTestFail;
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAdministrativeState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPLSADMINISTRATIVESTATE_LOCKED:
		case MTPLSADMINISTRATIVESTATE_UNLOCKED:
		case MTPLSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		StorageTmp->mtpLsAdministrativeState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		StorageTmp->mtpLsAdministrativeState = StorageOld->mtpLsAdministrativeState;
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsInLsLoadShareAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsInLsLoadShareAlgorithm(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsInLsLoadShareAlgorithm entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsInLsLoadShareAlgorithm: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value defaultInLsLoadShareAlgorithm */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpLsInLsLoadShareAlgorithm);
		StorageTmp->mtpLsInLsLoadShareAlgorithm = objid;
		StorageTmp->mtpLsInLsLoadShareAlgorithmLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsInLsLoadShareAlgorithm for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		if (StorageOld->mtpLsInLsLoadShareAlgorithm != NULL) {
			SNMP_FREE(StorageTmp->mtpLsInLsLoadShareAlgorithm);
			StorageTmp->mtpLsInLsLoadShareAlgorithm = StorageOld->mtpLsInLsLoadShareAlgorithm;
			StorageTmp->mtpLsInLsLoadShareAlgorithmLen = StorageOld->mtpLsInLsLoadShareAlgorithmLen;
			StorageOld->mtpLsInLsLoadShareAlgorithm = NULL;
			StorageOld->mtpLsInLsLoadShareAlgorithmLen = 0;
		}
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpLsProfilePointer);
		StorageTmp->mtpLsProfilePointer = string;
		StorageTmp->mtpLsProfilePointerLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		if (StorageOld->mtpLsProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpLsProfilePointer);
			StorageTmp->mtpLsProfilePointer = StorageOld->mtpLsProfilePointer;
			StorageTmp->mtpLsProfilePointerLen = StorageOld->mtpLsProfilePointerLen;
			StorageOld->mtpLsProfilePointer = NULL;
			StorageOld->mtpLsProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsNumberOfNormallyActiveSignLinks(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsNumberOfNormallyActiveSignLinks(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsNumberOfNormallyActiveSignLinks entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		/* Note: ranges 0..32 */
		if ((0 > set_value || set_value > 32)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsNumberOfNormallyActiveSignLinks: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		StorageTmp->mtpLsNumberOfNormallyActiveSignLinks = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsNumberOfNormallyActiveSignLinks for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		StorageTmp->mtpLsNumberOfNormallyActiveSignLinks = StorageOld->mtpLsNumberOfNormallyActiveSignLinks;
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpLsName);
		StorageTmp->mtpLsName = string;
		StorageTmp->mtpLsNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		if (StorageOld->mtpLsName != NULL) {
			SNMP_FREE(StorageTmp->mtpLsName);
			StorageTmp->mtpLsName = StorageOld->mtpLsName;
			StorageTmp->mtpLsNameLen = StorageOld->mtpLsNameLen;
			StorageOld->mtpLsName = NULL;
			StorageOld->mtpLsNameLen = 0;
		}
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpLsAsaProfilePointer);
		StorageTmp->mtpLsAsaProfilePointer = objid;
		StorageTmp->mtpLsAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		if (StorageOld->mtpLsAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpLsAsaProfilePointer);
			StorageTmp->mtpLsAsaProfilePointer = StorageOld->mtpLsAsaProfilePointer;
			StorageTmp->mtpLsAsaProfilePointerLen = StorageOld->mtpLsAsaProfilePointerLen;
			StorageOld->mtpLsAsaProfilePointer = NULL;
			StorageOld->mtpLsAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpLsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpLsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			if (StorageTmp->mtpLsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpLsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpLsAlarmStatus);
		StorageTmp->mtpLsAlarmStatus = string;
		StorageTmp->mtpLsAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpLsTable_tsts == 0)
				if ((ret = check_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpLsAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpLsTable_sets == 0)
				if ((ret = update_mtpLsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpLsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			StorageTmp->mtpLsTable_rsvs = 0;
			StorageTmp->mtpLsTable_tsts = 0;
			StorageTmp->mtpLsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpLsTable_sets == 0)
			revert_mtpLsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
			break;
		if (StorageOld->mtpLsAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->mtpLsAlarmStatus);
			StorageTmp->mtpLsAlarmStatus = StorageOld->mtpLsAlarmStatus;
			StorageTmp->mtpLsAlarmStatusLen = StorageOld->mtpLsAlarmStatusLen;
			StorageOld->mtpLsAlarmStatus = NULL;
			StorageOld->mtpLsAlarmStatusLen = 0;
		}
		if (--StorageTmp->mtpLsTable_rsvs == 0)
			mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT1 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT1 = StorageOld->mtpSlL3ProfileTimerT1;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT3 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT3 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT3 = StorageOld->mtpSlL3ProfileTimerT3;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT17(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT17 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 120 */
		/* Note: ranges 80..150 */
		if ((80 > set_value || set_value > 150)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT17: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT17 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT17 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT17 = StorageOld->mtpSlL3ProfileTimerT17;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT24I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT24I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT24I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 50 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT24I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT24I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT24I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT24I = StorageOld->mtpSlL3ProfileTimerT24I;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSlL3ProfileName);
		StorageTmp->mtpSlL3ProfileName = string;
		StorageTmp->mtpSlL3ProfileNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpSlL3ProfileName != NULL) {
			SNMP_FREE(StorageTmp->mtpSlL3ProfileName);
			StorageTmp->mtpSlL3ProfileName = StorageOld->mtpSlL3ProfileName;
			StorageTmp->mtpSlL3ProfileNameLen = StorageOld->mtpSlL3ProfileNameLen;
			StorageOld->mtpSlL3ProfileName = NULL;
			StorageOld->mtpSlL3ProfileNameLen = 0;
		}
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT2 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 140 */
		/* Note: ranges 70..200 */
		if ((70 > set_value || set_value > 200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT2 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT2 = StorageOld->mtpSlL3ProfileTimerT2;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT4 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT4 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT4 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT4 = StorageOld->mtpSlL3ProfileTimerT4;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT5 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 50..120 */
		if ((50 > set_value || set_value > 120)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT5 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT5 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT5 = StorageOld->mtpSlL3ProfileTimerT5;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT12(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT12 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 120 */
		/* Note: ranges 80..150 */
		if ((80 > set_value || set_value > 150)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT12: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT12 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT12 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT12 = StorageOld->mtpSlL3ProfileTimerT12;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT13(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT13 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 120 */
		/* Note: ranges 80..150 */
		if ((80 > set_value || set_value > 150)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT13: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT13 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT13 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT13 = StorageOld->mtpSlL3ProfileTimerT13;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT14(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT14 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 250 */
		/* Note: ranges 200..300 */
		if ((200 > set_value || set_value > 300)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT14: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT14 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT14 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT14 = StorageOld->mtpSlL3ProfileTimerT14;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT19A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 54000 */
		/* Note: ranges 48000..60000 */
		if ((48000 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT19A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT19A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT19A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT19A = StorageOld->mtpSlL3ProfileTimerT19A;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT20A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT20A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT20A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT20A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT20A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT20A = StorageOld->mtpSlL3ProfileTimerT20A;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT21A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT21A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 9000..12000 */
		if ((9000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT21A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT21A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT21A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT21A = StorageOld->mtpSlL3ProfileTimerT21A;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT22I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT22I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT22I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT22I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT22I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT22I = StorageOld->mtpSlL3ProfileTimerT22I;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT23I(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT23I entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 27000 */
		/* Note: ranges 18000..36000 */
		if ((18000 > set_value || set_value > 36000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT23I: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT23I = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT23I for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT23I = StorageOld->mtpSlL3ProfileTimerT23I;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT31A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 1000..12000 */
		if ((1000 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT31A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT31A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT31A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT31A = StorageOld->mtpSlL3ProfileTimerT31A;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT32A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT32A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT32A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT32A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT32A = StorageOld->mtpSlL3ProfileTimerT32A;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT33A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 36000 */
		/* Note: ranges 6000..60000 */
		if ((6000 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT33A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT33A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT33A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT33A = StorageOld->mtpSlL3ProfileTimerT33A;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT34A entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 500..12000 */
		if ((500 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT34A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT34A = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT34A for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT34A = StorageOld->mtpSlL3ProfileTimerT34A;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1T entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 400 */
		/* Note: ranges 400..1200 */
		if ((400 > set_value || set_value > 1200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT1T = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT1T for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT1T = StorageOld->mtpSlL3ProfileTimerT1T;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT2T entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 3000..9000 */
		if ((3000 > set_value || set_value > 9000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT2T = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT2T for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT2T = StorageOld->mtpSlL3ProfileTimerT2T;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileTimerT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileTimerT1S(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileTimerT1S entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 400 */
		/* Note: ranges 400..1200 */
		if ((400 > set_value || set_value > 1200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileTimerT1S: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		StorageTmp->mtpSlL3ProfileTimerT1S = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileTimerT1S for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL3ProfileTimerT1S = StorageOld->mtpSlL3ProfileTimerT1S;
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileL2Default(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfileL2Default(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileL2Default entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL3ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileL2Default: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL3ProfileTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSlL3ProfileL2Default);
		StorageTmp->mtpSlL3ProfileL2Default = string;
		StorageTmp->mtpSlL3ProfileL2DefaultLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL3ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfileL2Default for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL3ProfileTable_sets == 0)
				if ((ret = update_mtpSlL3ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL3ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL3ProfileTable_tsts = 0;
			StorageTmp->mtpSlL3ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL3ProfileTable_sets == 0)
			revert_mtpSlL3ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpSlL3ProfileL2Default != NULL) {
			SNMP_FREE(StorageTmp->mtpSlL3ProfileL2Default);
			StorageTmp->mtpSlL3ProfileL2Default = StorageOld->mtpSlL3ProfileL2Default;
			StorageTmp->mtpSlL3ProfileL2DefaultLen = StorageOld->mtpSlL3ProfileL2DefaultLen;
			StorageOld->mtpSlL3ProfileL2Default = NULL;
			StorageOld->mtpSlL3ProfileL2DefaultLen = 0;
		}
		if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
			mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileErrorCorrectionMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileErrorCorrectionMethod(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileErrorCorrectionMethod entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value basicRetr */
		switch (set_value) {
		case MTPSLL2PROFILEERRORCORRECTIONMETHOD_BASICRETR:
		case MTPSLL2PROFILEERRORCORRECTIONMETHOD_PREVCYCLRETR:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileErrorCorrectionMethod: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileErrorCorrectionMethod = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileErrorCorrectionMethod for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileErrorCorrectionMethod = StorageOld->mtpSlL2ProfileErrorCorrectionMethod;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileProtocolVariant(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileProtocolVariant entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileProtocolVariant: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileProtocolVariant not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileProtocolVariant: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value ss7ProtocolItut */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSlL2ProfileProtocolVariant);
		StorageTmp->mtpSlL2ProfileProtocolVariant = objid;
		StorageTmp->mtpSlL2ProfileProtocolVariantLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileProtocolVariant for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpSlL2ProfileProtocolVariant != NULL) {
			SNMP_FREE(StorageTmp->mtpSlL2ProfileProtocolVariant);
			StorageTmp->mtpSlL2ProfileProtocolVariant = StorageOld->mtpSlL2ProfileProtocolVariant;
			StorageTmp->mtpSlL2ProfileProtocolVariantLen = StorageOld->mtpSlL2ProfileProtocolVariantLen;
			StorageOld->mtpSlL2ProfileProtocolVariant = NULL;
			StorageOld->mtpSlL2ProfileProtocolVariantLen = 0;
		}
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT1 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4500 */
		/* Note: ranges 1290..60000 */
		if ((1290 > set_value || set_value > 60000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerT1 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerT1 = StorageOld->mtpSlL2ProfileTimerT1;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* Note: ranges 500..15000 */
		if ((500 > set_value || set_value > 15000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerT2 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerT2 = StorageOld->mtpSlL2ProfileTimerT2;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT2L(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT2L(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2L entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2000 */
		/* Note: ranges 500..5000 */
		if ((500 > set_value || set_value > 5000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2L: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerT2L = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT2L for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerT2L = StorageOld->mtpSlL2ProfileTimerT2L;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT2H(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT2H(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT2H entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10000 */
		/* Note: ranges 7000..15000 */
		if ((7000 > set_value || set_value > 15000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT2H: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerT2H = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT2H for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerT2H = StorageOld->mtpSlL2ProfileTimerT2H;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT3 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 100..1400 */
		if ((100 > set_value || set_value > 1400)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerT3 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerT3 = StorageOld->mtpSlL2ProfileTimerT3;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT4N(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT4N(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT4N entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 800 */
		/* Note: ranges 230..12000 */
		if ((230 > set_value || set_value > 12000)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4N: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerT4N = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT4N for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerT4N = StorageOld->mtpSlL2ProfileTimerT4N;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT4E(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT4E(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT4E entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 50 */
		/* Note: ranges 40..800 */
		if ((40 > set_value || set_value > 800)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT4E: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerT4E = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT4E for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerT4E = StorageOld->mtpSlL2ProfileTimerT4E;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT5 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 8..12 */
		if ((8 > set_value || set_value > 12)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerT5 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT5 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerT5 = StorageOld->mtpSlL2ProfileTimerT5;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT6(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT6 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 400 */
		/* Note: ranges 300..1200 */
		if ((300 > set_value || set_value > 1200)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT6: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerT6 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT6 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerT6 = StorageOld->mtpSlL2ProfileTimerT6;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerT7 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 50..600 */
		if ((50 > set_value || set_value > 600)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerT7 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerT7 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerT7 = StorageOld->mtpSlL2ProfileTimerT7;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbOnset1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbOnset1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset1 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 69632 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTbOnset1 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbOnset1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTbOnset1 = StorageOld->mtpSlL2ProfileTbOnset1;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbAbate1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbAbate1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate1 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 34816 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTbAbate1 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbAbate1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTbAbate1 = StorageOld->mtpSlL2ProfileTbAbate1;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileNumberOfThresholdLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileNumberOfThresholdLevels(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileNumberOfThresholdLevels entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfThresholdLevels: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileNumberOfThresholdLevels = StorageOld->mtpSlL2ProfileNumberOfThresholdLevels;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileCongestionCounting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileCongestionCounting(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileCongestionCounting entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value octet */
		switch (set_value) {
		case MTPSLL2PROFILECONGESTIONCOUNTING_OCTET:
		case MTPSLL2PROFILECONGESTIONCOUNTING_MESSAGE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionCounting: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileCongestionCounting = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileCongestionCounting for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileCongestionCounting = StorageOld->mtpSlL2ProfileCongestionCounting;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileCongestionReportingBaseObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileCongestionReportingBaseObject(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileCongestionReportingBaseObject entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value routeSet */
		switch (set_value) {
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_ROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_LINKSETOFCONGESTEDROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_LINKOFCONGESTEDROUTESET:
		case MTPSLL2PROFILECONGESTIONREPORTINGBASEOBJECT_CONGESTEDLINKOFCONGESTEDROUTE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileCongestionReportingBaseObject: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileCongestionReportingBaseObject = StorageOld->mtpSlL2ProfileCongestionReportingBaseObject;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileLoopDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileLoopDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileLoopDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileLoopDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileLoopDelay = StorageOld->mtpSlL2ProfileLoopDelay;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSlL2ProfileName);
		StorageTmp->mtpSlL2ProfileName = string;
		StorageTmp->mtpSlL2ProfileNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileName for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		if (StorageOld->mtpSlL2ProfileName != NULL) {
			SNMP_FREE(StorageTmp->mtpSlL2ProfileName);
			StorageTmp->mtpSlL2ProfileName = StorageOld->mtpSlL2ProfileName;
			StorageTmp->mtpSlL2ProfileNameLen = StorageOld->mtpSlL2ProfileNameLen;
			StorageOld->mtpSlL2ProfileName = NULL;
			StorageOld->mtpSlL2ProfileNameLen = 0;
		}
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbOnset2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbOnset2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset2 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 174080 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTbOnset2 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbOnset2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTbOnset2 = StorageOld->mtpSlL2ProfileTbOnset2;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbAbate2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbAbate2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate2 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 139264 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTbAbate2 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbAbate2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTbAbate2 = StorageOld->mtpSlL2ProfileTbAbate2;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbOnset3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbOnset3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbOnset3 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbOnset3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 278528 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTbOnset3 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbOnset3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTbOnset3 = StorageOld->mtpSlL2ProfileTbOnset3;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbAbate3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbAbate3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbAbate3 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbAbate3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 243712 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTbAbate3 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbAbate3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTbAbate3 = StorageOld->mtpSlL2ProfileTbAbate3;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbDiscard1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbDiscard1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard1 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 104448 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTbDiscard1 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbDiscard1 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTbDiscard1 = StorageOld->mtpSlL2ProfileTbDiscard1;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbDiscard2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbDiscard2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard2 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 208896 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTbDiscard2 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbDiscard2 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTbDiscard2 = StorageOld->mtpSlL2ProfileTbDiscard2;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTbDiscard3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTbDiscard3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTbDiscard3 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTbDiscard3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 313344 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTbDiscard3 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTbDiscard3 for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTbDiscard3 = StorageOld->mtpSlL2ProfileTbDiscard3;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerTx(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerTx(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerTx entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTx: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerTx = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerTx for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerTx = StorageOld->mtpSlL2ProfileTimerTx;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileTimerTy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileTimerTy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileTimerTy entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileTimerTy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileTimerTy = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileTimerTy for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileTimerTy = StorageOld->mtpSlL2ProfileTimerTy;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileNumberOfCongestionStates(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileNumberOfCongestionStates(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileNumberOfCongestionStates entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileNumberOfCongestionStates: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileNumberOfCongestionStates = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileNumberOfCongestionStates for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileNumberOfCongestionStates = StorageOld->mtpSlL2ProfileNumberOfCongestionStates;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileInitialLevelOfCongestion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileInitialLevelOfCongestion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileInitialLevelOfCongestion entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileInitialLevelOfCongestion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileInitialLevelOfCongestion = StorageOld->mtpSlL2ProfileInitialLevelOfCongestion;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileMaxMSUsRetransN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileMaxMSUsRetransN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileMaxMSUsRetransN1 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 127 */
		/* Note: ranges 0..16777215 */
		if ((0 > set_value || set_value > 16777215)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxMSUsRetransN1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileMaxMSUsRetransN1 = StorageOld->mtpSlL2ProfileMaxMSUsRetransN1;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileMaxOctRetransN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileMaxOctRetransN2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileMaxOctRetransN2 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileMaxOctRetransN2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8192 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileMaxOctRetransN2 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileMaxOctRetransN2 for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileMaxOctRetransN2 = StorageOld->mtpSlL2ProfileMaxOctRetransN2;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileReceiveCongestionThresholdOnset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileReceiveCongestionThresholdOnset(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdOnset entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdOnset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset for you to use, and you have just been asked to do something with it.
				   Note that anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdOnset = StorageOld->mtpSlL2ProfileReceiveCongestionThresholdOnset;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileReceiveCongestionThresholdAbate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileReceiveCongestionThresholdAbate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdAbate entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdAbate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate for you to use, and you have just been asked to do something with it.
				   Note that anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdAbate = StorageOld->mtpSlL2ProfileReceiveCongestionThresholdAbate;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileReceiveCongestionThresholdDiscard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileReceiveCongestionThresholdDiscard(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileReceiveCongestionThresholdDiscard entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileReceiveCongestionThresholdDiscard: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 9 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard for you to use, and you have just been asked to do something with it.
				   Note that anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileReceiveCongestionThresholdDiscard = StorageOld->mtpSlL2ProfileReceiveCongestionThresholdDiscard;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL2ProfileM(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileM entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlL2ProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileM: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlL2ProfileTable_rsvs++;
		StorageTmp->mtpSlL2ProfileM = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlL2ProfileTable_tsts == 0)
				if ((ret = check_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL2ProfileM for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlL2ProfileTable_sets == 0)
				if ((ret = update_mtpSlL2ProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlL2ProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
			StorageTmp->mtpSlL2ProfileTable_tsts = 0;
			StorageTmp->mtpSlL2ProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlL2ProfileTable_sets == 0)
			revert_mtpSlL2ProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSlL2ProfileM = StorageOld->mtpSlL2ProfileM;
		if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
			mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAdministrativeState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPSLADMINISTRATIVESTATE_LOCKED:
		case MTPSLADMINISTRATIVESTATE_UNLOCKED:
		case MTPSLADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		StorageTmp->mtpSlAdministrativeState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		StorageTmp->mtpSlAdministrativeState = StorageOld->mtpSlAdministrativeState;
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlMtpL2ProtocolProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlMtpL2ProtocolProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlMtpL2ProtocolProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlMtpL2ProtocolProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSlMtpL2ProtocolProfilePointer);
		StorageTmp->mtpSlMtpL2ProtocolProfilePointer = string;
		StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlMtpL2ProtocolProfilePointer for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		if (StorageOld->mtpSlMtpL2ProtocolProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSlMtpL2ProtocolProfilePointer);
			StorageTmp->mtpSlMtpL2ProtocolProfilePointer = StorageOld->mtpSlMtpL2ProtocolProfilePointer;
			StorageTmp->mtpSlMtpL2ProtocolProfilePointerLen = StorageOld->mtpSlMtpL2ProtocolProfilePointerLen;
			StorageOld->mtpSlMtpL2ProtocolProfilePointer = NULL;
			StorageOld->mtpSlMtpL2ProtocolProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSignTermPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSignTermPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSignTermPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignTermPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSlSignTermPointer);
		StorageTmp->mtpSlSignTermPointer = objid;
		StorageTmp->mtpSlSignTermPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSignTermPointer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		if (StorageOld->mtpSlSignTermPointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSlSignTermPointer);
			StorageTmp->mtpSlSignTermPointer = StorageOld->mtpSlSignTermPointer;
			StorageTmp->mtpSlSignTermPointerLen = StorageOld->mtpSlSignTermPointerLen;
			StorageOld->mtpSlSignTermPointer = NULL;
			StorageOld->mtpSlSignTermPointerLen = 0;
		}
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSignDataLinkTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSignDataLinkTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSignDataLinkTpPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSignDataLinkTpPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSlSignDataLinkTpPointer);
		StorageTmp->mtpSlSignDataLinkTpPointer = objid;
		StorageTmp->mtpSlSignDataLinkTpPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSignDataLinkTpPointer for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		if (StorageOld->mtpSlSignDataLinkTpPointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSlSignDataLinkTpPointer);
			StorageTmp->mtpSlSignDataLinkTpPointer = StorageOld->mtpSlSignDataLinkTpPointer;
			StorageTmp->mtpSlSignDataLinkTpPointerLen = StorageOld->mtpSlSignDataLinkTpPointerLen;
			StorageOld->mtpSlSignDataLinkTpPointer = NULL;
			StorageOld->mtpSlSignDataLinkTpPointerLen = 0;
		}
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlLocalInhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlLocalInhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlLocalInhibit entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLLOCALINHIBIT_SUCCESS:
		case MTPSLLOCALINHIBIT_UNSUCCESSFUL:
		case MTPSLLOCALINHIBIT_NOTPERFORMED:
		case MTPSLLOCALINHIBIT_LINKALREADYINHIBITED:
		case MTPSLLOCALINHIBIT_LINKNOTINHIBITED:
		case MTPSLLOCALINHIBIT_WRONGCLASSREFERENCED:
		case MTPSLLOCALINHIBIT_SIGNTERMNONEXISTING:
		case MTPSLLOCALINHIBIT_SIGNTERMALREADYREFERENCED:
		case MTPSLLOCALINHIBIT_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalInhibit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		StorageTmp->mtpSlLocalInhibit = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlLocalInhibit for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		StorageTmp->mtpSlLocalInhibit = StorageOld->mtpSlLocalInhibit;
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlLocalUninhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlLocalUninhibit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlLocalUninhibit entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLLOCALUNINHIBIT_SUCCESS:
		case MTPSLLOCALUNINHIBIT_UNSUCCESSFUL:
		case MTPSLLOCALUNINHIBIT_NOTPERFORMED:
		case MTPSLLOCALUNINHIBIT_LINKALREADYINHIBITED:
		case MTPSLLOCALUNINHIBIT_LINKNOTINHIBITED:
		case MTPSLLOCALUNINHIBIT_WRONGCLASSREFERENCED:
		case MTPSLLOCALUNINHIBIT_SIGNTERMNONEXISTING:
		case MTPSLLOCALUNINHIBIT_SIGNTERMALREADYREFERENCED:
		case MTPSLLOCALUNINHIBIT_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlLocalUninhibit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		StorageTmp->mtpSlLocalUninhibit = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlLocalUninhibit for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		StorageTmp->mtpSlLocalUninhibit = StorageOld->mtpSlLocalUninhibit;
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlReplaceSt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlReplaceSt(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlReplaceSt entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLREPLACEST_SUCCESS:
		case MTPSLREPLACEST_UNSUCCESSFUL:
		case MTPSLREPLACEST_NOTPERFORMED:
		case MTPSLREPLACEST_LINKALREADYINHIBITED:
		case MTPSLREPLACEST_LINKNOTINHIBITED:
		case MTPSLREPLACEST_WRONGCLASSREFERENCED:
		case MTPSLREPLACEST_SIGNTERMNONEXISTING:
		case MTPSLREPLACEST_SIGNTERMALREADYREFERENCED:
		case MTPSLREPLACEST_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlReplaceSt: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		StorageTmp->mtpSlReplaceSt = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlReplaceSt for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		StorageTmp->mtpSlReplaceSt = StorageOld->mtpSlReplaceSt;
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlAsaProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAsaProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAsaProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSlAsaProfilePointer);
		StorageTmp->mtpSlAsaProfilePointer = objid;
		StorageTmp->mtpSlAsaProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlAsaProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		if (StorageOld->mtpSlAsaProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSlAsaProfilePointer);
			StorageTmp->mtpSlAsaProfilePointer = StorageOld->mtpSlAsaProfilePointer;
			StorageTmp->mtpSlAsaProfilePointerLen = StorageOld->mtpSlAsaProfilePointerLen;
			StorageOld->mtpSlAsaProfilePointer = NULL;
			StorageOld->mtpSlAsaProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlRelatedLinkGroupNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlRelatedLinkGroupNumber(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlRelatedLinkGroupNumber entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..15 */
		if ((0 > set_value || set_value > 15)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRelatedLinkGroupNumber: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		StorageTmp->mtpSlRelatedLinkGroupNumber = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlRelatedLinkGroupNumber for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		StorageTmp->mtpSlRelatedLinkGroupNumber = StorageOld->mtpSlRelatedLinkGroupNumber;
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdlList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdlList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlList entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		StorageTmp->mtpSlSdlList = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSdlList for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		StorageTmp->mtpSlSdlList = StorageOld->mtpSlSdlList;
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlTest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlTest(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlTest entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSLTEST_SUCCESS:
		case MTPSLTEST_UNSUCCESSFUL:
		case MTPSLTEST_NOTPERFORMED:
		case MTPSLTEST_LINKALREADYINHIBITED:
		case MTPSLTEST_LINKNOTINHIBITED:
		case MTPSLTEST_WRONGCLASSREFERENCED:
		case MTPSLTEST_SIGNTERMNONEXISTING:
		case MTPSLTEST_SIGNTERMALREADYREFERENCED:
		case MTPSLTEST_WRONGSIGNLINKTPSTATUS:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlTest: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		StorageTmp->mtpSlTest = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlTest for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		StorageTmp->mtpSlTest = StorageOld->mtpSlTest;
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSlName);
		StorageTmp->mtpSlName = string;
		StorageTmp->mtpSlNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		if (StorageOld->mtpSlName != NULL) {
			SNMP_FREE(StorageTmp->mtpSlName);
			StorageTmp->mtpSlName = StorageOld->mtpSlName;
			StorageTmp->mtpSlNameLen = StorageOld->mtpSlNameLen;
			StorageOld->mtpSlName = NULL;
			StorageOld->mtpSlNameLen = 0;
		}
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdtList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdtList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtList entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		StorageTmp->mtpSlSdtList = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSdtList for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		StorageTmp->mtpSlSdtList = StorageOld->mtpSlSdtList;
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSlsCodeNormalList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSlsCodeNormalList(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSlsCodeNormalList entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..0 2..2 4..4 32..32 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 0 && var_val_len != 2 && var_val_len != 4 && var_val_len != 32)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSlsCodeNormalList: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\xFF\xFF\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSlSlsCodeNormalList);
		StorageTmp->mtpSlSlsCodeNormalList = string;
		StorageTmp->mtpSlSlsCodeNormalListLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSlsCodeNormalList for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		if (StorageOld->mtpSlSlsCodeNormalList != NULL) {
			SNMP_FREE(StorageTmp->mtpSlSlsCodeNormalList);
			StorageTmp->mtpSlSlsCodeNormalList = StorageOld->mtpSlSlsCodeNormalList;
			StorageTmp->mtpSlSlsCodeNormalListLen = StorageOld->mtpSlSlsCodeNormalListLen;
			StorageOld->mtpSlSlsCodeNormalList = NULL;
			StorageOld->mtpSlSlsCodeNormalListLen = 0;
		}
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlL3ProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSlL3ProfilePointer);
		StorageTmp->mtpSlL3ProfilePointer = string;
		StorageTmp->mtpSlL3ProfilePointerLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlL3ProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		if (StorageOld->mtpSlL3ProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSlL3ProfilePointer);
			StorageTmp->mtpSlL3ProfilePointer = StorageOld->mtpSlL3ProfilePointer;
			StorageTmp->mtpSlL3ProfilePointerLen = StorageOld->mtpSlL3ProfilePointerLen;
			StorageOld->mtpSlL3ProfilePointer = NULL;
			StorageOld->mtpSlL3ProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlAlarmStatus entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 1) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlAlarmStatus: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			if (StorageTmp->mtpSlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSlAlarmStatus);
		StorageTmp->mtpSlAlarmStatus = string;
		StorageTmp->mtpSlAlarmStatusLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlTable_tsts == 0)
				if ((ret = check_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlAlarmStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlTable_sets == 0)
				if ((ret = update_mtpSlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			StorageTmp->mtpSlTable_rsvs = 0;
			StorageTmp->mtpSlTable_tsts = 0;
			StorageTmp->mtpSlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlTable_sets == 0)
			revert_mtpSlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
			break;
		if (StorageOld->mtpSlAlarmStatus != NULL) {
			SNMP_FREE(StorageTmp->mtpSlAlarmStatus);
			StorageTmp->mtpSlAlarmStatus = StorageOld->mtpSlAlarmStatus;
			StorageTmp->mtpSlAlarmStatusLen = StorageOld->mtpSlAlarmStatusLen;
			StorageOld->mtpSlAlarmStatus = NULL;
			StorageOld->mtpSlAlarmStatusLen = 0;
		}
		if (--StorageTmp->mtpSlTable_rsvs == 0)
			mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdlListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdlListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlListPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlSdlListRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlSdlListTable_old) == NULL)
			if (StorageTmp->mtpSlSdlListTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlSdlListTable_old = mtpSlSdlListTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlSdlListTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSlSdlListPointer);
		StorageTmp->mtpSlSdlListPointer = objid;
		StorageTmp->mtpSlSdlListPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlSdlListTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlSdlListTable_tsts == 0)
				if ((ret = check_mtpSlSdlListTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlSdlListTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSdlListPointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlSdlListTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlSdlListTable_sets == 0)
				if ((ret = update_mtpSlSdlListTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlSdlListTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlSdlListTable_old) != NULL) {
			mtpSlSdlListTable_destroy(&StorageTmp->mtpSlSdlListTable_old);
			StorageTmp->mtpSlSdlListTable_rsvs = 0;
			StorageTmp->mtpSlSdlListTable_tsts = 0;
			StorageTmp->mtpSlSdlListTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlSdlListTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlSdlListTable_sets == 0)
			revert_mtpSlSdlListTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlSdlListTable_old) == NULL)
			break;
		if (StorageOld->mtpSlSdlListPointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSlSdlListPointer);
			StorageTmp->mtpSlSdlListPointer = StorageOld->mtpSlSdlListPointer;
			StorageTmp->mtpSlSdlListPointerLen = StorageOld->mtpSlSdlListPointerLen;
			StorageOld->mtpSlSdlListPointer = NULL;
			StorageOld->mtpSlSdlListPointerLen = 0;
		}
		if (--StorageTmp->mtpSlSdlListTable_rsvs == 0)
			mtpSlSdlListTable_destroy(&StorageTmp->mtpSlSdlListTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdtListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSlSdtListPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtListPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSlSdtListRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSlSdtListTable_old) == NULL)
			if (StorageTmp->mtpSlSdtListTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSlSdtListTable_old = mtpSlSdtListTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSlSdtListTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSlSdtListPointer);
		StorageTmp->mtpSlSdtListPointer = objid;
		StorageTmp->mtpSlSdtListPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSlSdtListTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSlSdtListTable_tsts == 0)
				if ((ret = check_mtpSlSdtListTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlSdtListTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSlSdtListPointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSlSdtListTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSlSdtListTable_sets == 0)
				if ((ret = update_mtpSlSdtListTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSlSdtListTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSlSdtListTable_old) != NULL) {
			mtpSlSdtListTable_destroy(&StorageTmp->mtpSlSdtListTable_old);
			StorageTmp->mtpSlSdtListTable_rsvs = 0;
			StorageTmp->mtpSlSdtListTable_tsts = 0;
			StorageTmp->mtpSlSdtListTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSlSdtListTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSlSdtListTable_sets == 0)
			revert_mtpSlSdtListTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSlSdtListTable_old) == NULL)
			break;
		if (StorageOld->mtpSlSdtListPointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSlSdtListPointer);
			StorageTmp->mtpSlSdtListPointer = StorageOld->mtpSlSdtListPointer;
			StorageTmp->mtpSlSdtListPointerLen = StorageOld->mtpSlSdtListPointerLen;
			StorageOld->mtpSlSdtListPointer = NULL;
			StorageOld->mtpSlSdtListPointerLen = 0;
		}
		if (--StorageTmp->mtpSlSdtListTable_rsvs == 0)
			mtpSlSdtListTable_destroy(&StorageTmp->mtpSlSdtListTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNbTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpNbTransmissionRate entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value kbits64 */
		switch (set_value) {
		case MTPNBTRANSMISSIONRATE_KBITS4POINT8:
		case MTPNBTRANSMISSIONRATE_KBITS56:
		case MTPNBTRANSMISSIONRATE_KBITS64:
		case MTPNBTRANSMISSIONRATE_KBITS1544:
		case MTPNBTRANSMISSIONRATE_KBITS2048:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpNbTable_old) == NULL)
			if (StorageTmp->mtpNbTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpNbTable_old = mtpNbTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpNbTable_rsvs++;
		StorageTmp->mtpNbTransmissionRate = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpNbTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpNbTable_tsts == 0)
				if ((ret = check_mtpNbTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNbTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNbTransmissionRate for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpNbTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpNbTable_sets == 0)
				if ((ret = update_mtpNbTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNbTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpNbTable_old) != NULL) {
			mtpNbTable_destroy(&StorageTmp->mtpNbTable_old);
			StorageTmp->mtpNbTable_rsvs = 0;
			StorageTmp->mtpNbTable_tsts = 0;
			StorageTmp->mtpNbTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpNbTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpNbTable_sets == 0)
			revert_mtpNbTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpNbTable_old) == NULL)
			break;
		StorageTmp->mtpNbTransmissionRate = StorageOld->mtpNbTransmissionRate;
		if (--StorageTmp->mtpNbTable_rsvs == 0)
			mtpNbTable_destroy(&StorageTmp->mtpNbTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbf(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpNbf(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNbTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpNbf entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpNbRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value one */
		switch (set_value) {
		case MTPNBF_ONE:
		case MTPNBF_SHARED:
		case MTPNBF_TWO:
		case MTPNBF_THREE:
		case MTPNBF_FOUR:
		case MTPNBF_FIVE:
		case MTPNBF_SIX:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbf: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpNbTable_old) == NULL)
			if (StorageTmp->mtpNbTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpNbTable_old = mtpNbTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpNbTable_rsvs++;
		StorageTmp->mtpNbf = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpNbTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpNbTable_tsts == 0)
				if ((ret = check_mtpNbTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNbTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpNbf for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpNbTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpNbTable_sets == 0)
				if ((ret = update_mtpNbTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpNbTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpNbTable_old) != NULL) {
			mtpNbTable_destroy(&StorageTmp->mtpNbTable_old);
			StorageTmp->mtpNbTable_rsvs = 0;
			StorageTmp->mtpNbTable_tsts = 0;
			StorageTmp->mtpNbTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpNbTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpNbTable_sets == 0)
			revert_mtpNbTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpNbTable_old) == NULL)
			break;
		StorageTmp->mtpNbf = StorageOld->mtpNbf;
		if (--StorageTmp->mtpNbTable_rsvs == 0)
			mtpNbTable_destroy(&StorageTmp->mtpNbTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalBufferRelease(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalBufferRelease(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalBufferRelease entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalBufferRelease: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalBufferRelease = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalBufferRelease for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalBufferRelease = StorageOld->mtpSaalBufferRelease;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxCc entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxCc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalMaxCc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxCc for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalMaxCc = StorageOld->mtpSaalMaxCc;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxNrp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxNrp(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxNrp entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxNrp: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalMaxNrp = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxNrp for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalMaxNrp = StorageOld->mtpSaalMaxNrp;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxInformationFieldLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxInformationFieldLength(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxInformationFieldLength entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxInformationFieldLength: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4096 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalMaxInformationFieldLength = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxInformationFieldLength for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalMaxInformationFieldLength = StorageOld->mtpSaalMaxInformationFieldLength;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxLengthSscopUuField(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxLengthSscopUuField(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxLengthSscopUuField entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxLengthSscopUuField: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalMaxLengthSscopUuField = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxLengthSscopUuField for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalMaxLengthSscopUuField = StorageOld->mtpSaalMaxLengthSscopUuField;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxPd(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxPd(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxPd entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxPd: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalMaxPd = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxPd for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalMaxPd = StorageOld->mtpSaalMaxPd;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxSscopCreditToPeer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxSscopCreditToPeer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxSscopCreditToPeer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxSscopCreditToPeer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 128 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalMaxSscopCreditToPeer = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxSscopCreditToPeer for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalMaxSscopCreditToPeer = StorageOld->mtpSaalMaxSscopCreditToPeer;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalMaxStat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalMaxStat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalMaxStat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalMaxStat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 67 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalMaxStat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalMaxStat for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalMaxStat = StorageOld->mtpSaalMaxStat;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalN1 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalN1 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalN1 for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalN1 = StorageOld->mtpSaalN1;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniLayerManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniLayerManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementProvingState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value neutral */
		switch (set_value) {
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_NORMAL:
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_EMERGENCY:
		case MTPSAALNNILAYERMANAGEMENTPROVINGSTATE_NEUTRAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementProvingState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalNniLayerManagementProvingState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniLayerManagementProvingState for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalNniLayerManagementProvingState = StorageOld->mtpSaalNniLayerManagementProvingState;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniLayerManagementTimerNoCredit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniLayerManagementTimerNoCredit(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementTimerNoCredit entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerNoCredit: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniLayerManagementTimerNoCredit for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalNniLayerManagementTimerNoCredit = StorageOld->mtpSaalNniLayerManagementTimerNoCredit;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniLayerManagementTimerRepeatSrec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniLayerManagementTimerRepeatSrec(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniLayerManagementTimerRepeatSrec entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniLayerManagementTimerRepeatSrec: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalNniLayerManagementTimerRepeatSrec = StorageOld->mtpSaalNniLayerManagementTimerRepeatSrec;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT1 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalNniTimerT1 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniTimerT1 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalNniTimerT1 = StorageOld->mtpSaalNniTimerT1;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT2 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalNniTimerT2 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniTimerT2 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalNniTimerT2 = StorageOld->mtpSaalNniTimerT2;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalNniTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalNniTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalNniTimerT3 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalNniTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalNniTimerT3 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalNniTimerT3 for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalNniTimerT3 = StorageOld->mtpSaalNniTimerT3;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerCc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerCc entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerCc: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalSscopTimerCc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalSscopTimerCc for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalSscopTimerCc = StorageOld->mtpSaalSscopTimerCc;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerIdle entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerIdle: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalSscopTimerIdle = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalSscopTimerIdle for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalSscopTimerIdle = StorageOld->mtpSaalSscopTimerIdle;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerKeepAlive(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerKeepAlive entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerKeepAlive: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalSscopTimerKeepAlive = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalSscopTimerKeepAlive for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalSscopTimerKeepAlive = StorageOld->mtpSaalSscopTimerKeepAlive;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerNoResponse(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerNoResponse(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerNoResponse entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 150 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerNoResponse: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalSscopTimerNoResponse = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalSscopTimerNoResponse for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalSscopTimerNoResponse = StorageOld->mtpSaalSscopTimerNoResponse;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalSscopTimerPoll(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalSscopTimerPoll(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalSscopTimerPoll entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalSscopTimerPoll: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalSscopTimerPoll = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalSscopTimerPoll for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalSscopTimerPoll = StorageOld->mtpSaalSscopTimerPoll;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalTransmissionRateIntervalLower entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 129 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalLower: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalTransmissionRateIntervalLower = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalTransmissionRateIntervalLower for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalTransmissionRateIntervalLower = StorageOld->mtpSaalTransmissionRateIntervalLower;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalTransmissionRateIntervalUpper: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalTransmissionRateIntervalUpper for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalTransmissionRateIntervalUpper = StorageOld->mtpSaalTransmissionRateIntervalUpper;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalEgressTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalEgressTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalEgressTransmissionRateIntervalLower entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 129 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalLower: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalEgressTransmissionRateIntervalLower for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalLower = StorageOld->mtpSaalEgressTransmissionRateIntervalLower;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalEgressTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalEgressTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalEgressTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 256 */
		/* Note: ranges 64..4096 */
		if ((64 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalEgressTransmissionRateIntervalUpper: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper for you to use, and you have just been asked to do something with it.  Note
				   that anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalEgressTransmissionRateIntervalUpper = StorageOld->mtpSaalEgressTransmissionRateIntervalUpper;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalPollAfterRetransmission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSaalPollAfterRetransmission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalPollAfterRetransmission entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSaalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalPollAfterRetransmission: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			if (StorageTmp->mtpSaalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSaalTable_rsvs++;
		StorageTmp->mtpSaalPollAfterRetransmission = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSaalTable_tsts == 0)
				if ((ret = check_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSaalPollAfterRetransmission for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSaalTable_sets == 0)
				if ((ret = update_mtpSaalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSaalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			StorageTmp->mtpSaalTable_rsvs = 0;
			StorageTmp->mtpSaalTable_tsts = 0;
			StorageTmp->mtpSaalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSaalTable_sets == 0)
			revert_mtpSaalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
			break;
		StorageTmp->mtpSaalPollAfterRetransmission = StorageOld->mtpSaalPollAfterRetransmission;
		if (--StorageTmp->mtpSaalTable_rsvs == 0)
			mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paN1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paN1 entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paN1 = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paN1 for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paN1 = StorageOld->mtpM2paN1;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paProving(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paProving(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paProving entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProving: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paProving = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paProving for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paProving = StorageOld->mtpM2paProving;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paManagementProvingState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paManagementProvingState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value neutral */
		switch (set_value) {
		case MTPM2PAMANAGEMENTPROVINGSTATE_NORMAL:
		case MTPM2PAMANAGEMENTPROVINGSTATE_EMERGENCY:
		case MTPM2PAMANAGEMENTPROVINGSTATE_NEUTRAL:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paManagementProvingState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paManagementProvingState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paManagementProvingState for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paManagementProvingState = StorageOld->mtpM2paManagementProvingState;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paProvingAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paProvingAttempts(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paProvingAttempts entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paProvingAttempts: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paProvingAttempts = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paProvingAttempts for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paProvingAttempts = StorageOld->mtpM2paProvingAttempts;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpNoDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpNoDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpNoDelay = StorageOld->mtpM2paSctpNoDelay;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxseg entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		if ((1 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpMaxseg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpMaxseg = StorageOld->mtpM2paSctpMaxseg;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpHeartbeatItvl entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpHeartbeatItvl = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpHeartbeatItvl for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpHeartbeatItvl = StorageOld->mtpM2paSctpHeartbeatItvl;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpHeartbeat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpHeartbeat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpHeartbeat for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpHeartbeat = StorageOld->mtpM2paSctpHeartbeat;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoInitial entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpRtoInitial = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpRtoInitial for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpRtoInitial = StorageOld->mtpM2paSctpRtoInitial;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoMin entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpRtoMin = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpRtoMin for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpRtoMin = StorageOld->mtpM2paSctpRtoMin;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpRtoMax entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpRtoMax = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpRtoMax for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpRtoMax = StorageOld->mtpM2paSctpRtoMax;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpPathMaxRetrans entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpPathMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpPathMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpPathMaxRetrans = StorageOld->mtpM2paSctpPathMaxRetrans;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpCookieLife entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpCookieLife = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpCookieLife for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpCookieLife = StorageOld->mtpM2paSctpCookieLife;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpCookieInc entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpCookieInc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpCookieInc for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpCookieInc = StorageOld->mtpM2paSctpCookieInc;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxInitRetries entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpMaxInitRetries = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpMaxInitRetries for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpMaxInitRetries = StorageOld->mtpM2paSctpMaxInitRetries;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpMaxBurst entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpMaxBurst = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpMaxBurst for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpMaxBurst = StorageOld->mtpM2paSctpMaxBurst;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpAssocMaxRetrans entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpAssocMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpAssocMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpAssocMaxRetrans = StorageOld->mtpM2paSctpAssocMaxRetrans;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpSackDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..500 */
		if ((0 > set_value || set_value > 500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpSackDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpSackDelay for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpSackDelay = StorageOld->mtpM2paSctpSackDelay;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paSctpLifetime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paSctpLifetime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paSctpLifetime for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paSctpLifetime = StorageOld->mtpM2paSctpLifetime;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paLoopDelayLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paLoopDelayLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paLoopDelayLower entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paLoopDelayLower = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paLoopDelayLower for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paLoopDelayLower = StorageOld->mtpM2paLoopDelayLower;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paLoopDelayUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paLoopDelayUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paLoopDelayUpper entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paLoopDelayUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 600 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paLoopDelayUpper = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paLoopDelayUpper for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paLoopDelayUpper = StorageOld->mtpM2paLoopDelayUpper;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paTransmissionRateIntervalLower(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paTransmissionRateIntervalLower entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1544000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paTransmissionRateIntervalLower = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paTransmissionRateIntervalLower for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paTransmissionRateIntervalLower = StorageOld->mtpM2paTransmissionRateIntervalLower;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2paTransmissionRateIntervalUpper(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2paRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 155000000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			if (StorageTmp->mtpM2paTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2paTable_rsvs++;
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2paTable_tsts == 0)
				if ((ret = check_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2paTransmissionRateIntervalUpper for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2paTable_sets == 0)
				if ((ret = update_mtpM2paTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2paTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			StorageTmp->mtpM2paTable_rsvs = 0;
			StorageTmp->mtpM2paTable_tsts = 0;
			StorageTmp->mtpM2paTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2paTable_sets == 0)
			revert_mtpM2paTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
			break;
		StorageTmp->mtpM2paTransmissionRateIntervalUpper = StorageOld->mtpM2paTransmissionRateIntervalUpper;
		if (--StorageTmp->mtpM2paTable_rsvs == 0)
			mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtAdministrativeState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPSDTADMINISTRATIVESTATE_LOCKED:
		case MTPSDTADMINISTRATIVESTATE_UNLOCKED:
		case MTPSDTADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			if (StorageTmp->mtpSdtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdtTable_old = mtpSdtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdtTable_rsvs++;
		StorageTmp->mtpSdtAdministrativeState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdtTable_tsts == 0)
				if ((ret = check_mtpSdtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdtAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdtTable_sets == 0)
				if ((ret = update_mtpSdtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			mtpSdtTable_destroy(&StorageTmp->mtpSdtTable_old);
			StorageTmp->mtpSdtTable_rsvs = 0;
			StorageTmp->mtpSdtTable_tsts = 0;
			StorageTmp->mtpSdtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdtTable_sets == 0)
			revert_mtpSdtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			break;
		StorageTmp->mtpSdtAdministrativeState = StorageOld->mtpSdtAdministrativeState;
		if (--StorageTmp->mtpSdtTable_rsvs == 0)
			mtpSdtTable_destroy(&StorageTmp->mtpSdtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtEquipmentPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtEquipmentPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			if (StorageTmp->mtpSdtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdtTable_old = mtpSdtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdtTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSdtEquipmentPointer);
		StorageTmp->mtpSdtEquipmentPointer = objid;
		StorageTmp->mtpSdtEquipmentPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdtTable_tsts == 0)
				if ((ret = check_mtpSdtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdtEquipmentPointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdtTable_sets == 0)
				if ((ret = update_mtpSdtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			mtpSdtTable_destroy(&StorageTmp->mtpSdtTable_old);
			StorageTmp->mtpSdtTable_rsvs = 0;
			StorageTmp->mtpSdtTable_tsts = 0;
			StorageTmp->mtpSdtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdtTable_sets == 0)
			revert_mtpSdtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			break;
		if (StorageOld->mtpSdtEquipmentPointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSdtEquipmentPointer);
			StorageTmp->mtpSdtEquipmentPointer = StorageOld->mtpSdtEquipmentPointer;
			StorageTmp->mtpSdtEquipmentPointerLen = StorageOld->mtpSdtEquipmentPointerLen;
			StorageOld->mtpSdtEquipmentPointer = NULL;
			StorageOld->mtpSdtEquipmentPointerLen = 0;
		}
		if (--StorageTmp->mtpSdtTable_rsvs == 0)
			mtpSdtTable_destroy(&StorageTmp->mtpSdtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			if (StorageTmp->mtpSdtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdtTable_old = mtpSdtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdtTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSdtName);
		StorageTmp->mtpSdtName = string;
		StorageTmp->mtpSdtNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdtTable_tsts == 0)
				if ((ret = check_mtpSdtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdtName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdtTable_sets == 0)
				if ((ret = update_mtpSdtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			mtpSdtTable_destroy(&StorageTmp->mtpSdtTable_old);
			StorageTmp->mtpSdtTable_rsvs = 0;
			StorageTmp->mtpSdtTable_tsts = 0;
			StorageTmp->mtpSdtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdtTable_sets == 0)
			revert_mtpSdtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			break;
		if (StorageOld->mtpSdtName != NULL) {
			SNMP_FREE(StorageTmp->mtpSdtName);
			StorageTmp->mtpSdtName = StorageOld->mtpSdtName;
			StorageTmp->mtpSdtNameLen = StorageOld->mtpSdtNameLen;
			StorageOld->mtpSdtName = NULL;
			StorageOld->mtpSdtNameLen = 0;
		}
		if (--StorageTmp->mtpSdtTable_rsvs == 0)
			mtpSdtTable_destroy(&StorageTmp->mtpSdtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdtProfilePointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtProfilePointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdtRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtProfilePointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			if (StorageTmp->mtpSdtTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdtTable_old = mtpSdtTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdtTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSdtProfilePointer);
		StorageTmp->mtpSdtProfilePointer = objid;
		StorageTmp->mtpSdtProfilePointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdtTable_tsts == 0)
				if ((ret = check_mtpSdtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdtTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdtProfilePointer for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdtTable_sets == 0)
				if ((ret = update_mtpSdtTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdtTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
			mtpSdtTable_destroy(&StorageTmp->mtpSdtTable_old);
			StorageTmp->mtpSdtTable_rsvs = 0;
			StorageTmp->mtpSdtTable_tsts = 0;
			StorageTmp->mtpSdtTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdtTable_sets == 0)
			revert_mtpSdtTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
			break;
		if (StorageOld->mtpSdtProfilePointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSdtProfilePointer);
			StorageTmp->mtpSdtProfilePointer = StorageOld->mtpSdtProfilePointer;
			StorageTmp->mtpSdtProfilePointerLen = StorageOld->mtpSdtProfilePointerLen;
			StorageOld->mtpSdtProfilePointer = NULL;
			StorageOld->mtpSdtProfilePointerLen = 0;
		}
		if (--StorageTmp->mtpSdtTable_rsvs == 0)
			mtpSdtTable_destroy(&StorageTmp->mtpSdtTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPSDLTYPE_NARROWBAND:
		case MTPSDLTYPE_BROADBAND:
		case MTPSDLTYPE_M2PA:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			if (StorageTmp->mtpSdlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdlTable_rsvs++;
		StorageTmp->mtpSdlType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdlTable_tsts == 0)
				if ((ret = check_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlType for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdlTable_sets == 0)
				if ((ret = update_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			StorageTmp->mtpSdlTable_rsvs = 0;
			StorageTmp->mtpSdlTable_tsts = 0;
			StorageTmp->mtpSdlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdlTable_sets == 0)
			revert_mtpSdlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		StorageTmp->mtpSdlType = StorageOld->mtpSdlType;
		if (--StorageTmp->mtpSdlTable_rsvs == 0)
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlAdjPc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlAdjPc entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlAdjPc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x00\x00\x00\x00\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			if (StorageTmp->mtpSdlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdlTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSdlAdjPc);
		StorageTmp->mtpSdlAdjPc = string;
		StorageTmp->mtpSdlAdjPcLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdlTable_tsts == 0)
				if ((ret = check_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlAdjPc for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdlTable_sets == 0)
				if ((ret = update_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			StorageTmp->mtpSdlTable_rsvs = 0;
			StorageTmp->mtpSdlTable_tsts = 0;
			StorageTmp->mtpSdlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdlTable_sets == 0)
			revert_mtpSdlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		if (StorageOld->mtpSdlAdjPc != NULL) {
			SNMP_FREE(StorageTmp->mtpSdlAdjPc);
			StorageTmp->mtpSdlAdjPc = StorageOld->mtpSdlAdjPc;
			StorageTmp->mtpSdlAdjPcLen = StorageOld->mtpSdlAdjPcLen;
			StorageOld->mtpSdlAdjPc = NULL;
			StorageOld->mtpSdlAdjPcLen = 0;
		}
		if (--StorageTmp->mtpSdlTable_rsvs == 0)
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlLoopDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlLoopDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlLoopDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			if (StorageTmp->mtpSdlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdlTable_rsvs++;
		StorageTmp->mtpSdlLoopDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdlTable_tsts == 0)
				if ((ret = check_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlLoopDelay for you to use, and you have just been asked to do something with it.  Note that anything done here must 
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdlTable_sets == 0)
				if ((ret = update_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			StorageTmp->mtpSdlTable_rsvs = 0;
			StorageTmp->mtpSdlTable_tsts = 0;
			StorageTmp->mtpSdlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdlTable_sets == 0)
			revert_mtpSdlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		StorageTmp->mtpSdlLoopDelay = StorageOld->mtpSdlLoopDelay;
		if (--StorageTmp->mtpSdlTable_rsvs == 0)
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlEquipmentPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlEquipmentPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlEquipmentPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			if (StorageTmp->mtpSdlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdlTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSdlEquipmentPointer);
		StorageTmp->mtpSdlEquipmentPointer = objid;
		StorageTmp->mtpSdlEquipmentPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdlTable_tsts == 0)
				if ((ret = check_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlEquipmentPointer for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdlTable_sets == 0)
				if ((ret = update_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			StorageTmp->mtpSdlTable_rsvs = 0;
			StorageTmp->mtpSdlTable_tsts = 0;
			StorageTmp->mtpSdlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdlTable_sets == 0)
			revert_mtpSdlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		if (StorageOld->mtpSdlEquipmentPointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSdlEquipmentPointer);
			StorageTmp->mtpSdlEquipmentPointer = StorageOld->mtpSdlEquipmentPointer;
			StorageTmp->mtpSdlEquipmentPointerLen = StorageOld->mtpSdlEquipmentPointerLen;
			StorageOld->mtpSdlEquipmentPointer = NULL;
			StorageOld->mtpSdlEquipmentPointerLen = 0;
		}
		if (--StorageTmp->mtpSdlTable_rsvs == 0)
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlCIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlCIC entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlCIC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			if (StorageTmp->mtpSdlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdlTable_rsvs++;
		StorageTmp->mtpSdlCIC = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdlTable_tsts == 0)
				if ((ret = check_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlCIC for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdlTable_sets == 0)
				if ((ret = update_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			StorageTmp->mtpSdlTable_rsvs = 0;
			StorageTmp->mtpSdlTable_tsts = 0;
			StorageTmp->mtpSdlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdlTable_sets == 0)
			revert_mtpSdlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		StorageTmp->mtpSdlCIC = StorageOld->mtpSdlCIC;
		if (--StorageTmp->mtpSdlTable_rsvs == 0)
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlTransmissionRate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlTransmissionRate entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value kbits64 */
		switch (set_value) {
		case MTPSDLTRANSMISSIONRATE_KBITS4POINT8:
		case MTPSDLTRANSMISSIONRATE_KBITS56:
		case MTPSDLTRANSMISSIONRATE_KBITS64:
		case MTPSDLTRANSMISSIONRATE_KBITS1544:
		case MTPSDLTRANSMISSIONRATE_KBITS2048:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlTransmissionRate: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			if (StorageTmp->mtpSdlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdlTable_rsvs++;
		StorageTmp->mtpSdlTransmissionRate = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdlTable_tsts == 0)
				if ((ret = check_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlTransmissionRate for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdlTable_sets == 0)
				if ((ret = update_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			StorageTmp->mtpSdlTable_rsvs = 0;
			StorageTmp->mtpSdlTable_tsts = 0;
			StorageTmp->mtpSdlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdlTable_sets == 0)
			revert_mtpSdlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		StorageTmp->mtpSdlTransmissionRate = StorageOld->mtpSdlTransmissionRate;
		if (--StorageTmp->mtpSdlTable_rsvs == 0)
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlStmChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlStmChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlStmChannel entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlStmChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\x13\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			if (StorageTmp->mtpSdlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdlTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSdlStmChannel);
		StorageTmp->mtpSdlStmChannel = string;
		StorageTmp->mtpSdlStmChannelLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdlTable_tsts == 0)
				if ((ret = check_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlStmChannel for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdlTable_sets == 0)
				if ((ret = update_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			StorageTmp->mtpSdlTable_rsvs = 0;
			StorageTmp->mtpSdlTable_tsts = 0;
			StorageTmp->mtpSdlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdlTable_sets == 0)
			revert_mtpSdlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		if (StorageOld->mtpSdlStmChannel != NULL) {
			SNMP_FREE(StorageTmp->mtpSdlStmChannel);
			StorageTmp->mtpSdlStmChannel = StorageOld->mtpSdlStmChannel;
			StorageTmp->mtpSdlStmChannelLen = StorageOld->mtpSdlStmChannelLen;
			StorageOld->mtpSdlStmChannel = NULL;
			StorageOld->mtpSdlStmChannelLen = 0;
		}
		if (--StorageTmp->mtpSdlTable_rsvs == 0)
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlVcTTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlVcTTpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlVcTTpPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlVcTTpPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			if (StorageTmp->mtpSdlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdlTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSdlVcTTpPointer);
		StorageTmp->mtpSdlVcTTpPointer = objid;
		StorageTmp->mtpSdlVcTTpPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdlTable_tsts == 0)
				if ((ret = check_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlVcTTpPointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdlTable_sets == 0)
				if ((ret = update_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			StorageTmp->mtpSdlTable_rsvs = 0;
			StorageTmp->mtpSdlTable_tsts = 0;
			StorageTmp->mtpSdlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdlTable_sets == 0)
			revert_mtpSdlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		if (StorageOld->mtpSdlVcTTpPointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSdlVcTTpPointer);
			StorageTmp->mtpSdlVcTTpPointer = StorageOld->mtpSdlVcTTpPointer;
			StorageTmp->mtpSdlVcTTpPointerLen = StorageOld->mtpSdlVcTTpPointerLen;
			StorageOld->mtpSdlVcTTpPointer = NULL;
			StorageOld->mtpSdlVcTTpPointerLen = 0;
		}
		if (--StorageTmp->mtpSdlTable_rsvs == 0)
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlSctpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlSctpPointer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlSctpPointer entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlSctpPointer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlSctpPointer not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlSctpPointer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			if (StorageTmp->mtpSdlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdlTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpSdlSctpPointer);
		StorageTmp->mtpSdlSctpPointer = objid;
		StorageTmp->mtpSdlSctpPointerLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdlTable_tsts == 0)
				if ((ret = check_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlSctpPointer for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdlTable_sets == 0)
				if ((ret = update_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			StorageTmp->mtpSdlTable_rsvs = 0;
			StorageTmp->mtpSdlTable_tsts = 0;
			StorageTmp->mtpSdlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdlTable_sets == 0)
			revert_mtpSdlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		if (StorageOld->mtpSdlSctpPointer != NULL) {
			SNMP_FREE(StorageTmp->mtpSdlSctpPointer);
			StorageTmp->mtpSdlSctpPointer = StorageOld->mtpSdlSctpPointer;
			StorageTmp->mtpSdlSctpPointerLen = StorageOld->mtpSdlSctpPointerLen;
			StorageOld->mtpSdlSctpPointer = NULL;
			StorageOld->mtpSdlSctpPointerLen = 0;
		}
		if (--StorageTmp->mtpSdlTable_rsvs == 0)
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSdlName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlName entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSdlRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			if (StorageTmp->mtpSdlTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSdlTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSdlName);
		StorageTmp->mtpSdlName = string;
		StorageTmp->mtpSdlNameLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSdlTable_tsts == 0)
				if ((ret = check_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSdlName for you to use, and you have just been asked to do something with it.  Note that anything done here must be
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSdlTable_sets == 0)
				if ((ret = update_mtpSdlTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSdlTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			StorageTmp->mtpSdlTable_rsvs = 0;
			StorageTmp->mtpSdlTable_tsts = 0;
			StorageTmp->mtpSdlTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSdlTable_sets == 0)
			revert_mtpSdlTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
			break;
		if (StorageOld->mtpSdlName != NULL) {
			SNMP_FREE(StorageTmp->mtpSdlName);
			StorageTmp->mtpSdlName = StorageOld->mtpSdlName;
			StorageTmp->mtpSdlNameLen = StorageOld->mtpSdlNameLen;
			StorageOld->mtpSdlName = NULL;
			StorageOld->mtpSdlNameLen = 0;
		}
		if (--StorageTmp->mtpSdlTable_rsvs == 0)
			mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileNoDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileNoDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileNoDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileNoDelay = StorageOld->mtpSctpProfileNoDelay;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileMaxseg entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxseg: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		if ((1 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileMaxseg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileMaxseg = StorageOld->mtpSctpProfileMaxseg;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileHeartbeatItvl entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeatItvl: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileHeartbeatItvl = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileHeartbeatItvl for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileHeartbeatItvl = StorageOld->mtpSctpProfileHeartbeatItvl;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileHeartbeat entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeat: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileHeartbeat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileHeartbeat for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileHeartbeat = StorageOld->mtpSctpProfileHeartbeat;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileRtoInitial entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoInitial: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileRtoInitial = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileRtoInitial for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileRtoInitial = StorageOld->mtpSctpProfileRtoInitial;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileRtoMin entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMin: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileRtoMin = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileRtoMin for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileRtoMin = StorageOld->mtpSctpProfileRtoMin;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileRtoMax entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMax: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileRtoMax = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileRtoMax for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileRtoMax = StorageOld->mtpSctpProfileRtoMax;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfilePathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfilePathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfilePathMaxRetrans entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfilePathMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfilePathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfilePathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfilePathMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfilePathMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfilePathMaxRetrans = StorageOld->mtpSctpProfilePathMaxRetrans;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileCookieLife entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieLife: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileCookieLife = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileCookieLife for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileCookieLife = StorageOld->mtpSctpProfileCookieLife;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileCookieInc entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieInc: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileCookieInc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileCookieInc for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileCookieInc = StorageOld->mtpSctpProfileCookieInc;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileMaxInitRetries entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxInitRetries: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileMaxInitRetries = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileMaxInitRetries for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileMaxInitRetries = StorageOld->mtpSctpProfileMaxInitRetries;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileMaxBurst entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxBurst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileMaxBurst = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileMaxBurst for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileMaxBurst = StorageOld->mtpSctpProfileMaxBurst;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileAssocMaxRetrans entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileAssocMaxRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileAssocMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileAssocMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileAssocMaxRetrans = StorageOld->mtpSctpProfileAssocMaxRetrans;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileSackDelay entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileSackDelay: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..500 */
		if ((0 > set_value || set_value > 500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileSackDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileSackDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileSackDelay = StorageOld->mtpSctpProfileSackDelay;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileLifetime entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileLifetime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileLifetime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileLifetime for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileLifetime = StorageOld->mtpSctpProfileLifetime;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileMinOstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileMinOstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileMinOstreams entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMinOstreams: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMinOstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMinOstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		/* Note: ranges 2..65535 */
		if ((2 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMinOstreams: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileMinOstreams = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileMinOstreams for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileMinOstreams = StorageOld->mtpSctpProfileMinOstreams;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileMaxIstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfileMaxIstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileMaxIstreams entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpProfileRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxIstreams: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxIstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxIstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4096 */
		/* Note: ranges 2..65535 */
		if ((2 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileMaxIstreams: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpProfileTable_rsvs++;
		StorageTmp->mtpSctpProfileMaxIstreams = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpProfileTable_tsts == 0)
				if ((ret = check_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfileMaxIstreams for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpProfileTable_sets == 0)
				if ((ret = update_mtpSctpProfileTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpProfileTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			StorageTmp->mtpSctpProfileTable_rsvs = 0;
			StorageTmp->mtpSctpProfileTable_tsts = 0;
			StorageTmp->mtpSctpProfileTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpProfileTable_sets == 0)
			revert_mtpSctpProfileTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProfileMaxIstreams = StorageOld->mtpSctpProfileMaxIstreams;
		if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
			mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpAdministrativeState entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value locked */
		switch (set_value) {
		case MTPSCTPADMINISTRATIVESTATE_LOCKED:
		case MTPSCTPADMINISTRATIVESTATE_UNLOCKED:
		case MTPSCTPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			if (StorageTmp->mtpSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpTable_old = mtpSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpTable_rsvs++;
		StorageTmp->mtpSctpAdministrativeState = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpTable_tsts == 0)
				if ((ret = check_mtpSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpAdministrativeState for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpTable_sets == 0)
				if ((ret = update_mtpSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
			StorageTmp->mtpSctpTable_rsvs = 0;
			StorageTmp->mtpSctpTable_tsts = 0;
			StorageTmp->mtpSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpTable_sets == 0)
			revert_mtpSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			break;
		StorageTmp->mtpSctpAdministrativeState = StorageOld->mtpSctpAdministrativeState;
		if (--StorageTmp->mtpSctpTable_rsvs == 0)
			mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpLocalPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpLocalPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpLocalPort entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalPort: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..65535 */
		if ((0 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalPort: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			if (StorageTmp->mtpSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpTable_old = mtpSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpTable_rsvs++;
		StorageTmp->mtpSctpLocalPort = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpTable_tsts == 0)
				if ((ret = check_mtpSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpLocalPort for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpTable_sets == 0)
				if ((ret = update_mtpSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
			StorageTmp->mtpSctpTable_rsvs = 0;
			StorageTmp->mtpSctpTable_tsts = 0;
			StorageTmp->mtpSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpTable_sets == 0)
			revert_mtpSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			break;
		StorageTmp->mtpSctpLocalPort = StorageOld->mtpSctpLocalPort;
		if (--StorageTmp->mtpSctpTable_rsvs == 0)
			mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpRemotePort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpRemotePort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpRemotePort entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemotePort: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemotePort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemotePort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..65535 */
		if ((1 > set_value || set_value > 65535)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemotePort: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			if (StorageTmp->mtpSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpTable_old = mtpSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpTable_rsvs++;
		StorageTmp->mtpSctpRemotePort = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpTable_tsts == 0)
				if ((ret = check_mtpSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpRemotePort for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpTable_sets == 0)
				if ((ret = update_mtpSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
			StorageTmp->mtpSctpTable_rsvs = 0;
			StorageTmp->mtpSctpTable_tsts = 0;
			StorageTmp->mtpSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpTable_sets == 0)
			revert_mtpSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			break;
		StorageTmp->mtpSctpRemotePort = StorageOld->mtpSctpRemotePort;
		if (--StorageTmp->mtpSctpTable_rsvs == 0)
			mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfile entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfile not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value \"\" */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			if (StorageTmp->mtpSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpTable_old = mtpSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSctpProfile);
		StorageTmp->mtpSctpProfile = string;
		StorageTmp->mtpSctpProfileLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpTable_tsts == 0)
				if ((ret = check_mtpSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProfile for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpTable_sets == 0)
				if ((ret = update_mtpSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
			StorageTmp->mtpSctpTable_rsvs = 0;
			StorageTmp->mtpSctpTable_tsts = 0;
			StorageTmp->mtpSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpTable_sets == 0)
			revert_mtpSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			break;
		if (StorageOld->mtpSctpProfile != NULL) {
			SNMP_FREE(StorageTmp->mtpSctpProfile);
			StorageTmp->mtpSctpProfile = StorageOld->mtpSctpProfile;
			StorageTmp->mtpSctpProfileLen = StorageOld->mtpSctpProfileLen;
			StorageOld->mtpSctpProfile = NULL;
			StorageOld->mtpSctpProfileLen = 0;
		}
		if (--StorageTmp->mtpSctpTable_rsvs == 0)
			mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProtocolPayloadId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProtocolPayloadId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProtocolPayloadId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProtocolPayloadId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			if (StorageTmp->mtpSctpTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpTable_old = mtpSctpTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpTable_rsvs++;
		StorageTmp->mtpSctpProtocolPayloadId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpTable_tsts == 0)
				if ((ret = check_mtpSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpProtocolPayloadId for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpTable_sets == 0)
				if ((ret = update_mtpSctpTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
			mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
			StorageTmp->mtpSctpTable_rsvs = 0;
			StorageTmp->mtpSctpTable_tsts = 0;
			StorageTmp->mtpSctpTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpTable_sets == 0)
			revert_mtpSctpTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
			break;
		StorageTmp->mtpSctpProtocolPayloadId = StorageOld->mtpSctpProtocolPayloadId;
		if (--StorageTmp->mtpSctpTable_rsvs == 0)
			mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpLocalAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpLocalAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpLocalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpLocalAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpLocalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpLocalRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_IPADDRESS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalAddress not ASN_IPADDRESS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpLocalTable_old) == NULL)
			if (StorageTmp->mtpSctpLocalTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpLocalTable_old = mtpSctpLocalTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpLocalTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSctpLocalAddress);
		StorageTmp->mtpSctpLocalAddress = string;
		StorageTmp->mtpSctpLocalAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpLocalTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpLocalTable_tsts == 0)
				if ((ret = check_mtpSctpLocalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpLocalTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpLocalAddress for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpLocalTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpLocalTable_sets == 0)
				if ((ret = update_mtpSctpLocalTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpLocalTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpLocalTable_old) != NULL) {
			mtpSctpLocalTable_destroy(&StorageTmp->mtpSctpLocalTable_old);
			StorageTmp->mtpSctpLocalTable_rsvs = 0;
			StorageTmp->mtpSctpLocalTable_tsts = 0;
			StorageTmp->mtpSctpLocalTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpLocalTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpLocalTable_sets == 0)
			revert_mtpSctpLocalTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpLocalTable_old) == NULL)
			break;
		if (StorageOld->mtpSctpLocalAddress != NULL) {
			SNMP_FREE(StorageTmp->mtpSctpLocalAddress);
			StorageTmp->mtpSctpLocalAddress = StorageOld->mtpSctpLocalAddress;
			StorageTmp->mtpSctpLocalAddressLen = StorageOld->mtpSctpLocalAddressLen;
			StorageOld->mtpSctpLocalAddress = NULL;
			StorageOld->mtpSctpLocalAddressLen = 0;
		}
		if (--StorageTmp->mtpSctpLocalTable_rsvs == 0)
			mtpSctpLocalTable_destroy(&StorageTmp->mtpSctpLocalTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpRemoteAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpSctpRemoteAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpRemoteTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpRemoteAddress entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpSctpRemoteTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpSctpRemoteRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemoteAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_IPADDRESS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemoteAddress not ASN_IPADDRESS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemoteAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old) == NULL)
			if (StorageTmp->mtpSctpRemoteTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old = mtpSctpRemoteTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpSctpRemoteTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpSctpRemoteAddress);
		StorageTmp->mtpSctpRemoteAddress = string;
		StorageTmp->mtpSctpRemoteAddressLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpSctpRemoteTable_tsts == 0)
				if ((ret = check_mtpSctpRemoteTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpRemoteTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpSctpRemoteAddress for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpSctpRemoteTable_sets == 0)
				if ((ret = update_mtpSctpRemoteTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpSctpRemoteTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old) != NULL) {
			mtpSctpRemoteTable_destroy(&StorageTmp->mtpSctpRemoteTable_old);
			StorageTmp->mtpSctpRemoteTable_rsvs = 0;
			StorageTmp->mtpSctpRemoteTable_tsts = 0;
			StorageTmp->mtpSctpRemoteTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpSctpRemoteTable_sets == 0)
			revert_mtpSctpRemoteTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old) == NULL)
			break;
		if (StorageOld->mtpSctpRemoteAddress != NULL) {
			SNMP_FREE(StorageTmp->mtpSctpRemoteAddress);
			StorageTmp->mtpSctpRemoteAddress = StorageOld->mtpSctpRemoteAddress;
			StorageTmp->mtpSctpRemoteAddressLen = StorageOld->mtpSctpRemoteAddressLen;
			StorageOld->mtpSctpRemoteAddress = NULL;
			StorageOld->mtpSctpRemoteAddressLen = 0;
		}
		if (--StorageTmp->mtpSctpRemoteTable_rsvs == 0)
			mtpSctpRemoteTable_destroy(&StorageTmp->mtpSctpRemoteTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			if (StorageTmp->mtpM2uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAspTable_old = mtpM2uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAspTable_rsvs++;
		StorageTmp->mtpM2uaAspId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAspTable_tsts == 0)
				if ((ret = check_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspId for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAspTable_sets == 0)
				if ((ret = update_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
			StorageTmp->mtpM2uaAspTable_rsvs = 0;
			StorageTmp->mtpM2uaAspTable_tsts = 0;
			StorageTmp->mtpM2uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAspTable_sets == 0)
			revert_mtpM2uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM2uaAspId = StorageOld->mtpM2uaAspId;
		if (--StorageTmp->mtpM2uaAspTable_rsvs == 0)
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspCapabilities entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspCapabilities: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspCapabilities not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 3) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspCapabilities: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspCapabilities: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			if (StorageTmp->mtpM2uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAspTable_old = mtpM2uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAspTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpM2uaAspCapabilities);
		StorageTmp->mtpM2uaAspCapabilities = string;
		StorageTmp->mtpM2uaAspCapabilitiesLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAspTable_tsts == 0)
				if ((ret = check_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspCapabilities for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAspTable_sets == 0)
				if ((ret = update_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
			StorageTmp->mtpM2uaAspTable_rsvs = 0;
			StorageTmp->mtpM2uaAspTable_tsts = 0;
			StorageTmp->mtpM2uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAspTable_sets == 0)
			revert_mtpM2uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		if (StorageOld->mtpM2uaAspCapabilities != NULL) {
			SNMP_FREE(StorageTmp->mtpM2uaAspCapabilities);
			StorageTmp->mtpM2uaAspCapabilities = StorageOld->mtpM2uaAspCapabilities;
			StorageTmp->mtpM2uaAspCapabilitiesLen = StorageOld->mtpM2uaAspCapabilitiesLen;
			StorageOld->mtpM2uaAspCapabilities = NULL;
			StorageOld->mtpM2uaAspCapabilitiesLen = 0;
		}
		if (--StorageTmp->mtpM2uaAspTable_rsvs == 0)
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspSgVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspSgVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspSgVersion entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value interoperableVersion */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			if (StorageTmp->mtpM2uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAspTable_old = mtpM2uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAspTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpM2uaAspSgVersion);
		StorageTmp->mtpM2uaAspSgVersion = objid;
		StorageTmp->mtpM2uaAspSgVersionLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAspTable_tsts == 0)
				if ((ret = check_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspSgVersion for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAspTable_sets == 0)
				if ((ret = update_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
			StorageTmp->mtpM2uaAspTable_rsvs = 0;
			StorageTmp->mtpM2uaAspTable_tsts = 0;
			StorageTmp->mtpM2uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAspTable_sets == 0)
			revert_mtpM2uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		if (StorageOld->mtpM2uaAspSgVersion != NULL) {
			SNMP_FREE(StorageTmp->mtpM2uaAspSgVersion);
			StorageTmp->mtpM2uaAspSgVersion = StorageOld->mtpM2uaAspSgVersion;
			StorageTmp->mtpM2uaAspSgVersionLen = StorageOld->mtpM2uaAspSgVersionLen;
			StorageOld->mtpM2uaAspSgVersion = NULL;
			StorageOld->mtpM2uaAspSgVersionLen = 0;
		}
		if (--StorageTmp->mtpM2uaAspTable_rsvs == 0)
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspSgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspSgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspSgOptions entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgOptions not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 3) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			if (StorageTmp->mtpM2uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAspTable_old = mtpM2uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAspTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpM2uaAspSgOptions);
		StorageTmp->mtpM2uaAspSgOptions = string;
		StorageTmp->mtpM2uaAspSgOptionsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAspTable_tsts == 0)
				if ((ret = check_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspSgOptions for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAspTable_sets == 0)
				if ((ret = update_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
			StorageTmp->mtpM2uaAspTable_rsvs = 0;
			StorageTmp->mtpM2uaAspTable_tsts = 0;
			StorageTmp->mtpM2uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAspTable_sets == 0)
			revert_mtpM2uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		if (StorageOld->mtpM2uaAspSgOptions != NULL) {
			SNMP_FREE(StorageTmp->mtpM2uaAspSgOptions);
			StorageTmp->mtpM2uaAspSgOptions = StorageOld->mtpM2uaAspSgOptions;
			StorageTmp->mtpM2uaAspSgOptionsLen = StorageOld->mtpM2uaAspSgOptionsLen;
			StorageOld->mtpM2uaAspSgOptions = NULL;
			StorageOld->mtpM2uaAspSgOptionsLen = 0;
		}
		if (--StorageTmp->mtpM2uaAspTable_rsvs == 0)
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspSgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspSgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspSgRegistrationPolicy entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgRegistrationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPM2UAASPSGREGISTRATIONPOLICY_UNKNOWN:
		case MTPM2UAASPSGREGISTRATIONPOLICY_FORBIDDEN:
		case MTPM2UAASPSGREGISTRATIONPOLICY_PERMITTED:
		case MTPM2UAASPSGREGISTRATIONPOLICY_REQUIRED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgRegistrationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			if (StorageTmp->mtpM2uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAspTable_old = mtpM2uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAspTable_rsvs++;
		StorageTmp->mtpM2uaAspSgRegistrationPolicy = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAspTable_tsts == 0)
				if ((ret = check_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspSgRegistrationPolicy for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAspTable_sets == 0)
				if ((ret = update_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
			StorageTmp->mtpM2uaAspTable_rsvs = 0;
			StorageTmp->mtpM2uaAspTable_tsts = 0;
			StorageTmp->mtpM2uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAspTable_sets == 0)
			revert_mtpM2uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM2uaAspSgRegistrationPolicy = StorageOld->mtpM2uaAspSgRegistrationPolicy;
		if (--StorageTmp->mtpM2uaAspTable_rsvs == 0)
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspSgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspSgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspSgAspIdPolicy entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgAspIdPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgAspIdPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unknown */
		switch (set_value) {
		case MTPM2UAASPSGASPIDPOLICY_UNKNOWN:
		case MTPM2UAASPSGASPIDPOLICY_PERMITTED:
		case MTPM2UAASPSGASPIDPOLICY_REQUIRED:
		case MTPM2UAASPSGASPIDPOLICY_FORBIDDEN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspSgAspIdPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			if (StorageTmp->mtpM2uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAspTable_old = mtpM2uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAspTable_rsvs++;
		StorageTmp->mtpM2uaAspSgAspIdPolicy = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAspTable_tsts == 0)
				if ((ret = check_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspSgAspIdPolicy for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAspTable_sets == 0)
				if ((ret = update_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
			StorageTmp->mtpM2uaAspTable_rsvs = 0;
			StorageTmp->mtpM2uaAspTable_tsts = 0;
			StorageTmp->mtpM2uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAspTable_sets == 0)
			revert_mtpM2uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM2uaAspSgAspIdPolicy = StorageOld->mtpM2uaAspSgAspIdPolicy;
		if (--StorageTmp->mtpM2uaAspTable_rsvs == 0)
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspAssociationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspAssociationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspAssociationPolicy entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspAssociationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspAssociationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspAssociationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unknown */
		switch (set_value) {
		case MTPM2UAASPASSOCIATIONPOLICY_UNKNOWN:
		case MTPM2UAASPASSOCIATIONPOLICY_ALWAYS:
		case MTPM2UAASPASSOCIATIONPOLICY_ONDEMAND:
		case MTPM2UAASPASSOCIATIONPOLICY_OTHER:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspAssociationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			if (StorageTmp->mtpM2uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAspTable_old = mtpM2uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAspTable_rsvs++;
		StorageTmp->mtpM2uaAspAssociationPolicy = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAspTable_tsts == 0)
				if ((ret = check_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspAssociationPolicy for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAspTable_sets == 0)
				if ((ret = update_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
			StorageTmp->mtpM2uaAspTable_rsvs = 0;
			StorageTmp->mtpM2uaAspTable_tsts = 0;
			StorageTmp->mtpM2uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAspTable_sets == 0)
			revert_mtpM2uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM2uaAspAssociationPolicy = StorageOld->mtpM2uaAspAssociationPolicy;
		if (--StorageTmp->mtpM2uaAspTable_rsvs == 0)
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAspProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspProtocolPayloadId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspProtocolPayloadId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspProtocolPayloadId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspProtocolPayloadId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			if (StorageTmp->mtpM2uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAspTable_old = mtpM2uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAspTable_rsvs++;
		StorageTmp->mtpM2uaAspProtocolPayloadId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAspTable_tsts == 0)
				if ((ret = check_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAspProtocolPayloadId for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAspTable_sets == 0)
				if ((ret = update_mtpM2uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
			StorageTmp->mtpM2uaAspTable_rsvs = 0;
			StorageTmp->mtpM2uaAspTable_tsts = 0;
			StorageTmp->mtpM2uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAspTable_sets == 0)
			revert_mtpM2uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM2uaAspProtocolPayloadId = StorageOld->mtpM2uaAspProtocolPayloadId;
		if (--StorageTmp->mtpM2uaAspTable_rsvs == 0)
			mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAsInterfaceIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAsInterfaceIdentifier(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAsInterfaceIdentifier entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsInterfaceIdentifier: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsInterfaceIdentifier not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsInterfaceIdentifier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..-1 */
		if ((1 > set_value || set_value > -1)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsInterfaceIdentifier: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			if (StorageTmp->mtpM2uaAsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAsTable_old = mtpM2uaAsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAsTable_rsvs++;
		StorageTmp->mtpM2uaAsInterfaceIdentifier = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAsTable_tsts == 0)
				if ((ret = check_mtpM2uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAsInterfaceIdentifier for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAsTable_sets == 0)
				if ((ret = update_mtpM2uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			mtpM2uaAsTable_destroy(&StorageTmp->mtpM2uaAsTable_old);
			StorageTmp->mtpM2uaAsTable_rsvs = 0;
			StorageTmp->mtpM2uaAsTable_tsts = 0;
			StorageTmp->mtpM2uaAsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAsTable_sets == 0)
			revert_mtpM2uaAsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			break;
		StorageTmp->mtpM2uaAsInterfaceIdentifier = StorageOld->mtpM2uaAsInterfaceIdentifier;
		if (--StorageTmp->mtpM2uaAsTable_rsvs == 0)
			mtpM2uaAsTable_destroy(&StorageTmp->mtpM2uaAsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaInterfaceIdentifierText(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaInterfaceIdentifierText(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaInterfaceIdentifierText entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaInterfaceIdentifierText: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaInterfaceIdentifierText not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 1..255 */
		if (var_val_len > SPRINT_MAX_LEN || ((1 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaInterfaceIdentifierText: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			if (StorageTmp->mtpM2uaAsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAsTable_old = mtpM2uaAsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpM2uaInterfaceIdentifierText);
		StorageTmp->mtpM2uaInterfaceIdentifierText = string;
		StorageTmp->mtpM2uaInterfaceIdentifierTextLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAsTable_tsts == 0)
				if ((ret = check_mtpM2uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaInterfaceIdentifierText for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAsTable_sets == 0)
				if ((ret = update_mtpM2uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			mtpM2uaAsTable_destroy(&StorageTmp->mtpM2uaAsTable_old);
			StorageTmp->mtpM2uaAsTable_rsvs = 0;
			StorageTmp->mtpM2uaAsTable_tsts = 0;
			StorageTmp->mtpM2uaAsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAsTable_sets == 0)
			revert_mtpM2uaAsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			break;
		if (StorageOld->mtpM2uaInterfaceIdentifierText != NULL) {
			SNMP_FREE(StorageTmp->mtpM2uaInterfaceIdentifierText);
			StorageTmp->mtpM2uaInterfaceIdentifierText = StorageOld->mtpM2uaInterfaceIdentifierText;
			StorageTmp->mtpM2uaInterfaceIdentifierTextLen = StorageOld->mtpM2uaInterfaceIdentifierTextLen;
			StorageOld->mtpM2uaInterfaceIdentifierText = NULL;
			StorageOld->mtpM2uaInterfaceIdentifierTextLen = 0;
		}
		if (--StorageTmp->mtpM2uaAsTable_rsvs == 0)
			mtpM2uaAsTable_destroy(&StorageTmp->mtpM2uaAsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAsSDTI(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAsSDTI(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAsSDTI entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsSDTI: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsSDTI not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsSDTI: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			if (StorageTmp->mtpM2uaAsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAsTable_old = mtpM2uaAsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAsTable_rsvs++;
		StorageTmp->mtpM2uaAsSDTI = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAsTable_tsts == 0)
				if ((ret = check_mtpM2uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAsSDTI for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAsTable_sets == 0)
				if ((ret = update_mtpM2uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			mtpM2uaAsTable_destroy(&StorageTmp->mtpM2uaAsTable_old);
			StorageTmp->mtpM2uaAsTable_rsvs = 0;
			StorageTmp->mtpM2uaAsTable_tsts = 0;
			StorageTmp->mtpM2uaAsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAsTable_sets == 0)
			revert_mtpM2uaAsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			break;
		StorageTmp->mtpM2uaAsSDTI = StorageOld->mtpM2uaAsSDTI;
		if (--StorageTmp->mtpM2uaAsTable_rsvs == 0)
			mtpM2uaAsTable_destroy(&StorageTmp->mtpM2uaAsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAsTrafficMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM2uaAsTrafficMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAsTrafficMode entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM2uaAsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM2uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsTrafficMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsTrafficMode not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsTrafficMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value activeStandby */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			if (StorageTmp->mtpM2uaAsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM2uaAsTable_old = mtpM2uaAsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM2uaAsTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpM2uaAsTrafficMode);
		StorageTmp->mtpM2uaAsTrafficMode = objid;
		StorageTmp->mtpM2uaAsTrafficModeLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM2uaAsTable_tsts == 0)
				if ((ret = check_mtpM2uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM2uaAsTrafficMode for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM2uaAsTable_sets == 0)
				if ((ret = update_mtpM2uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM2uaAsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
			mtpM2uaAsTable_destroy(&StorageTmp->mtpM2uaAsTable_old);
			StorageTmp->mtpM2uaAsTable_rsvs = 0;
			StorageTmp->mtpM2uaAsTable_tsts = 0;
			StorageTmp->mtpM2uaAsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM2uaAsTable_sets == 0)
			revert_mtpM2uaAsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
			break;
		if (StorageOld->mtpM2uaAsTrafficMode != NULL) {
			SNMP_FREE(StorageTmp->mtpM2uaAsTrafficMode);
			StorageTmp->mtpM2uaAsTrafficMode = StorageOld->mtpM2uaAsTrafficMode;
			StorageTmp->mtpM2uaAsTrafficModeLen = StorageOld->mtpM2uaAsTrafficModeLen;
			StorageOld->mtpM2uaAsTrafficMode = NULL;
			StorageOld->mtpM2uaAsTrafficModeLen = 0;
		}
		if (--StorageTmp->mtpM2uaAsTable_rsvs == 0)
			mtpM2uaAsTable_destroy(&StorageTmp->mtpM2uaAsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAsType(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsType entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsType: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value ipsp */
		switch (set_value) {
		case MTPM3UAASTYPE_ASP:
		case MTPM3UAASTYPE_IPSP:
		case MTPM3UAASTYPE_SGP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsType: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			if (StorageTmp->mtpM3uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAspTable_old = mtpM3uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAspTable_rsvs++;
		StorageTmp->mtpM3uaAsType = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAspTable_tsts == 0)
				if ((ret = check_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAsType for you to use, and you have just been asked to do something with it.  Note that anything done here must
				   be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAspTable_sets == 0)
				if ((ret = update_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
			StorageTmp->mtpM3uaAspTable_rsvs = 0;
			StorageTmp->mtpM3uaAspTable_tsts = 0;
			StorageTmp->mtpM3uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAspTable_sets == 0)
			revert_mtpM3uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM3uaAsType = StorageOld->mtpM3uaAsType;
		if (--StorageTmp->mtpM3uaAspTable_rsvs == 0)
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			if (StorageTmp->mtpM3uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAspTable_old = mtpM3uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAspTable_rsvs++;
		StorageTmp->mtpM3uaAspId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAspTable_tsts == 0)
				if ((ret = check_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspId for you to use, and you have just been asked to do something with it.  Note that anything done here must be 
				   reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAspTable_sets == 0)
				if ((ret = update_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
			StorageTmp->mtpM3uaAspTable_rsvs = 0;
			StorageTmp->mtpM3uaAspTable_tsts = 0;
			StorageTmp->mtpM3uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAspTable_sets == 0)
			revert_mtpM3uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM3uaAspId = StorageOld->mtpM3uaAspId;
		if (--StorageTmp->mtpM3uaAspTable_rsvs == 0)
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspCapabilities entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspCapabilities: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspCapabilities not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 3) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspCapabilities: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspCapabilities: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			if (StorageTmp->mtpM3uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAspTable_old = mtpM3uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAspTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpM3uaAspCapabilities);
		StorageTmp->mtpM3uaAspCapabilities = string;
		StorageTmp->mtpM3uaAspCapabilitiesLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAspTable_tsts == 0)
				if ((ret = check_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspCapabilities for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAspTable_sets == 0)
				if ((ret = update_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
			StorageTmp->mtpM3uaAspTable_rsvs = 0;
			StorageTmp->mtpM3uaAspTable_tsts = 0;
			StorageTmp->mtpM3uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAspTable_sets == 0)
			revert_mtpM3uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		if (StorageOld->mtpM3uaAspCapabilities != NULL) {
			SNMP_FREE(StorageTmp->mtpM3uaAspCapabilities);
			StorageTmp->mtpM3uaAspCapabilities = StorageOld->mtpM3uaAspCapabilities;
			StorageTmp->mtpM3uaAspCapabilitiesLen = StorageOld->mtpM3uaAspCapabilitiesLen;
			StorageOld->mtpM3uaAspCapabilities = NULL;
			StorageOld->mtpM3uaAspCapabilitiesLen = 0;
		}
		if (--StorageTmp->mtpM3uaAspTable_rsvs == 0)
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspSgVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspSgVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspSgVersion entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value interoperableVersion */
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			if (StorageTmp->mtpM3uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAspTable_old = mtpM3uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAspTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpM3uaAspSgVersion);
		StorageTmp->mtpM3uaAspSgVersion = objid;
		StorageTmp->mtpM3uaAspSgVersionLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAspTable_tsts == 0)
				if ((ret = check_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspSgVersion for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAspTable_sets == 0)
				if ((ret = update_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
			StorageTmp->mtpM3uaAspTable_rsvs = 0;
			StorageTmp->mtpM3uaAspTable_tsts = 0;
			StorageTmp->mtpM3uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAspTable_sets == 0)
			revert_mtpM3uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		if (StorageOld->mtpM3uaAspSgVersion != NULL) {
			SNMP_FREE(StorageTmp->mtpM3uaAspSgVersion);
			StorageTmp->mtpM3uaAspSgVersion = StorageOld->mtpM3uaAspSgVersion;
			StorageTmp->mtpM3uaAspSgVersionLen = StorageOld->mtpM3uaAspSgVersionLen;
			StorageOld->mtpM3uaAspSgVersion = NULL;
			StorageOld->mtpM3uaAspSgVersionLen = 0;
		}
		if (--StorageTmp->mtpM3uaAspTable_rsvs == 0)
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspSgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspSgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspSgOptions entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if ((var_val_type != ASN_BIT_STR && var_val_type != ASN_OCTET_STR)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgOptions not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_type == ASN_BIT_STR) {
			if (1 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != 3) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		if (var_val_type == ASN_OCTET_STR) {
			if (var_val_len > SPRINT_MAX_LEN || var_val_len != 2) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgOptions: bad length\n");
				return SNMP_ERR_WRONGLENGTH;
			}
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			if (StorageTmp->mtpM3uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAspTable_old = mtpM3uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAspTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpM3uaAspSgOptions);
		StorageTmp->mtpM3uaAspSgOptions = string;
		StorageTmp->mtpM3uaAspSgOptionsLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAspTable_tsts == 0)
				if ((ret = check_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspSgOptions for you to use, and you have just been asked to do something with it.  Note that anything done here
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAspTable_sets == 0)
				if ((ret = update_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
			StorageTmp->mtpM3uaAspTable_rsvs = 0;
			StorageTmp->mtpM3uaAspTable_tsts = 0;
			StorageTmp->mtpM3uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAspTable_sets == 0)
			revert_mtpM3uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		if (StorageOld->mtpM3uaAspSgOptions != NULL) {
			SNMP_FREE(StorageTmp->mtpM3uaAspSgOptions);
			StorageTmp->mtpM3uaAspSgOptions = StorageOld->mtpM3uaAspSgOptions;
			StorageTmp->mtpM3uaAspSgOptionsLen = StorageOld->mtpM3uaAspSgOptionsLen;
			StorageOld->mtpM3uaAspSgOptions = NULL;
			StorageOld->mtpM3uaAspSgOptionsLen = 0;
		}
		if (--StorageTmp->mtpM3uaAspTable_rsvs == 0)
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspSgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspSgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspSgRegistrationPolicy entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgRegistrationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case MTPM3UAASPSGREGISTRATIONPOLICY_UNKNOWN:
		case MTPM3UAASPSGREGISTRATIONPOLICY_FORBIDDEN:
		case MTPM3UAASPSGREGISTRATIONPOLICY_PERMITTED:
		case MTPM3UAASPSGREGISTRATIONPOLICY_REQUIRED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgRegistrationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			if (StorageTmp->mtpM3uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAspTable_old = mtpM3uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAspTable_rsvs++;
		StorageTmp->mtpM3uaAspSgRegistrationPolicy = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAspTable_tsts == 0)
				if ((ret = check_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspSgRegistrationPolicy for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAspTable_sets == 0)
				if ((ret = update_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
			StorageTmp->mtpM3uaAspTable_rsvs = 0;
			StorageTmp->mtpM3uaAspTable_tsts = 0;
			StorageTmp->mtpM3uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAspTable_sets == 0)
			revert_mtpM3uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM3uaAspSgRegistrationPolicy = StorageOld->mtpM3uaAspSgRegistrationPolicy;
		if (--StorageTmp->mtpM3uaAspTable_rsvs == 0)
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspSgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspSgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspSgAspIdPolicy entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgAspIdPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgAspIdPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unknown */
		switch (set_value) {
		case MTPM3UAASPSGASPIDPOLICY_UNKNOWN:
		case MTPM3UAASPSGASPIDPOLICY_PERMITTED:
		case MTPM3UAASPSGASPIDPOLICY_REQUIRED:
		case MTPM3UAASPSGASPIDPOLICY_FORBIDDEN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspSgAspIdPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			if (StorageTmp->mtpM3uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAspTable_old = mtpM3uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAspTable_rsvs++;
		StorageTmp->mtpM3uaAspSgAspIdPolicy = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAspTable_tsts == 0)
				if ((ret = check_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspSgAspIdPolicy for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAspTable_sets == 0)
				if ((ret = update_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
			StorageTmp->mtpM3uaAspTable_rsvs = 0;
			StorageTmp->mtpM3uaAspTable_tsts = 0;
			StorageTmp->mtpM3uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAspTable_sets == 0)
			revert_mtpM3uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM3uaAspSgAspIdPolicy = StorageOld->mtpM3uaAspSgAspIdPolicy;
		if (--StorageTmp->mtpM3uaAspTable_rsvs == 0)
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspAssociationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspAssociationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspAssociationPolicy entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspAssociationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspAssociationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspAssociationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value unknown */
		switch (set_value) {
		case MTPM3UAASPASSOCIATIONPOLICY_UNKNOWN:
		case MTPM3UAASPASSOCIATIONPOLICY_ALWAYS:
		case MTPM3UAASPASSOCIATIONPOLICY_ONDEMAND:
		case MTPM3UAASPASSOCIATIONPOLICY_OTHER:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspAssociationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			if (StorageTmp->mtpM3uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAspTable_old = mtpM3uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAspTable_rsvs++;
		StorageTmp->mtpM3uaAspAssociationPolicy = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAspTable_tsts == 0)
				if ((ret = check_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspAssociationPolicy for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAspTable_sets == 0)
				if ((ret = update_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
			StorageTmp->mtpM3uaAspTable_rsvs = 0;
			StorageTmp->mtpM3uaAspTable_tsts = 0;
			StorageTmp->mtpM3uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAspTable_sets == 0)
			revert_mtpM3uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM3uaAspAssociationPolicy = StorageOld->mtpM3uaAspAssociationPolicy;
		if (--StorageTmp->mtpM3uaAspTable_rsvs == 0)
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAspProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspProtocolPayloadId entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAspRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspProtocolPayloadId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspProtocolPayloadId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspProtocolPayloadId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			if (StorageTmp->mtpM3uaAspTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAspTable_old = mtpM3uaAspTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAspTable_rsvs++;
		StorageTmp->mtpM3uaAspProtocolPayloadId = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAspTable_tsts == 0)
				if ((ret = check_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAspProtocolPayloadId for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAspTable_sets == 0)
				if ((ret = update_mtpM3uaAspTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAspTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
			StorageTmp->mtpM3uaAspTable_rsvs = 0;
			StorageTmp->mtpM3uaAspTable_tsts = 0;
			StorageTmp->mtpM3uaAspTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAspTable_sets == 0)
			revert_mtpM3uaAspTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
			break;
		StorageTmp->mtpM3uaAspProtocolPayloadId = StorageOld->mtpM3uaAspProtocolPayloadId;
		if (--StorageTmp->mtpM3uaAspTable_rsvs == 0)
			mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsRoutingContext(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAsRoutingContext(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsRoutingContext entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsRoutingContext: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsRoutingContext not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsRoutingContext: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			if (StorageTmp->mtpM3uaAsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAsTable_old = mtpM3uaAsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAsTable_rsvs++;
		StorageTmp->mtpM3uaAsRoutingContext = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAsTable_tsts == 0)
				if ((ret = check_mtpM3uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAsRoutingContext for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAsTable_sets == 0)
				if ((ret = update_mtpM3uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			mtpM3uaAsTable_destroy(&StorageTmp->mtpM3uaAsTable_old);
			StorageTmp->mtpM3uaAsTable_rsvs = 0;
			StorageTmp->mtpM3uaAsTable_tsts = 0;
			StorageTmp->mtpM3uaAsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAsTable_sets == 0)
			revert_mtpM3uaAsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			break;
		StorageTmp->mtpM3uaAsRoutingContext = StorageOld->mtpM3uaAsRoutingContext;
		if (--StorageTmp->mtpM3uaAsTable_rsvs == 0)
			mtpM3uaAsTable_destroy(&StorageTmp->mtpM3uaAsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsNetworkAppearance(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAsNetworkAppearance(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsNetworkAppearance entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkAppearance: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkAppearance not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkAppearance: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			if (StorageTmp->mtpM3uaAsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAsTable_old = mtpM3uaAsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAsTable_rsvs++;
		StorageTmp->mtpM3uaAsNetworkAppearance = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAsTable_tsts == 0)
				if ((ret = check_mtpM3uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAsNetworkAppearance for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAsTable_sets == 0)
				if ((ret = update_mtpM3uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			mtpM3uaAsTable_destroy(&StorageTmp->mtpM3uaAsTable_old);
			StorageTmp->mtpM3uaAsTable_rsvs = 0;
			StorageTmp->mtpM3uaAsTable_tsts = 0;
			StorageTmp->mtpM3uaAsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAsTable_sets == 0)
			revert_mtpM3uaAsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			break;
		StorageTmp->mtpM3uaAsNetworkAppearance = StorageOld->mtpM3uaAsNetworkAppearance;
		if (--StorageTmp->mtpM3uaAsTable_rsvs == 0)
			mtpM3uaAsTable_destroy(&StorageTmp->mtpM3uaAsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsNetworkPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAsNetworkPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	uint8_t *string = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsNetworkPointCode entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkPointCode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsNetworkPointCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			if (StorageTmp->mtpM3uaAsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAsTable_old = mtpM3uaAsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAsTable_rsvs++;
		if ((string = malloc(var_val_len + 1)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		string[var_val_len] = 0;
		SNMP_FREE(StorageTmp->mtpM3uaAsNetworkPointCode);
		StorageTmp->mtpM3uaAsNetworkPointCode = string;
		StorageTmp->mtpM3uaAsNetworkPointCodeLen = var_val_len;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAsTable_tsts == 0)
				if ((ret = check_mtpM3uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAsNetworkPointCode for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAsTable_sets == 0)
				if ((ret = update_mtpM3uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			mtpM3uaAsTable_destroy(&StorageTmp->mtpM3uaAsTable_old);
			StorageTmp->mtpM3uaAsTable_rsvs = 0;
			StorageTmp->mtpM3uaAsTable_tsts = 0;
			StorageTmp->mtpM3uaAsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAsTable_sets == 0)
			revert_mtpM3uaAsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			break;
		if (StorageOld->mtpM3uaAsNetworkPointCode != NULL) {
			SNMP_FREE(StorageTmp->mtpM3uaAsNetworkPointCode);
			StorageTmp->mtpM3uaAsNetworkPointCode = StorageOld->mtpM3uaAsNetworkPointCode;
			StorageTmp->mtpM3uaAsNetworkPointCodeLen = StorageOld->mtpM3uaAsNetworkPointCodeLen;
			StorageOld->mtpM3uaAsNetworkPointCode = NULL;
			StorageOld->mtpM3uaAsNetworkPointCodeLen = 0;
		}
		if (--StorageTmp->mtpM3uaAsTable_rsvs == 0)
			mtpM3uaAsTable_destroy(&StorageTmp->mtpM3uaAsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsTrafficMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpM3uaAsTrafficMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 16;
	oid *objid = NULL;
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsTrafficMode entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpM3uaAsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpM3uaAsRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsTrafficMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsTrafficMode not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsTrafficMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			if (StorageTmp->mtpM3uaAsTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpM3uaAsTable_old = mtpM3uaAsTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpM3uaAsTable_rsvs++;
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		SNMP_FREE(StorageTmp->mtpM3uaAsTrafficMode);
		StorageTmp->mtpM3uaAsTrafficMode = objid;
		StorageTmp->mtpM3uaAsTrafficModeLen = var_val_len / sizeof(oid);
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpM3uaAsTable_tsts == 0)
				if ((ret = check_mtpM3uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAsTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpM3uaAsTrafficMode for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpM3uaAsTable_sets == 0)
				if ((ret = update_mtpM3uaAsTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpM3uaAsTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
			mtpM3uaAsTable_destroy(&StorageTmp->mtpM3uaAsTable_old);
			StorageTmp->mtpM3uaAsTable_rsvs = 0;
			StorageTmp->mtpM3uaAsTable_tsts = 0;
			StorageTmp->mtpM3uaAsTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpM3uaAsTable_sets == 0)
			revert_mtpM3uaAsTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
			break;
		if (StorageOld->mtpM3uaAsTrafficMode != NULL) {
			SNMP_FREE(StorageTmp->mtpM3uaAsTrafficMode);
			StorageTmp->mtpM3uaAsTrafficMode = StorageOld->mtpM3uaAsTrafficMode;
			StorageTmp->mtpM3uaAsTrafficModeLen = StorageOld->mtpM3uaAsTrafficModeLen;
			StorageOld->mtpM3uaAsTrafficMode = NULL;
			StorageOld->mtpM3uaAsTrafficModeLen = 0;
		}
		if (--StorageTmp->mtpM3uaAsTable_rsvs == 0)
			mtpM3uaAsTable_destroy(&StorageTmp->mtpM3uaAsTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpNoDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpNoDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpNoDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpNoDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpNoDelay = StorageOld->mtpDefaultSctpNoDelay;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpMaxseg(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		if ((1 > set_value || set_value > 65536)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxseg: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpMaxseg = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpMaxseg for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpMaxseg = StorageOld->mtpDefaultSctpMaxseg;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpHeartbeatItvl(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpHeartbeatItvl not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpHeartbeatItvl = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpHeartbeatItvl for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpHeartbeatItvl = StorageOld->mtpDefaultSctpHeartbeatItvl;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpHeartbeat(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpHeartbeat: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpHeartbeat = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpHeartbeat for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpHeartbeat = StorageOld->mtpDefaultSctpHeartbeat;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpRtoInitial(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoInitial not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpRtoInitial = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpRtoInitial for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpRtoInitial = StorageOld->mtpDefaultSctpRtoInitial;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoMin not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpRtoMin = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpRtoMin for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpRtoMin = StorageOld->mtpDefaultSctpRtoMin;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpRtoMax(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoMax not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpRtoMax = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpRtoMax for you to use, and you have just been asked to do something with it.  Note that anything done here 
				   must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpRtoMax = StorageOld->mtpDefaultSctpRtoMax;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpPathMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpPathMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpPathMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpPathMaxRetrans = StorageOld->mtpDefaultSctpPathMaxRetrans;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpCookieLife(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpCookieLife not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 60000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpCookieLife = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpCookieLife for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpCookieLife = StorageOld->mtpDefaultSctpCookieLife;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpCookieInc(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpCookieInc not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpCookieInc = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpCookieInc for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpCookieInc = StorageOld->mtpDefaultSctpCookieInc;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpMaxInitRetries(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpMaxInitRetries = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpMaxInitRetries for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpMaxInitRetries = StorageOld->mtpDefaultSctpMaxInitRetries;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpMaxBurst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpMaxBurst = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpMaxBurst for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpMaxBurst = StorageOld->mtpDefaultSctpMaxBurst;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpAssocMaxRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpAssocMaxRetrans = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpAssocMaxRetrans for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpAssocMaxRetrans = StorageOld->mtpDefaultSctpAssocMaxRetrans;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpSackDelay(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpSackDelay not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 200 */
		/* Note: ranges 0..500 */
		if ((0 > set_value || set_value > 500)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpSackDelay: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpSackDelay = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpSackDelay for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpSackDelay = StorageOld->mtpDefaultSctpSackDelay;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpDefaultSctpLifetime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMIB_data *StorageTmp = NULL, *StorageOld = NULL;
	ulong set_value = *((ulong *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpMIB", "write_mtpDefaultSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = mtpMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpLifetime not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpDefaultSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* one allocation for whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			if (StorageTmp->mtpMIB_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpMIB_old = mtpMIB_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpMIB_rsvs++;
		StorageTmp->mtpDefaultSctpLifetime = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* one consistency check for the whole mib */
			if (StorageTmp->mtpMIB_tsts == 0)
				if ((ret = check_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpDefaultSctpLifetime for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpMIB_sets == 0)
				if ((ret = update_mtpMIB(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpMIB_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpMIB_old) != NULL) {
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
			StorageTmp->mtpMIB_rsvs = 0;
			StorageTmp->mtpMIB_tsts = 0;
			StorageTmp->mtpMIB_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpMIB_tsts == 0)
			revert_mtpMIB(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpMIB_old) == NULL)
			break;
		StorageTmp->mtpDefaultSctpLifetime = StorageOld->mtpDefaultSctpLifetime;
		if (--StorageTmp->mtpMIB_rsvs == 0)
			mtpMIB_destroy(&StorageTmp->mtpMIB_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSapTable_row(struct mtpSapTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpNaTable_row(struct mtpNaTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpMsTable_row(struct mtpMsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSpProfileTable_row(struct mtpSpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSpTable_row(struct mtpSpTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpL3Table_row(struct mtpL3Table_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpGsTable_row(struct mtpGsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpGsLineTable_row(struct mtpGsLineTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpGsLineContentTable_row(struct mtpGsLineContentTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpRsProfileTable_row(struct mtpRsProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpRsTable_row(struct mtpRsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpRtProfileTable_row(struct mtpRtProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpRtTable_row(struct mtpRtTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpLsProfileTable_row(struct mtpLsProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpLsTable_row(struct mtpLsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSlL3ProfileTable_row(struct mtpSlL3ProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSlL2ProfileTable_row(struct mtpSlL2ProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSlTable_row(struct mtpSlTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSlSdlListTable_row(struct mtpSlSdlListTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSlSdtListTable_row(struct mtpSlSdtListTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpNbTable_row(struct mtpNbTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSaalTable_row(struct mtpSaalTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpM2paTable_row(struct mtpM2paTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSdtTable_row(struct mtpSdtTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSdlTable_row(struct mtpSdlTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSctpProfileTable_row(struct mtpSctpProfileTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSctpTable_row(struct mtpSctpTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSctpLocalTable_row(struct mtpSctpLocalTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpSctpRemoteTable_row(struct mtpSctpRemoteTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpM2uaAspTable_row(struct mtpM2uaAspTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpM2uaAsTable_row(struct mtpM2uaAsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpM3uaAspTable_row(struct mtpM3uaAspTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpM3uaAsTable_row(struct mtpM3uaAsTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSapRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSapTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSapRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSapRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSapId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSapId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSapId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSapTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSapTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSapId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSapTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSapRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSapTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
				if (StorageTmp->mtpSapTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSapTable_old = mtpSapTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSapTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSapTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSapTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSapTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSapRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSapTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSapRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSapTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSapRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSapTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSapRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSapTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSapRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSapTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSapRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSapTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSapTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSapRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSapRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSapRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSapTable_old) != NULL) {
				mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
				StorageTmp->mtpSapTable_rsvs = 0;
				StorageTmp->mtpSapTable_tsts = 0;
				StorageTmp->mtpSapTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSapTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSapTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSapRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSapTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSapRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSapTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSapTable_del(StorageNew);
				mtpSapTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSapTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSapTable_rsvs == 0)
				mtpSapTable_destroy(&StorageTmp->mtpSapTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSapTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpNaRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNaTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpNaTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpNaRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNaTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNaRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpNaId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpNaId */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpNaId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..255 */
			if ((1 > (long) *vp->val.integer || (long) *vp->val.integer > 255)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpNaId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpNaTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpNaTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpNaId = (long) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpNaTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpNaRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpNaTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
				if (StorageTmp->mtpNaTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpNaTable_old = mtpNaTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpNaTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpNaTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpNaTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpNaTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpNaRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpNaTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpNaRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpNaTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpNaRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpNaTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpNaRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpNaTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpNaRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpNaTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpNaRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpNaTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpNaTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpNaRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpNaRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpNaRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpNaTable_old) != NULL) {
				mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
				StorageTmp->mtpNaTable_rsvs = 0;
				StorageTmp->mtpNaTable_tsts = 0;
				StorageTmp->mtpNaTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpNaTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpNaTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpNaRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpNaTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpNaRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpNaTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpNaTable_del(StorageNew);
				mtpNaTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpNaTable_old) == NULL)
				break;
			if (--StorageTmp->mtpNaTable_rsvs == 0)
				mtpNaTable_destroy(&StorageTmp->mtpNaTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpNaTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpMsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpMsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpMsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpMsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpMsRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpMsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpMsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpMsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpMsTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpMsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpMsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpMsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
				if (StorageTmp->mtpMsTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpMsTable_old = mtpMsTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpMsTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpMsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpMsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpMsTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpMsRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpMsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpMsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpMsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpMsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpMsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpMsRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpMsTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpMsRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpMsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpMsRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpMsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpMsTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpMsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpMsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpMsRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpMsTable_old) != NULL) {
				mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
				StorageTmp->mtpMsTable_rsvs = 0;
				StorageTmp->mtpMsTable_tsts = 0;
				StorageTmp->mtpMsTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpMsTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpMsTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpMsRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpMsTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpMsRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpMsTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpMsTable_del(StorageNew);
				mtpMsTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpMsTable_old) == NULL)
				break;
			if (--StorageTmp->mtpMsTable_rsvs == 0)
				mtpMsTable_destroy(&StorageTmp->mtpMsTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpMsTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpProfileRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSpProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSpProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpProfileTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->mtpSpProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSpProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSpProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSpProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSpProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
				if (StorageTmp->mtpSpProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSpProfileTable_old = mtpSpProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSpProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSpProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSpProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSpProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSpProfileRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSpProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSpProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSpProfileRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSpProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSpProfileRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSpProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSpProfileRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSpProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSpProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSpProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSpProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSpProfileRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSpProfileTable_old) != NULL) {
				mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
				StorageTmp->mtpSpProfileTable_rsvs = 0;
				StorageTmp->mtpSpProfileTable_tsts = 0;
				StorageTmp->mtpSpProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSpProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSpProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSpProfileRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSpProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSpProfileRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSpProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSpProfileTable_del(StorageNew);
				mtpSpProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSpProfileTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSpProfileTable_rsvs == 0)
				mtpSpProfileTable_destroy(&StorageTmp->mtpSpProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSpProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSpRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSpTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSpTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSpTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
				if (StorageTmp->mtpSpTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSpTable_old = mtpSpTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSpTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSpTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSpTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSpRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSpRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSpTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSpRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSpTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSpRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSpTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSpTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSpRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSpTable_old) != NULL) {
				mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
				StorageTmp->mtpSpTable_rsvs = 0;
				StorageTmp->mtpSpTable_tsts = 0;
				StorageTmp->mtpSpTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSpTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSpTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSpRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSpTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSpRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSpTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSpTable_del(StorageNew);
				mtpSpTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSpTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSpTable_rsvs == 0)
				mtpSpTable_destroy(&StorageTmp->mtpSpTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSpTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpL3RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpL3RowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpL3Table_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpL3Table_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpL3RowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpL3TableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3RowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpL3RowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpL3Id */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpL3Id */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpL3Id: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpL3Table_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpL3Table_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpL3Id = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpL3TableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpL3RowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpL3Table_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
				if (StorageTmp->mtpL3Table_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpL3Table_old = mtpL3Table_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpL3Table_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpL3Table_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpL3Table_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpL3Table_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpL3RowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpL3Table_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpL3RowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpL3Table_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpL3RowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpL3Table_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpL3RowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpL3Table_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpL3RowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpL3Table_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpL3RowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpL3Table_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpL3Table_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpL3RowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpL3RowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpL3RowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpL3Table_old) != NULL) {
				mtpL3Table_destroy(&StorageTmp->mtpL3Table_old);
				StorageTmp->mtpL3Table_rsvs = 0;
				StorageTmp->mtpL3Table_tsts = 0;
				StorageTmp->mtpL3Table_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpL3Table_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpL3Table_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpL3RowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpL3Table_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpL3RowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpL3Table_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpL3Table_del(StorageNew);
				mtpL3Table_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpL3Table_old) == NULL)
				break;
			if (--StorageTmp->mtpL3Table_rsvs == 0)
				mtpL3Table_destroy(&StorageTmp->mtpL3Table_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpL3Table_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpGsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpGsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpGsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpGsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpGsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpGsTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpGsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
				if (StorageTmp->mtpGsTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpGsTable_old = mtpGsTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpGsTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpGsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpGsTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpGsRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpGsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpGsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpGsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpGsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpGsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpGsRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpGsTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpGsRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpGsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpGsRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpGsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpGsTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpGsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpGsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpGsRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpGsTable_old) != NULL) {
				mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
				StorageTmp->mtpGsTable_rsvs = 0;
				StorageTmp->mtpGsTable_tsts = 0;
				StorageTmp->mtpGsTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpGsTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpGsTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpGsRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpGsTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpGsRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpGsTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpGsTable_del(StorageNew);
				mtpGsTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpGsTable_old) == NULL)
				break;
			if (--StorageTmp->mtpGsTable_rsvs == 0)
				mtpGsTable_destroy(&StorageTmp->mtpGsTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpGsTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpGsLineRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpGsLineTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsLineTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsLineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpGsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpGsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpGsLineId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpGsLineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpGsLineTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpGsLineTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpGsLineTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsLineRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsLineTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpGsLineTable_old) == NULL)
				if (StorageTmp->mtpGsLineTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpGsLineTable_old = mtpGsLineTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpGsLineTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsLineTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpGsLineTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpGsLineTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpGsLineRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpGsLineTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpGsLineRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpGsLineTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpGsLineRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpGsLineTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpGsLineRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpGsLineTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpGsLineRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpGsLineTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpGsLineRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpGsLineTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpGsLineTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpGsLineRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpGsLineRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpGsLineRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpGsLineTable_old) != NULL) {
				mtpGsLineTable_destroy(&StorageTmp->mtpGsLineTable_old);
				StorageTmp->mtpGsLineTable_rsvs = 0;
				StorageTmp->mtpGsLineTable_tsts = 0;
				StorageTmp->mtpGsLineTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpGsLineTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpGsLineTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpGsLineRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpGsLineTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpGsLineRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpGsLineTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpGsLineTable_del(StorageNew);
				mtpGsLineTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpGsLineTable_old) == NULL)
				break;
			if (--StorageTmp->mtpGsLineTable_rsvs == 0)
				mtpGsLineTable_destroy(&StorageTmp->mtpGsLineTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpGsLineTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpGsLineContentRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpGsLineContentRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpGsLineContentTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpGsLineContentTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpGsLineContentRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpGsLineContentTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpGsLineContentRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsLineId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpGsLineContentId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpGsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpGsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpGsLineId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpGsLineId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpGsLineContentId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpGsLineContentId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpGsLineContentTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpGsLineContentTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpGsLineContentId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpGsLineContentTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpGsLineContentRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpGsLineContentTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
				if (StorageTmp->mtpGsLineContentTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpGsLineContentTable_old = mtpGsLineContentTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpGsLineContentTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpGsLineContentTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpGsLineContentTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpGsLineContentTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpGsLineContentRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpGsLineContentTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpGsLineContentRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpGsLineContentTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpGsLineContentRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpGsLineContentTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpGsLineContentRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpGsLineContentTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpGsLineContentRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpGsLineContentTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpGsLineContentRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpGsLineContentTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpGsLineContentTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpGsLineContentRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpGsLineContentRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpGsLineContentRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) != NULL) {
				mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
				StorageTmp->mtpGsLineContentTable_rsvs = 0;
				StorageTmp->mtpGsLineContentTable_tsts = 0;
				StorageTmp->mtpGsLineContentTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpGsLineContentTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpGsLineContentTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpGsLineContentRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpGsLineContentTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpGsLineContentRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpGsLineContentTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpGsLineContentTable_del(StorageNew);
				mtpGsLineContentTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpGsLineContentTable_old) == NULL)
				break;
			if (--StorageTmp->mtpGsLineContentTable_rsvs == 0)
				mtpGsLineContentTable_destroy(&StorageTmp->mtpGsLineContentTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpGsLineContentTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpRsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsProfileRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpRsProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpRsProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpRsProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpRsProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpRsProfileTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->mtpRsProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpRsProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpRsProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRsProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRsProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
				if (StorageTmp->mtpRsProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpRsProfileTable_old = mtpRsProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpRsProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRsProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRsProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpRsProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpRsProfileRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpRsProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpRsProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpRsProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpRsProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpRsProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpRsProfileRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpRsProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpRsProfileRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpRsProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpRsProfileRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpRsProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpRsProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpRsProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpRsProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpRsProfileRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpRsProfileTable_old) != NULL) {
				mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
				StorageTmp->mtpRsProfileTable_rsvs = 0;
				StorageTmp->mtpRsProfileTable_tsts = 0;
				StorageTmp->mtpRsProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpRsProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpRsProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpRsProfileRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpRsProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpRsProfileRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpRsProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpRsProfileTable_del(StorageNew);
				mtpRsProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpRsProfileTable_old) == NULL)
				break;
			if (--StorageTmp->mtpRsProfileTable_rsvs == 0)
				mtpRsProfileTable_destroy(&StorageTmp->mtpRsProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpRsProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpRsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpRsRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpRsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpRsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpRsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpRsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpRsTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpRsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
				if (StorageTmp->mtpRsTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpRsTable_old = mtpRsTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpRsTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpRsTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpRsRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpRsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpRsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpRsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpRsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpRsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpRsRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpRsTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpRsRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpRsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpRsRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpRsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpRsTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpRsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpRsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpRsRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpRsTable_old) != NULL) {
				mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
				StorageTmp->mtpRsTable_rsvs = 0;
				StorageTmp->mtpRsTable_tsts = 0;
				StorageTmp->mtpRsTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpRsTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpRsTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpRsRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpRsTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpRsRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpRsTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpRsTable_del(StorageNew);
				mtpRsTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpRsTable_old) == NULL)
				break;
			if (--StorageTmp->mtpRsTable_rsvs == 0)
				mtpRsTable_destroy(&StorageTmp->mtpRsTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpRsTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRtProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpRtProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtProfileRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpRtProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpRtProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpRtProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpRtProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpRtProfileTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->mtpRtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpRtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpRtProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRtProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRtProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpRtProfileTable_old) == NULL)
				if (StorageTmp->mtpRtProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpRtProfileTable_old = mtpRtProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpRtProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRtProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRtProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpRtProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpRtProfileRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpRtProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpRtProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpRtProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpRtProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpRtProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpRtProfileRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpRtProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpRtProfileRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpRtProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpRtProfileRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpRtProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpRtProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpRtProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpRtProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpRtProfileRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpRtProfileTable_old) != NULL) {
				mtpRtProfileTable_destroy(&StorageTmp->mtpRtProfileTable_old);
				StorageTmp->mtpRtProfileTable_rsvs = 0;
				StorageTmp->mtpRtProfileTable_tsts = 0;
				StorageTmp->mtpRtProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpRtProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpRtProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpRtProfileRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpRtProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpRtProfileRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpRtProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpRtProfileTable_del(StorageNew);
				mtpRtProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpRtProfileTable_old) == NULL)
				break;
			if (--StorageTmp->mtpRtProfileTable_rsvs == 0)
				mtpRtProfileTable_destroy(&StorageTmp->mtpRtProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpRtProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpRtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpRtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpRtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpRtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpRtRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpRtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpRtRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpRsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpRtId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpRsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpRsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpRtId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpRtId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpRtTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpRtTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRtId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpRtTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpRtRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpRtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
				if (StorageTmp->mtpRtTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpRtTable_old = mtpRtTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpRtTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpRtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpRtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpRtTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpRtRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpRtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpRtRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpRtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpRtRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpRtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpRtRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpRtTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpRtRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpRtTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpRtRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpRtTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpRtTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpRtRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpRtRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpRtRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpRtTable_old) != NULL) {
				mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
				StorageTmp->mtpRtTable_rsvs = 0;
				StorageTmp->mtpRtTable_tsts = 0;
				StorageTmp->mtpRtTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpRtTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpRtTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpRtRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpRtTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpRtRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpRtTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpRtTable_del(StorageNew);
				mtpRtTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpRtTable_old) == NULL)
				break;
			if (--StorageTmp->mtpRtTable_rsvs == 0)
				mtpRtTable_destroy(&StorageTmp->mtpRtTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpRtTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpLsProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpLsProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsProfileRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpLsProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpLsProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpLsProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpLsProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpLsProfileTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->mtpLsProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpLsProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpLsProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpLsProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpLsProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
				if (StorageTmp->mtpLsProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpLsProfileTable_old = mtpLsProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpLsProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpLsProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpLsProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpLsProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpLsProfileRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpLsProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpLsProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpLsProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpLsProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpLsProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpLsProfileRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpLsProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpLsProfileRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpLsProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpLsProfileRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpLsProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpLsProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpLsProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpLsProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpLsProfileRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpLsProfileTable_old) != NULL) {
				mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
				StorageTmp->mtpLsProfileTable_rsvs = 0;
				StorageTmp->mtpLsProfileTable_tsts = 0;
				StorageTmp->mtpLsProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpLsProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpLsProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpLsProfileRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpLsProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpLsProfileRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpLsProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpLsProfileTable_del(StorageNew);
				mtpLsProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpLsProfileTable_old) == NULL)
				break;
			if (--StorageTmp->mtpLsProfileTable_rsvs == 0)
				mtpLsProfileTable_destroy(&StorageTmp->mtpLsProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpLsProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpLsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpLsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpLsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpLsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpLsRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpLsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpLsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpLsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpLsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpLsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpLsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpLsTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpLsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpLsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpLsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
				if (StorageTmp->mtpLsTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpLsTable_old = mtpLsTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpLsTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpLsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpLsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpLsTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpLsRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpLsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpLsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpLsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpLsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpLsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpLsRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpLsTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpLsRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpLsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpLsRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpLsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpLsTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpLsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpLsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpLsRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpLsTable_old) != NULL) {
				mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
				StorageTmp->mtpLsTable_rsvs = 0;
				StorageTmp->mtpLsTable_tsts = 0;
				StorageTmp->mtpLsTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpLsTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpLsTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpLsRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpLsTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpLsRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpLsTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpLsTable_del(StorageNew);
				mtpLsTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpLsTable_old) == NULL)
				break;
			if (--StorageTmp->mtpLsTable_rsvs == 0)
				mtpLsTable_destroy(&StorageTmp->mtpLsTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpLsTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL3ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlL3ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL3ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSlL3ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL3ProfileRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL3ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL3ProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSlL3ProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSlL3ProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlL3ProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSlL3ProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSlL3ProfileTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->mtpSlL3ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlL3ProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSlL3ProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlL3ProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlL3ProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
				if (StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old = mtpSlL3ProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSlL3ProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlL3ProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlL3ProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSlL3ProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSlL3ProfileRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSlL3ProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSlL3ProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSlL3ProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSlL3ProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSlL3ProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSlL3ProfileRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSlL3ProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSlL3ProfileRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSlL3ProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSlL3ProfileRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSlL3ProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSlL3ProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSlL3ProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSlL3ProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSlL3ProfileRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) != NULL) {
				mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
				StorageTmp->mtpSlL3ProfileTable_rsvs = 0;
				StorageTmp->mtpSlL3ProfileTable_tsts = 0;
				StorageTmp->mtpSlL3ProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSlL3ProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSlL3ProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSlL3ProfileRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSlL3ProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSlL3ProfileRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSlL3ProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSlL3ProfileTable_del(StorageNew);
				mtpSlL3ProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSlL3ProfileTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSlL3ProfileTable_rsvs == 0)
				mtpSlL3ProfileTable_destroy(&StorageTmp->mtpSlL3ProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSlL3ProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlL2ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlL2ProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlL2ProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSlL2ProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlL2ProfileRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlL2ProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlL2ProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSlL2ProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlL2ProfileTransmissionRate */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSlL2ProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlL2ProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSlL2ProfileTransmissionRate */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlL2ProfileTransmissionRate: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			switch ((long) *vp->val.integer) {
			case MTPSLL2PROFILETRANSMISSIONRATE_KBITS4POINT8:
			case MTPSLL2PROFILETRANSMISSIONRATE_KBITS56:
			case MTPSLL2PROFILETRANSMISSIONRATE_KBITS64:
			case MTPSLL2PROFILETRANSMISSIONRATE_KBITS1544:
			case MTPSLL2PROFILETRANSMISSIONRATE_KBITS2048:
				break;
			default:
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlL2ProfileTransmissionRate: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSlL2ProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSlL2ProfileTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->mtpSlL2ProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSlL2ProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			StorageNew->mtpSlL2ProfileTransmissionRate = (long) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSlL2ProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlL2ProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlL2ProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
				if (StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old = mtpSlL2ProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSlL2ProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlL2ProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlL2ProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSlL2ProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSlL2ProfileRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSlL2ProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSlL2ProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSlL2ProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSlL2ProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSlL2ProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSlL2ProfileRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSlL2ProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSlL2ProfileRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSlL2ProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSlL2ProfileRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSlL2ProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSlL2ProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSlL2ProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSlL2ProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSlL2ProfileRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) != NULL) {
				mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
				StorageTmp->mtpSlL2ProfileTable_rsvs = 0;
				StorageTmp->mtpSlL2ProfileTable_tsts = 0;
				StorageTmp->mtpSlL2ProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSlL2ProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSlL2ProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSlL2ProfileRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSlL2ProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSlL2ProfileRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSlL2ProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSlL2ProfileTable_del(StorageNew);
				mtpSlL2ProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSlL2ProfileTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSlL2ProfileTable_rsvs == 0)
				mtpSlL2ProfileTable_destroy(&StorageTmp->mtpSlL2ProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSlL2ProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpLsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpLsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpLsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSlId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..16 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 16)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSlTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSlTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSlTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
				if (StorageTmp->mtpSlTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSlTable_old = mtpSlTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSlTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSlTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSlRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSlTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSlRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSlTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSlRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSlTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSlRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSlTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSlRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSlTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSlRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSlTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSlTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSlRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSlRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSlRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSlTable_old) != NULL) {
				mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
				StorageTmp->mtpSlTable_rsvs = 0;
				StorageTmp->mtpSlTable_tsts = 0;
				StorageTmp->mtpSlTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSlTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSlTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSlRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSlTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSlRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSlTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSlTable_del(StorageNew);
				mtpSlTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSlTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSlTable_rsvs == 0)
				mtpSlTable_destroy(&StorageTmp->mtpSlTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSlTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdlListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlSdlListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdlListTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSlSdlListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdlListRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlSdlListTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdlListRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpLsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlSdlListId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpLsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpLsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSlId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..16 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 16)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSlSdlListId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlSdlListId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSlSdlListTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSlSdlListTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdlListId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSlSdlListTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlSdlListRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlSdlListTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSlSdlListTable_old) == NULL)
				if (StorageTmp->mtpSlSdlListTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSlSdlListTable_old = mtpSlSdlListTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSlSdlListTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlSdlListTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlSdlListTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSlSdlListTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSlSdlListRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSlSdlListTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSlSdlListRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSlSdlListTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSlSdlListRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSlSdlListTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSlSdlListRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSlSdlListTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSlSdlListRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSlSdlListTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSlSdlListRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSlSdlListTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSlSdlListTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSlSdlListRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSlSdlListRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSlSdlListRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSlSdlListTable_old) != NULL) {
				mtpSlSdlListTable_destroy(&StorageTmp->mtpSlSdlListTable_old);
				StorageTmp->mtpSlSdlListTable_rsvs = 0;
				StorageTmp->mtpSlSdlListTable_tsts = 0;
				StorageTmp->mtpSlSdlListTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSlSdlListTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSlSdlListTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSlSdlListRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSlSdlListTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSlSdlListRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSlSdlListTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSlSdlListTable_del(StorageNew);
				mtpSlSdlListTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSlSdlListTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSlSdlListTable_rsvs == 0)
				mtpSlSdlListTable_destroy(&StorageTmp->mtpSlSdlListTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSlSdlListTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSlSdtListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSlSdtListRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSlSdtListTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSlSdtListTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSlSdtListRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSlSdtListTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSlSdtListRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpLsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSlSdtListId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpLsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpLsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSlId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..16 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 16)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSlSdtListId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlSdtListId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSlSdtListTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSlSdtListTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpLsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSlSdtListId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSlSdtListTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSlSdtListRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSlSdtListTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSlSdtListTable_old) == NULL)
				if (StorageTmp->mtpSlSdtListTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSlSdtListTable_old = mtpSlSdtListTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSlSdtListTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSlSdtListTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSlSdtListTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSlSdtListTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSlSdtListRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSlSdtListTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSlSdtListRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSlSdtListTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSlSdtListRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSlSdtListTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSlSdtListRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSlSdtListTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSlSdtListRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSlSdtListTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSlSdtListRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSlSdtListTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSlSdtListTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSlSdtListRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSlSdtListRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSlSdtListRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSlSdtListTable_old) != NULL) {
				mtpSlSdtListTable_destroy(&StorageTmp->mtpSlSdtListTable_old);
				StorageTmp->mtpSlSdtListTable_rsvs = 0;
				StorageTmp->mtpSlSdtListTable_tsts = 0;
				StorageTmp->mtpSlSdtListTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSlSdtListTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSlSdtListTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSlSdtListRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSlSdtListTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSlSdtListRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSlSdtListTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSlSdtListTable_del(StorageNew);
				mtpSlSdtListTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSlSdtListTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSlSdtListTable_rsvs == 0)
				mtpSlSdtListTable_destroy(&StorageTmp->mtpSlSdtListTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSlSdtListTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpNbRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpNbRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpNbTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpNbTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpNbRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpNbTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpNbRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSdtProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSdtProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpNbTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpNbTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpNbTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpNbRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpNbTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpNbTable_old) == NULL)
				if (StorageTmp->mtpNbTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpNbTable_old = mtpNbTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpNbTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpNbTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpNbTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpNbTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpNbRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpNbTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpNbRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpNbTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpNbRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpNbTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpNbRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in 
		   the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpNbTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpNbRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpNbTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpNbRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpNbTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpNbTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpNbRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpNbRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpNbRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpNbTable_old) != NULL) {
				mtpNbTable_destroy(&StorageTmp->mtpNbTable_old);
				StorageTmp->mtpNbTable_rsvs = 0;
				StorageTmp->mtpNbTable_tsts = 0;
				StorageTmp->mtpNbTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpNbTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpNbTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpNbRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpNbTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpNbRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpNbTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpNbTable_del(StorageNew);
				mtpNbTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpNbTable_old) == NULL)
				break;
			if (--StorageTmp->mtpNbTable_rsvs == 0)
				mtpNbTable_destroy(&StorageTmp->mtpNbTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpNbTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSaalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSaalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSaalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSaalTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSaalRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSaalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSaalRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSdtProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSdtProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSaalTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSaalTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSaalTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSaalRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSaalTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
				if (StorageTmp->mtpSaalTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSaalTable_old = mtpSaalTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSaalTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSaalTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSaalTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSaalTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSaalRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSaalTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSaalRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSaalTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSaalRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSaalTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSaalRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSaalTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSaalRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSaalTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSaalRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSaalTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSaalTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSaalRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSaalRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSaalRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSaalTable_old) != NULL) {
				mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
				StorageTmp->mtpSaalTable_rsvs = 0;
				StorageTmp->mtpSaalTable_tsts = 0;
				StorageTmp->mtpSaalTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSaalTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSaalTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSaalRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSaalTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSaalRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSaalTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSaalTable_del(StorageNew);
				mtpSaalTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSaalTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSaalTable_rsvs == 0)
				mtpSaalTable_destroy(&StorageTmp->mtpSaalTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSaalTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2paRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM2paRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2paTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpM2paTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2paRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2paTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2paRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSdtProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSdtProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSdtProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpM2paTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpM2paTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->mtpSdtProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSdtProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpM2paTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM2paRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM2paTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
				if (StorageTmp->mtpM2paTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpM2paTable_old = mtpM2paTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpM2paTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM2paTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM2paTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpM2paTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpM2paRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpM2paTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpM2paRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpM2paTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpM2paRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpM2paTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpM2paRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpM2paTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpM2paRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpM2paTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpM2paRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpM2paTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpM2paTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpM2paRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpM2paRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpM2paRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpM2paTable_old) != NULL) {
				mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
				StorageTmp->mtpM2paTable_rsvs = 0;
				StorageTmp->mtpM2paTable_tsts = 0;
				StorageTmp->mtpM2paTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpM2paTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpM2paTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpM2paRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpM2paTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpM2paRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpM2paTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpM2paTable_del(StorageNew);
				mtpM2paTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpM2paTable_old) == NULL)
				break;
			if (--StorageTmp->mtpM2paTable_rsvs == 0)
				mtpM2paTable_destroy(&StorageTmp->mtpM2paTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpM2paTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSdtRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdtTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSdtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdtRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdtTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdtRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSdtId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSdtId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSdtId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSdtTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSdtTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSdtId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSdtTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSdtRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSdtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
				if (StorageTmp->mtpSdtTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSdtTable_old = mtpSdtTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSdtTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSdtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSdtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSdtTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSdtRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSdtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSdtRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSdtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSdtRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSdtTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSdtRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSdtTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSdtRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSdtTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSdtRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSdtTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSdtTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSdtRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSdtRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSdtRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSdtTable_old) != NULL) {
				mtpSdtTable_destroy(&StorageTmp->mtpSdtTable_old);
				StorageTmp->mtpSdtTable_rsvs = 0;
				StorageTmp->mtpSdtTable_tsts = 0;
				StorageTmp->mtpSdtTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSdtTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSdtTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSdtRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSdtTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSdtRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSdtTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSdtTable_del(StorageNew);
				mtpSdtTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSdtTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSdtTable_rsvs == 0)
				mtpSdtTable_destroy(&StorageTmp->mtpSdtTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSdtTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSdlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSdlRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSdlTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSdlTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSdlRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSdlTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSdlRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpMsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSdlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpMsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpMsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSdlId */
			/* Note: ranges 4..4 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 4)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSdlId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSdlTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSdlTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpMsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpSdlId, vp->val.string, vp->val_len);
			StorageNew->mtpSdlIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSdlTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSdlRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSdlTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
				if (StorageTmp->mtpSdlTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSdlTable_old = mtpSdlTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSdlTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSdlTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSdlTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSdlTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSdlRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSdlTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSdlRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSdlTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSdlRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSdlTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSdlRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSdlTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSdlRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSdlTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSdlRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSdlTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSdlTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSdlRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSdlRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSdlRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSdlTable_old) != NULL) {
				mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
				StorageTmp->mtpSdlTable_rsvs = 0;
				StorageTmp->mtpSdlTable_tsts = 0;
				StorageTmp->mtpSdlTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSdlTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSdlTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSdlRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSdlTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSdlRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSdlTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSdlTable_del(StorageNew);
				mtpSdlTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSdlTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSdlTable_rsvs == 0)
				mtpSdlTable_destroy(&StorageTmp->mtpSdlTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSdlTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSctpProfileRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpProfileTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSctpProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpProfileRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpProfileTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpProfileRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSctpProfileId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSctpProfileId */
			/* Note: ranges 1..32 */
			if (vp->val_len > SPRINT_MAX_LEN || ((1 > vp->val_len || vp->val_len > 32))) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSctpProfileId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSctpProfileTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSctpProfileTable_rsvs = 1;
			vp = vars;
			memdup((void *) &StorageNew->mtpSctpProfileId, vp->val.string, vp->val_len);
			StorageNew->mtpSctpProfileIdLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSctpProfileTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSctpProfileRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSctpProfileTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
				if (StorageTmp->mtpSctpProfileTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSctpProfileTable_old = mtpSctpProfileTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSctpProfileTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSctpProfileTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSctpProfileTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSctpProfileTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSctpProfileRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSctpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSctpProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSctpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSctpProfileRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSctpProfileTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSctpProfileRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSctpProfileTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSctpProfileRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSctpProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSctpProfileRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSctpProfileTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSctpProfileTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSctpProfileRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSctpProfileRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSctpProfileRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) != NULL) {
				mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
				StorageTmp->mtpSctpProfileTable_rsvs = 0;
				StorageTmp->mtpSctpProfileTable_tsts = 0;
				StorageTmp->mtpSctpProfileTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSctpProfileTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSctpProfileTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSctpProfileRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSctpProfileTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSctpProfileRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSctpProfileTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSctpProfileTable_del(StorageNew);
				mtpSctpProfileTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSctpProfileTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSctpProfileTable_rsvs == 0)
				mtpSctpProfileTable_destroy(&StorageTmp->mtpSctpProfileTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSctpProfileTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSctpRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSctpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSctpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSctpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSctpTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSctpTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSctpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSctpTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSctpRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSctpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
				if (StorageTmp->mtpSctpTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSctpTable_old = mtpSctpTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSctpTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSctpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSctpTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSctpTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSctpRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSctpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSctpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSctpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSctpRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSctpTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSctpRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSctpTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSctpRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSctpTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSctpRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSctpTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSctpTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSctpRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSctpRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSctpRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSctpTable_old) != NULL) {
				mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
				StorageTmp->mtpSctpTable_rsvs = 0;
				StorageTmp->mtpSctpTable_tsts = 0;
				StorageTmp->mtpSctpTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSctpTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSctpTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSctpRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSctpTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSctpRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSctpTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSctpTable_del(StorageNew);
				mtpSctpTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSctpTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSctpTable_rsvs == 0)
				mtpSctpTable_destroy(&StorageTmp->mtpSctpTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSctpTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpLocalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSctpLocalRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpLocalTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSctpLocalTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpLocalRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpLocalTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpLocalRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSctpLocalId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSctpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSctpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSctpLocalId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSctpLocalId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSctpLocalTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSctpLocalTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSctpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSctpLocalId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSctpLocalTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSctpLocalRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSctpLocalTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSctpLocalTable_old) == NULL)
				if (StorageTmp->mtpSctpLocalTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSctpLocalTable_old = mtpSctpLocalTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSctpLocalTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSctpLocalTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSctpLocalTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSctpLocalTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSctpLocalRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSctpLocalTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSctpLocalRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSctpLocalTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSctpLocalRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSctpLocalTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSctpLocalRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSctpLocalTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSctpLocalRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSctpLocalTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSctpLocalRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSctpLocalTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSctpLocalTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSctpLocalRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSctpLocalRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSctpLocalRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSctpLocalTable_old) != NULL) {
				mtpSctpLocalTable_destroy(&StorageTmp->mtpSctpLocalTable_old);
				StorageTmp->mtpSctpLocalTable_rsvs = 0;
				StorageTmp->mtpSctpLocalTable_tsts = 0;
				StorageTmp->mtpSctpLocalTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSctpLocalTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSctpLocalTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSctpLocalRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSctpLocalTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSctpLocalRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSctpLocalTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSctpLocalTable_del(StorageNew);
				mtpSctpLocalTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSctpLocalTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSctpLocalTable_rsvs == 0)
				mtpSctpLocalTable_destroy(&StorageTmp->mtpSctpLocalTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSctpLocalTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpSctpRemoteRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpSctpRemoteRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpSctpRemoteTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpSctpRemoteTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpSctpRemoteRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpSctpRemoteTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemoteRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpSctpRemoteRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpSctpRemoteId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSctpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSctpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpSctpRemoteId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSctpRemoteId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpSctpRemoteTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpSctpRemoteTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSctpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpSctpRemoteId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpSctpRemoteTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpSctpRemoteRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpSctpRemoteTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old) == NULL)
				if (StorageTmp->mtpSctpRemoteTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old = mtpSctpRemoteTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpSctpRemoteTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpSctpRemoteTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpSctpRemoteTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpSctpRemoteTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpSctpRemoteRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpSctpRemoteTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSctpRemoteRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSctpRemoteTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpSctpRemoteRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpSctpRemoteTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpSctpRemoteRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpSctpRemoteTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpSctpRemoteRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpSctpRemoteTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpSctpRemoteRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpSctpRemoteTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpSctpRemoteTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpSctpRemoteRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpSctpRemoteRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpSctpRemoteRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old) != NULL) {
				mtpSctpRemoteTable_destroy(&StorageTmp->mtpSctpRemoteTable_old);
				StorageTmp->mtpSctpRemoteTable_rsvs = 0;
				StorageTmp->mtpSctpRemoteTable_tsts = 0;
				StorageTmp->mtpSctpRemoteTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpSctpRemoteTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpSctpRemoteTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpSctpRemoteRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpSctpRemoteTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpSctpRemoteRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpSctpRemoteTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpSctpRemoteTable_del(StorageNew);
				mtpSctpRemoteTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpSctpRemoteTable_old) == NULL)
				break;
			if (--StorageTmp->mtpSctpRemoteTable_rsvs == 0)
				mtpSctpRemoteTable_destroy(&StorageTmp->mtpSctpRemoteTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpSctpRemoteTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAspRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM2uaAspRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpM2uaAspTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAspRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAspRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSctpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSctpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpM2uaAspTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpM2uaAspTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSctpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpM2uaAspTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM2uaAspRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM2uaAspTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
				if (StorageTmp->mtpM2uaAspTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpM2uaAspTable_old = mtpM2uaAspTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpM2uaAspTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM2uaAspTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM2uaAspTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpM2uaAspTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpM2uaAspRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpM2uaAspTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpM2uaAspRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpM2uaAspTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpM2uaAspRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpM2uaAspTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpM2uaAspRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpM2uaAspTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpM2uaAspRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpM2uaAspTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpM2uaAspRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpM2uaAspTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpM2uaAspTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpM2uaAspRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpM2uaAspRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpM2uaAspRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) != NULL) {
				mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
				StorageTmp->mtpM2uaAspTable_rsvs = 0;
				StorageTmp->mtpM2uaAspTable_tsts = 0;
				StorageTmp->mtpM2uaAspTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpM2uaAspTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpM2uaAspTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpM2uaAspRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpM2uaAspTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpM2uaAspRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpM2uaAspTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpM2uaAspTable_del(StorageNew);
				mtpM2uaAspTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpM2uaAspTable_old) == NULL)
				break;
			if (--StorageTmp->mtpM2uaAspTable_rsvs == 0)
				mtpM2uaAspTable_destroy(&StorageTmp->mtpM2uaAspTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpM2uaAspTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM2uaAsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM2uaAsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM2uaAsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpM2uaAsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpM2uaAsRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM2uaAsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM2uaAsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpM3uaAsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSctpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSctpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpM3uaAsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpM3uaAsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpM2uaAsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpM2uaAsTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSctpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpM3uaAsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpM2uaAsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM2uaAsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM2uaAsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
				if (StorageTmp->mtpM2uaAsTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpM2uaAsTable_old = mtpM2uaAsTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpM2uaAsTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM2uaAsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM2uaAsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpM2uaAsTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpM2uaAsRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpM2uaAsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpM2uaAsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpM2uaAsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpM2uaAsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpM2uaAsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpM2uaAsRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpM2uaAsTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpM2uaAsRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpM2uaAsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpM2uaAsRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpM2uaAsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpM2uaAsTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpM2uaAsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpM2uaAsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpM2uaAsRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) != NULL) {
				mtpM2uaAsTable_destroy(&StorageTmp->mtpM2uaAsTable_old);
				StorageTmp->mtpM2uaAsTable_rsvs = 0;
				StorageTmp->mtpM2uaAsTable_tsts = 0;
				StorageTmp->mtpM2uaAsTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpM2uaAsTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpM2uaAsTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpM2uaAsRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpM2uaAsTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpM2uaAsRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpM2uaAsTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpM2uaAsTable_del(StorageNew);
				mtpM2uaAsTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpM2uaAsTable_old) == NULL)
				break;
			if (--StorageTmp->mtpM2uaAsTable_rsvs == 0)
				mtpM2uaAsTable_destroy(&StorageTmp->mtpM2uaAsTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpM2uaAsTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAspRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM3uaAspRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAspTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpM3uaAspTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAspRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAspTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAspRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSctpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSctpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpM3uaAspTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpM3uaAspTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSctpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpM3uaAspTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM3uaAspRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM3uaAspTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
				if (StorageTmp->mtpM3uaAspTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpM3uaAspTable_old = mtpM3uaAspTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpM3uaAspTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM3uaAspTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM3uaAspTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpM3uaAspTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpM3uaAspRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpM3uaAspTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpM3uaAspRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpM3uaAspTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpM3uaAspRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpM3uaAspTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpM3uaAspRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpM3uaAspTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpM3uaAspRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpM3uaAspTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpM3uaAspRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpM3uaAspTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpM3uaAspTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpM3uaAspRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpM3uaAspRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpM3uaAspRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) != NULL) {
				mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
				StorageTmp->mtpM3uaAspTable_rsvs = 0;
				StorageTmp->mtpM3uaAspTable_tsts = 0;
				StorageTmp->mtpM3uaAspTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpM3uaAspTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpM3uaAspTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpM3uaAspRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpM3uaAspTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpM3uaAspRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpM3uaAspTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpM3uaAspTable_del(StorageNew);
				mtpM3uaAspTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpM3uaAspTable_old) == NULL)
				break;
			if (--StorageTmp->mtpM3uaAspTable_rsvs == 0)
				mtpM3uaAspTable_destroy(&StorageTmp->mtpM3uaAspTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpM3uaAspTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpM3uaAsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpM3uaAsRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpM3uaAsTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpM3uaAsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpMIB", "write_mtpM3uaAsRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpM3uaAsTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpM3uaAsRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSctpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpM3uaAsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSctpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSctpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpM3uaAsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpM3uaAsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpM3uaAsTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpM3uaAsTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSctpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpM3uaAsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpM3uaAsTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpM3uaAsRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpM3uaAsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
				if (StorageTmp->mtpM3uaAsTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpM3uaAsTable_old = mtpM3uaAsTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpM3uaAsTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpM3uaAsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpM3uaAsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpM3uaAsTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpM3uaAsRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpM3uaAsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpM3uaAsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpM3uaAsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpM3uaAsRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpM3uaAsTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpM3uaAsRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpM3uaAsTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpM3uaAsRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpM3uaAsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpM3uaAsRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpM3uaAsTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destrution to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpM3uaAsTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpM3uaAsRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpM3uaAsRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpM3uaAsRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) != NULL) {
				mtpM3uaAsTable_destroy(&StorageTmp->mtpM3uaAsTable_old);
				StorageTmp->mtpM3uaAsTable_rsvs = 0;
				StorageTmp->mtpM3uaAsTable_tsts = 0;
				StorageTmp->mtpM3uaAsTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpM3uaAsTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpM3uaAsTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpM3uaAsRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpM3uaAsTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpM3uaAsRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpM3uaAsTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpM3uaAsTable_del(StorageNew);
				mtpM3uaAsTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpM3uaAsTable_old) == NULL)
				break;
			if (--StorageTmp->mtpM3uaAsTable_rsvs == 0)
				mtpM3uaAsTable_destroy(&StorageTmp->mtpM3uaAsTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpM3uaAsTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

void
send_mtpRestarting_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_mtpRestarting_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = mtpRestarting_oid;
	trap.val_len = sizeof(mtpRestarting_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_ss7OnOccEvent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_ss7OnOccEvent_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = ss7OnOccEvent_oid;
	trap.val_len = sizeof(ss7OnOccEvent_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_sdlEventLostSync_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_sdlEventLostSync_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdlEventLostSync_oid;
	trap.val_len = sizeof(sdlEventLostSync_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_sdlEventSuError_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_sdlEventSuError_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdlEventSuError_oid;
	trap.val_len = sizeof(sdlEventSuError_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_sdlEventTxFail_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_sdlEventTxFail_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdlEventTxFail_oid;
	trap.val_len = sizeof(sdlEventTxFail_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_sdlEventRxFail_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_sdlEventRxFail_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdlEventRxFail_oid;
	trap.val_len = sizeof(sdlEventRxFail_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_sdtEventLostSync_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_sdtEventLostSync_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdtEventLostSync_oid;
	trap.val_len = sizeof(sdtEventLostSync_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_sdtEventSuError_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_sdtEventSuError_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdtEventSuError_oid;
	trap.val_len = sizeof(sdtEventSuError_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_sdtEventTxFail_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_sdtEventTxFail_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdtEventTxFail_oid;
	trap.val_len = sizeof(sdtEventTxFail_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_sdtEventRxFail_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_sdtEventRxFail_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdtEventRxFail_oid;
	trap.val_len = sizeof(sdtEventRxFail_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_sdtEventCarrier_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_sdtEventCarrier_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = sdtEventCarrier_oid;
	trap.val_len = sizeof(sdtEventCarrier_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventFailureAllReasons_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventFailureAllReasons_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventFailureAllReasons_oid;
	trap.val_len = sizeof(slEventFailureAllReasons_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventFailureAbnormalBsnrFibr_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventFailureAbnormalBsnrFibr_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventFailureAbnormalBsnrFibr_oid;
	trap.val_len = sizeof(slEventFailureAbnormalBsnrFibr_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventFailureExcessiveDelayOfAck_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventFailureExcessiveDelayOfAck_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventFailureExcessiveDelayOfAck_oid;
	trap.val_len = sizeof(slEventFailureExcessiveDelayOfAck_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventFailureExcessiveErrorRate_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventFailureExcessiveErrorRate_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventFailureExcessiveErrorRate_oid;
	trap.val_len = sizeof(slEventFailureExcessiveErrorRate_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventFailureExcessiveDurationCongestion_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventFailureExcessiveDurationCongestion_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventFailureExcessiveDurationCongestion_oid;
	trap.val_len = sizeof(slEventFailureExcessiveDurationCongestion_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventLocalAutomaticChangeover_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventLocalAutomaticChangeover_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventLocalAutomaticChangeover_oid;
	trap.val_len = sizeof(slEventLocalAutomaticChangeover_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventLocalAutomaticChangeback_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventLocalAutomaticChangeback_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventLocalAutomaticChangeback_oid;
	trap.val_len = sizeof(slEventLocalAutomaticChangeback_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventRestoration_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventRestoration_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventRestoration_oid;
	trap.val_len = sizeof(slEventRestoration_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventRpoStartEvent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventRpoStartEvent_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventRpoStartEvent_oid;
	trap.val_len = sizeof(slEventRpoStartEvent_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventRpoStopEvent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventRpoStopEvent_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventRpoStopEvent_oid;
	trap.val_len = sizeof(slEventRpoStopEvent_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventLocalInhibitionStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventLocalInhibitionStart_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventLocalInhibitionStart_oid;
	trap.val_len = sizeof(slEventLocalInhibitionStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventLocalInhibitionStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventLocalInhibitionStop_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventLocalInhibitionStop_oid;
	trap.val_len = sizeof(slEventLocalInhibitionStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventRemoteInhibitionStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventRemoteInhibitionStart_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventRemoteInhibitionStart_oid;
	trap.val_len = sizeof(slEventRemoteInhibitionStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventRemoteInhibitionStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventRemoteInhibitionStop_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventRemoteInhibitionStop_oid;
	trap.val_len = sizeof(slEventRemoteInhibitionStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventCongestionStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventCongestionStart_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventCongestionStart_oid;
	trap.val_len = sizeof(slEventCongestionStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventCongestionStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventCongestionStop_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventCongestionStop_oid;
	trap.val_len = sizeof(slEventCongestionStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_slEventCongestionLoss_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_slEventCongestionLoss_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = slEventCongestionLoss_oid;
	trap.val_len = sizeof(slEventCongestionLoss_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_lkEventFailureStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_lkEventFailureStart_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lkEventFailureStart_oid;
	trap.val_len = sizeof(lkEventFailureStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_lkEventFailureStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_lkEventFailureStop_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lkEventFailureStop_oid;
	trap.val_len = sizeof(lkEventFailureStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_lkEventSendTFP_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_lkEventSendTFP_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lkEventSendTFP_oid;
	trap.val_len = sizeof(lkEventSendTFP_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_lkEventSendTFA_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_lkEventSendTFA_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = lkEventSendTFA_oid;
	trap.val_len = sizeof(lkEventSendTFA_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_rsEventUnavailableStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_rsEventUnavailableStart_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventUnavailableStart_oid;
	trap.val_len = sizeof(rsEventUnavailableStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_rsEventUnavailableStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_rsEventUnavailableStop_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventUnavailableStop_oid;
	trap.val_len = sizeof(rsEventUnavailableStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_rsEventAdjSpLinkSetChange_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_rsEventAdjSpLinkSetChange_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventAdjSpLinkSetChange_oid;
	trap.val_len = sizeof(rsEventAdjSpLinkSetChange_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_rsEventAdjSPInaccessibleStart_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_rsEventAdjSPInaccessibleStart_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventAdjSPInaccessibleStart_oid;
	trap.val_len = sizeof(rsEventAdjSPInaccessibleStart_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_rsEventAdjSpInaccessibleStop_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_rsEventAdjSpInaccessibleStop_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventAdjSpInaccessibleStop_oid;
	trap.val_len = sizeof(rsEventAdjSpInaccessibleStop_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_rsEventRecvTFC_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_rsEventRecvTFC_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = rsEventRecvTFC_oid;
	trap.val_len = sizeof(rsEventRecvTFC_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_spEventMsuDiscard_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_spEventMsuDiscard_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = spEventMsuDiscard_oid;
	trap.val_len = sizeof(spEventMsuDiscard_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_spEventUpuSent_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_spEventUpuSent_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = spEventUpuSent_oid;
	trap.val_len = sizeof(spEventUpuSent_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

void
send_spEventUpuRecv_v2trap(struct variable_list *vars)
{
	struct variable_list trap;

	DEBUGMSGTL(("mtpMIB", "send_spEventUpuRecv_v2trap: sending trap...  "));
	trap.next_variable = vars;
	trap.name = snmpTrapOID_oid;
	trap.name_length = sizeof(snmpTrapOID_oid) / sizeof(oid);
	trap.type = ASN_OBJECT_ID;
	trap.val.objid = spEventUpuRecv_oid;
	trap.val_len = sizeof(spEventUpuRecv_oid);
	trap.index = 0;
	send_v2trap(&trap);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/**
 * @fn void mtpMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
mtpMIB_loop_handler(int sig)
{
	DEBUGMSGTL(("mtpMIB", "mtpMIB_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (mtpMIBold_signal_handler != NULL)
		(*mtpMIBold_signal_handler) (sig);
	DEBUGMSGTL(("mtpMIB", "done.\n"));
}

/**
 * @fn void mtpMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
mtpMIB_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("mtpMIB", "mtpMIB_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("mtpMIB", "done.\n"));
	return;
}
