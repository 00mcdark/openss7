/*****************************************************************************

 @(#) $RCSfile: mtpOmMIB.c,v $ $Name:  $($Revision: 1.1.2.2 $) $Date: 2010-11-28 14:22:14 $

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2011  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2010-11-28 14:22:14 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: mtpOmMIB.c,v $
 Revision 1.1.2.2  2010-11-28 14:22:14  brian
 - remove #ident, protect _XOPEN_SOURCE

 Revision 1.1.2.1  2009-06-21 11:42:34  brian
 - added files to new distro

 Revision 0.9.2.13  2009-02-18 20:18:51  brian
 - updated agents

 Revision 0.9.2.12  2009-01-19 13:31:47  brian
 - updating standalone agents

 Revision 0.9.2.11  2009-01-16 20:44:57  brian
 - updating mibs and agents

 Revision 0.9.2.10  2009-01-14 14:30:04  brian
 - working up agents

 Revision 0.9.2.9  2009-01-10 17:09:18  brian
 - updated agents

 Revision 0.9.2.8  2009-01-04 13:16:03  brian
 - updated agents

 Revision 0.9.2.7  2009-01-03 10:51:04  brian
 - updated agent

 Revision 0.9.2.6  2009-01-02 15:46:42  brian
 - corrections

 Revision 0.9.2.5  2009-01-02 15:04:13  brian
 - updated agents

 Revision 0.9.2.4  2008-12-31 16:04:46  brian
 - updated mibs

 Revision 0.9.2.3  2008-12-27 15:29:46  brian
 - split MTP and MTP OM mib

 Revision 0.9.2.2  2008-12-24 13:08:25  brian
 - building ss7confd

 *****************************************************************************/

static char const ident[] = "$RCSfile: mtpOmMIB.c,v $ $Name:  $($Revision: 1.1.2.2 $) $Date: 2010-11-28 14:22:14 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "mtpOmMIB.h"
#undef MASTER
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "mtpOmMIB";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int mtpOmMIB_refresh = 1;
volatile int mtpOmSpTable_refresh = 1;
volatile int mtpOmSpInt5minTable_refresh = 1;
volatile int mtpOmSpInt15minTable_refresh = 1;
volatile int mtpOmSpSiTable_refresh = 1;
volatile int mtpOmSpSiInt5minTable_refresh = 1;
volatile int mtpOmSpSiInt15minTable_refresh = 1;
volatile int mtpOmSpStudyTable_refresh = 1;
volatile int mtpOmSpStudyInt5minTable_refresh = 1;
volatile int mtpOmSpStudyInt15minTable_refresh = 1;
volatile int mtpOmSpStudyMapTable_refresh = 1;
volatile int mtpOmRsTable_refresh = 1;
volatile int mtpOmRsInt5minTable_refresh = 1;
volatile int mtpOmRsInt15minTable_refresh = 1;
volatile int mtpOmRsSiTable_refresh = 1;
volatile int mtpOmRsSiInt5minTable_refresh = 1;
volatile int mtpOmRsSiInt15minTable_refresh = 1;
volatile int mtpOmLsTable_refresh = 1;
volatile int mtpOmLsInt5minTable_refresh = 1;
volatile int mtpOmLsInt15minTable_refresh = 1;
volatile int mtpOmSlStatsTable_refresh = 1;
volatile int mtpOmSlL3Table_refresh = 1;
volatile int mtpOmSlL3Int5minTable_refresh = 1;
volatile int mtpOmSlL3Int15minTable_refresh = 1;
volatile int mtpOmSlL2Table_refresh = 1;
volatile int mtpOmSlL2Int5minTable_refresh = 1;
volatile int mtpOmSlL2Int15minTable_refresh = 1;
volatile int mtpOmSdtStatsTable_refresh = 1;
volatile int mtpOmSdlStatsTable_refresh = 1;

/*
 * mtpOmMIB_variables_oid: object identifier for mtpOmMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid mtpOmMIB_variables_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1 };
oid mtpOmSpSiTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 1, 4, 1 };
oid mtpOmSpStudyTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 1, 7, 1 };
oid mtpOmSpStudyMapTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 1, 10, 1 };
oid mtpOmRsSiTable_variables_oid[15] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 2, 4, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */

/*
 * Oids accessible only for notify defined in this MIB.
 */

/*
 * Other oids defined in this MIB.
 */
oid mtpOmGeneralCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 2, 1, 1 };
oid mtpOmObjectGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 2, 2, 1 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 mtpOmMIB_variables: tree for mtpOmMIB
 * This variable defines function callbacks and type return information for the mtpOmMIB mib section
 */
struct variable7 mtpOmMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   MTPOMSPVALIDINTERVALS  1
	{(u_char) MTPOMSPVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 1}},
#define   MTPOMSPTIMEDISCONTINUITY  2
	{(u_char) MTPOMSPTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 2}},
#define   MTPOMSPDISCARDEDMSUS  3
	{(u_char) MTPOMSPDISCARDEDMSUS, ASN_COUNTER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 3}},
#define   MTPOMSPRECEIVEDTFCSTATUS0  4
	{(u_char) MTPOMSPRECEIVEDTFCSTATUS0, ASN_COUNTER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 4}},
#define   MTPOMSPRECEIVEDTFCSTATUS1  5
	{(u_char) MTPOMSPRECEIVEDTFCSTATUS1, ASN_COUNTER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 5}},
#define   MTPOMSPRECEIVEDTFCSTATUS2  6
	{(u_char) MTPOMSPRECEIVEDTFCSTATUS2, ASN_COUNTER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 6}},
#define   MTPOMSPOCTETSXFERRED  7
	{(u_char) MTPOMSPOCTETSXFERRED, ASN_COUNTER, RONLY, var_mtpOmSpTable, 6, {1, 1, 1, 1, 1, 7}},
#define   MTPOMSPINT5MINTIMESTAMP  8
	{(u_char) MTPOMSPINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 2}},
#define   MTPOMSPINT5MINDISCARDEDMSUS  9
	{(u_char) MTPOMSPINT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 3}},
#define   MTPOMSPINT5MINRECEIVEDTFCSTATUS0  10
	{(u_char) MTPOMSPINT5MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 4}},
#define   MTPOMSPINT5MINRECEIVEDTFCSTATUS1  11
	{(u_char) MTPOMSPINT5MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 5}},
#define   MTPOMSPINT5MINRECEIVEDTFCSTATUS2  12
	{(u_char) MTPOMSPINT5MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 6}},
#define   MTPOMSPINT5MINOCTETSXFERRED  13
	{(u_char) MTPOMSPINT5MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpOmSpInt5minTable, 6, {1, 1, 1, 2, 1, 7}},
#define   MTPOMSPINT15MINTIMESTAMP  14
	{(u_char) MTPOMSPINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 2}},
#define   MTPOMSPINT15MINDISCARDEDMSUS  15
	{(u_char) MTPOMSPINT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 3}},
#define   MTPOMSPINT15MINRECEIVEDTFCSTATUS0  16
	{(u_char) MTPOMSPINT15MINRECEIVEDTFCSTATUS0, ASN_GAUGE, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 4}},
#define   MTPOMSPINT15MINRECEIVEDTFCSTATUS1  17
	{(u_char) MTPOMSPINT15MINRECEIVEDTFCSTATUS1, ASN_GAUGE, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 5}},
#define   MTPOMSPINT15MINRECEIVEDTFCSTATUS2  18
	{(u_char) MTPOMSPINT15MINRECEIVEDTFCSTATUS2, ASN_GAUGE, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 6}},
#define   MTPOMSPINT15MINOCTETSXFERRED  19
	{(u_char) MTPOMSPINT15MINOCTETSXFERRED, ASN_GAUGE, RONLY, var_mtpOmSpInt15minTable, 6, {1, 1, 1, 3, 1, 7}},
#define   MTPOMSPSIVALIDINTERVALS  20
	{(u_char) MTPOMSPSIVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 2}},
#define   MTPOMSPSITIMEDISCONTINUITY  21
	{(u_char) MTPOMSPSITIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 3}},
#define   MTPOMSPSITRANSMITTEDUPUNAVAILABLE  22
	{(u_char) MTPOMSPSITRANSMITTEDUPUNAVAILABLE, ASN_COUNTER, RONLY, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 4}},
#define   MTPOMSPSIRECEIVEDUPUNAVAILABLE  23
	{(u_char) MTPOMSPSIRECEIVEDUPUNAVAILABLE, ASN_COUNTER, RONLY, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 5}},
#define   MTPOMSPSIHANDLEDOCTETSSIO  24
	{(u_char) MTPOMSPSIHANDLEDOCTETSSIO, ASN_COUNTER, RONLY, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 6}},
#define   MTPOMSPSISTATUS       25
	{(u_char) MTPOMSPSISTATUS, ASN_INTEGER, RWRITE, var_mtpOmSpSiTable, 6, {1, 1, 1, 4, 1, 7}},
#define   MTPOMSPSIINT5MINTIMESTAMP  26
	{(u_char) MTPOMSPSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 2}},
#define   MTPOMSPSIINT5MINTRANSMITTEDUPUNAVAILABLE  27
	{(u_char) MTPOMSPSIINT5MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 3}},
#define   MTPOMSPSIINT5MINRECEIVEDUPUNAVAILABLE  28
	{(u_char) MTPOMSPSIINT5MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 4}},
#define   MTPOMSPSIINT5MINHANDLEDOCTETSSIO  29
	{(u_char) MTPOMSPSIINT5MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpOmSpSiInt5minTable, 6, {1, 1, 1, 5, 1, 5}},
#define   MTPOMSPSIINT15MINTIMESTAMP  30
	{(u_char) MTPOMSPSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 2}},
#define   MTPOMSPSIINT15MINTRANSMITTEDUPUNAVAILABLE  31
	{(u_char) MTPOMSPSIINT15MINTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 3}},
#define   MTPOMSPSIINT15MINRECEIVEDUPUNAVAILABLE  32
	{(u_char) MTPOMSPSIINT15MINRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 4}},
#define   MTPOMSPSIINT15MINHANDLEDOCTETSSIO  33
	{(u_char) MTPOMSPSIINT15MINHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpOmSpSiInt15minTable, 6, {1, 1, 1, 6, 1, 5}},
#define   MTPOMSPSTUDYVALIDINTERVALS  34
	{(u_char) MTPOMSPSTUDYVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmSpStudyTable, 6, {1, 1, 1, 7, 1, 2}},
#define   MTPOMSPSTUDYTIMEDISCONTINUITY  35
	{(u_char) MTPOMSPSTUDYTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmSpStudyTable, 6, {1, 1, 1, 7, 1, 3}},
#define   MTPOMSPSTUDYHANDLEDOCTETSOPCDPCSIO  36
	{(u_char) MTPOMSPSTUDYHANDLEDOCTETSOPCDPCSIO, ASN_COUNTER, RONLY, var_mtpOmSpStudyTable, 6, {1, 1, 1, 7, 1, 4}},
#define   MTPOMSPSTUDYHANDLEDMSUSOPCDPCSIO  37
	{(u_char) MTPOMSPSTUDYHANDLEDMSUSOPCDPCSIO, ASN_COUNTER, RONLY, var_mtpOmSpStudyTable, 6, {1, 1, 1, 7, 1, 5}},
#define   MTPOMSPSTUDYSTATUS    38
	{(u_char) MTPOMSPSTUDYSTATUS, ASN_INTEGER, RWRITE, var_mtpOmSpStudyTable, 6, {1, 1, 1, 7, 1, 6}},
#define   MTPOMSPSTUDYINT5MINTIMESTAMP  39
	{(u_char) MTPOMSPSTUDYINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpStudyInt5minTable, 6, {1, 1, 1, 8, 1, 2}},
#define   MTPOMSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO  40
	{(u_char) MTPOMSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpOmSpStudyInt5minTable, 6, {1, 1, 1, 8, 1, 3}},
#define   MTPOMSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO  41
	{(u_char) MTPOMSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpOmSpStudyInt5minTable, 6, {1, 1, 1, 8, 1, 4}},
#define   MTPOMSPSTUDYINT15MINTIMESTAMP  42
	{(u_char) MTPOMSPSTUDYINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSpStudyInt15minTable, 6, {1, 1, 1, 9, 1, 2}},
#define   MTPOMSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO  43
	{(u_char) MTPOMSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpOmSpStudyInt15minTable, 6, {1, 1, 1, 9, 1, 3}},
#define   MTPOMSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO  44
	{(u_char) MTPOMSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpOmSpStudyInt15minTable, 6, {1, 1, 1, 9, 1, 4}},
#define   MTPOMSPSTUDYMAPSTATUS  45
	{(u_char) MTPOMSPSTUDYMAPSTATUS, ASN_INTEGER, RWRITE, var_mtpOmSpStudyMapTable, 6, {1, 1, 1, 10, 1, 3}},
#define   MTPOMRSVALIDINTERVALS  46
	{(u_char) MTPOMRSVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 1}},
#define   MTPOMRSTIMEDISCONTINUITY  47
	{(u_char) MTPOMRSTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 2}},
#define   MTPOMRSRECEIVEDOCTETSOPC  48
	{(u_char) MTPOMRSRECEIVEDOCTETSOPC, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 3}},
#define   MTPOMRSTRANSMITTEDOCTETSDPC  49
	{(u_char) MTPOMRSTRANSMITTEDOCTETSDPC, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 4}},
#define   MTPOMRSRECEIVEDMSUSOPC  50
	{(u_char) MTPOMRSRECEIVEDMSUSOPC, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 5}},
#define   MTPOMRSTRANSMITTEDMSUSDPC  51
	{(u_char) MTPOMRSTRANSMITTEDMSUSDPC, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 6}},
#define   MTPOMRSROUTESETUNAVAILABLE  52
	{(u_char) MTPOMRSROUTESETUNAVAILABLE, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 7}},
#define   MTPOMRSROUTESETUNAVAILABLEDURATION  53
	{(u_char) MTPOMRSROUTESETUNAVAILABLEDURATION, ASN_COUNTER, RONLY, var_mtpOmRsTable, 6, {1, 1, 2, 1, 1, 8}},
#define   MTPOMRSINT5MINTIMESTAMP  54
	{(u_char) MTPOMRSINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 2}},
#define   MTPOMRSINT5MINRECEIVEDOCTETSOPC  55
	{(u_char) MTPOMRSINT5MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 3}},
#define   MTPOMRSINT5MINTRANSMITTEDOCTETSDPC  56
	{(u_char) MTPOMRSINT5MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 4}},
#define   MTPOMRSINT5MINRECEIVEDMSUSOPC  57
	{(u_char) MTPOMRSINT5MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 5}},
#define   MTPOMRSINT5MINTRANSMITTEDMSUSDPC  58
	{(u_char) MTPOMRSINT5MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 6}},
#define   MTPOMRSINT5MINROUTESETUNAVAILABLE  59
	{(u_char) MTPOMRSINT5MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 7}},
#define   MTPOMRSINT5MINROUTESETUNAVAILABLEDURATION  60
	{(u_char) MTPOMRSINT5MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpOmRsInt5minTable, 6, {1, 1, 2, 2, 1, 8}},
#define   MTPOMRSINT15MINTIMESTAMP  61
	{(u_char) MTPOMRSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 2}},
#define   MTPOMRSINT15MINRECEIVEDOCTETSOPC  62
	{(u_char) MTPOMRSINT15MINRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 3}},
#define   MTPOMRSINT15MINTRANSMITTEDOCTETSDPC  63
	{(u_char) MTPOMRSINT15MINTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 4}},
#define   MTPOMRSINT15MINRECEIVEDMSUSOPC  64
	{(u_char) MTPOMRSINT15MINRECEIVEDMSUSOPC, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 5}},
#define   MTPOMRSINT15MINTRANSMITTEDMSUSDPC  65
	{(u_char) MTPOMRSINT15MINTRANSMITTEDMSUSDPC, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 6}},
#define   MTPOMRSINT15MINROUTESETUNAVAILABLE  66
	{(u_char) MTPOMRSINT15MINROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 7}},
#define   MTPOMRSINT15MINROUTESETUNAVAILABLEDURATION  67
	{(u_char) MTPOMRSINT15MINROUTESETUNAVAILABLEDURATION, ASN_GAUGE, RONLY, var_mtpOmRsInt15minTable, 6, {1, 1, 2, 3, 1, 8}},
#define   MTPOMRSSIVALIDINTERVALS  68
	{(u_char) MTPOMRSSIVALIDINTERVALS, ASN_INTEGER, RWRITE, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 2}},
#define   MTPOMRSSITIMEDISCONTINUITY  69
	{(u_char) MTPOMRSSITIMEDISCONTINUITY, ASN_TIMETICKS, RWRITE, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 3}},
#define   MTPOMRSSIRECEIVEDOCTETSOPCSIO  70
	{(u_char) MTPOMRSSIRECEIVEDOCTETSOPCSIO, ASN_COUNTER, RONLY, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 4}},
#define   MTPOMRSSITRANSMITTEDOCTETSDPCSIO  71
	{(u_char) MTPOMRSSITRANSMITTEDOCTETSDPCSIO, ASN_COUNTER, RONLY, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 5}},
#define   MTPOMRSSIRECEIVEDMSUSOPCSIO  72
	{(u_char) MTPOMRSSIRECEIVEDMSUSOPCSIO, ASN_COUNTER, RONLY, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 6}},
#define   MTPOMRSSITRANSMITTEDMSUSDPCSIO  73
	{(u_char) MTPOMRSSITRANSMITTEDMSUSDPCSIO, ASN_COUNTER, RONLY, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 7}},
#define   MTPOMRSSISTATUS       74
	{(u_char) MTPOMRSSISTATUS, ASN_INTEGER, RWRITE, var_mtpOmRsSiTable, 6, {1, 1, 2, 4, 1, 8}},
#define   MTPOMRSSIINT5MINTIMESTAMP  75
	{(u_char) MTPOMRSSIINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 2}},
#define   MTPOMRSSIINT5MINRECEIVEDOCTETSOPCSIO  76
	{(u_char) MTPOMRSSIINT5MINRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 3}},
#define   MTPOMRSSIINT5MINTRANSMITTEDOCTETSDPCSIO  77
	{(u_char) MTPOMRSSIINT5MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 4}},
#define   MTPOMRSSIINT5MINRECEIVEDMSUSOPCSIO  78
	{(u_char) MTPOMRSSIINT5MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 5}},
#define   MTPOMRSSIINT5MINTRANSMITTEDMSUSDPCSIO  79
	{(u_char) MTPOMRSSIINT5MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt5minTable, 6, {1, 1, 2, 5, 1, 6}},
#define   MTPOMRSSIINT15MINTIMESTAMP  80
	{(u_char) MTPOMRSSIINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 2}},
#define   MTPOMRSSIINT15MINRECEIVEDOCTETSOPCSIO  81
	{(u_char) MTPOMRSSIINT15MINRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 3}},
#define   MTPOMRSSIINT15MINTRANSMITTEDOCTETSDPCSIO  82
	{(u_char) MTPOMRSSIINT15MINTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 4}},
#define   MTPOMRSSIINT15MINRECEIVEDMSUSOPCSIO  83
	{(u_char) MTPOMRSSIINT15MINRECEIVEDMSUSOPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 5}},
#define   MTPOMRSSIINT15MINTRANSMITTEDMSUSDPCSIO  84
	{(u_char) MTPOMRSSIINT15MINTRANSMITTEDMSUSDPCSIO, ASN_GAUGE, RONLY, var_mtpOmRsSiInt15minTable, 6, {1, 1, 2, 6, 1, 6}},
#define   MTPOMLSVALIDINTERVALS  85
	{(u_char) MTPOMLSVALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmLsTable, 6, {1, 1, 3, 1, 1, 1}},
#define   MTPOMLSTIMEDISCONTINUITY  86
	{(u_char) MTPOMLSTIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmLsTable, 6, {1, 1, 3, 1, 1, 2}},
#define   MTPOMLSADJACENTINACCESSIBLEEVENTS  87
	{(u_char) MTPOMLSADJACENTINACCESSIBLEEVENTS, ASN_COUNTER, RONLY, var_mtpOmLsTable, 6, {1, 1, 3, 1, 1, 3}},
#define   MTPOMLSADJACENTINACCESSIBLEDURATION  88
	{(u_char) MTPOMLSADJACENTINACCESSIBLEDURATION, ASN_COUNTER, RONLY, var_mtpOmLsTable, 6, {1, 1, 3, 1, 1, 4}},
#define   MTPOMLSSLSUNAVAILABLE  89
	{(u_char) MTPOMLSSLSUNAVAILABLE, ASN_COUNTER, RONLY, var_mtpOmLsTable, 6, {1, 1, 3, 1, 1, 5}},
#define   MTPOMLSINT5MINTIMESTAMP  90
	{(u_char) MTPOMLSINT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmLsInt5minTable, 6, {1, 1, 3, 2, 1, 2}},
#define   MTPOMLSINT5MINADJACENTINACCESSIBLEEVENTS  91
	{(u_char) MTPOMLSINT5MINADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpOmLsInt5minTable, 6, {1, 1, 3, 2, 1, 3}},
#define   MTPOMLSINT5MINADJACENTINACCESSIBLEDURATION  92
	{(u_char) MTPOMLSINT5MINADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RONLY, var_mtpOmLsInt5minTable, 6, {1, 1, 3, 2, 1, 4}},
#define   MTPOMLSINT5MINSLSUNAVAILABLE  93
	{(u_char) MTPOMLSINT5MINSLSUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmLsInt5minTable, 6, {1, 1, 3, 2, 1, 5}},
#define   MTPOMLSINT15MINTIMESTAMP  94
	{(u_char) MTPOMLSINT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmLsInt15minTable, 6, {1, 1, 3, 3, 1, 2}},
#define   MTPOMLSINT15MINADJACENTINACCESSIBLEEVENTS  95
	{(u_char) MTPOMLSINT15MINADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpOmLsInt15minTable, 6, {1, 1, 3, 3, 1, 3}},
#define   MTPOMLSINT15MINADJACENTINACCESSIBLEDURATION  96
	{(u_char) MTPOMLSINT15MINADJACENTINACCESSIBLEDURATION, ASN_GAUGE, RONLY, var_mtpOmLsInt15minTable, 6, {1, 1, 3, 3, 1, 4}},
#define   MTPOMLSINT15MINSLSUNAVAILABLE  97
	{(u_char) MTPOMLSINT15MINSLSUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmLsInt15minTable, 6, {1, 1, 3, 3, 1, 5}},
#define   MTPOMSLSTATSDURINSERVICE  98
	{(u_char) MTPOMSLSTATSDURINSERVICE, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 1}},
#define   MTPOMSLSTATSFAILALIGNORPROVING  99
	{(u_char) MTPOMSLSTATSFAILALIGNORPROVING, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 2}},
#define   MTPOMSLSTATSNACKSRECEIVED  100
	{(u_char) MTPOMSLSTATSNACKSRECEIVED, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 3}},
#define   MTPOMSLSTATSDURUNAVAIL  101
	{(u_char) MTPOMSLSTATSDURUNAVAIL, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 4}},
#define   MTPOMSLSTATSDURUNAVAILFAILED  102
	{(u_char) MTPOMSLSTATSDURUNAVAILFAILED, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 5}},
#define   MTPOMSLSTATSDURUNAVAILRPO  103
	{(u_char) MTPOMSLSTATSDURUNAVAILRPO, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 6}},
#define   MTPOMSLSTATSSIBSSENT  104
	{(u_char) MTPOMSLSTATSSIBSSENT, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 7}},
#define   MTPOMSLSTATSTRANSIOSIFOCTETS  105
	{(u_char) MTPOMSLSTATSTRANSIOSIFOCTETS, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 8}},
#define   MTPOMSLSTATSRETRANSOCTETS  106
	{(u_char) MTPOMSLSTATSRETRANSOCTETS, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 9}},
#define   MTPOMSLSTATSTRANMSUS  107
	{(u_char) MTPOMSLSTATSTRANMSUS, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 10}},
#define   MTPOMSLSTATSRECVSIOSIFOCTETS  108
	{(u_char) MTPOMSLSTATSRECVSIOSIFOCTETS, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 11}},
#define   MTPOMSLSTATSRECVMSUS  109
	{(u_char) MTPOMSLSTATSRECVMSUS, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 12}},
#define   MTPOMSLSTATSCONGONSETIND0  110
	{(u_char) MTPOMSLSTATSCONGONSETIND0, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 13}},
#define   MTPOMSLSTATSCONGONSETIND1  111
	{(u_char) MTPOMSLSTATSCONGONSETIND1, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 14}},
#define   MTPOMSLSTATSCONGONSETIND2  112
	{(u_char) MTPOMSLSTATSCONGONSETIND2, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 15}},
#define   MTPOMSLSTATSCONGONSETIND3  113
	{(u_char) MTPOMSLSTATSCONGONSETIND3, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 16}},
#define   MTPOMSLSTATSDURCONGSTATUS0  114
	{(u_char) MTPOMSLSTATSDURCONGSTATUS0, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 17}},
#define   MTPOMSLSTATSDURCONGSTATUS1  115
	{(u_char) MTPOMSLSTATSDURCONGSTATUS1, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 18}},
#define   MTPOMSLSTATSDURCONGSTATUS2  116
	{(u_char) MTPOMSLSTATSDURCONGSTATUS2, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 19}},
#define   MTPOMSLSTATSDURCONGSTATUS3  117
	{(u_char) MTPOMSLSTATSDURCONGSTATUS3, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 20}},
#define   MTPOMSLSTATSCONGDISCDIND0  118
	{(u_char) MTPOMSLSTATSCONGDISCDIND0, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 21}},
#define   MTPOMSLSTATSCONGDISCDIND1  119
	{(u_char) MTPOMSLSTATSCONGDISCDIND1, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 22}},
#define   MTPOMSLSTATSCONGDISCDIND2  120
	{(u_char) MTPOMSLSTATSCONGDISCDIND2, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 23}},
#define   MTPOMSLSTATSCONGDISCDIND3  121
	{(u_char) MTPOMSLSTATSCONGDISCDIND3, ASN_COUNTER, RONLY, var_mtpOmSlStatsTable, 6, {1, 1, 4, 1, 1, 24}},
#define   MTPOMSLL3VALIDINTERVALS  122
	{(u_char) MTPOMSLL3VALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 1}},
#define   MTPOMSLL3TIMEDISCONTINUITY  123
	{(u_char) MTPOMSLL3TIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 2}},
#define   MTPOMSLL3SLUNAVAILABILITYDURATION  124
	{(u_char) MTPOMSLL3SLUNAVAILABILITYDURATION, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 3}},
#define   MTPOMSLL3SLLOCALINHIBITION  125
	{(u_char) MTPOMSLL3SLLOCALINHIBITION, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 4}},
#define   MTPOMSLL3SLREMOTEINHIBITION  126
	{(u_char) MTPOMSLL3SLREMOTEINHIBITION, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 5}},
#define   MTPOMSLL3SLFAILED     127
	{(u_char) MTPOMSLL3SLFAILED, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 6}},
#define   MTPOMSLL3SLREMOTEPROCOUTAGE  128
	{(u_char) MTPOMSLL3SLREMOTEPROCOUTAGE, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 7}},
#define   MTPOMSLL3LOCALMGMTINHIBIT  129
	{(u_char) MTPOMSLL3LOCALMGMTINHIBIT, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 8}},
#define   MTPOMSLL3LOCALMGMTUNINHIBIT  130
	{(u_char) MTPOMSLL3LOCALMGMTUNINHIBIT, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 9}},
#define   MTPOMSLL3LOCALBUSY    131
	{(u_char) MTPOMSLL3LOCALBUSY, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 10}},
#define   MTPOMSLL3SLCONGESTEDSTARTS  132
	{(u_char) MTPOMSLL3SLCONGESTEDSTARTS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 11}},
#define   MTPOMSLL3SLCONGESTEDDURATION  133
	{(u_char) MTPOMSLL3SLCONGESTEDDURATION, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 12}},
#define   MTPOMSLL3SLCONGESTIONSTOPS  134
	{(u_char) MTPOMSLL3SLCONGESTIONSTOPS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 13}},
#define   MTPOMSLL3DISCARDEDMSUS  135
	{(u_char) MTPOMSLL3DISCARDEDMSUS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 14}},
#define   MTPOMSLL3CONGESTIONEVENTSMSULOSS  136
	{(u_char) MTPOMSLL3CONGESTIONEVENTSMSULOSS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 15}},
#define   MTPOMSLL3CHANGEOVERS  137
	{(u_char) MTPOMSLL3CHANGEOVERS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 16}},
#define   MTPOMSLL3CHANGEBACKS  138
	{(u_char) MTPOMSLL3CHANGEBACKS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 17}},
#define   MTPOMSLL3RESTORATIONS  139
	{(u_char) MTPOMSLL3RESTORATIONS, ASN_COUNTER, RONLY, var_mtpOmSlL3Table, 6, {1, 1, 4, 2, 1, 18}},
#define   MTPOMSLL3INT5MINTIMESTAMP  140
	{(u_char) MTPOMSLL3INT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 2}},
#define   MTPOMSLL3INT5MINSLUNAVAILABILITYDURATION  141
	{(u_char) MTPOMSLL3INT5MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 3}},
#define   MTPOMSLL3INT5MINSLLOCALINHIBITION  142
	{(u_char) MTPOMSLL3INT5MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 4}},
#define   MTPOMSLL3INT5MINSLREMOTEINHIBITION  143
	{(u_char) MTPOMSLL3INT5MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 5}},
#define   MTPOMSLL3INT5MINSLFAILED  144
	{(u_char) MTPOMSLL3INT5MINSLFAILED, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 6}},
#define   MTPOMSLL3INT5MINSLREMOTEPROCOUTAGE  145
	{(u_char) MTPOMSLL3INT5MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 7}},
#define   MTPOMSLL3INT5MINLOCALMGMTINHIBIT  146
	{(u_char) MTPOMSLL3INT5MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 8}},
#define   MTPOMSLL3INT5MINLOCALMGMTUNINHIBIT  147
	{(u_char) MTPOMSLL3INT5MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 9}},
#define   MTPOMSLL3INT5MINLOCALBUSY  148
	{(u_char) MTPOMSLL3INT5MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 10}},
#define   MTPOMSLL3INT5MINSLCONGESTEDSTARTS  149
	{(u_char) MTPOMSLL3INT5MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 11}},
#define   MTPOMSLL3INT5MINSLCONGESTEDDURATION  150
	{(u_char) MTPOMSLL3INT5MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 12}},
#define   MTPOMSLL3INT5MINSLCONGESTIONSTOPS  151
	{(u_char) MTPOMSLL3INT5MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 13}},
#define   MTPOMSLL3INT5MINDISCARDEDMSUS  152
	{(u_char) MTPOMSLL3INT5MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 14}},
#define   MTPOMSLL3INT5MINCONGESTIONEVENTSMSULOSS  153
	{(u_char) MTPOMSLL3INT5MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 15}},
#define   MTPOMSLL3INT5MINCHANGEOVERS  154
	{(u_char) MTPOMSLL3INT5MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 16}},
#define   MTPOMSLL3INT5MINCHANGEBACKS  155
	{(u_char) MTPOMSLL3INT5MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 17}},
#define   MTPOMSLL3INT5MINRESTORATIONS  156
	{(u_char) MTPOMSLL3INT5MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int5minTable, 6, {1, 1, 4, 3, 1, 18}},
#define   MTPOMSLL3INT15MINTIMESTAMP  157
	{(u_char) MTPOMSLL3INT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 2}},
#define   MTPOMSLL3INT15MINSLUNAVAILABILITYDURATION  158
	{(u_char) MTPOMSLL3INT15MINSLUNAVAILABILITYDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 3}},
#define   MTPOMSLL3INT15MINSLLOCALINHIBITION  159
	{(u_char) MTPOMSLL3INT15MINSLLOCALINHIBITION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 4}},
#define   MTPOMSLL3INT15MINSLREMOTEINHIBITION  160
	{(u_char) MTPOMSLL3INT15MINSLREMOTEINHIBITION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 5}},
#define   MTPOMSLL3INT15MINSLFAILED  161
	{(u_char) MTPOMSLL3INT15MINSLFAILED, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 6}},
#define   MTPOMSLL3INT15MINSLREMOTEPROCOUTAGE  162
	{(u_char) MTPOMSLL3INT15MINSLREMOTEPROCOUTAGE, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 7}},
#define   MTPOMSLL3INT15MINLOCALMGMTINHIBIT  163
	{(u_char) MTPOMSLL3INT15MINLOCALMGMTINHIBIT, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 8}},
#define   MTPOMSLL3INT15MINLOCALMGMTUNINHIBIT  164
	{(u_char) MTPOMSLL3INT15MINLOCALMGMTUNINHIBIT, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 9}},
#define   MTPOMSLL3INT15MINLOCALBUSY  165
	{(u_char) MTPOMSLL3INT15MINLOCALBUSY, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 10}},
#define   MTPOMSLL3INT15MINSLCONGESTEDSTARTS  166
	{(u_char) MTPOMSLL3INT15MINSLCONGESTEDSTARTS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 11}},
#define   MTPOMSLL3INT15MINSLCONGESTEDDURATION  167
	{(u_char) MTPOMSLL3INT15MINSLCONGESTEDDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 12}},
#define   MTPOMSLL3INT15MINSLCONGESTIONSTOPS  168
	{(u_char) MTPOMSLL3INT15MINSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 13}},
#define   MTPOMSLL3INT15MINDISCARDEDMSUS  169
	{(u_char) MTPOMSLL3INT15MINDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 14}},
#define   MTPOMSLL3INT15MINCONGESTIONEVENTSMSULOSS  170
	{(u_char) MTPOMSLL3INT15MINCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 15}},
#define   MTPOMSLL3INT15MINCHANGEOVERS  171
	{(u_char) MTPOMSLL3INT15MINCHANGEOVERS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 16}},
#define   MTPOMSLL3INT15MINCHANGEBACKS  172
	{(u_char) MTPOMSLL3INT15MINCHANGEBACKS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 17}},
#define   MTPOMSLL3INT15MINRESTORATIONS  173
	{(u_char) MTPOMSLL3INT15MINRESTORATIONS, ASN_GAUGE, RONLY, var_mtpOmSlL3Int15minTable, 6, {1, 1, 4, 4, 1, 18}},
#define   MTPOMSLL2VALIDINTERVALS  174
	{(u_char) MTPOMSLL2VALIDINTERVALS, ASN_INTEGER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 1}},
#define   MTPOMSLL2TIMEDISCONTINUITY  175
	{(u_char) MTPOMSLL2TIMEDISCONTINUITY, ASN_TIMETICKS, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 2}},
#define   MTPOMSLL2SLINSERVICEDURATION  176
	{(u_char) MTPOMSLL2SLINSERVICEDURATION, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 3}},
#define   MTPOMSLL2SLALIGNMENT  177
	{(u_char) MTPOMSLL2SLALIGNMENT, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 4}},
#define   MTPOMSLL2SIGNUNITSRECEIVED  178
	{(u_char) MTPOMSLL2SIGNUNITSRECEIVED, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 5}},
#define   MTPOMSLL2NEGACKRECEIVED  179
	{(u_char) MTPOMSLL2NEGACKRECEIVED, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 6}},
#define   MTPOMSLL2TRANSMITTEDOCTETSSIFSIO  180
	{(u_char) MTPOMSLL2TRANSMITTEDOCTETSSIFSIO, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 7}},
#define   MTPOMSLL2RETRANSMITTEDOCTETS  181
	{(u_char) MTPOMSLL2RETRANSMITTEDOCTETS, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 8}},
#define   MTPOMSLL2TRANSMITTEDMSUS  182
	{(u_char) MTPOMSLL2TRANSMITTEDMSUS, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 9}},
#define   MTPOMSLL2RECEIVEDOCTETSSIFSIO  183
	{(u_char) MTPOMSLL2RECEIVEDOCTETSSIFSIO, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 10}},
#define   MTPOMSLL2RECEIVEDMSUS  184
	{(u_char) MTPOMSLL2RECEIVEDMSUS, ASN_COUNTER, RONLY, var_mtpOmSlL2Table, 6, {1, 1, 4, 5, 1, 11}},
#define   MTPOMSLL2INT5MINTIMESTAMP  185
	{(u_char) MTPOMSLL2INT5MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 2}},
#define   MTPOMSLL2INT5MINSLINSERVICEDURATION  186
	{(u_char) MTPOMSLL2INT5MINSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 3}},
#define   MTPOMSLL2INT5MINSLALIGNMENT  187
	{(u_char) MTPOMSLL2INT5MINSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 4}},
#define   MTPOMSLL2INT5MINSIGNUNITSRECEIVED  188
	{(u_char) MTPOMSLL2INT5MINSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 5}},
#define   MTPOMSLL2INT5MINNEGACKRECEIVED  189
	{(u_char) MTPOMSLL2INT5MINNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 6}},
#define   MTPOMSLL2INT5MINTRANSMITTEDOCTETSSIFSIO  190
	{(u_char) MTPOMSLL2INT5MINTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 7}},
#define   MTPOMSLL2INT5MINRETRANSMITTEDOCTETS  191
	{(u_char) MTPOMSLL2INT5MINRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 8}},
#define   MTPOMSLL2INT5MINTRANSMITTEDMSUS  192
	{(u_char) MTPOMSLL2INT5MINTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 9}},
#define   MTPOMSLL2INT5MINRECEIVEDOCTETSSIFSIO  193
	{(u_char) MTPOMSLL2INT5MINRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 10}},
#define   MTPOMSLL2INT5MINRECEIVEDMSUS  194
	{(u_char) MTPOMSLL2INT5MINRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int5minTable, 6, {1, 1, 4, 6, 1, 11}},
#define   MTPOMSLL2INT15MINTIMESTAMP  195
	{(u_char) MTPOMSLL2INT15MINTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 2}},
#define   MTPOMSLL2INT15MINSLINSERVICEDURATION  196
	{(u_char) MTPOMSLL2INT15MINSLINSERVICEDURATION, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 3}},
#define   MTPOMSLL2INT15MINSLALIGNMENT  197
	{(u_char) MTPOMSLL2INT15MINSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 4}},
#define   MTPOMSLL2INT15MINSIGNUNITSRECEIVED  198
	{(u_char) MTPOMSLL2INT15MINSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 5}},
#define   MTPOMSLL2INT15MINNEGACKRECEIVED  199
	{(u_char) MTPOMSLL2INT15MINNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 6}},
#define   MTPOMSLL2INT15MINTRANSMITTEDOCTETSSIFSIO  200
	{(u_char) MTPOMSLL2INT15MINTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 7}},
#define   MTPOMSLL2INT15MINRETRANSMITTEDOCTETS  201
	{(u_char) MTPOMSLL2INT15MINRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 8}},
#define   MTPOMSLL2INT15MINTRANSMITTEDMSUS  202
	{(u_char) MTPOMSLL2INT15MINTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 9}},
#define   MTPOMSLL2INT15MINRECEIVEDOCTETSSIFSIO  203
	{(u_char) MTPOMSLL2INT15MINRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 10}},
#define   MTPOMSLL2INT15MINRECEIVEDMSUS  204
	{(u_char) MTPOMSLL2INT15MINRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSlL2Int15minTable, 6, {1, 1, 4, 7, 1, 11}},
#define   MTPOMSDTSTATSTXBYTES  205
	{(u_char) MTPOMSDTSTATSTXBYTES, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 1}},
#define   MTPOMSDTSTATSTXSUS    206
	{(u_char) MTPOMSDTSTATSTXSUS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 2}},
#define   MTPOMSDTSTATSTXSUSREPEATED  207
	{(u_char) MTPOMSDTSTATSTXSUSREPEATED, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 3}},
#define   MTPOMSDTSTATSTXUNDERRUNS  208
	{(u_char) MTPOMSDTSTATSTXUNDERRUNS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 4}},
#define   MTPOMSDTSTATSTXABORTS  209
	{(u_char) MTPOMSDTSTATSTXABORTS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 5}},
#define   MTPOMSDTSTATSTXBUFFEROVERFLOWS  210
	{(u_char) MTPOMSDTSTATSTXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 6}},
#define   MTPOMSDTSTATSTXSUSINERROR  211
	{(u_char) MTPOMSDTSTATSTXSUSINERROR, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 7}},
#define   MTPOMSDTSTATSRXBYTES  212
	{(u_char) MTPOMSDTSTATSRXBYTES, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 8}},
#define   MTPOMSDTSTATSRXSUSCOMPRESSED  213
	{(u_char) MTPOMSDTSTATSRXSUSCOMPRESSED, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 9}},
#define   MTPOMSDTSTATSRXOVERRUNS  214
	{(u_char) MTPOMSDTSTATSRXOVERRUNS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 10}},
#define   MTPOMSDTSTATSRXABORTS  215
	{(u_char) MTPOMSDTSTATSRXABORTS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 11}},
#define   MTPOMSDTSTATSRXBUFFEROVERFLOWS  216
	{(u_char) MTPOMSDTSTATSRXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 12}},
#define   MTPOMSDTSTATSRXSUSINERROR  217
	{(u_char) MTPOMSDTSTATSRXSUSINERROR, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 13}},
#define   MTPOMSDTSTATSRXSYNCTRANSITIONS  218
	{(u_char) MTPOMSDTSTATSRXSYNCTRANSITIONS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 14}},
#define   MTPOMSDTSTATSRXBITSOCTETCOUNTED  219
	{(u_char) MTPOMSDTSTATSRXBITSOCTETCOUNTED, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 15}},
#define   MTPOMSDTSTATSRXCRCERRORS  220
	{(u_char) MTPOMSDTSTATSRXCRCERRORS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 16}},
#define   MTPOMSDTSTATSRXFRAMEERRORS  221
	{(u_char) MTPOMSDTSTATSRXFRAMEERRORS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 17}},
#define   MTPOMSDTSTATSRXFRAMEOVERFLOWS  222
	{(u_char) MTPOMSDTSTATSRXFRAMEOVERFLOWS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 18}},
#define   MTPOMSDTSTATSRXFRAMETOOLONG  223
	{(u_char) MTPOMSDTSTATSRXFRAMETOOLONG, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 19}},
#define   MTPOMSDTSTATSRXFRAMETOOSHORT  224
	{(u_char) MTPOMSDTSTATSRXFRAMETOOSHORT, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 20}},
#define   MTPOMSDTSTATSRXRESIDUEERRORS  225
	{(u_char) MTPOMSDTSTATSRXRESIDUEERRORS, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 21}},
#define   MTPOMSDTSTATSCARRIERCTSLOST  226
	{(u_char) MTPOMSDTSTATSCARRIERCTSLOST, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 22}},
#define   MTPOMSDTSTATSCARRIERDCDLOST  227
	{(u_char) MTPOMSDTSTATSCARRIERDCDLOST, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 23}},
#define   MTPOMSDTSTATSCARRIERLOST  228
	{(u_char) MTPOMSDTSTATSCARRIERLOST, ASN_COUNTER, RONLY, var_mtpOmSdtStatsTable, 6, {1, 1, 5, 1, 1, 24}},
#define   MTPOMSDLSTATSRXOCTETS  229
	{(u_char) MTPOMSDLSTATSRXOCTETS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 1}},
#define   MTPOMSDLSTATSTXOCTETS  230
	{(u_char) MTPOMSDLSTATSTXOCTETS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 2}},
#define   MTPOMSDLSTATSRXOVERRUNS  231
	{(u_char) MTPOMSDLSTATSRXOVERRUNS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 3}},
#define   MTPOMSDLSTATSTXUNDERRUNS  232
	{(u_char) MTPOMSDLSTATSTXUNDERRUNS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 4}},
#define   MTPOMSDLSTATSRXBUFFEROVERFLOWS  233
	{(u_char) MTPOMSDLSTATSRXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 5}},
#define   MTPOMSDLSTATSTXBUFFEROVERFLOWS  234
	{(u_char) MTPOMSDLSTATSTXBUFFEROVERFLOWS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 6}},
#define   MTPOMSDLSTATSLEADCTSLOST  235
	{(u_char) MTPOMSDLSTATSLEADCTSLOST, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 7}},
#define   MTPOMSDLSTATSLEADDCDLOST  236
	{(u_char) MTPOMSDLSTATSLEADDCDLOST, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 8}},
#define   MTPOMSDLSTATSCARRIERLOST  237
	{(u_char) MTPOMSDLSTATSCARRIERLOST, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 9}},
#define   MTPOMSDLSTATSBIPOLARVIOLATIONS  238
	{(u_char) MTPOMSDLSTATSBIPOLARVIOLATIONS, ASN_COUNTER, RONLY, var_mtpOmSdlStatsTable, 6, {1, 1, 6, 1, 1, 10}},
#define   MTPOM1STANDINTERVALACTIVATE  239
	{(u_char) MTPOM1STANDINTERVALACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 1}},
#define   MTPOM1STANDINTERVALDEACTIVATE  240
	{(u_char) MTPOM1STANDINTERVALDEACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 2}},
#define   MTPOM5MINACTIVATE     241
	{(u_char) MTPOM5MINACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 3}},
#define   MTPOM5MINDEAACTIVATE  242
	{(u_char) MTPOM5MINDEAACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 4}},
#define   MTPOM15MINACTIVATE    243
	{(u_char) MTPOM15MINACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 5}},
#define   MTPOM15MINDEAACTIVATE  244
	{(u_char) MTPOM15MINDEAACTIVATE, ASN_OBJECT_ID, RWRITE, var_mtpOmMIB, 3, {1, 2, 6}},
#define   MTPOMDISCONTINUITYTIME  245
	{(u_char) MTPOMDISCONTINUITYTIME, ASN_TIMETICKS, RONLY, var_mtpOmMIB, 3, {1, 2, 8}},
#define   MTPOMTIMESTAMP        246
	{(u_char) MTPOMTIMESTAMP, ASN_TIMETICKS, RONLY, var_mtpOmMIB, 3, {1, 2, 9}},
#define   MTPOM5MINMAXINTERVALS  247
	{(u_char) MTPOM5MINMAXINTERVALS, ASN_UNSIGNED, RWRITE, var_mtpOmMIB, 3, {1, 2, 10}},
#define   MTPOM15MINMAXINTERVALS  248
	{(u_char) MTPOM15MINMAXINTERVALS, ASN_UNSIGNED, RWRITE, var_mtpOmMIB, 3, {1, 2, 11}},
};

/* (L = length of the oidsuffix) */
struct mtpOmMIB_data *mtpOmMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *mtpOmSpTableStorage = NULL;
struct header_complex_index *mtpOmSpInt5minTableStorage = NULL;
struct header_complex_index *mtpOmSpInt15minTableStorage = NULL;
struct header_complex_index *mtpOmSpSiTableStorage = NULL;
struct header_complex_index *mtpOmSpSiInt5minTableStorage = NULL;
struct header_complex_index *mtpOmSpSiInt15minTableStorage = NULL;
struct header_complex_index *mtpOmSpStudyTableStorage = NULL;
struct header_complex_index *mtpOmSpStudyInt5minTableStorage = NULL;
struct header_complex_index *mtpOmSpStudyInt15minTableStorage = NULL;
struct header_complex_index *mtpOmSpStudyMapTableStorage = NULL;
struct header_complex_index *mtpOmRsTableStorage = NULL;
struct header_complex_index *mtpOmRsInt5minTableStorage = NULL;
struct header_complex_index *mtpOmRsInt15minTableStorage = NULL;
struct header_complex_index *mtpOmRsSiTableStorage = NULL;
struct header_complex_index *mtpOmRsSiInt5minTableStorage = NULL;
struct header_complex_index *mtpOmRsSiInt15minTableStorage = NULL;
struct header_complex_index *mtpOmLsTableStorage = NULL;
struct header_complex_index *mtpOmLsInt5minTableStorage = NULL;
struct header_complex_index *mtpOmLsInt15minTableStorage = NULL;
struct header_complex_index *mtpOmSlStatsTableStorage = NULL;
struct header_complex_index *mtpOmSlL3TableStorage = NULL;
struct header_complex_index *mtpOmSlL3Int5minTableStorage = NULL;
struct header_complex_index *mtpOmSlL3Int15minTableStorage = NULL;
struct header_complex_index *mtpOmSlL2TableStorage = NULL;
struct header_complex_index *mtpOmSlL2Int5minTableStorage = NULL;
struct header_complex_index *mtpOmSlL2Int15minTableStorage = NULL;
struct header_complex_index *mtpOmSdtStatsTableStorage = NULL;
struct header_complex_index *mtpOmSdlStatsTableStorage = NULL;

void (*mtpOmMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void mtpOmMIB_loop_handler(int);
void mtpOmMIB_fd_handler(int, void *);

/**
 * @fn void init_mtpOmMIB(void)
 * @brief mtpOmMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (mtpOmMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_mtpOmMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("mtpOmMIB", "init_mtpOmMIB: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpOmMIB", mtpOmMIB_variables, variable7, mtpOmMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpOmMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpOmMIB", parse_mtpOmMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpTable", parse_mtpOmSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpInt5minTable", parse_mtpOmSpInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpInt15minTable", parse_mtpOmSpInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpSiTable", parse_mtpOmSpSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpSiInt5minTable", parse_mtpOmSpSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpSiInt15minTable", parse_mtpOmSpSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpStudyTable", parse_mtpOmSpStudyTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpStudyInt5minTable", parse_mtpOmSpStudyInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpStudyInt15minTable", parse_mtpOmSpStudyInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpStudyMapTable", parse_mtpOmSpStudyMapTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsTable", parse_mtpOmRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsInt5minTable", parse_mtpOmRsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsInt15minTable", parse_mtpOmRsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsSiTable", parse_mtpOmRsSiTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsSiInt5minTable", parse_mtpOmRsSiInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmRsSiInt15minTable", parse_mtpOmRsSiInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmLsTable", parse_mtpOmLsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmLsInt5minTable", parse_mtpOmLsInt5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmLsInt15minTable", parse_mtpOmLsInt15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlStatsTable", parse_mtpOmSlStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL3Table", parse_mtpOmSlL3Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL3Int5minTable", parse_mtpOmSlL3Int5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL3Int15minTable", parse_mtpOmSlL3Int15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL2Table", parse_mtpOmSlL2Table, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL2Int5minTable", parse_mtpOmSlL2Int5minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlL2Int15minTable", parse_mtpOmSlL2Int15minTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSdtStatsTable", parse_mtpOmSdtStatsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSdlStatsTable", parse_mtpOmSdlStatsTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpStudyTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpStudyInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpStudyInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpStudyMapTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsSiTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsSiInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmRsSiInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmLsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmLsInt5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmLsInt15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL3Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL3Int5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL3Int15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL2Table, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL2Int5minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlL2Int15minTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSdtStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSdlStatsTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, mtpOmMIB_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, mtpOmMIB_fd_handler, (void *) 1);
	}
	mtpOmMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &mtpOmMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/**
 * @fn void deinit_mtpOmMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (mtpOmMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_mtpOmMIB(void)
{
	DEBUGMSGTL(("mtpOmMIB", "deinit_mtpOmMIB: deinitializating...  "));
	external_signal_handler[SIGCHLD] = mtpOmMIBold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(mtpOmMIB_variables_oid, sizeof(mtpOmMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpOmMIB");
	snmpd_unregister_config_handler("mtpOmSpTable");
	snmpd_unregister_config_handler("mtpOmSpInt5minTable");
	snmpd_unregister_config_handler("mtpOmSpInt15minTable");
	snmpd_unregister_config_handler("mtpOmSpSiTable");
	snmpd_unregister_config_handler("mtpOmSpSiInt5minTable");
	snmpd_unregister_config_handler("mtpOmSpSiInt15minTable");
	snmpd_unregister_config_handler("mtpOmSpStudyTable");
	snmpd_unregister_config_handler("mtpOmSpStudyInt5minTable");
	snmpd_unregister_config_handler("mtpOmSpStudyInt15minTable");
	snmpd_unregister_config_handler("mtpOmSpStudyMapTable");
	snmpd_unregister_config_handler("mtpOmRsTable");
	snmpd_unregister_config_handler("mtpOmRsInt5minTable");
	snmpd_unregister_config_handler("mtpOmRsInt15minTable");
	snmpd_unregister_config_handler("mtpOmRsSiTable");
	snmpd_unregister_config_handler("mtpOmRsSiInt5minTable");
	snmpd_unregister_config_handler("mtpOmRsSiInt15minTable");
	snmpd_unregister_config_handler("mtpOmLsTable");
	snmpd_unregister_config_handler("mtpOmLsInt5minTable");
	snmpd_unregister_config_handler("mtpOmLsInt15minTable");
	snmpd_unregister_config_handler("mtpOmSlStatsTable");
	snmpd_unregister_config_handler("mtpOmSlL3Table");
	snmpd_unregister_config_handler("mtpOmSlL3Int5minTable");
	snmpd_unregister_config_handler("mtpOmSlL3Int15minTable");
	snmpd_unregister_config_handler("mtpOmSlL2Table");
	snmpd_unregister_config_handler("mtpOmSlL2Int5minTable");
	snmpd_unregister_config_handler("mtpOmSlL2Int15minTable");
	snmpd_unregister_config_handler("mtpOmSdtStatsTable");
	snmpd_unregister_config_handler("mtpOmSdlStatsTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

int
term_mtpOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("mtpOmMIB", "term_mtpOmMIB: terminating...  "));
	deinit_mtpOmMIB();
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return 0;
}

/**
 * @fn struct mtpOmMIB_data *mtpOmMIB_create(void)
 * @brief create a fresh data structure representing scalars in mtpOmMIB.
 *
 * Creates a new mtpOmMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in mtpOmMIB.
 */
struct mtpOmMIB_data *
mtpOmMIB_create(void)
{
	struct mtpOmMIB_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmMIB_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */
		if ((StorageNew->mtpOm1stAndIntervalActivate = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpOm1stAndIntervalActivateLen = 2;
		if ((StorageNew->mtpOm1stAndIntervalDeactivate = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpOm1stAndIntervalDeactivateLen = 2;
		if ((StorageNew->mtpOm5MinActivate = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpOm5MinActivateLen = 2;
		if ((StorageNew->mtpOm5MinDeaActivate = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpOm5MinDeaActivateLen = 2;
		if ((StorageNew->mtpOm15MinActivate = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpOm15MinActivateLen = 2;
		if ((StorageNew->mtpOm15MinDeaActivate = snmp_duplicate_objid(zeroDotZero_oid, 2)))
			StorageNew->mtpOm15MinDeaActivateLen = 2;
		StorageNew->mtpOmDiscontinuityTime = 0;
		StorageNew->mtpOmTimeStamp = 0;
		StorageNew->mtpOm5MinMaxIntervals = 96;
		StorageNew->mtpOm15MinMaxIntervals = 96;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int mtpOmMIB_destroy(struct mtpOmMIB_data **thedata)
 * @param thedata pointer to the data structure in mtpOmMIB.
 * @brief delete a scalars structure from mtpOmMIB.
 *
 * Frees scalars that were previously removed from mtpOmMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmMIB_destroy(struct mtpOmMIB_data **thedata)
{
	struct mtpOmMIB_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpOm1stAndIntervalActivate);
		StorageDel->mtpOm1stAndIntervalActivateLen = 0;
		SNMP_FREE(StorageDel->mtpOm1stAndIntervalDeactivate);
		StorageDel->mtpOm1stAndIntervalDeactivateLen = 0;
		SNMP_FREE(StorageDel->mtpOm5MinActivate);
		StorageDel->mtpOm5MinActivateLen = 0;
		SNMP_FREE(StorageDel->mtpOm5MinDeaActivate);
		StorageDel->mtpOm5MinDeaActivateLen = 0;
		SNMP_FREE(StorageDel->mtpOm15MinActivate);
		StorageDel->mtpOm15MinActivateLen = 0;
		SNMP_FREE(StorageDel->mtpOm15MinDeaActivate);
		StorageDel->mtpOm15MinDeaActivateLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmMIB_add(struct mtpOmMIB_data *thedata)
 * @param thedata the structure representing mtpOmMIB scalars.
 * @brief adds node to the mtpOmMIB scalar data set.
 *
 * Adds a scalar structure to the mtpOmMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
mtpOmMIB_add(struct mtpOmMIB_data *thedata)
{
	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_add: adding data...  "));
	if (thedata)
		mtpOmMIBStorage = thedata;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmMIB entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_mtpOmMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmMIB_data *StorageTmp = mtpOmMIB_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmMIB: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	SNMP_FREE(StorageTmp->mtpOm1stAndIntervalActivate);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm1stAndIntervalActivate, &StorageTmp->mtpOm1stAndIntervalActivateLen);
	if (StorageTmp->mtpOm1stAndIntervalActivate == NULL) {
		config_perror("invalid specification for mtpOm1stAndIntervalActivate");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOm1stAndIntervalDeactivate);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm1stAndIntervalDeactivate, &StorageTmp->mtpOm1stAndIntervalDeactivateLen);
	if (StorageTmp->mtpOm1stAndIntervalDeactivate == NULL) {
		config_perror("invalid specification for mtpOm1stAndIntervalDeactivate");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOm5MinActivate);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm5MinActivate, &StorageTmp->mtpOm5MinActivateLen);
	if (StorageTmp->mtpOm5MinActivate == NULL) {
		config_perror("invalid specification for mtpOm5MinActivate");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOm5MinDeaActivate);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm5MinDeaActivate, &StorageTmp->mtpOm5MinDeaActivateLen);
	if (StorageTmp->mtpOm5MinDeaActivate == NULL) {
		config_perror("invalid specification for mtpOm5MinDeaActivate");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOm15MinActivate);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm15MinActivate, &StorageTmp->mtpOm15MinActivateLen);
	if (StorageTmp->mtpOm15MinActivate == NULL) {
		config_perror("invalid specification for mtpOm15MinActivate");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOm15MinDeaActivate);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->mtpOm15MinDeaActivate, &StorageTmp->mtpOm15MinDeaActivateLen);
	if (StorageTmp->mtpOm15MinDeaActivate == NULL) {
		config_perror("invalid specification for mtpOm15MinDeaActivate");
		return;
	}
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmDiscontinuityTime, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOm5MinMaxIntervals, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOm15MinMaxIntervals, &tmpsize);
	mtpOmMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmMIB_data *StorageTmp;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmMIB: storing data...  "));
	refresh_mtpOmMIB(1);
	if ((StorageTmp = mtpOmMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpOmMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "mtpOmMIB ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm1stAndIntervalActivate, &StorageTmp->mtpOm1stAndIntervalActivateLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm1stAndIntervalDeactivate, &StorageTmp->mtpOm1stAndIntervalDeactivateLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm5MinActivate, &StorageTmp->mtpOm5MinActivateLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm5MinDeaActivate, &StorageTmp->mtpOm5MinDeaActivateLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm15MinActivate, &StorageTmp->mtpOm15MinActivateLen);
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->mtpOm15MinDeaActivate, &StorageTmp->mtpOm15MinDeaActivateLen);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmDiscontinuityTime, &tmpsize);
		cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmTimeStamp, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOm5MinMaxIntervals, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOm15MinMaxIntervals, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_mtpOmMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of mtpOmMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_mtpOmMIB(int force)
{
	if (mtpOmMIBStorage == NULL) {
		struct mtpOmMIB_data *StorageNew;

		if ((StorageNew = mtpOmMIB_create()) == NULL)
			return;
		mtpOmMIBStorage = StorageNew;
		mtpOmMIB_refresh = 1;
	}
	if (!force && mtpOmMIB_refresh == 0)
		return;
	DEBUGMSGTL(("mtpOmMIB", "refresh_mtpOmMIB: refreshing...  "));
	/* XXX: Update scalars as required here... */
	mtpOmMIB_refresh = 0;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/**
 * @fn u_char * var_mtpOmMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in mtpOmMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_mtpOmMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmMIB_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmMIB: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_mtpOmMIB(0);
	if ((StorageTmp = mtpOmMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpOmMIB", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOM1STANDINTERVALACTIVATE:	/* ReadWrite */
		*write_method = write_mtpOm1stAndIntervalActivate;
		if (!StorageTmp)
		break;
		*var_len = StorageTmp->mtpOm1stAndIntervalActivateLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpOm1stAndIntervalActivate;
		break;
	case (u_char) MTPOM1STANDINTERVALDEACTIVATE:	/* ReadWrite */
		*write_method = write_mtpOm1stAndIntervalDeactivate;
		if (!StorageTmp)
		break;
		*var_len = StorageTmp->mtpOm1stAndIntervalDeactivateLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpOm1stAndIntervalDeactivate;
		break;
	case (u_char) MTPOM5MINACTIVATE:	/* ReadWrite */
		*write_method = write_mtpOm5MinActivate;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpOm5MinActivateLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpOm5MinActivate;
		break;
	case (u_char) MTPOM5MINDEAACTIVATE:	/* ReadWrite */
		*write_method = write_mtpOm5MinDeaActivate;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpOm5MinDeaActivateLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpOm5MinDeaActivate;
		break;
	case (u_char) MTPOM15MINACTIVATE:	/* ReadWrite */
		*write_method = write_mtpOm15MinActivate;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpOm15MinActivateLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpOm15MinActivate;
		break;
	case (u_char) MTPOM15MINDEAACTIVATE:	/* ReadWrite */
		*write_method = write_mtpOm15MinDeaActivate;
		if (!StorageTmp)
			break;
		*var_len = StorageTmp->mtpOm15MinDeaActivateLen * sizeof(oid);
		rval = (u_char *) StorageTmp->mtpOm15MinDeaActivate;
		break;
	case (u_char) MTPOMDISCONTINUITYTIME:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmDiscontinuityTime);
		rval = (u_char *) &StorageTmp->mtpOmDiscontinuityTime;
		break;
	case (u_char) MTPOMTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmTimeStamp;
		break;
	case (u_char) MTPOM5MINMAXINTERVALS:	/* ReadWrite */
		*write_method = write_mtpOm5MinMaxIntervals;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOm5MinMaxIntervals);
		rval = (u_char *) &StorageTmp->mtpOm5MinMaxIntervals;
		break;
	case (u_char) MTPOM15MINMAXINTERVALS:	/* ReadWrite */
		*write_method = write_mtpOm15MinMaxIntervals;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOm15MinMaxIntervals);
		rval = (u_char *) &StorageTmp->mtpOm15MinMaxIntervals;
		break;
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("mtpOmMIB", "found.\n"));
	else
		DEBUGMSGTL(("mtpOmMIB", "not found.\n"));
	return (rval);
}

/**
 * @fn struct mtpOmSpTable_data *mtpOmSpTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpTable table.
 *
 * Creates a new mtpOmSpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpTable_data *
mtpOmSpTable_create(void)
{
	struct mtpOmSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmSpValidIntervals = 0;
		StorageNew->mtpOmSpTimeDiscontinuity = 0;
		StorageNew->mtpOmSpDiscardedMSUs = 0;
		StorageNew->mtpOmSpReceivedTFCstatus0 = 0;
		StorageNew->mtpOmSpReceivedTFCstatus1 = 0;
		StorageNew->mtpOmSpReceivedTFCstatus2 = 0;
		StorageNew->mtpOmSpOctetsXferred = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSpTable_data *mtpOmSpTable_duplicate(struct mtpOmSpTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpTable_data *
mtpOmSpTable_duplicate(struct mtpOmSpTable_data *thedata)
{
	struct mtpOmSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpTable_destroy(struct mtpOmSpTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpTable_destroy(struct mtpOmSpTable_data **thedata)
{
	struct mtpOmSpTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpTable_add(struct mtpOmSpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpTable table data set.
 *
 * Adds a table row structure to the mtpOmSpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpTable_add(struct mtpOmSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		header_complex_add_data(&mtpOmSpTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpTable_del(struct mtpOmSpTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpTable_del(struct mtpOmSpTable_data *thedata)
{
	struct mtpOmSpTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpTable_data *StorageTmp = mtpOmSpTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpReceivedTFCstatus0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpReceivedTFCstatus1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpReceivedTFCstatus2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpOctetsXferred, &tmpsize);
	mtpOmSpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpTable(): store configuraiton file for mtpOmSpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpTable: storing data...  "));
	refresh_mtpOmSpTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpReceivedTFCstatus0, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpReceivedTFCstatus1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpReceivedTFCstatus2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpOctetsXferred, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSpInt5minTable_data *mtpOmSpInt5minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpInt5minTable table.
 *
 * Creates a new mtpOmSpInt5minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpInt5minTable_data *
mtpOmSpInt5minTable_create(void)
{
	struct mtpOmSpInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpInt5minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmSpInt5minTimeStamp = 0;
		StorageNew->mtpOmSpInt5minDiscardedMSUs = 0;
		StorageNew->mtpOmSpInt5minReceivedTFCstatus0 = 0;
		StorageNew->mtpOmSpInt5minReceivedTFCstatus1 = 0;
		StorageNew->mtpOmSpInt5minReceivedTFCstatus2 = 0;
		StorageNew->mtpOmSpInt5minOctetsXferred = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSpInt5minTable_data *mtpOmSpInt5minTable_duplicate(struct mtpOmSpInt5minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpInt5minTable_data *
mtpOmSpInt5minTable_duplicate(struct mtpOmSpInt5minTable_data *thedata)
{
	struct mtpOmSpInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpInt5minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpInt5minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpInt5minTable_destroy(struct mtpOmSpInt5minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpInt5minTable_destroy(struct mtpOmSpInt5minTable_data **thedata)
{
	struct mtpOmSpInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpInt5minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpInt5minTable_add(struct mtpOmSpInt5minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpInt5minTable table data set.
 *
 * Adds a table row structure to the mtpOmSpInt5minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpInt5minTable_add(struct mtpOmSpInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpInt5minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmSpInt5minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpInt5minInterval, sizeof(thedata->mtpOmSpInt5minInterval));
		header_complex_add_data(&mtpOmSpInt5minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpInt5minTable_del(struct mtpOmSpInt5minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpInt5minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpInt5minTable_del(struct mtpOmSpInt5minTable_data *thedata)
{
	struct mtpOmSpInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpInt5minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpInt5minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpInt5minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpInt5minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpInt5minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpInt5minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpInt5minTable_data *StorageTmp = mtpOmSpInt5minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpInt5minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt5minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus0, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus1, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus2, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt5minOctetsXferred, &tmpsize);
	mtpOmSpInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpInt5minTable(): store configuraiton file for mtpOmSpInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpInt5minTable: storing data...  "));
	refresh_mtpOmSpInt5minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpInt5minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpInt5minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt5minDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus0, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus1, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt5minReceivedTFCstatus2, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt5minOctetsXferred, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSpInt15minTable_data *mtpOmSpInt15minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpInt15minTable table.
 *
 * Creates a new mtpOmSpInt15minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpInt15minTable_data *
mtpOmSpInt15minTable_create(void)
{
	struct mtpOmSpInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpInt15minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmSpInt15minTimeStamp = 0;
		StorageNew->mtpOmSpInt15minDiscardedMSUs = 0;
		StorageNew->mtpOmSpInt15minReceivedTFCstatus0 = 0;
		StorageNew->mtpOmSpInt15minReceivedTFCstatus1 = 0;
		StorageNew->mtpOmSpInt15minReceivedTFCstatus2 = 0;
		StorageNew->mtpOmSpInt15minOctetsXferred = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSpInt15minTable_data *mtpOmSpInt15minTable_duplicate(struct mtpOmSpInt15minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpInt15minTable_data *
mtpOmSpInt15minTable_duplicate(struct mtpOmSpInt15minTable_data *thedata)
{
	struct mtpOmSpInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpInt15minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpInt15minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpInt15minTable_destroy(struct mtpOmSpInt15minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpInt15minTable_destroy(struct mtpOmSpInt15minTable_data **thedata)
{
	struct mtpOmSpInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpInt15minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpInt15minTable_add(struct mtpOmSpInt15minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpInt15minTable table data set.
 *
 * Adds a table row structure to the mtpOmSpInt15minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpInt15minTable_add(struct mtpOmSpInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpInt15minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmSpInt15minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpInt15minInterval, sizeof(thedata->mtpOmSpInt15minInterval));
		header_complex_add_data(&mtpOmSpInt15minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpInt15minTable_del(struct mtpOmSpInt15minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpInt15minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpInt15minTable_del(struct mtpOmSpInt15minTable_data *thedata)
{
	struct mtpOmSpInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpInt15minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpInt15minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpInt15minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpInt15minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpInt15minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpInt15minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpInt15minTable_data *StorageTmp = mtpOmSpInt15minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpInt15minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt15minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus0, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus1, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus2, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpInt15minOctetsXferred, &tmpsize);
	mtpOmSpInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpInt15minTable(): store configuraiton file for mtpOmSpInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpInt15minTable: storing data...  "));
	refresh_mtpOmSpInt15minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpInt15minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpInt15minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt15minDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus0, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus1, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt15minReceivedTFCstatus2, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpInt15minOctetsXferred, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSpSiTable_data *mtpOmSpSiTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpSiTable table.
 *
 * Creates a new mtpOmSpSiTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpSiTable_data *
mtpOmSpSiTable_create(void)
{
	struct mtpOmSpSiTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpSiTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmSpSiValidIntervals = 0;
		StorageNew->mtpOmSpSiTimeDiscontinuity = 0;
		StorageNew->mtpOmSpSiTransmittedUPUnavailable = 0;
		StorageNew->mtpOmSpSiReceivedUPUnavailable = 0;
		StorageNew->mtpOmSpSiHandledOctetsSIO = 0;
		StorageNew->mtpOmSpSiStatus = 0;
		StorageNew->mtpOmSpSiStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSpSiTable_data *mtpOmSpSiTable_duplicate(struct mtpOmSpSiTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpSiTable_data *
mtpOmSpSiTable_duplicate(struct mtpOmSpSiTable_data *thedata)
{
	struct mtpOmSpSiTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpSiTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpSiTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpSiTable_destroy(struct mtpOmSpSiTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpSiTable_destroy(struct mtpOmSpSiTable_data **thedata)
{
	struct mtpOmSpSiTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpSiTable_add(struct mtpOmSpSiTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpSiTable table data set.
 *
 * Adds a table row structure to the mtpOmSpSiTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpSiTable_add(struct mtpOmSpSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmSpSiCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpOmSpSiCode, sizeof(thedata->mtpOmSpSiCode));
		header_complex_add_data(&mtpOmSpSiTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpSiTable_del(struct mtpOmSpSiTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpSiTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpSiTable_del(struct mtpOmSpSiTable_data *thedata)
{
	struct mtpOmSpSiTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpSiTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpSiTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpSiTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpSiTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpSiTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpSiTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpSiTable_data *StorageTmp = mtpOmSpSiTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpSiTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpSiValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpSiTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpSiTransmittedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpSiReceivedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpSiHandledOctetsSIO, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpSiStatus, &tmpsize);
	mtpOmSpSiTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpSiTable(): store configuraiton file for mtpOmSpSiTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpSiTable: storing data...  "));
	refresh_mtpOmSpSiTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpSiTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpSiTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpSiValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpSiTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpSiTransmittedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpSiReceivedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpSiHandledOctetsSIO, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpSiStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSpSiInt5minTable_data *mtpOmSpSiInt5minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpSiInt5minTable table.
 *
 * Creates a new mtpOmSpSiInt5minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpSiInt5minTable_data *
mtpOmSpSiInt5minTable_create(void)
{
	struct mtpOmSpSiInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpSiInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiInt5minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmSpSiCode = 0;
		StorageNew->mtpOmSpSiInt5minTimeStamp = 0;
		StorageNew->mtpOmSpSiInt5minTransmittedUPUnavailable = 0;
		StorageNew->mtpOmSpSiInt5minReceivedUPUnavailable = 0;
		StorageNew->mtpOmSpSiInt5minHandledOctetsSIO = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSpSiInt5minTable_data *mtpOmSpSiInt5minTable_duplicate(struct mtpOmSpSiInt5minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpSiInt5minTable_data *
mtpOmSpSiInt5minTable_duplicate(struct mtpOmSpSiInt5minTable_data *thedata)
{
	struct mtpOmSpSiInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpSiInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiInt5minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpSiInt5minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpSiInt5minTable_destroy(struct mtpOmSpSiInt5minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpSiInt5minTable_destroy(struct mtpOmSpSiInt5minTable_data **thedata)
{
	struct mtpOmSpSiInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiInt5minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpSiInt5minTable_add(struct mtpOmSpSiInt5minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpSiInt5minTable table data set.
 *
 * Adds a table row structure to the mtpOmSpSiInt5minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpSiInt5minTable_add(struct mtpOmSpSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiInt5minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmSpSiCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpOmSpSiCode, sizeof(thedata->mtpOmSpSiCode));
		/* mtpOmSpSiInt5minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpSiInt5minInterval, sizeof(thedata->mtpOmSpSiInt5minInterval));
		header_complex_add_data(&mtpOmSpSiInt5minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpSiInt5minTable_del(struct mtpOmSpSiInt5minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpSiInt5minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpSiInt5minTable_del(struct mtpOmSpSiInt5minTable_data *thedata)
{
	struct mtpOmSpSiInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiInt5minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpSiInt5minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpSiInt5minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpSiInt5minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpSiInt5minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpSiInt5minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpSiInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpSiInt5minTable_data *StorageTmp = mtpOmSpSiInt5minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpSiInt5minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpSiInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpSiInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt5minTransmittedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt5minReceivedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt5minHandledOctetsSIO, &tmpsize);
	mtpOmSpSiInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpSiInt5minTable(): store configuraiton file for mtpOmSpSiInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpSiInt5minTable: storing data...  "));
	refresh_mtpOmSpSiInt5minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpSiInt5minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpSiInt5minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpSiInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpSiInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt5minTransmittedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt5minReceivedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt5minHandledOctetsSIO, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSpSiInt15minTable_data *mtpOmSpSiInt15minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpSiInt15minTable table.
 *
 * Creates a new mtpOmSpSiInt15minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpSiInt15minTable_data *
mtpOmSpSiInt15minTable_create(void)
{
	struct mtpOmSpSiInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpSiInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiInt15minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmSpSiCode = 0;
		StorageNew->mtpOmSpSiInt15minTimeStamp = 0;
		StorageNew->mtpOmSpSiInt15minTransmittedUPUnavailable = 0;
		StorageNew->mtpOmSpSiInt15minReceivedUPUnavailable = 0;
		StorageNew->mtpOmSpSiInt15minHandledOctetsSIO = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSpSiInt15minTable_data *mtpOmSpSiInt15minTable_duplicate(struct mtpOmSpSiInt15minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpSiInt15minTable_data *
mtpOmSpSiInt15minTable_duplicate(struct mtpOmSpSiInt15minTable_data *thedata)
{
	struct mtpOmSpSiInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpSiInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiInt15minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpSiInt15minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpSiInt15minTable_destroy(struct mtpOmSpSiInt15minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpSiInt15minTable_destroy(struct mtpOmSpSiInt15minTable_data **thedata)
{
	struct mtpOmSpSiInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiInt15minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpSiInt15minTable_add(struct mtpOmSpSiInt15minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpSiInt15minTable table data set.
 *
 * Adds a table row structure to the mtpOmSpSiInt15minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpSiInt15minTable_add(struct mtpOmSpSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiInt15minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmSpSiCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpOmSpSiCode, sizeof(thedata->mtpOmSpSiCode));
		/* mtpOmSpSiInt15minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpSiInt15minInterval, sizeof(thedata->mtpOmSpSiInt15minInterval));
		header_complex_add_data(&mtpOmSpSiInt15minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpSiInt15minTable_del(struct mtpOmSpSiInt15minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpSiInt15minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpSiInt15minTable_del(struct mtpOmSpSiInt15minTable_data *thedata)
{
	struct mtpOmSpSiInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpSiInt15minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpSiInt15minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpSiInt15minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpSiInt15minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpSiInt15minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpSiInt15minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpSiInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpSiInt15minTable_data *StorageTmp = mtpOmSpSiInt15minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpSiInt15minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpSiInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpSiInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt15minTransmittedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt15minReceivedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpSiInt15minHandledOctetsSIO, &tmpsize);
	mtpOmSpSiInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpSiInt15minTable(): store configuraiton file for mtpOmSpSiInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpSiInt15minTable: storing data...  "));
	refresh_mtpOmSpSiInt15minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpSiInt15minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpSiInt15minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpSiInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpSiInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt15minTransmittedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt15minReceivedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpSiInt15minHandledOctetsSIO, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSpStudyTable_data *mtpOmSpStudyTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpStudyTable table.
 *
 * Creates a new mtpOmSpStudyTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpStudyTable_data *
mtpOmSpStudyTable_create(void)
{
	struct mtpOmSpStudyTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpStudyTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpOmSpStudyValidIntervals = 0;
		StorageNew->mtpOmSpStudyTimeDiscontinuity = 0;
		StorageNew->mtpOmSpStudyHandledOctetsOpcDpcSio = 0;
		StorageNew->mtpOmSpStudyHandledMSUsOpcDpcSio = 0;
		StorageNew->mtpOmSpStudyStatus = 0;
		StorageNew->mtpOmSpStudyStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSpStudyTable_data *mtpOmSpStudyTable_duplicate(struct mtpOmSpStudyTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpStudyTable_data *
mtpOmSpStudyTable_duplicate(struct mtpOmSpStudyTable_data *thedata)
{
	struct mtpOmSpStudyTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpStudyTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpStudyTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpStudyTable_destroy(struct mtpOmSpStudyTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpStudyTable_destroy(struct mtpOmSpStudyTable_data **thedata)
{
	struct mtpOmSpStudyTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpStudyTable_add(struct mtpOmSpStudyTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpStudyTable table data set.
 *
 * Adds a table row structure to the mtpOmSpStudyTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpStudyTable_add(struct mtpOmSpStudyTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpOmSpStudyId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyId, sizeof(thedata->mtpOmSpStudyId));
		header_complex_add_data(&mtpOmSpStudyTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpStudyTable_del(struct mtpOmSpStudyTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpStudyTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpStudyTable_del(struct mtpOmSpStudyTable_data *thedata)
{
	struct mtpOmSpStudyTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpStudyTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpStudyTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpStudyTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpStudyTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpStudyTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpStudyTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpStudyTable_data *StorageTmp = mtpOmSpStudyTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpStudyTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpStudyValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpStudyTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpStudyHandledOctetsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSpStudyHandledMSUsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpStudyStatus, &tmpsize);
	mtpOmSpStudyTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpStudyTable(): store configuraiton file for mtpOmSpStudyTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpStudyTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpStudyTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpStudyTable: storing data...  "));
	refresh_mtpOmSpStudyTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpStudyTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpStudyTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpStudyTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpStudyValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpStudyTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpStudyHandledOctetsOpcDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSpStudyHandledMSUsOpcDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpStudyStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSpStudyInt5minTable_data *mtpOmSpStudyInt5minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpStudyInt5minTable table.
 *
 * Creates a new mtpOmSpStudyInt5minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpStudyInt5minTable_data *
mtpOmSpStudyInt5minTable_create(void)
{
	struct mtpOmSpStudyInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpStudyInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyInt5minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpOmSpStudyId = 0;
		StorageNew->mtpOmSpStudyInt5minTimeStamp = 0;
		StorageNew->mtpOmSpStudyInt5minHandledOctetsOpcDpcSio = 0;
		StorageNew->mtpOmSpStudyInt5minHandledMSUsOpcDpcSio = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSpStudyInt5minTable_data *mtpOmSpStudyInt5minTable_duplicate(struct mtpOmSpStudyInt5minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpStudyInt5minTable_data *
mtpOmSpStudyInt5minTable_duplicate(struct mtpOmSpStudyInt5minTable_data *thedata)
{
	struct mtpOmSpStudyInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpStudyInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyInt5minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpStudyInt5minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpStudyInt5minTable_destroy(struct mtpOmSpStudyInt5minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpStudyInt5minTable_destroy(struct mtpOmSpStudyInt5minTable_data **thedata)
{
	struct mtpOmSpStudyInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyInt5minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpStudyInt5minTable_add(struct mtpOmSpStudyInt5minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpStudyInt5minTable table data set.
 *
 * Adds a table row structure to the mtpOmSpStudyInt5minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpStudyInt5minTable_add(struct mtpOmSpStudyInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyInt5minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpOmSpStudyId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyId, sizeof(thedata->mtpOmSpStudyId));
		/* mtpOmSpStudyInt5minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyInt5minInterval, sizeof(thedata->mtpOmSpStudyInt5minInterval));
		header_complex_add_data(&mtpOmSpStudyInt5minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpStudyInt5minTable_del(struct mtpOmSpStudyInt5minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpStudyInt5minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpStudyInt5minTable_del(struct mtpOmSpStudyInt5minTable_data *thedata)
{
	struct mtpOmSpStudyInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyInt5minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpStudyInt5minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpStudyInt5minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpStudyInt5minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpStudyInt5minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpStudyInt5minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpStudyInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpStudyInt5minTable_data *StorageTmp = mtpOmSpStudyInt5minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpStudyInt5minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpStudyInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpStudyInt5minHandledOctetsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpStudyInt5minHandledMSUsOpcDpcSio, &tmpsize);
	mtpOmSpStudyInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpStudyInt5minTable(): store configuraiton file for mtpOmSpStudyInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpStudyInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpStudyInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpStudyInt5minTable: storing data...  "));
	refresh_mtpOmSpStudyInt5minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpStudyInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpStudyInt5minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpStudyInt5minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpStudyInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpStudyInt5minHandledOctetsOpcDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpStudyInt5minHandledMSUsOpcDpcSio, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSpStudyInt15minTable_data *mtpOmSpStudyInt15minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpStudyInt15minTable table.
 *
 * Creates a new mtpOmSpStudyInt15minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpStudyInt15minTable_data *
mtpOmSpStudyInt15minTable_create(void)
{
	struct mtpOmSpStudyInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpStudyInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyInt15minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpOmSpStudyId = 0;
		StorageNew->mtpOmSpStudyInt15minTimeStamp = 0;
		StorageNew->mtpOmSpStudyInt15minHandledOctetsOpcDpcSio = 0;
		StorageNew->mtpOmSpStudyInt15minHandledMSUsOpcDpcSio = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSpStudyInt15minTable_data *mtpOmSpStudyInt15minTable_duplicate(struct mtpOmSpStudyInt15minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpStudyInt15minTable_data *
mtpOmSpStudyInt15minTable_duplicate(struct mtpOmSpStudyInt15minTable_data *thedata)
{
	struct mtpOmSpStudyInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpStudyInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyInt15minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpStudyInt15minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpStudyInt15minTable_destroy(struct mtpOmSpStudyInt15minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpStudyInt15minTable_destroy(struct mtpOmSpStudyInt15minTable_data **thedata)
{
	struct mtpOmSpStudyInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyInt15minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpStudyInt15minTable_add(struct mtpOmSpStudyInt15minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpStudyInt15minTable table data set.
 *
 * Adds a table row structure to the mtpOmSpStudyInt15minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpStudyInt15minTable_add(struct mtpOmSpStudyInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyInt15minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpOmSpStudyId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyId, sizeof(thedata->mtpOmSpStudyId));
		/* mtpOmSpStudyInt15minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyInt15minInterval, sizeof(thedata->mtpOmSpStudyInt15minInterval));
		header_complex_add_data(&mtpOmSpStudyInt15minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpStudyInt15minTable_del(struct mtpOmSpStudyInt15minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpStudyInt15minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpStudyInt15minTable_del(struct mtpOmSpStudyInt15minTable_data *thedata)
{
	struct mtpOmSpStudyInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyInt15minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpStudyInt15minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpStudyInt15minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpStudyInt15minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpStudyInt15minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpStudyInt15minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpStudyInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpStudyInt15minTable_data *StorageTmp = mtpOmSpStudyInt15minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpStudyInt15minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSpStudyInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpStudyInt15minHandledOctetsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpStudyInt15minHandledMSUsOpcDpcSio, &tmpsize);
	mtpOmSpStudyInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpStudyInt15minTable(): store configuraiton file for mtpOmSpStudyInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpStudyInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpStudyInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpStudyInt15minTable: storing data...  "));
	refresh_mtpOmSpStudyInt15minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpStudyInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpStudyInt15minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpStudyInt15minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSpStudyInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpStudyInt15minHandledOctetsOpcDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpStudyInt15minHandledMSUsOpcDpcSio, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSpStudyMapTable_data *mtpOmSpStudyMapTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpStudyMapTable table.
 *
 * Creates a new mtpOmSpStudyMapTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpStudyMapTable_data *
mtpOmSpStudyMapTable_create(void)
{
	struct mtpOmSpStudyMapTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpStudyMapTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyMapTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmSpSiCode = 0;
		StorageNew->mtpOmSpStudyId = 0;
		StorageNew->mtpOmSpStudyMapStatus = 0;
		StorageNew->mtpOmSpStudyMapStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSpStudyMapTable_data *mtpOmSpStudyMapTable_duplicate(struct mtpOmSpStudyMapTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpStudyMapTable_data *
mtpOmSpStudyMapTable_duplicate(struct mtpOmSpStudyMapTable_data *thedata)
{
	struct mtpOmSpStudyMapTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpStudyMapTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyMapTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpStudyMapTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpStudyMapTable_destroy(struct mtpOmSpStudyMapTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpStudyMapTable_destroy(struct mtpOmSpStudyMapTable_data **thedata)
{
	struct mtpOmSpStudyMapTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyMapTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpStudyMapTable_add(struct mtpOmSpStudyMapTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpStudyMapTable table data set.
 *
 * Adds a table row structure to the mtpOmSpStudyMapTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpStudyMapTable_add(struct mtpOmSpStudyMapTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyMapTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmSpSiCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpOmSpSiCode, sizeof(thedata->mtpOmSpSiCode));
		/* mtpOmSpStudyId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSpStudyId, sizeof(thedata->mtpOmSpStudyId));
		/* mtpOmOpcRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmOpcRsId, sizeof(thedata->mtpOmOpcRsId));
		/* mtpOmDpcRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmDpcRsId, sizeof(thedata->mtpOmDpcRsId));
		header_complex_add_data(&mtpOmSpStudyMapTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpStudyMapTable_del(struct mtpOmSpStudyMapTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpStudyMapTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpStudyMapTable_del(struct mtpOmSpStudyMapTable_data *thedata)
{
	struct mtpOmSpStudyMapTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpStudyMapTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpStudyMapTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpStudyMapTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpStudyMapTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpStudyMapTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpStudyMapTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpStudyMapTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpStudyMapTable_data *StorageTmp = mtpOmSpStudyMapTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpStudyMapTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSpStudyId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmOpcRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmDpcRsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSpStudyMapStatus, &tmpsize);
	mtpOmSpStudyMapTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpStudyMapTable(): store configuraiton file for mtpOmSpStudyMapTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpStudyMapTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpStudyMapTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpStudyMapTable: storing data...  "));
	refresh_mtpOmSpStudyMapTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpStudyMapTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpStudyMapTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpStudyMapTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSpStudyId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmOpcRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmDpcRsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSpStudyMapStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmRsTable_data *mtpOmRsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmRsTable table.
 *
 * Creates a new mtpOmRsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmRsTable_data *
mtpOmRsTable_create(void)
{
	struct mtpOmRsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpRsId = 0;
		StorageNew->mtpOmRsValidIntervals = 0;
		StorageNew->mtpOmRsTimeDiscontinuity = 0;
		StorageNew->mtpOmRsReceivedOctetsOPC = 0;
		StorageNew->mtpOmRsTransmittedOctetsDPC = 0;
		StorageNew->mtpOmRsReceivedMSUsOpc = 0;
		StorageNew->mtpOmRsTransmittedMSUsDpc = 0;
		StorageNew->mtpOmRsRouteSetUnavailable = 0;
		StorageNew->mtpOmRsRouteSetUnavailableDuration = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmRsTable_data *mtpOmRsTable_duplicate(struct mtpOmRsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmRsTable_data *
mtpOmRsTable_duplicate(struct mtpOmRsTable_data *thedata)
{
	struct mtpOmRsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmRsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmRsTable_destroy(struct mtpOmRsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmRsTable_destroy(struct mtpOmRsTable_data **thedata)
{
	struct mtpOmRsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsTable_add(struct mtpOmRsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmRsTable table data set.
 *
 * Adds a table row structure to the mtpOmRsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmRsTable_add(struct mtpOmRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
		header_complex_add_data(&mtpOmRsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsTable_del(struct mtpOmRsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmRsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmRsTable_del(struct mtpOmRsTable_data *thedata)
{
	struct mtpOmRsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmRsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmRsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmRsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmRsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmRsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmRsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsTable_data *StorageTmp = mtpOmRsTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmRsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmRsValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsReceivedOctetsOPC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsTransmittedOctetsDPC, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsReceivedMSUsOpc, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsTransmittedMSUsDpc, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsRouteSetUnavailable, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsRouteSetUnavailableDuration, &tmpsize);
	mtpOmRsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmRsTable(): store configuraiton file for mtpOmRsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmRsTable: storing data...  "));
	refresh_mtpOmRsTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmRsValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsReceivedOctetsOPC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsTransmittedOctetsDPC, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsReceivedMSUsOpc, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsTransmittedMSUsDpc, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsRouteSetUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsRouteSetUnavailableDuration, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmRsInt5minTable_data *mtpOmRsInt5minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmRsInt5minTable table.
 *
 * Creates a new mtpOmRsInt5minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmRsInt5minTable_data *
mtpOmRsInt5minTable_create(void)
{
	struct mtpOmRsInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsInt5minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpRsId = 0;
		StorageNew->mtpOmRsInt5minTimeStamp = 0;
		StorageNew->mtpOmRsInt5minReceivedOctetsOPC = 0;
		StorageNew->mtpOmRsInt5minTransmittedOctetsDPC = 0;
		StorageNew->mtpOmRsInt5minReceivedMSUsOpc = 0;
		StorageNew->mtpOmRsInt5minTransmittedMSUsDpc = 0;
		StorageNew->mtpOmRsInt5minRouteSetUnavailable = 0;
		StorageNew->mtpOmRsInt5minRouteSetUnavailableDuration = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmRsInt5minTable_data *mtpOmRsInt5minTable_duplicate(struct mtpOmRsInt5minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmRsInt5minTable_data *
mtpOmRsInt5minTable_duplicate(struct mtpOmRsInt5minTable_data *thedata)
{
	struct mtpOmRsInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsInt5minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmRsInt5minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmRsInt5minTable_destroy(struct mtpOmRsInt5minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmRsInt5minTable_destroy(struct mtpOmRsInt5minTable_data **thedata)
{
	struct mtpOmRsInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsInt5minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsInt5minTable_add(struct mtpOmRsInt5minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmRsInt5minTable table data set.
 *
 * Adds a table row structure to the mtpOmRsInt5minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmRsInt5minTable_add(struct mtpOmRsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsInt5minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
		/* mtpOmRsInt5minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsInt5minInterval, sizeof(thedata->mtpOmRsInt5minInterval));
		header_complex_add_data(&mtpOmRsInt5minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsInt5minTable_del(struct mtpOmRsInt5minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmRsInt5minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmRsInt5minTable_del(struct mtpOmRsInt5minTable_data *thedata)
{
	struct mtpOmRsInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsInt5minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmRsInt5minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmRsInt5minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmRsInt5minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmRsInt5minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmRsInt5minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmRsInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsInt5minTable_data *StorageTmp = mtpOmRsInt5minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmRsInt5minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minReceivedOctetsOPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minTransmittedOctetsDPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minReceivedMSUsOpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minTransmittedMSUsDpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minRouteSetUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt5minRouteSetUnavailableDuration, &tmpsize);
	mtpOmRsInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmRsInt5minTable(): store configuraiton file for mtpOmRsInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmRsInt5minTable: storing data...  "));
	refresh_mtpOmRsInt5minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmRsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsInt5minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsInt5minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minReceivedOctetsOPC, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minTransmittedOctetsDPC, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minReceivedMSUsOpc, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minTransmittedMSUsDpc, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minRouteSetUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt5minRouteSetUnavailableDuration, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmRsInt15minTable_data *mtpOmRsInt15minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmRsInt15minTable table.
 *
 * Creates a new mtpOmRsInt15minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmRsInt15minTable_data *
mtpOmRsInt15minTable_create(void)
{
	struct mtpOmRsInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsInt15minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpRsId = 0;
		StorageNew->mtpOmRsInt15minTimeStamp = 0;
		StorageNew->mtpOmRsInt15minReceivedOctetsOPC = 0;
		StorageNew->mtpOmRsInt15minTransmittedOctetsDPC = 0;
		StorageNew->mtpOmRsInt15minReceivedMSUsOpc = 0;
		StorageNew->mtpOmRsInt15minTransmittedMSUsDpc = 0;
		StorageNew->mtpOmRsInt15minRouteSetUnavailable = 0;
		StorageNew->mtpOmRsInt15minRouteSetUnavailableDuration = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmRsInt15minTable_data *mtpOmRsInt15minTable_duplicate(struct mtpOmRsInt15minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmRsInt15minTable_data *
mtpOmRsInt15minTable_duplicate(struct mtpOmRsInt15minTable_data *thedata)
{
	struct mtpOmRsInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsInt15minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmRsInt15minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmRsInt15minTable_destroy(struct mtpOmRsInt15minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmRsInt15minTable_destroy(struct mtpOmRsInt15minTable_data **thedata)
{
	struct mtpOmRsInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsInt15minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsInt15minTable_add(struct mtpOmRsInt15minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmRsInt15minTable table data set.
 *
 * Adds a table row structure to the mtpOmRsInt15minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmRsInt15minTable_add(struct mtpOmRsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsInt15minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
		/* mtpOmRsInt15minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsInt15minInterval, sizeof(thedata->mtpOmRsInt15minInterval));
		header_complex_add_data(&mtpOmRsInt15minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsInt15minTable_del(struct mtpOmRsInt15minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmRsInt15minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmRsInt15minTable_del(struct mtpOmRsInt15minTable_data *thedata)
{
	struct mtpOmRsInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsInt15minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmRsInt15minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmRsInt15minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmRsInt15minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmRsInt15minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmRsInt15minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmRsInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsInt15minTable_data *StorageTmp = mtpOmRsInt15minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmRsInt15minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minReceivedOctetsOPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minTransmittedOctetsDPC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minReceivedMSUsOpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minTransmittedMSUsDpc, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minRouteSetUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsInt15minRouteSetUnavailableDuration, &tmpsize);
	mtpOmRsInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmRsInt15minTable(): store configuraiton file for mtpOmRsInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmRsInt15minTable: storing data...  "));
	refresh_mtpOmRsInt15minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmRsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsInt15minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsInt15minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minReceivedOctetsOPC, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minTransmittedOctetsDPC, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minReceivedMSUsOpc, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minTransmittedMSUsDpc, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minRouteSetUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsInt15minRouteSetUnavailableDuration, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmRsSiTable_data *mtpOmRsSiTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmRsSiTable table.
 *
 * Creates a new mtpOmRsSiTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmRsSiTable_data *
mtpOmRsSiTable_create(void)
{
	struct mtpOmRsSiTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsSiTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpRsId = 0;
		StorageNew->mtpOmRsSiValidIntervals = 0;
		StorageNew->mtpOmRsSiTimeDiscontinuity = 0;
		StorageNew->mtpOmRsSiReceivedOctetsOpcSio = 0;
		StorageNew->mtpOmRsSiTransmittedOctetsDpcSio = 0;
		StorageNew->mtpOmRsSiReceivedMSUsOpcSio = 0;
		StorageNew->mtpOmRsSiTransmittedMSUsDpcSio = 0;
		StorageNew->mtpOmRsSiStatus = 0;
		StorageNew->mtpOmRsSiStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmRsSiTable_data *mtpOmRsSiTable_duplicate(struct mtpOmRsSiTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmRsSiTable_data *
mtpOmRsSiTable_duplicate(struct mtpOmRsSiTable_data *thedata)
{
	struct mtpOmRsSiTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsSiTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmRsSiTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmRsSiTable_destroy(struct mtpOmRsSiTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmRsSiTable_destroy(struct mtpOmRsSiTable_data **thedata)
{
	struct mtpOmRsSiTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsSiTable_add(struct mtpOmRsSiTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmRsSiTable table data set.
 *
 * Adds a table row structure to the mtpOmRsSiTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmRsSiTable_add(struct mtpOmRsSiTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
		/* mtpOmRsSiCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpOmRsSiCode, sizeof(thedata->mtpOmRsSiCode));
		header_complex_add_data(&mtpOmRsSiTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsSiTable_del(struct mtpOmRsSiTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmRsSiTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmRsSiTable_del(struct mtpOmRsSiTable_data *thedata)
{
	struct mtpOmRsSiTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmRsSiTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmRsSiTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmRsSiTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmRsSiTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmRsSiTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmRsSiTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsSiTable_data *StorageTmp = mtpOmRsSiTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmRsSiTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmRsSiCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmRsSiValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsSiTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsSiReceivedOctetsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsSiTransmittedOctetsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsSiReceivedMSUsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmRsSiTransmittedMSUsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmRsSiStatus, &tmpsize);
	mtpOmRsSiTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmRsSiTable(): store configuraiton file for mtpOmRsSiTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsSiTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsSiTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmRsSiTable: storing data...  "));
	refresh_mtpOmRsSiTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmRsSiTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsSiTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsSiTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmRsSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmRsSiValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsSiTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsSiReceivedOctetsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsSiTransmittedOctetsDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsSiReceivedMSUsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmRsSiTransmittedMSUsDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmRsSiStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmRsSiInt5minTable_data *mtpOmRsSiInt5minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmRsSiInt5minTable table.
 *
 * Creates a new mtpOmRsSiInt5minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmRsSiInt5minTable_data *
mtpOmRsSiInt5minTable_create(void)
{
	struct mtpOmRsSiInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsSiInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiInt5minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpRsId = 0;
		StorageNew->mtpOmRsSiCode = 0;
		StorageNew->mtpOmRsSiInt5minTimeStamp = 0;
		StorageNew->mtpOmRsSiInt5minReceivedOctetsOpcSio = 0;
		StorageNew->mtpOmRsSiInt5minTransmittedOctetsDpcSio = 0;
		StorageNew->mtpOmRsSiInt5minReceivedMSUsOpcSio = 0;
		StorageNew->mtpOmRsSiInt5minTransmittedMSUsDpcSio = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmRsSiInt5minTable_data *mtpOmRsSiInt5minTable_duplicate(struct mtpOmRsSiInt5minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmRsSiInt5minTable_data *
mtpOmRsSiInt5minTable_duplicate(struct mtpOmRsSiInt5minTable_data *thedata)
{
	struct mtpOmRsSiInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsSiInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiInt5minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmRsSiInt5minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmRsSiInt5minTable_destroy(struct mtpOmRsSiInt5minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmRsSiInt5minTable_destroy(struct mtpOmRsSiInt5minTable_data **thedata)
{
	struct mtpOmRsSiInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiInt5minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsSiInt5minTable_add(struct mtpOmRsSiInt5minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmRsSiInt5minTable table data set.
 *
 * Adds a table row structure to the mtpOmRsSiInt5minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmRsSiInt5minTable_add(struct mtpOmRsSiInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiInt5minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
		/* mtpOmRsSiCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpOmRsSiCode, sizeof(thedata->mtpOmRsSiCode));
		/* mtpOmRsSiInt5minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsSiInt5minInterval, sizeof(thedata->mtpOmRsSiInt5minInterval));
		header_complex_add_data(&mtpOmRsSiInt5minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsSiInt5minTable_del(struct mtpOmRsSiInt5minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmRsSiInt5minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmRsSiInt5minTable_del(struct mtpOmRsSiInt5minTable_data *thedata)
{
	struct mtpOmRsSiInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiInt5minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmRsSiInt5minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmRsSiInt5minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmRsSiInt5minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmRsSiInt5minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmRsSiInt5minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmRsSiInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsSiInt5minTable_data *StorageTmp = mtpOmRsSiInt5minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmRsSiInt5minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmRsSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsSiInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsSiInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt5minReceivedOctetsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt5minTransmittedOctetsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt5minReceivedMSUsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt5minTransmittedMSUsDpcSio, &tmpsize);
	mtpOmRsSiInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmRsSiInt5minTable(): store configuraiton file for mtpOmRsSiInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsSiInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsSiInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmRsSiInt5minTable: storing data...  "));
	refresh_mtpOmRsSiInt5minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmRsSiInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsSiInt5minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsSiInt5minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmRsSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsSiInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsSiInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt5minReceivedOctetsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt5minTransmittedOctetsDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt5minReceivedMSUsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt5minTransmittedMSUsDpcSio, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmRsSiInt15minTable_data *mtpOmRsSiInt15minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmRsSiInt15minTable table.
 *
 * Creates a new mtpOmRsSiInt15minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmRsSiInt15minTable_data *
mtpOmRsSiInt15minTable_create(void)
{
	struct mtpOmRsSiInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsSiInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiInt15minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpRsId = 0;
		StorageNew->mtpOmRsSiCode = 0;
		StorageNew->mtpOmRsSiInt15minTimeStamp = 0;
		StorageNew->mtpOmRsSiInt15minReceivedOctetsOpcSio = 0;
		StorageNew->mtpOmRsSiInt15minTransmittedOctetsDpcSio = 0;
		StorageNew->mtpOmRsSiInt15minReceivedMSUsOpcSio = 0;
		StorageNew->mtpOmRsSiInt15minTransmittedMSUsDpcSio = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmRsSiInt15minTable_data *mtpOmRsSiInt15minTable_duplicate(struct mtpOmRsSiInt15minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmRsSiInt15minTable_data *
mtpOmRsSiInt15minTable_duplicate(struct mtpOmRsSiInt15minTable_data *thedata)
{
	struct mtpOmRsSiInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmRsSiInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiInt15minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmRsSiInt15minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmRsSiInt15minTable_destroy(struct mtpOmRsSiInt15minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmRsSiInt15minTable_destroy(struct mtpOmRsSiInt15minTable_data **thedata)
{
	struct mtpOmRsSiInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiInt15minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsSiInt15minTable_add(struct mtpOmRsSiInt15minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmRsSiInt15minTable table data set.
 *
 * Adds a table row structure to the mtpOmRsSiInt15minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmRsSiInt15minTable_add(struct mtpOmRsSiInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiInt15minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
		/* mtpOmRsSiCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpOmRsSiCode, sizeof(thedata->mtpOmRsSiCode));
		/* mtpOmRsSiInt15minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmRsSiInt15minInterval, sizeof(thedata->mtpOmRsSiInt15minInterval));
		header_complex_add_data(&mtpOmRsSiInt15minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmRsSiInt15minTable_del(struct mtpOmRsSiInt15minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmRsSiInt15minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmRsSiInt15minTable_del(struct mtpOmRsSiInt15minTable_data *thedata)
{
	struct mtpOmRsSiInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmRsSiInt15minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmRsSiInt15minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmRsSiInt15minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmRsSiInt15minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmRsSiInt15minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmRsSiInt15minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmRsSiInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmRsSiInt15minTable_data *StorageTmp = mtpOmRsSiInt15minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmRsSiInt15minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmRsSiCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmRsSiInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmRsSiInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt15minReceivedOctetsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt15minTransmittedOctetsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt15minReceivedMSUsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRsSiInt15minTransmittedMSUsDpcSio, &tmpsize);
	mtpOmRsSiInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmRsSiInt15minTable(): store configuraiton file for mtpOmRsSiInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmRsSiInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmRsSiInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmRsSiInt15minTable: storing data...  "));
	refresh_mtpOmRsSiInt15minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmRsSiInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmRsSiInt15minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmRsSiInt15minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmRsSiCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmRsSiInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmRsSiInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt15minReceivedOctetsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt15minTransmittedOctetsDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt15minReceivedMSUsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRsSiInt15minTransmittedMSUsDpcSio, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmLsTable_data *mtpOmLsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmLsTable table.
 *
 * Creates a new mtpOmLsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmLsTable_data *
mtpOmLsTable_create(void)
{
	struct mtpOmLsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmLsTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpOmLsValidIntervals = 0;
		StorageNew->mtpOmLsTimeDiscontinuity = 0;
		StorageNew->mtpOmLsAdjacentInaccessibleEvents = 0;
		StorageNew->mtpOmLsAdjacentInaccessibleDuration = 0;
		StorageNew->mtpOmLsSlsUnavailable = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmLsTable_data *mtpOmLsTable_duplicate(struct mtpOmLsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmLsTable_data *
mtpOmLsTable_duplicate(struct mtpOmLsTable_data *thedata)
{
	struct mtpOmLsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmLsTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmLsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmLsTable_destroy(struct mtpOmLsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmLsTable_destroy(struct mtpOmLsTable_data **thedata)
{
	struct mtpOmLsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmLsTable_add(struct mtpOmLsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmLsTable table data set.
 *
 * Adds a table row structure to the mtpOmLsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmLsTable_add(struct mtpOmLsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		header_complex_add_data(&mtpOmLsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmLsTable_del(struct mtpOmLsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmLsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmLsTable_del(struct mtpOmLsTable_data *thedata)
{
	struct mtpOmLsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmLsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmLsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmLsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmLsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmLsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmLsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmLsTable_data *StorageTmp = mtpOmLsTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmLsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmLsValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmLsTimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmLsAdjacentInaccessibleEvents, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmLsAdjacentInaccessibleDuration, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmLsSlsUnavailable, &tmpsize);
	mtpOmLsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmLsTable(): store configuraiton file for mtpOmLsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmLsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmLsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmLsTable: storing data...  "));
	refresh_mtpOmLsTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmLsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmLsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmLsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmLsValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmLsTimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmLsAdjacentInaccessibleEvents, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmLsAdjacentInaccessibleDuration, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmLsSlsUnavailable, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmLsInt5minTable_data *mtpOmLsInt5minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmLsInt5minTable table.
 *
 * Creates a new mtpOmLsInt5minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmLsInt5minTable_data *
mtpOmLsInt5minTable_create(void)
{
	struct mtpOmLsInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmLsInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsInt5minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpOmLsInt5minTimeStamp = 0;
		StorageNew->mtpOmLsInt5minAdjacentInaccessibleEvents = 0;
		StorageNew->mtpOmLsInt5minAdjacentInaccessibleDuration = 0;
		StorageNew->mtpOmLsInt5minSlsUnavailable = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmLsInt5minTable_data *mtpOmLsInt5minTable_duplicate(struct mtpOmLsInt5minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmLsInt5minTable_data *
mtpOmLsInt5minTable_duplicate(struct mtpOmLsInt5minTable_data *thedata)
{
	struct mtpOmLsInt5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmLsInt5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsInt5minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmLsInt5minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmLsInt5minTable_destroy(struct mtpOmLsInt5minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmLsInt5minTable_destroy(struct mtpOmLsInt5minTable_data **thedata)
{
	struct mtpOmLsInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsInt5minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmLsInt5minTable_add(struct mtpOmLsInt5minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmLsInt5minTable table data set.
 *
 * Adds a table row structure to the mtpOmLsInt5minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmLsInt5minTable_add(struct mtpOmLsInt5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsInt5minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpOmLsInt5minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmLsInt5minInterval, sizeof(thedata->mtpOmLsInt5minInterval));
		header_complex_add_data(&mtpOmLsInt5minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmLsInt5minTable_del(struct mtpOmLsInt5minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmLsInt5minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmLsInt5minTable_del(struct mtpOmLsInt5minTable_data *thedata)
{
	struct mtpOmLsInt5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsInt5minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmLsInt5minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmLsInt5minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmLsInt5minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmLsInt5minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmLsInt5minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmLsInt5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmLsInt5minTable_data *StorageTmp = mtpOmLsInt5minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmLsInt5minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmLsInt5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmLsInt5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleEvents, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt5minSlsUnavailable, &tmpsize);
	mtpOmLsInt5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmLsInt5minTable(): store configuraiton file for mtpOmLsInt5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmLsInt5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmLsInt5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmLsInt5minTable: storing data...  "));
	refresh_mtpOmLsInt5minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmLsInt5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmLsInt5minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmLsInt5minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmLsInt5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmLsInt5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleEvents, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt5minSlsUnavailable, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmLsInt15minTable_data *mtpOmLsInt15minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmLsInt15minTable table.
 *
 * Creates a new mtpOmLsInt15minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmLsInt15minTable_data *
mtpOmLsInt15minTable_create(void)
{
	struct mtpOmLsInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmLsInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsInt15minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpOmLsInt15minTimeStamp = 0;
		StorageNew->mtpOmLsInt15minAdjacentInaccessibleEvents = 0;
		StorageNew->mtpOmLsInt15minAdjacentInaccessibleDuration = 0;
		StorageNew->mtpOmLsInt15minSlsUnavailable = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmLsInt15minTable_data *mtpOmLsInt15minTable_duplicate(struct mtpOmLsInt15minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmLsInt15minTable_data *
mtpOmLsInt15minTable_duplicate(struct mtpOmLsInt15minTable_data *thedata)
{
	struct mtpOmLsInt15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmLsInt15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsInt15minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmLsInt15minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmLsInt15minTable_destroy(struct mtpOmLsInt15minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmLsInt15minTable_destroy(struct mtpOmLsInt15minTable_data **thedata)
{
	struct mtpOmLsInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsInt15minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmLsInt15minTable_add(struct mtpOmLsInt15minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmLsInt15minTable table data set.
 *
 * Adds a table row structure to the mtpOmLsInt15minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmLsInt15minTable_add(struct mtpOmLsInt15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsInt15minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpOmLsInt15minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmLsInt15minInterval, sizeof(thedata->mtpOmLsInt15minInterval));
		header_complex_add_data(&mtpOmLsInt15minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmLsInt15minTable_del(struct mtpOmLsInt15minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmLsInt15minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmLsInt15minTable_del(struct mtpOmLsInt15minTable_data *thedata)
{
	struct mtpOmLsInt15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmLsInt15minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmLsInt15minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmLsInt15minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmLsInt15minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmLsInt15minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmLsInt15minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmLsInt15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmLsInt15minTable_data *StorageTmp = mtpOmLsInt15minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmLsInt15minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmLsInt15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmLsInt15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleEvents, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLsInt15minSlsUnavailable, &tmpsize);
	mtpOmLsInt15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmLsInt15minTable(): store configuraiton file for mtpOmLsInt15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmLsInt15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmLsInt15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmLsInt15minTable: storing data...  "));
	refresh_mtpOmLsInt15minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmLsInt15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmLsInt15minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmLsInt15minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmLsInt15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmLsInt15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleEvents, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLsInt15minSlsUnavailable, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSlStatsTable_data *mtpOmSlStatsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSlStatsTable table.
 *
 * Creates a new mtpOmSlStatsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSlStatsTable_data *
mtpOmSlStatsTable_create(void)
{
	struct mtpOmSlStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlStatsTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlStatsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlId = 0;
		StorageNew->mtpOmSlStatsDurInService = 0;
		StorageNew->mtpOmSlStatsFailAlignOrProving = 0;
		StorageNew->mtpOmSlStatsNacksReceived = 0;
		StorageNew->mtpOmSlStatsDurUnavail = 0;
		StorageNew->mtpOmSlStatsDurUnavailFailed = 0;
		StorageNew->mtpOmSlStatsDurUnavailRpo = 0;
		StorageNew->mtpOmSlStatsSibsSent = 0;
		StorageNew->mtpOmSlStatsTranSioSifOctets = 0;
		StorageNew->mtpOmSlStatsRetransOctets = 0;
		StorageNew->mtpOmSlStatsTranMsus = 0;
		StorageNew->mtpOmSlStatsRecvSioSifOctets = 0;
		StorageNew->mtpOmSlStatsRecvMsus = 0;
		StorageNew->mtpOmSlStatsCongOnsetInd0 = 0;
		StorageNew->mtpOmSlStatsCongOnsetInd1 = 0;
		StorageNew->mtpOmSlStatsCongOnsetInd2 = 0;
		StorageNew->mtpOmSlStatsCongOnsetInd3 = 0;
		StorageNew->mtpOmSlStatsDurCongStatus0 = 0;
		StorageNew->mtpOmSlStatsDurCongStatus1 = 0;
		StorageNew->mtpOmSlStatsDurCongStatus2 = 0;
		StorageNew->mtpOmSlStatsDurCongStatus3 = 0;
		StorageNew->mtpOmSlStatsCongDiscdInd0 = 0;
		StorageNew->mtpOmSlStatsCongDiscdInd1 = 0;
		StorageNew->mtpOmSlStatsCongDiscdInd2 = 0;
		StorageNew->mtpOmSlStatsCongDiscdInd3 = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSlStatsTable_data *mtpOmSlStatsTable_duplicate(struct mtpOmSlStatsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSlStatsTable_data *
mtpOmSlStatsTable_duplicate(struct mtpOmSlStatsTable_data *thedata)
{
	struct mtpOmSlStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlStatsTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlStatsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSlStatsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSlStatsTable_destroy(struct mtpOmSlStatsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSlStatsTable_destroy(struct mtpOmSlStatsTable_data **thedata)
{
	struct mtpOmSlStatsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlStatsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlStatsTable_add(struct mtpOmSlStatsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSlStatsTable table data set.
 *
 * Adds a table row structure to the mtpOmSlStatsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSlStatsTable_add(struct mtpOmSlStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlStatsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpSlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
		header_complex_add_data(&mtpOmSlStatsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlStatsTable_del(struct mtpOmSlStatsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSlStatsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSlStatsTable_del(struct mtpOmSlStatsTable_data *thedata)
{
	struct mtpOmSlStatsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlStatsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSlStatsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSlStatsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSlStatsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSlStatsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSlStatsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSlStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlStatsTable_data *StorageTmp = mtpOmSlStatsTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSlStatsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurInService, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsFailAlignOrProving, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsNacksReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurUnavail, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurUnavailFailed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurUnavailRpo, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsSibsSent, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsTranSioSifOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsRetransOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsTranMsus, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsRecvSioSifOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsRecvMsus, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongOnsetInd0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongOnsetInd1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongOnsetInd2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongOnsetInd3, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurCongStatus0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurCongStatus1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurCongStatus2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsDurCongStatus3, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongDiscdInd0, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongDiscdInd1, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongDiscdInd2, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlStatsCongDiscdInd3, &tmpsize);
	mtpOmSlStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSlStatsTable(): store configuraiton file for mtpOmSlStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSlStatsTable: storing data...  "));
	refresh_mtpOmSlStatsTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSlStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlStatsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlStatsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurInService, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsFailAlignOrProving, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsNacksReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurUnavail, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurUnavailFailed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurUnavailRpo, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsSibsSent, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsTranSioSifOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsRetransOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsTranMsus, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsRecvSioSifOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsRecvMsus, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongOnsetInd0, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongOnsetInd1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongOnsetInd2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongOnsetInd3, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurCongStatus0, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurCongStatus1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurCongStatus2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsDurCongStatus3, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongDiscdInd0, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongDiscdInd1, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongDiscdInd2, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlStatsCongDiscdInd3, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSlL3Table_data *mtpOmSlL3Table_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSlL3Table table.
 *
 * Creates a new mtpOmSlL3Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSlL3Table_data *
mtpOmSlL3Table_create(void)
{
	struct mtpOmSlL3Table_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL3Table_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Table_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlSlCode = 0;
		StorageNew->mtpOmSlL3ValidIntervals = 0;
		StorageNew->mtpOmSlL3TimeDiscontinuity = 0;
		StorageNew->mtpOmSlL3SlUnavailabilityDuration = 0;
		StorageNew->mtpOmSlL3SlLocalInhibition = 0;
		StorageNew->mtpOmSlL3SlRemoteInhibition = 0;
		StorageNew->mtpOmSlL3SlFailed = 0;
		StorageNew->mtpOmSlL3SlRemoteProcOutage = 0;
		StorageNew->mtpOmSlL3LocalMgmtInhibit = 0;
		StorageNew->mtpOmSlL3LocalMgmtUninhibit = 0;
		StorageNew->mtpOmSlL3LocalBusy = 0;
		StorageNew->mtpOmSlL3SlCongestedStarts = 0;
		StorageNew->mtpOmSlL3SlCongestedDuration = 0;
		StorageNew->mtpOmSlL3SlCongestionStops = 0;
		StorageNew->mtpOmSlL3DiscardedMSUs = 0;
		StorageNew->mtpOmSlL3CongestionEventsMSULoss = 0;
		StorageNew->mtpOmSlL3Changeovers = 0;
		StorageNew->mtpOmSlL3Changebacks = 0;
		StorageNew->mtpOmSlL3Restorations = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSlL3Table_data *mtpOmSlL3Table_duplicate(struct mtpOmSlL3Table_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSlL3Table_data *
mtpOmSlL3Table_duplicate(struct mtpOmSlL3Table_data *thedata)
{
	struct mtpOmSlL3Table_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL3Table_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Table_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSlL3Table_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSlL3Table_destroy(struct mtpOmSlL3Table_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSlL3Table_destroy(struct mtpOmSlL3Table_data **thedata)
{
	struct mtpOmSlL3Table_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Table_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL3Table_add(struct mtpOmSlL3Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSlL3Table table data set.
 *
 * Adds a table row structure to the mtpOmSlL3Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSlL3Table_add(struct mtpOmSlL3Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Table_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpSlSlCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
		header_complex_add_data(&mtpOmSlL3TableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL3Table_del(struct mtpOmSlL3Table_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSlL3Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSlL3Table_del(struct mtpOmSlL3Table_data *thedata)
{
	struct mtpOmSlL3Table_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Table_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSlL3TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSlL3TableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSlL3Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSlL3Table entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSlL3Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSlL3Table(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL3Table_data *StorageTmp = mtpOmSlL3Table_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSlL3Table: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlL3ValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL3TimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlUnavailabilityDuration, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlLocalInhibition, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlRemoteInhibition, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlFailed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlRemoteProcOutage, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3LocalMgmtInhibit, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3LocalMgmtUninhibit, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3LocalBusy, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlCongestedStarts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlCongestedDuration, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3SlCongestionStops, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3DiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3CongestionEventsMSULoss, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3Changeovers, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3Changebacks, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL3Restorations, &tmpsize);
	mtpOmSlL3Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSlL3Table(): store configuraiton file for mtpOmSlL3Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL3Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL3Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSlL3Table: storing data...  "));
	refresh_mtpOmSlL3Table(1);
	(void) tmpsize;
	for (hcindex = mtpOmSlL3TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL3Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL3Table ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlL3ValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL3TimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlUnavailabilityDuration, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlLocalInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlRemoteInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlFailed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlRemoteProcOutage, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3LocalMgmtInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3LocalMgmtUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3LocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlCongestedStarts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlCongestedDuration, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3SlCongestionStops, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3DiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3CongestionEventsMSULoss, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3Changeovers, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3Changebacks, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL3Restorations, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSlL3Int5minTable_data *mtpOmSlL3Int5minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSlL3Int5minTable table.
 *
 * Creates a new mtpOmSlL3Int5minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSlL3Int5minTable_data *
mtpOmSlL3Int5minTable_create(void)
{
	struct mtpOmSlL3Int5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL3Int5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Int5minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlSlCode = 0;
		StorageNew->mtpOmSlL3Int5minTimeStamp = 0;
		StorageNew->mtpOmSlL3Int5minSlUnavailabilityDuration = 0;
		StorageNew->mtpOmSlL3Int5minSlLocalInhibition = 0;
		StorageNew->mtpOmSlL3Int5minSlRemoteInhibition = 0;
		StorageNew->mtpOmSlL3Int5minSlFailed = 0;
		StorageNew->mtpOmSlL3Int5minSlRemoteProcOutage = 0;
		StorageNew->mtpOmSlL3Int5minLocalMgmtInhibit = 0;
		StorageNew->mtpOmSlL3Int5minLocalMgmtUninhibit = 0;
		StorageNew->mtpOmSlL3Int5minLocalBusy = 0;
		StorageNew->mtpOmSlL3Int5minSlCongestedStarts = 0;
		StorageNew->mtpOmSlL3Int5minSlCongestedDuration = 0;
		StorageNew->mtpOmSlL3Int5minSlCongestionStops = 0;
		StorageNew->mtpOmSlL3Int5minDiscardedMSUs = 0;
		StorageNew->mtpOmSlL3Int5minCongestionEventsMSULoss = 0;
		StorageNew->mtpOmSlL3Int5minChangeovers = 0;
		StorageNew->mtpOmSlL3Int5minChangebacks = 0;
		StorageNew->mtpOmSlL3Int5minRestorations = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSlL3Int5minTable_data *mtpOmSlL3Int5minTable_duplicate(struct mtpOmSlL3Int5minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSlL3Int5minTable_data *
mtpOmSlL3Int5minTable_duplicate(struct mtpOmSlL3Int5minTable_data *thedata)
{
	struct mtpOmSlL3Int5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL3Int5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Int5minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSlL3Int5minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSlL3Int5minTable_destroy(struct mtpOmSlL3Int5minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSlL3Int5minTable_destroy(struct mtpOmSlL3Int5minTable_data **thedata)
{
	struct mtpOmSlL3Int5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Int5minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL3Int5minTable_add(struct mtpOmSlL3Int5minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSlL3Int5minTable table data set.
 *
 * Adds a table row structure to the mtpOmSlL3Int5minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSlL3Int5minTable_add(struct mtpOmSlL3Int5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Int5minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpSlSlCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
		/* mtpOmSlL3Int5minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSlL3Int5minInterval, sizeof(thedata->mtpOmSlL3Int5minInterval));
		header_complex_add_data(&mtpOmSlL3Int5minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL3Int5minTable_del(struct mtpOmSlL3Int5minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSlL3Int5minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSlL3Int5minTable_del(struct mtpOmSlL3Int5minTable_data *thedata)
{
	struct mtpOmSlL3Int5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Int5minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSlL3Int5minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSlL3Int5minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSlL3Int5minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSlL3Int5minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSlL3Int5minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSlL3Int5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL3Int5minTable_data *StorageTmp = mtpOmSlL3Int5minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSlL3Int5minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSlL3Int5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL3Int5minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlUnavailabilityDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlLocalInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlRemoteInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlFailed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlRemoteProcOutage, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minLocalMgmtInhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minLocalMgmtUninhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minLocalBusy, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlCongestedStarts, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlCongestedDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minSlCongestionStops, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minCongestionEventsMSULoss, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minChangeovers, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minChangebacks, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int5minRestorations, &tmpsize);
	mtpOmSlL3Int5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSlL3Int5minTable(): store configuraiton file for mtpOmSlL3Int5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL3Int5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL3Int5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSlL3Int5minTable: storing data...  "));
	refresh_mtpOmSlL3Int5minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSlL3Int5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL3Int5minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL3Int5minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSlL3Int5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL3Int5minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlUnavailabilityDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlLocalInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlRemoteInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlFailed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlRemoteProcOutage, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minLocalMgmtInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minLocalMgmtUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minLocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlCongestedStarts, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlCongestedDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minSlCongestionStops, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minCongestionEventsMSULoss, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minChangeovers, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minChangebacks, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int5minRestorations, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSlL3Int15minTable_data *mtpOmSlL3Int15minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSlL3Int15minTable table.
 *
 * Creates a new mtpOmSlL3Int15minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSlL3Int15minTable_data *
mtpOmSlL3Int15minTable_create(void)
{
	struct mtpOmSlL3Int15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL3Int15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Int15minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlSlCode = 0;
		StorageNew->mtpOmSlL3Int15minTimeStamp = 0;
		StorageNew->mtpOmSlL3Int15minSlUnavailabilityDuration = 0;
		StorageNew->mtpOmSlL3Int15minSlLocalInhibition = 0;
		StorageNew->mtpOmSlL3Int15minSlRemoteInhibition = 0;
		StorageNew->mtpOmSlL3Int15minSlFailed = 0;
		StorageNew->mtpOmSlL3Int15minSlRemoteProcOutage = 0;
		StorageNew->mtpOmSlL3Int15minLocalMgmtInhibit = 0;
		StorageNew->mtpOmSlL3Int15minLocalMgmtUninhibit = 0;
		StorageNew->mtpOmSlL3Int15minLocalBusy = 0;
		StorageNew->mtpOmSlL3Int15minSlCongestedStarts = 0;
		StorageNew->mtpOmSlL3Int15minSlCongestedDuration = 0;
		StorageNew->mtpOmSlL3Int15minSlCongestionStops = 0;
		StorageNew->mtpOmSlL3Int15minDiscardedMSUs = 0;
		StorageNew->mtpOmSlL3Int15minCongestionEventsMSULoss = 0;
		StorageNew->mtpOmSlL3Int15minChangeovers = 0;
		StorageNew->mtpOmSlL3Int15minChangebacks = 0;
		StorageNew->mtpOmSlL3Int15minRestorations = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSlL3Int15minTable_data *mtpOmSlL3Int15minTable_duplicate(struct mtpOmSlL3Int15minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSlL3Int15minTable_data *
mtpOmSlL3Int15minTable_duplicate(struct mtpOmSlL3Int15minTable_data *thedata)
{
	struct mtpOmSlL3Int15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL3Int15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Int15minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSlL3Int15minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSlL3Int15minTable_destroy(struct mtpOmSlL3Int15minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSlL3Int15minTable_destroy(struct mtpOmSlL3Int15minTable_data **thedata)
{
	struct mtpOmSlL3Int15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Int15minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL3Int15minTable_add(struct mtpOmSlL3Int15minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSlL3Int15minTable table data set.
 *
 * Adds a table row structure to the mtpOmSlL3Int15minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSlL3Int15minTable_add(struct mtpOmSlL3Int15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Int15minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpSlSlCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
		/* mtpOmSlL3Int15minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSlL3Int15minInterval, sizeof(thedata->mtpOmSlL3Int15minInterval));
		header_complex_add_data(&mtpOmSlL3Int15minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL3Int15minTable_del(struct mtpOmSlL3Int15minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSlL3Int15minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSlL3Int15minTable_del(struct mtpOmSlL3Int15minTable_data *thedata)
{
	struct mtpOmSlL3Int15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL3Int15minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSlL3Int15minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSlL3Int15minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSlL3Int15minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSlL3Int15minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSlL3Int15minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSlL3Int15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL3Int15minTable_data *StorageTmp = mtpOmSlL3Int15minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSlL3Int15minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSlL3Int15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL3Int15minTimeStamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlUnavailabilityDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlLocalInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlRemoteInhibition, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlFailed, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlRemoteProcOutage, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minLocalMgmtInhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minLocalMgmtUninhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minLocalBusy, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlCongestedStarts, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlCongestedDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minSlCongestionStops, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minCongestionEventsMSULoss, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minChangeovers, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minChangebacks, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL3Int15minRestorations, &tmpsize);
	mtpOmSlL3Int15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSlL3Int15minTable(): store configuraiton file for mtpOmSlL3Int15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL3Int15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL3Int15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSlL3Int15minTable: storing data...  "));
	refresh_mtpOmSlL3Int15minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSlL3Int15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL3Int15minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL3Int15minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSlL3Int15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL3Int15minTimeStamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlUnavailabilityDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlLocalInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlRemoteInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlFailed, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlRemoteProcOutage, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minLocalMgmtInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minLocalMgmtUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minLocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlCongestedStarts, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlCongestedDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minSlCongestionStops, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minCongestionEventsMSULoss, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minChangeovers, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minChangebacks, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL3Int15minRestorations, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSlL2Table_data *mtpOmSlL2Table_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSlL2Table table.
 *
 * Creates a new mtpOmSlL2Table_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSlL2Table_data *
mtpOmSlL2Table_create(void)
{
	struct mtpOmSlL2Table_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL2Table_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Table_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlSlCode = 0;
		StorageNew->mtpOmSlL2ValidIntervals = 0;
		StorageNew->mtpOmSlL2TimeDiscontinuity = 0;
		StorageNew->mtpOmSlL2SlInServiceDuration = 0;
		StorageNew->mtpOmSlL2SlAlignment = 0;
		StorageNew->mtpOmSlL2SignUnitsReceived = 0;
		StorageNew->mtpOmSlL2NegAckReceived = 0;
		StorageNew->mtpOmSlL2TransmittedOctetsSIFSIO = 0;
		StorageNew->mtpOmSlL2RetransmittedOctets = 0;
		StorageNew->mtpOmSlL2TransmittedMSUs = 0;
		StorageNew->mtpOmSlL2ReceivedOctetsSIFSIO = 0;
		StorageNew->mtpOmSlL2ReceivedMSUs = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSlL2Table_data *mtpOmSlL2Table_duplicate(struct mtpOmSlL2Table_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSlL2Table_data *
mtpOmSlL2Table_duplicate(struct mtpOmSlL2Table_data *thedata)
{
	struct mtpOmSlL2Table_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL2Table_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Table_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSlL2Table_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSlL2Table_destroy(struct mtpOmSlL2Table_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSlL2Table_destroy(struct mtpOmSlL2Table_data **thedata)
{
	struct mtpOmSlL2Table_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Table_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL2Table_add(struct mtpOmSlL2Table_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSlL2Table table data set.
 *
 * Adds a table row structure to the mtpOmSlL2Table table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSlL2Table_add(struct mtpOmSlL2Table_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Table_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpSlSlCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
		header_complex_add_data(&mtpOmSlL2TableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL2Table_del(struct mtpOmSlL2Table_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSlL2Table table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSlL2Table_del(struct mtpOmSlL2Table_data *thedata)
{
	struct mtpOmSlL2Table_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Table_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSlL2TableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSlL2TableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSlL2Table(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSlL2Table entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSlL2Table).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSlL2Table(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL2Table_data *StorageTmp = mtpOmSlL2Table_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSlL2Table: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlL2ValidIntervals, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL2TimeDiscontinuity, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2SlInServiceDuration, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2SlAlignment, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2SignUnitsReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2NegAckReceived, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2TransmittedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2RetransmittedOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2TransmittedMSUs, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2ReceivedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSlL2ReceivedMSUs, &tmpsize);
	mtpOmSlL2Table_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSlL2Table(): store configuraiton file for mtpOmSlL2Table
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL2Table(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL2Table_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSlL2Table: storing data...  "));
	refresh_mtpOmSlL2Table(1);
	(void) tmpsize;
	for (hcindex = mtpOmSlL2TableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL2Table_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL2Table ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlL2ValidIntervals, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL2TimeDiscontinuity, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2SlInServiceDuration, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2SlAlignment, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2SignUnitsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2NegAckReceived, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2TransmittedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2RetransmittedOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2TransmittedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2ReceivedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSlL2ReceivedMSUs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSlL2Int5minTable_data *mtpOmSlL2Int5minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSlL2Int5minTable table.
 *
 * Creates a new mtpOmSlL2Int5minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSlL2Int5minTable_data *
mtpOmSlL2Int5minTable_create(void)
{
	struct mtpOmSlL2Int5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL2Int5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Int5minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlSlCode = 0;
		StorageNew->mtpOmSlL2Int5minTimestamp = 0;
		StorageNew->mtpOmSlL2Int5minSlInServiceDuration = 0;
		StorageNew->mtpOmSlL2Int5minSlAlignment = 0;
		StorageNew->mtpOmSlL2Int5minSignUnitsReceived = 0;
		StorageNew->mtpOmSlL2Int5minNegAckReceived = 0;
		StorageNew->mtpOmSlL2Int5minTransmittedOctetsSIFSIO = 0;
		StorageNew->mtpOmSlL2Int5minRetransmittedOctets = 0;
		StorageNew->mtpOmSlL2Int5minTransmittedMSUs = 0;
		StorageNew->mtpOmSlL2Int5minReceivedOctetsSIFSIO = 0;
		StorageNew->mtpOmSlL2Int5minReceivedMSUs = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSlL2Int5minTable_data *mtpOmSlL2Int5minTable_duplicate(struct mtpOmSlL2Int5minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSlL2Int5minTable_data *
mtpOmSlL2Int5minTable_duplicate(struct mtpOmSlL2Int5minTable_data *thedata)
{
	struct mtpOmSlL2Int5minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL2Int5minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Int5minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSlL2Int5minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSlL2Int5minTable_destroy(struct mtpOmSlL2Int5minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSlL2Int5minTable_destroy(struct mtpOmSlL2Int5minTable_data **thedata)
{
	struct mtpOmSlL2Int5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Int5minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL2Int5minTable_add(struct mtpOmSlL2Int5minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSlL2Int5minTable table data set.
 *
 * Adds a table row structure to the mtpOmSlL2Int5minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSlL2Int5minTable_add(struct mtpOmSlL2Int5minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Int5minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpSlSlCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
		/* mtpOmSlL2Int5minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSlL2Int5minInterval, sizeof(thedata->mtpOmSlL2Int5minInterval));
		header_complex_add_data(&mtpOmSlL2Int5minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL2Int5minTable_del(struct mtpOmSlL2Int5minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSlL2Int5minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSlL2Int5minTable_del(struct mtpOmSlL2Int5minTable_data *thedata)
{
	struct mtpOmSlL2Int5minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Int5minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSlL2Int5minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSlL2Int5minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSlL2Int5minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSlL2Int5minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSlL2Int5minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSlL2Int5minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL2Int5minTable_data *StorageTmp = mtpOmSlL2Int5minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSlL2Int5minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSlL2Int5minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL2Int5minTimestamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minSlInServiceDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minSlAlignment, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minSignUnitsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minNegAckReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minTransmittedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minRetransmittedOctets, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minTransmittedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minReceivedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int5minReceivedMSUs, &tmpsize);
	mtpOmSlL2Int5minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSlL2Int5minTable(): store configuraiton file for mtpOmSlL2Int5minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL2Int5minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL2Int5minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSlL2Int5minTable: storing data...  "));
	refresh_mtpOmSlL2Int5minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSlL2Int5minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL2Int5minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL2Int5minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSlL2Int5minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL2Int5minTimestamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minSlInServiceDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minSlAlignment, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minSignUnitsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minNegAckReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minTransmittedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minRetransmittedOctets, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minTransmittedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minReceivedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int5minReceivedMSUs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSlL2Int15minTable_data *mtpOmSlL2Int15minTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSlL2Int15minTable table.
 *
 * Creates a new mtpOmSlL2Int15minTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSlL2Int15minTable_data *
mtpOmSlL2Int15minTable_create(void)
{
	struct mtpOmSlL2Int15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL2Int15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Int15minTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpLsId = 0;
		StorageNew->mtpSlSlCode = 0;
		StorageNew->mtpOmSlL2Int15minTimestamp = 0;
		StorageNew->mtpOmSlL2Int15minSlInServiceDuration = 0;
		StorageNew->mtpOmSlL2Int15minSlAlignment = 0;
		StorageNew->mtpOmSlL2Int15minSignUnitsReceived = 0;
		StorageNew->mtpOmSlL2Int15minNegAckReceived = 0;
		StorageNew->mtpOmSlL2Int15minTransmittedOctetsSIFSIO = 0;
		StorageNew->mtpOmSlL2Int15minRetransmittedOctets = 0;
		StorageNew->mtpOmSlL2Int15minTransmittedMSUs = 0;
		StorageNew->mtpOmSlL2Int15minReceivedOctetsSIFSIO = 0;
		StorageNew->mtpOmSlL2Int15minReceivedMSUs = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSlL2Int15minTable_data *mtpOmSlL2Int15minTable_duplicate(struct mtpOmSlL2Int15minTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSlL2Int15minTable_data *
mtpOmSlL2Int15minTable_duplicate(struct mtpOmSlL2Int15minTable_data *thedata)
{
	struct mtpOmSlL2Int15minTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlL2Int15minTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Int15minTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSlL2Int15minTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSlL2Int15minTable_destroy(struct mtpOmSlL2Int15minTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSlL2Int15minTable_destroy(struct mtpOmSlL2Int15minTable_data **thedata)
{
	struct mtpOmSlL2Int15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Int15minTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL2Int15minTable_add(struct mtpOmSlL2Int15minTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSlL2Int15minTable table data set.
 *
 * Adds a table row structure to the mtpOmSlL2Int15minTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSlL2Int15minTable_add(struct mtpOmSlL2Int15minTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Int15minTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		/* mtpSlSlCode */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpSlSlCode, sizeof(thedata->mtpSlSlCode));
		/* mtpOmSlL2Int15minInterval */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpOmSlL2Int15minInterval, sizeof(thedata->mtpOmSlL2Int15minInterval));
		header_complex_add_data(&mtpOmSlL2Int15minTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlL2Int15minTable_del(struct mtpOmSlL2Int15minTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSlL2Int15minTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSlL2Int15minTable_del(struct mtpOmSlL2Int15minTable_data *thedata)
{
	struct mtpOmSlL2Int15minTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlL2Int15minTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSlL2Int15minTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSlL2Int15minTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSlL2Int15minTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSlL2Int15minTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSlL2Int15minTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSlL2Int15minTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlL2Int15minTable_data *StorageTmp = mtpOmSlL2Int15minTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSlL2Int15minTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpSlSlCode, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpOmSlL2Int15minInterval, &tmpsize);
	line = read_config_read_data(ASN_TIMETICKS, line, &StorageTmp->mtpOmSlL2Int15minTimestamp, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minSlInServiceDuration, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minSlAlignment, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minSignUnitsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minNegAckReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minTransmittedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minRetransmittedOctets, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minTransmittedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minReceivedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlL2Int15minReceivedMSUs, &tmpsize);
	mtpOmSlL2Int15minTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSlL2Int15minTable(): store configuraiton file for mtpOmSlL2Int15minTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlL2Int15minTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlL2Int15minTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSlL2Int15minTable: storing data...  "));
	refresh_mtpOmSlL2Int15minTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSlL2Int15minTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlL2Int15minTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlL2Int15minTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpSlSlCode, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpOmSlL2Int15minInterval, &tmpsize);
			cptr = read_config_store_data(ASN_TIMETICKS, cptr, &StorageTmp->mtpOmSlL2Int15minTimestamp, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minSlInServiceDuration, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minSlAlignment, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minSignUnitsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minNegAckReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minTransmittedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minRetransmittedOctets, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minTransmittedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minReceivedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlL2Int15minReceivedMSUs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSdtStatsTable_data *mtpOmSdtStatsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSdtStatsTable table.
 *
 * Creates a new mtpOmSdtStatsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSdtStatsTable_data *
mtpOmSdtStatsTable_create(void)
{
	struct mtpOmSdtStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSdtStatsTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSdtStatsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSdtId = 0;
		StorageNew->mtpOmSdtStatsTxBytes = 0;
		StorageNew->mtpOmSdtStatsTxSus = 0;
		StorageNew->mtpOmSdtStatsTxSusRepeated = 0;
		StorageNew->mtpOmSdtStatsTxUnderruns = 0;
		StorageNew->mtpOmSdtStatsTxAborts = 0;
		StorageNew->mtpOmSdtStatsTxBufferOverflows = 0;
		StorageNew->mtpOmSdtStatsTxSusInError = 0;
		StorageNew->mtpOmSdtStatsRxBytes = 0;
		StorageNew->mtpOmSdtStatsRxSusCompressed = 0;
		StorageNew->mtpOmSdtStatsRxOverruns = 0;
		StorageNew->mtpOmSdtStatsRxAborts = 0;
		StorageNew->mtpOmSdtStatsRxBufferOverflows = 0;
		StorageNew->mtpOmSdtStatsRxSusInError = 0;
		StorageNew->mtpOmSdtStatsRxSyncTransitions = 0;
		StorageNew->mtpOmSdtStatsRxBitsOctetCounted = 0;
		StorageNew->mtpOmSdtStatsRxCrcErrors = 0;
		StorageNew->mtpOmSdtStatsRxFrameErrors = 0;
		StorageNew->mtpOmSdtStatsRxFrameOverflows = 0;
		StorageNew->mtpOmSdtStatsRxFrameTooLong = 0;
		StorageNew->mtpOmSdtStatsRxFrameTooShort = 0;
		StorageNew->mtpOmSdtStatsRxResidueErrors = 0;
		StorageNew->mtpOmSdtStatsCarrierCtsLost = 0;
		StorageNew->mtpOmSdtStatsCarrierDcdLost = 0;
		StorageNew->mtpOmSdtStatsCarrierLost = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSdtStatsTable_data *mtpOmSdtStatsTable_duplicate(struct mtpOmSdtStatsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSdtStatsTable_data *
mtpOmSdtStatsTable_duplicate(struct mtpOmSdtStatsTable_data *thedata)
{
	struct mtpOmSdtStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSdtStatsTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSdtStatsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSdtStatsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSdtStatsTable_destroy(struct mtpOmSdtStatsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSdtStatsTable_destroy(struct mtpOmSdtStatsTable_data **thedata)
{
	struct mtpOmSdtStatsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSdtStatsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSdtStatsTable_add(struct mtpOmSdtStatsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSdtStatsTable table data set.
 *
 * Adds a table row structure to the mtpOmSdtStatsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSdtStatsTable_add(struct mtpOmSdtStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSdtStatsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSdtId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSdtId, sizeof(thedata->mtpSdtId));
		header_complex_add_data(&mtpOmSdtStatsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSdtStatsTable_del(struct mtpOmSdtStatsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSdtStatsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSdtStatsTable_del(struct mtpOmSdtStatsTable_data *thedata)
{
	struct mtpOmSdtStatsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSdtStatsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSdtStatsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSdtStatsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSdtStatsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSdtStatsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSdtStatsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSdtStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSdtStatsTable_data *StorageTmp = mtpOmSdtStatsTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSdtStatsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSdtId, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxBytes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxSus, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxSusRepeated, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxUnderruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxAborts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsTxSusInError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxBytes, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxSusCompressed, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxOverruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxAborts, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxSusInError, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxSyncTransitions, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxBitsOctetCounted, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxCrcErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxFrameErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxFrameOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxFrameTooLong, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxFrameTooShort, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsRxResidueErrors, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsCarrierCtsLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsCarrierDcdLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdtStatsCarrierLost, &tmpsize);
	mtpOmSdtStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSdtStatsTable(): store configuraiton file for mtpOmSdtStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSdtStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSdtStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSdtStatsTable: storing data...  "));
	refresh_mtpOmSdtStatsTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSdtStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSdtStatsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSdtStatsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSdtId, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxBytes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxSus, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxSusRepeated, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxUnderruns, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxAborts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxBufferOverflows, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsTxSusInError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxBytes, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxSusCompressed, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxOverruns, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxAborts, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxBufferOverflows, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxSusInError, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxSyncTransitions, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxBitsOctetCounted, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxCrcErrors, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxFrameErrors, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxFrameOverflows, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxFrameTooLong, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxFrameTooShort, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsRxResidueErrors, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsCarrierCtsLost, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsCarrierDcdLost, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdtStatsCarrierLost, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSdlStatsTable_data *mtpOmSdlStatsTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSdlStatsTable table.
 *
 * Creates a new mtpOmSdlStatsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSdlStatsTable_data *
mtpOmSdlStatsTable_create(void)
{
	struct mtpOmSdlStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSdlStatsTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSdlStatsTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpMsId = 0;
		StorageNew->mtpSpId = 0;
		if ((StorageNew->mtpSdlId = (uint8_t *) strdup("")) != NULL)
			StorageNew->mtpSdlIdLen = strlen("");
		StorageNew->mtpOmSdlStatsRxOctets = 0;
		StorageNew->mtpOmSdlStatsTxOctets = 0;
		StorageNew->mtpOmSdlStatsRXOverruns = 0;
		StorageNew->mtpOmSdlStatsTxUnderruns = 0;
		StorageNew->mtpOmSdlStatsRxBufferOverflows = 0;
		StorageNew->mtpOmSdlStatsTxBufferOverflows = 0;
		StorageNew->mtpOmSdlStatsLeadCtsLost = 0;
		StorageNew->mtpOmSdlStatsLeadDcdLost = 0;
		StorageNew->mtpOmSdlStatsCarrierLost = 0;
		StorageNew->mtpOmSdlStatsBipolarViolations = 0;

	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn struct mtpOmSdlStatsTable_data *mtpOmSdlStatsTable_duplicate(struct mtpOmSdlStatsTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicat a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSdlStatsTable_data *
mtpOmSdlStatsTable_duplicate(struct mtpOmSdlStatsTable_data *thedata)
{
	struct mtpOmSdlStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSdlStatsTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSdlStatsTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSdlStatsTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSdlStatsTable_destroy(struct mtpOmSdlStatsTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSdlStatsTable_destroy(struct mtpOmSdlStatsTable_data **thedata)
{
	struct mtpOmSdlStatsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSdlStatsTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpSdlId);
		StorageDel->mtpSdlIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSdlStatsTable_add(struct mtpOmSdlStatsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSdlStatsTable table data set.
 *
 * Adds a table row structure to the mtpOmSdlStatsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSdlStatsTable_add(struct mtpOmSdlStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSdlStatsTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpMsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpMsId, sizeof(thedata->mtpMsId));
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpSdlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpSdlId, thedata->mtpSdlIdLen);
		header_complex_add_data(&mtpOmSdlStatsTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSdlStatsTable_del(struct mtpOmSdlStatsTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSdlStatsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSdlStatsTable_del(struct mtpOmSdlStatsTable_data *thedata)
{
	struct mtpOmSdlStatsTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSdlStatsTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSdlStatsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSdlStatsTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSdlStatsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSdlStatsTable entries.
 *
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSdlStatsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSdlStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSdlStatsTable_data *StorageTmp = mtpOmSdlStatsTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSdlStatsTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpMsId, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpSdlId);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpSdlId, &StorageTmp->mtpSdlIdLen);
	if (StorageTmp->mtpSdlId == NULL) {
		config_perror("invalid specification for mtpSdlId");
		return;
	}
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsRxOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsTxOctets, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsRXOverruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsTxUnderruns, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsRxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsTxBufferOverflows, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsLeadCtsLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsLeadDcdLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsCarrierLost, &tmpsize);
	line = read_config_read_data(ASN_COUNTER, line, &StorageTmp->mtpOmSdlStatsBipolarViolations, &tmpsize);
	mtpOmSdlStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSdlStatsTable(): store configuraiton file for mtpOmSdlStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSdlStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSdlStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSdlStatsTable: storing data...  "));
	refresh_mtpOmSdlStatsTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSdlStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSdlStatsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSdlStatsTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpMsId, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpSdlId, &StorageTmp->mtpSdlIdLen);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsRxOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsTxOctets, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsRXOverruns, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsTxUnderruns, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsRxBufferOverflows, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsTxBufferOverflows, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsLeadCtsLost, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsLeadDcdLost, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsCarrierLost, &tmpsize);
			cptr = read_config_store_data(ASN_COUNTER, cptr, &StorageTmp->mtpOmSdlStatsBipolarViolations, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_mtpOmSpTable_row(struct mtpOmSpTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpTable_data *
refresh_mtpOmSpTable_row(struct mtpOmSpTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpTable(int force)
{
	if (!force && mtpOmSpTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPVALIDINTERVALS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpValidIntervals);
		rval = (u_char *) &StorageTmp->mtpOmSpValidIntervals;
		break;
	case (u_char) MTPOMSPTIMEDISCONTINUITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpTimeDiscontinuity);
		rval = (u_char *) &StorageTmp->mtpOmSpTimeDiscontinuity;
		break;
	case (u_char) MTPOMSPDISCARDEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpDiscardedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSpDiscardedMSUs;
		break;
	case (u_char) MTPOMSPRECEIVEDTFCSTATUS0:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFCstatus0);
		rval = (u_char *) &StorageTmp->mtpOmSpReceivedTFCstatus0;
		break;
	case (u_char) MTPOMSPRECEIVEDTFCSTATUS1:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFCstatus1);
		rval = (u_char *) &StorageTmp->mtpOmSpReceivedTFCstatus1;
		break;
	case (u_char) MTPOMSPRECEIVEDTFCSTATUS2:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFCstatus2);
		rval = (u_char *) &StorageTmp->mtpOmSpReceivedTFCstatus2;
		break;
	case (u_char) MTPOMSPOCTETSXFERRED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpOctetsXferred);
		rval = (u_char *) &StorageTmp->mtpOmSpOctetsXferred;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSpInt5minTable_row(struct mtpOmSpInt5minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpInt5minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpInt5minTable_data *
refresh_mtpOmSpInt5minTable_row(struct mtpOmSpInt5minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpInt5minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpInt5minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpInt5minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpInt5minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpInt5minTable(int force)
{
	if (!force && mtpOmSpInt5minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpInt5minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpInt5minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpInt5minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpInt5minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpInt5minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpInt5minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpInt5minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPINT5MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmSpInt5minTimeStamp;
		break;
	case (u_char) MTPOMSPINT5MINDISCARDEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minDiscardedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSpInt5minDiscardedMSUs;
		break;
	case (u_char) MTPOMSPINT5MINRECEIVEDTFCSTATUS0:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minReceivedTFCstatus0);
		rval = (u_char *) &StorageTmp->mtpOmSpInt5minReceivedTFCstatus0;
		break;
	case (u_char) MTPOMSPINT5MINRECEIVEDTFCSTATUS1:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minReceivedTFCstatus1);
		rval = (u_char *) &StorageTmp->mtpOmSpInt5minReceivedTFCstatus1;
		break;
	case (u_char) MTPOMSPINT5MINRECEIVEDTFCSTATUS2:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minReceivedTFCstatus2);
		rval = (u_char *) &StorageTmp->mtpOmSpInt5minReceivedTFCstatus2;
		break;
	case (u_char) MTPOMSPINT5MINOCTETSXFERRED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt5minOctetsXferred);
		rval = (u_char *) &StorageTmp->mtpOmSpInt5minOctetsXferred;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSpInt15minTable_row(struct mtpOmSpInt15minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpInt15minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpInt15minTable_data *
refresh_mtpOmSpInt15minTable_row(struct mtpOmSpInt15minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpInt15minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpInt15minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpInt15minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpInt15minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpInt15minTable(int force)
{
	if (!force && mtpOmSpInt15minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpInt15minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpInt15minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpInt15minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpInt15minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpInt15minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpInt15minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpInt15minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPINT15MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmSpInt15minTimeStamp;
		break;
	case (u_char) MTPOMSPINT15MINDISCARDEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minDiscardedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSpInt15minDiscardedMSUs;
		break;
	case (u_char) MTPOMSPINT15MINRECEIVEDTFCSTATUS0:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minReceivedTFCstatus0);
		rval = (u_char *) &StorageTmp->mtpOmSpInt15minReceivedTFCstatus0;
		break;
	case (u_char) MTPOMSPINT15MINRECEIVEDTFCSTATUS1:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minReceivedTFCstatus1);
		rval = (u_char *) &StorageTmp->mtpOmSpInt15minReceivedTFCstatus1;
		break;
	case (u_char) MTPOMSPINT15MINRECEIVEDTFCSTATUS2:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minReceivedTFCstatus2);
		rval = (u_char *) &StorageTmp->mtpOmSpInt15minReceivedTFCstatus2;
		break;
	case (u_char) MTPOMSPINT15MINOCTETSXFERRED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpInt15minOctetsXferred);
		rval = (u_char *) &StorageTmp->mtpOmSpInt15minOctetsXferred;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSpSiTable_row(struct mtpOmSpSiTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpSiTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpSiTable_data *
refresh_mtpOmSpSiTable_row(struct mtpOmSpSiTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpSiTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpSiTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpSiTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpSiTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpSiTable(int force)
{
	if (!force && mtpOmSpSiTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpSiTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpSiTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpSiTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpSiTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpSiTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpSiTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpSiTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpSiTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPSIVALIDINTERVALS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiValidIntervals);
		rval = (u_char *) &StorageTmp->mtpOmSpSiValidIntervals;
		break;
	case (u_char) MTPOMSPSITIMEDISCONTINUITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiTimeDiscontinuity);
		rval = (u_char *) &StorageTmp->mtpOmSpSiTimeDiscontinuity;
		break;
	case (u_char) MTPOMSPSITRANSMITTEDUPUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiTransmittedUPUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmSpSiTransmittedUPUnavailable;
		break;
	case (u_char) MTPOMSPSIRECEIVEDUPUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiReceivedUPUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmSpSiReceivedUPUnavailable;
		break;
	case (u_char) MTPOMSPSIHANDLEDOCTETSSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiHandledOctetsSIO);
		rval = (u_char *) &StorageTmp->mtpOmSpSiHandledOctetsSIO;
		break;
	case (u_char) MTPOMSPSISTATUS:	/* Create */
		*write_method = write_mtpOmSpSiStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiStatus);
		rval = (u_char *) &StorageTmp->mtpOmSpSiStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSpSiInt5minTable_row(struct mtpOmSpSiInt5minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpSiInt5minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpSiInt5minTable_data *
refresh_mtpOmSpSiInt5minTable_row(struct mtpOmSpSiInt5minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpSiInt5minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpSiInt5minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpSiInt5minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpSiInt5minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpSiInt5minTable(int force)
{
	if (!force && mtpOmSpSiInt5minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpSiInt5minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpSiInt5minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpSiInt5minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpSiInt5minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpSiInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpSiInt5minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpSiInt5minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPSIINT5MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt5minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmSpSiInt5minTimeStamp;
		break;
	case (u_char) MTPOMSPSIINT5MINTRANSMITTEDUPUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt5minTransmittedUPUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmSpSiInt5minTransmittedUPUnavailable;
		break;
	case (u_char) MTPOMSPSIINT5MINRECEIVEDUPUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt5minReceivedUPUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmSpSiInt5minReceivedUPUnavailable;
		break;
	case (u_char) MTPOMSPSIINT5MINHANDLEDOCTETSSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt5minHandledOctetsSIO);
		rval = (u_char *) &StorageTmp->mtpOmSpSiInt5minHandledOctetsSIO;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSpSiInt15minTable_row(struct mtpOmSpSiInt15minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpSiInt15minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpSiInt15minTable_data *
refresh_mtpOmSpSiInt15minTable_row(struct mtpOmSpSiInt15minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpSiInt15minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpSiInt15minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpSiInt15minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpSiInt15minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpSiInt15minTable(int force)
{
	if (!force && mtpOmSpSiInt15minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpSiInt15minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpSiInt15minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpSiInt15minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpSiInt15minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpSiInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpSiInt15minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpSiInt15minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPSIINT15MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt15minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmSpSiInt15minTimeStamp;
		break;
	case (u_char) MTPOMSPSIINT15MINTRANSMITTEDUPUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt15minTransmittedUPUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmSpSiInt15minTransmittedUPUnavailable;
		break;
	case (u_char) MTPOMSPSIINT15MINRECEIVEDUPUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt15minReceivedUPUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmSpSiInt15minReceivedUPUnavailable;
		break;
	case (u_char) MTPOMSPSIINT15MINHANDLEDOCTETSSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpSiInt15minHandledOctetsSIO);
		rval = (u_char *) &StorageTmp->mtpOmSpSiInt15minHandledOctetsSIO;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSpStudyTable_row(struct mtpOmSpStudyTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpStudyTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpStudyTable_data *
refresh_mtpOmSpStudyTable_row(struct mtpOmSpStudyTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpStudyTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpStudyTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpStudyTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpStudyTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpStudyTable(int force)
{
	if (!force && mtpOmSpStudyTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpStudyTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpStudyTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpStudyTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpStudyTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpStudyTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpStudyTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpStudyTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpStudyTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpStudyTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPSTUDYVALIDINTERVALS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyValidIntervals);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyValidIntervals;
		break;
	case (u_char) MTPOMSPSTUDYTIMEDISCONTINUITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyTimeDiscontinuity);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyTimeDiscontinuity;
		break;
	case (u_char) MTPOMSPSTUDYHANDLEDOCTETSOPCDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyHandledOctetsOpcDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyHandledOctetsOpcDpcSio;
		break;
	case (u_char) MTPOMSPSTUDYHANDLEDMSUSOPCDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyHandledMSUsOpcDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyHandledMSUsOpcDpcSio;
		break;
	case (u_char) MTPOMSPSTUDYSTATUS:	/* Create */
		*write_method = write_mtpOmSpStudyStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyStatus);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSpStudyInt5minTable_row(struct mtpOmSpStudyInt5minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpStudyInt5minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpStudyInt5minTable_data *
refresh_mtpOmSpStudyInt5minTable_row(struct mtpOmSpStudyInt5minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpStudyInt5minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpStudyInt5minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpStudyInt5minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpStudyInt5minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpStudyInt5minTable(int force)
{
	if (!force && mtpOmSpStudyInt5minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpStudyInt5minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpStudyInt5minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpStudyInt5minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpStudyInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpStudyInt5minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpStudyInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpStudyInt5minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpStudyInt5minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpStudyInt5minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPSTUDYINT5MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt5minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyInt5minTimeStamp;
		break;
	case (u_char) MTPOMSPSTUDYINT5MINHANDLEDOCTETSOPCDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt5minHandledOctetsOpcDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyInt5minHandledOctetsOpcDpcSio;
		break;
	case (u_char) MTPOMSPSTUDYINT5MINHANDLEDMSUSOPCDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt5minHandledMSUsOpcDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyInt5minHandledMSUsOpcDpcSio;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSpStudyInt15minTable_row(struct mtpOmSpStudyInt15minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpStudyInt15minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpStudyInt15minTable_data *
refresh_mtpOmSpStudyInt15minTable_row(struct mtpOmSpStudyInt15minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpStudyInt15minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpStudyInt15minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpStudyInt15minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpStudyInt15minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpStudyInt15minTable(int force)
{
	if (!force && mtpOmSpStudyInt15minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpStudyInt15minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpStudyInt15minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpStudyInt15minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpStudyInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpStudyInt15minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpStudyInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpStudyInt15minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpStudyInt15minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpStudyInt15minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPSTUDYINT15MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt15minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyInt15minTimeStamp;
		break;
	case (u_char) MTPOMSPSTUDYINT15MINHANDLEDOCTETSOPCDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt15minHandledOctetsOpcDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyInt15minHandledOctetsOpcDpcSio;
		break;
	case (u_char) MTPOMSPSTUDYINT15MINHANDLEDMSUSOPCDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyInt15minHandledMSUsOpcDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyInt15minHandledMSUsOpcDpcSio;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSpStudyMapTable_row(struct mtpOmSpStudyMapTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpStudyMapTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpStudyMapTable_data *
refresh_mtpOmSpStudyMapTable_row(struct mtpOmSpStudyMapTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpStudyMapTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpStudyMapTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpStudyMapTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpStudyMapTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpStudyMapTable(int force)
{
	if (!force && mtpOmSpStudyMapTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpStudyMapTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpStudyMapTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpStudyMapTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpStudyMapTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpStudyMapTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpStudyMapTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpStudyMapTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpStudyMapTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpStudyMapTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPSTUDYMAPSTATUS:	/* Create */
		*write_method = write_mtpOmSpStudyMapStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpStudyMapStatus);
		rval = (u_char *) &StorageTmp->mtpOmSpStudyMapStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmRsTable_row(struct mtpOmRsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmRsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmRsTable_data *
refresh_mtpOmRsTable_row(struct mtpOmRsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmRsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmRsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmRsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmRsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsTable(int force)
{
	if (!force && mtpOmRsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmRsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmRsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmRsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmRsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmRsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmRsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMRSVALIDINTERVALS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsValidIntervals);
		rval = (u_char *) &StorageTmp->mtpOmRsValidIntervals;
		break;
	case (u_char) MTPOMRSTIMEDISCONTINUITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsTimeDiscontinuity);
		rval = (u_char *) &StorageTmp->mtpOmRsTimeDiscontinuity;
		break;
	case (u_char) MTPOMRSRECEIVEDOCTETSOPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsReceivedOctetsOPC);
		rval = (u_char *) &StorageTmp->mtpOmRsReceivedOctetsOPC;
		break;
	case (u_char) MTPOMRSTRANSMITTEDOCTETSDPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsTransmittedOctetsDPC);
		rval = (u_char *) &StorageTmp->mtpOmRsTransmittedOctetsDPC;
		break;
	case (u_char) MTPOMRSRECEIVEDMSUSOPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsReceivedMSUsOpc);
		rval = (u_char *) &StorageTmp->mtpOmRsReceivedMSUsOpc;
		break;
	case (u_char) MTPOMRSTRANSMITTEDMSUSDPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsTransmittedMSUsDpc);
		rval = (u_char *) &StorageTmp->mtpOmRsTransmittedMSUsDpc;
		break;
	case (u_char) MTPOMRSROUTESETUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsRouteSetUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmRsRouteSetUnavailable;
		break;
	case (u_char) MTPOMRSROUTESETUNAVAILABLEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsRouteSetUnavailableDuration);
		rval = (u_char *) &StorageTmp->mtpOmRsRouteSetUnavailableDuration;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmRsInt5minTable_row(struct mtpOmRsInt5minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmRsInt5minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmRsInt5minTable_data *
refresh_mtpOmRsInt5minTable_row(struct mtpOmRsInt5minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmRsInt5minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmRsInt5minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmRsInt5minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmRsInt5minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsInt5minTable(int force)
{
	if (!force && mtpOmRsInt5minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmRsInt5minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmRsInt5minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmRsInt5minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsInt5minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmRsInt5minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmRsInt5minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmRsInt5minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMRSINT5MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmRsInt5minTimeStamp;
		break;
	case (u_char) MTPOMRSINT5MINRECEIVEDOCTETSOPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minReceivedOctetsOPC);
		rval = (u_char *) &StorageTmp->mtpOmRsInt5minReceivedOctetsOPC;
		break;
	case (u_char) MTPOMRSINT5MINTRANSMITTEDOCTETSDPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minTransmittedOctetsDPC);
		rval = (u_char *) &StorageTmp->mtpOmRsInt5minTransmittedOctetsDPC;
		break;
	case (u_char) MTPOMRSINT5MINRECEIVEDMSUSOPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minReceivedMSUsOpc);
		rval = (u_char *) &StorageTmp->mtpOmRsInt5minReceivedMSUsOpc;
		break;
	case (u_char) MTPOMRSINT5MINTRANSMITTEDMSUSDPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minTransmittedMSUsDpc);
		rval = (u_char *) &StorageTmp->mtpOmRsInt5minTransmittedMSUsDpc;
		break;
	case (u_char) MTPOMRSINT5MINROUTESETUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minRouteSetUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmRsInt5minRouteSetUnavailable;
		break;
	case (u_char) MTPOMRSINT5MINROUTESETUNAVAILABLEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt5minRouteSetUnavailableDuration);
		rval = (u_char *) &StorageTmp->mtpOmRsInt5minRouteSetUnavailableDuration;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmRsInt15minTable_row(struct mtpOmRsInt15minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmRsInt15minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmRsInt15minTable_data *
refresh_mtpOmRsInt15minTable_row(struct mtpOmRsInt15minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmRsInt15minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmRsInt15minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmRsInt15minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmRsInt15minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsInt15minTable(int force)
{
	if (!force && mtpOmRsInt15minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmRsInt15minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmRsInt15minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmRsInt15minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsInt15minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmRsInt15minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmRsInt15minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmRsInt15minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMRSINT15MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmRsInt15minTimeStamp;
		break;
	case (u_char) MTPOMRSINT15MINRECEIVEDOCTETSOPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minReceivedOctetsOPC);
		rval = (u_char *) &StorageTmp->mtpOmRsInt15minReceivedOctetsOPC;
		break;
	case (u_char) MTPOMRSINT15MINTRANSMITTEDOCTETSDPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minTransmittedOctetsDPC);
		rval = (u_char *) &StorageTmp->mtpOmRsInt15minTransmittedOctetsDPC;
		break;
	case (u_char) MTPOMRSINT15MINRECEIVEDMSUSOPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minReceivedMSUsOpc);
		rval = (u_char *) &StorageTmp->mtpOmRsInt15minReceivedMSUsOpc;
		break;
	case (u_char) MTPOMRSINT15MINTRANSMITTEDMSUSDPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minTransmittedMSUsDpc);
		rval = (u_char *) &StorageTmp->mtpOmRsInt15minTransmittedMSUsDpc;
		break;
	case (u_char) MTPOMRSINT15MINROUTESETUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minRouteSetUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmRsInt15minRouteSetUnavailable;
		break;
	case (u_char) MTPOMRSINT15MINROUTESETUNAVAILABLEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsInt15minRouteSetUnavailableDuration);
		rval = (u_char *) &StorageTmp->mtpOmRsInt15minRouteSetUnavailableDuration;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmRsSiTable_row(struct mtpOmRsSiTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmRsSiTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmRsSiTable_data *
refresh_mtpOmRsSiTable_row(struct mtpOmRsSiTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmRsSiTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmRsSiTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmRsSiTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmRsSiTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsSiTable(int force)
{
	if (!force && mtpOmRsSiTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmRsSiTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmRsSiTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmRsSiTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsSiTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsSiTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsSiTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmRsSiTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmRsSiTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmRsSiTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMRSSIVALIDINTERVALS:	/* Create */
		*write_method = write_mtpOmRsSiValidIntervals;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiValidIntervals);
		rval = (u_char *) &StorageTmp->mtpOmRsSiValidIntervals;
		break;
	case (u_char) MTPOMRSSITIMEDISCONTINUITY:	/* Create */
		*write_method = write_mtpOmRsSiTimeDiscontinuity;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiTimeDiscontinuity);
		rval = (u_char *) &StorageTmp->mtpOmRsSiTimeDiscontinuity;
		break;
	case (u_char) MTPOMRSSIRECEIVEDOCTETSOPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiReceivedOctetsOpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiReceivedOctetsOpcSio;
		break;
	case (u_char) MTPOMRSSITRANSMITTEDOCTETSDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiTransmittedOctetsDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiTransmittedOctetsDpcSio;
		break;
	case (u_char) MTPOMRSSIRECEIVEDMSUSOPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiReceivedMSUsOpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiReceivedMSUsOpcSio;
		break;
	case (u_char) MTPOMRSSITRANSMITTEDMSUSDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiTransmittedMSUsDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiTransmittedMSUsDpcSio;
		break;
	case (u_char) MTPOMRSSISTATUS:	/* Create */
		*write_method = write_mtpOmRsSiStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiStatus);
		rval = (u_char *) &StorageTmp->mtpOmRsSiStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmRsSiInt5minTable_row(struct mtpOmRsSiInt5minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmRsSiInt5minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmRsSiInt5minTable_data *
refresh_mtpOmRsSiInt5minTable_row(struct mtpOmRsSiInt5minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmRsSiInt5minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmRsSiInt5minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmRsSiInt5minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmRsSiInt5minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsSiInt5minTable(int force)
{
	if (!force && mtpOmRsSiInt5minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmRsSiInt5minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmRsSiInt5minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmRsSiInt5minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsSiInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsSiInt5minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsSiInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmRsSiInt5minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmRsSiInt5minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmRsSiInt5minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMRSSIINT5MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt5minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmRsSiInt5minTimeStamp;
		break;
	case (u_char) MTPOMRSSIINT5MINRECEIVEDOCTETSOPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt5minReceivedOctetsOpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiInt5minReceivedOctetsOpcSio;
		break;
	case (u_char) MTPOMRSSIINT5MINTRANSMITTEDOCTETSDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt5minTransmittedOctetsDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiInt5minTransmittedOctetsDpcSio;
		break;
	case (u_char) MTPOMRSSIINT5MINRECEIVEDMSUSOPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt5minReceivedMSUsOpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiInt5minReceivedMSUsOpcSio;
		break;
	case (u_char) MTPOMRSSIINT5MINTRANSMITTEDMSUSDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt5minTransmittedMSUsDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiInt5minTransmittedMSUsDpcSio;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmRsSiInt15minTable_row(struct mtpOmRsSiInt15minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmRsSiInt15minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmRsSiInt15minTable_data *
refresh_mtpOmRsSiInt15minTable_row(struct mtpOmRsSiInt15minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmRsSiInt15minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmRsSiInt15minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmRsSiInt15minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmRsSiInt15minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmRsSiInt15minTable(int force)
{
	if (!force && mtpOmRsSiInt15minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmRsSiInt15minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmRsSiInt15minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmRsSiInt15minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmRsSiInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmRsSiInt15minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmRsSiInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmRsSiInt15minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmRsSiInt15minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmRsSiInt15minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMRSSIINT15MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt15minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmRsSiInt15minTimeStamp;
		break;
	case (u_char) MTPOMRSSIINT15MINRECEIVEDOCTETSOPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt15minReceivedOctetsOpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiInt15minReceivedOctetsOpcSio;
		break;
	case (u_char) MTPOMRSSIINT15MINTRANSMITTEDOCTETSDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt15minTransmittedOctetsDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiInt15minTransmittedOctetsDpcSio;
		break;
	case (u_char) MTPOMRSSIINT15MINRECEIVEDMSUSOPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt15minReceivedMSUsOpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiInt15minReceivedMSUsOpcSio;
		break;
	case (u_char) MTPOMRSSIINT15MINTRANSMITTEDMSUSDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRsSiInt15minTransmittedMSUsDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmRsSiInt15minTransmittedMSUsDpcSio;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmLsTable_row(struct mtpOmLsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmLsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmLsTable_data *
refresh_mtpOmLsTable_row(struct mtpOmLsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmLsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmLsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmLsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmLsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmLsTable(int force)
{
	if (!force && mtpOmLsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmLsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmLsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmLsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmLsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmLsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmLsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmLsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmLsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmLsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMLSVALIDINTERVALS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsValidIntervals);
		rval = (u_char *) &StorageTmp->mtpOmLsValidIntervals;
		break;
	case (u_char) MTPOMLSTIMEDISCONTINUITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsTimeDiscontinuity);
		rval = (u_char *) &StorageTmp->mtpOmLsTimeDiscontinuity;
		break;
	case (u_char) MTPOMLSADJACENTINACCESSIBLEEVENTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsAdjacentInaccessibleEvents);
		rval = (u_char *) &StorageTmp->mtpOmLsAdjacentInaccessibleEvents;
		break;
	case (u_char) MTPOMLSADJACENTINACCESSIBLEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsAdjacentInaccessibleDuration);
		rval = (u_char *) &StorageTmp->mtpOmLsAdjacentInaccessibleDuration;
		break;
	case (u_char) MTPOMLSSLSUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsSlsUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmLsSlsUnavailable;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmLsInt5minTable_row(struct mtpOmLsInt5minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmLsInt5minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmLsInt5minTable_data *
refresh_mtpOmLsInt5minTable_row(struct mtpOmLsInt5minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmLsInt5minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmLsInt5minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmLsInt5minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmLsInt5minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmLsInt5minTable(int force)
{
	if (!force && mtpOmLsInt5minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmLsInt5minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmLsInt5minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmLsInt5minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmLsInt5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmLsInt5minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmLsInt5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmLsInt5minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmLsInt5minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmLsInt5minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMLSINT5MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsInt5minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmLsInt5minTimeStamp;
		break;
	case (u_char) MTPOMLSINT5MINADJACENTINACCESSIBLEEVENTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsInt5minAdjacentInaccessibleEvents);
		rval = (u_char *) &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleEvents;
		break;
	case (u_char) MTPOMLSINT5MINADJACENTINACCESSIBLEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsInt5minAdjacentInaccessibleDuration);
		rval = (u_char *) &StorageTmp->mtpOmLsInt5minAdjacentInaccessibleDuration;
		break;
	case (u_char) MTPOMLSINT5MINSLSUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsInt5minSlsUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmLsInt5minSlsUnavailable;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmLsInt15minTable_row(struct mtpOmLsInt15minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmLsInt15minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmLsInt15minTable_data *
refresh_mtpOmLsInt15minTable_row(struct mtpOmLsInt15minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmLsInt15minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmLsInt15minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmLsInt15minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmLsInt15minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmLsInt15minTable(int force)
{
	if (!force && mtpOmLsInt15minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmLsInt15minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmLsInt15minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmLsInt15minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmLsInt15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmLsInt15minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmLsInt15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmLsInt15minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmLsInt15minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmLsInt15minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMLSINT15MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsInt15minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmLsInt15minTimeStamp;
		break;
	case (u_char) MTPOMLSINT15MINADJACENTINACCESSIBLEEVENTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsInt15minAdjacentInaccessibleEvents);
		rval = (u_char *) &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleEvents;
		break;
	case (u_char) MTPOMLSINT15MINADJACENTINACCESSIBLEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsInt15minAdjacentInaccessibleDuration);
		rval = (u_char *) &StorageTmp->mtpOmLsInt15minAdjacentInaccessibleDuration;
		break;
	case (u_char) MTPOMLSINT15MINSLSUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLsInt15minSlsUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmLsInt15minSlsUnavailable;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSlStatsTable_row(struct mtpOmSlStatsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSlStatsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSlStatsTable_data *
refresh_mtpOmSlStatsTable_row(struct mtpOmSlStatsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSlStatsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSlStatsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSlStatsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSlStatsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlStatsTable(int force)
{
	if (!force && mtpOmSlStatsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSlStatsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSlStatsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSlStatsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlStatsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSlStatsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSlStatsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSlStatsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLSTATSDURINSERVICE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurInService);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsDurInService;
		break;
	case (u_char) MTPOMSLSTATSFAILALIGNORPROVING:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsFailAlignOrProving);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsFailAlignOrProving;
		break;
	case (u_char) MTPOMSLSTATSNACKSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsNacksReceived);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsNacksReceived;
		break;
	case (u_char) MTPOMSLSTATSDURUNAVAIL:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurUnavail);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsDurUnavail;
		break;
	case (u_char) MTPOMSLSTATSDURUNAVAILFAILED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurUnavailFailed);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsDurUnavailFailed;
		break;
	case (u_char) MTPOMSLSTATSDURUNAVAILRPO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurUnavailRpo);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsDurUnavailRpo;
		break;
	case (u_char) MTPOMSLSTATSSIBSSENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsSibsSent);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsSibsSent;
		break;
	case (u_char) MTPOMSLSTATSTRANSIOSIFOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsTranSioSifOctets);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsTranSioSifOctets;
		break;
	case (u_char) MTPOMSLSTATSRETRANSOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsRetransOctets);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsRetransOctets;
		break;
	case (u_char) MTPOMSLSTATSTRANMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsTranMsus);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsTranMsus;
		break;
	case (u_char) MTPOMSLSTATSRECVSIOSIFOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsRecvSioSifOctets);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsRecvSioSifOctets;
		break;
	case (u_char) MTPOMSLSTATSRECVMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsRecvMsus);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsRecvMsus;
		break;
	case (u_char) MTPOMSLSTATSCONGONSETIND0:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongOnsetInd0);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsCongOnsetInd0;
		break;
	case (u_char) MTPOMSLSTATSCONGONSETIND1:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongOnsetInd1);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsCongOnsetInd1;
		break;
	case (u_char) MTPOMSLSTATSCONGONSETIND2:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongOnsetInd2);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsCongOnsetInd2;
		break;
	case (u_char) MTPOMSLSTATSCONGONSETIND3:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongOnsetInd3);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsCongOnsetInd3;
		break;
	case (u_char) MTPOMSLSTATSDURCONGSTATUS0:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurCongStatus0);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsDurCongStatus0;
		break;
	case (u_char) MTPOMSLSTATSDURCONGSTATUS1:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurCongStatus1);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsDurCongStatus1;
		break;
	case (u_char) MTPOMSLSTATSDURCONGSTATUS2:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurCongStatus2);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsDurCongStatus2;
		break;
	case (u_char) MTPOMSLSTATSDURCONGSTATUS3:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsDurCongStatus3);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsDurCongStatus3;
		break;
	case (u_char) MTPOMSLSTATSCONGDISCDIND0:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongDiscdInd0);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsCongDiscdInd0;
		break;
	case (u_char) MTPOMSLSTATSCONGDISCDIND1:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongDiscdInd1);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsCongDiscdInd1;
		break;
	case (u_char) MTPOMSLSTATSCONGDISCDIND2:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongDiscdInd2);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsCongDiscdInd2;
		break;
	case (u_char) MTPOMSLSTATSCONGDISCDIND3:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlStatsCongDiscdInd3);
		rval = (u_char *) &StorageTmp->mtpOmSlStatsCongDiscdInd3;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSlL3Table_row(struct mtpOmSlL3Table_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSlL3Table row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSlL3Table_data *
refresh_mtpOmSlL3Table_row(struct mtpOmSlL3Table_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSlL3Table_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSlL3Table_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSlL3Table(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSlL3Table.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL3Table(int force)
{
	if (!force && mtpOmSlL3Table_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSlL3Table_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSlL3Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSlL3Table.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL3Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL3Table_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL3Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSlL3Table(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSlL3TableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSlL3Table_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLL3VALIDINTERVALS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3ValidIntervals);
		rval = (u_char *) &StorageTmp->mtpOmSlL3ValidIntervals;
		break;
	case (u_char) MTPOMSLL3TIMEDISCONTINUITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3TimeDiscontinuity);
		rval = (u_char *) &StorageTmp->mtpOmSlL3TimeDiscontinuity;
		break;
	case (u_char) MTPOMSLL3SLUNAVAILABILITYDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlUnavailabilityDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlL3SlUnavailabilityDuration;
		break;
	case (u_char) MTPOMSLL3SLLOCALINHIBITION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlLocalInhibition);
		rval = (u_char *) &StorageTmp->mtpOmSlL3SlLocalInhibition;
		break;
	case (u_char) MTPOMSLL3SLREMOTEINHIBITION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlRemoteInhibition);
		rval = (u_char *) &StorageTmp->mtpOmSlL3SlRemoteInhibition;
		break;
	case (u_char) MTPOMSLL3SLFAILED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlFailed);
		rval = (u_char *) &StorageTmp->mtpOmSlL3SlFailed;
		break;
	case (u_char) MTPOMSLL3SLREMOTEPROCOUTAGE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlRemoteProcOutage);
		rval = (u_char *) &StorageTmp->mtpOmSlL3SlRemoteProcOutage;
		break;
	case (u_char) MTPOMSLL3LOCALMGMTINHIBIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3LocalMgmtInhibit);
		rval = (u_char *) &StorageTmp->mtpOmSlL3LocalMgmtInhibit;
		break;
	case (u_char) MTPOMSLL3LOCALMGMTUNINHIBIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3LocalMgmtUninhibit);
		rval = (u_char *) &StorageTmp->mtpOmSlL3LocalMgmtUninhibit;
		break;
	case (u_char) MTPOMSLL3LOCALBUSY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3LocalBusy);
		rval = (u_char *) &StorageTmp->mtpOmSlL3LocalBusy;
		break;
	case (u_char) MTPOMSLL3SLCONGESTEDSTARTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlCongestedStarts);
		rval = (u_char *) &StorageTmp->mtpOmSlL3SlCongestedStarts;
		break;
	case (u_char) MTPOMSLL3SLCONGESTEDDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlCongestedDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlL3SlCongestedDuration;
		break;
	case (u_char) MTPOMSLL3SLCONGESTIONSTOPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3SlCongestionStops);
		rval = (u_char *) &StorageTmp->mtpOmSlL3SlCongestionStops;
		break;
	case (u_char) MTPOMSLL3DISCARDEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3DiscardedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlL3DiscardedMSUs;
		break;
	case (u_char) MTPOMSLL3CONGESTIONEVENTSMSULOSS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3CongestionEventsMSULoss);
		rval = (u_char *) &StorageTmp->mtpOmSlL3CongestionEventsMSULoss;
		break;
	case (u_char) MTPOMSLL3CHANGEOVERS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Changeovers);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Changeovers;
		break;
	case (u_char) MTPOMSLL3CHANGEBACKS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Changebacks);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Changebacks;
		break;
	case (u_char) MTPOMSLL3RESTORATIONS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Restorations);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Restorations;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSlL3Int5minTable_row(struct mtpOmSlL3Int5minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSlL3Int5minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSlL3Int5minTable_data *
refresh_mtpOmSlL3Int5minTable_row(struct mtpOmSlL3Int5minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSlL3Int5minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSlL3Int5minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSlL3Int5minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSlL3Int5minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL3Int5minTable(int force)
{
	if (!force && mtpOmSlL3Int5minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSlL3Int5minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSlL3Int5minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSlL3Int5minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL3Int5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL3Int5minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL3Int5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSlL3Int5minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSlL3Int5minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSlL3Int5minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLL3INT5MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minTimeStamp;
		break;
	case (u_char) MTPOMSLL3INT5MINSLUNAVAILABILITYDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlUnavailabilityDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minSlUnavailabilityDuration;
		break;
	case (u_char) MTPOMSLL3INT5MINSLLOCALINHIBITION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlLocalInhibition);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minSlLocalInhibition;
		break;
	case (u_char) MTPOMSLL3INT5MINSLREMOTEINHIBITION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlRemoteInhibition);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minSlRemoteInhibition;
		break;
	case (u_char) MTPOMSLL3INT5MINSLFAILED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlFailed);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minSlFailed;
		break;
	case (u_char) MTPOMSLL3INT5MINSLREMOTEPROCOUTAGE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlRemoteProcOutage);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minSlRemoteProcOutage;
		break;
	case (u_char) MTPOMSLL3INT5MINLOCALMGMTINHIBIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minLocalMgmtInhibit);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minLocalMgmtInhibit;
		break;
	case (u_char) MTPOMSLL3INT5MINLOCALMGMTUNINHIBIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minLocalMgmtUninhibit);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minLocalMgmtUninhibit;
		break;
	case (u_char) MTPOMSLL3INT5MINLOCALBUSY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minLocalBusy);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minLocalBusy;
		break;
	case (u_char) MTPOMSLL3INT5MINSLCONGESTEDSTARTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlCongestedStarts);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minSlCongestedStarts;
		break;
	case (u_char) MTPOMSLL3INT5MINSLCONGESTEDDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlCongestedDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minSlCongestedDuration;
		break;
	case (u_char) MTPOMSLL3INT5MINSLCONGESTIONSTOPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minSlCongestionStops);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minSlCongestionStops;
		break;
	case (u_char) MTPOMSLL3INT5MINDISCARDEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minDiscardedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minDiscardedMSUs;
		break;
	case (u_char) MTPOMSLL3INT5MINCONGESTIONEVENTSMSULOSS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minCongestionEventsMSULoss);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minCongestionEventsMSULoss;
		break;
	case (u_char) MTPOMSLL3INT5MINCHANGEOVERS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minChangeovers);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minChangeovers;
		break;
	case (u_char) MTPOMSLL3INT5MINCHANGEBACKS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minChangebacks);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minChangebacks;
		break;
	case (u_char) MTPOMSLL3INT5MINRESTORATIONS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int5minRestorations);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int5minRestorations;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSlL3Int15minTable_row(struct mtpOmSlL3Int15minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSlL3Int15minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSlL3Int15minTable_data *
refresh_mtpOmSlL3Int15minTable_row(struct mtpOmSlL3Int15minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSlL3Int15minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSlL3Int15minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSlL3Int15minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSlL3Int15minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL3Int15minTable(int force)
{
	if (!force && mtpOmSlL3Int15minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSlL3Int15minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSlL3Int15minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSlL3Int15minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL3Int15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL3Int15minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL3Int15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSlL3Int15minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSlL3Int15minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSlL3Int15minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLL3INT15MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minTimeStamp);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minTimeStamp;
		break;
	case (u_char) MTPOMSLL3INT15MINSLUNAVAILABILITYDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlUnavailabilityDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minSlUnavailabilityDuration;
		break;
	case (u_char) MTPOMSLL3INT15MINSLLOCALINHIBITION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlLocalInhibition);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minSlLocalInhibition;
		break;
	case (u_char) MTPOMSLL3INT15MINSLREMOTEINHIBITION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlRemoteInhibition);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minSlRemoteInhibition;
		break;
	case (u_char) MTPOMSLL3INT15MINSLFAILED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlFailed);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minSlFailed;
		break;
	case (u_char) MTPOMSLL3INT15MINSLREMOTEPROCOUTAGE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlRemoteProcOutage);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minSlRemoteProcOutage;
		break;
	case (u_char) MTPOMSLL3INT15MINLOCALMGMTINHIBIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minLocalMgmtInhibit);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minLocalMgmtInhibit;
		break;
	case (u_char) MTPOMSLL3INT15MINLOCALMGMTUNINHIBIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minLocalMgmtUninhibit);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minLocalMgmtUninhibit;
		break;
	case (u_char) MTPOMSLL3INT15MINLOCALBUSY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minLocalBusy);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minLocalBusy;
		break;
	case (u_char) MTPOMSLL3INT15MINSLCONGESTEDSTARTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlCongestedStarts);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minSlCongestedStarts;
		break;
	case (u_char) MTPOMSLL3INT15MINSLCONGESTEDDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlCongestedDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minSlCongestedDuration;
		break;
	case (u_char) MTPOMSLL3INT15MINSLCONGESTIONSTOPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minSlCongestionStops);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minSlCongestionStops;
		break;
	case (u_char) MTPOMSLL3INT15MINDISCARDEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minDiscardedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minDiscardedMSUs;
		break;
	case (u_char) MTPOMSLL3INT15MINCONGESTIONEVENTSMSULOSS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minCongestionEventsMSULoss);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minCongestionEventsMSULoss;
		break;
	case (u_char) MTPOMSLL3INT15MINCHANGEOVERS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minChangeovers);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minChangeovers;
		break;
	case (u_char) MTPOMSLL3INT15MINCHANGEBACKS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minChangebacks);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minChangebacks;
		break;
	case (u_char) MTPOMSLL3INT15MINRESTORATIONS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL3Int15minRestorations);
		rval = (u_char *) &StorageTmp->mtpOmSlL3Int15minRestorations;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSlL2Table_row(struct mtpOmSlL2Table_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSlL2Table row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSlL2Table_data *
refresh_mtpOmSlL2Table_row(struct mtpOmSlL2Table_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSlL2Table_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSlL2Table_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSlL2Table(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSlL2Table.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL2Table(int force)
{
	if (!force && mtpOmSlL2Table_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSlL2Table_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSlL2Table(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSlL2Table.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL2Table(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL2Table_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL2Table: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSlL2Table(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSlL2TableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSlL2Table_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLL2VALIDINTERVALS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2ValidIntervals);
		rval = (u_char *) &StorageTmp->mtpOmSlL2ValidIntervals;
		break;
	case (u_char) MTPOMSLL2TIMEDISCONTINUITY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2TimeDiscontinuity);
		rval = (u_char *) &StorageTmp->mtpOmSlL2TimeDiscontinuity;
		break;
	case (u_char) MTPOMSLL2SLINSERVICEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2SlInServiceDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlL2SlInServiceDuration;
		break;
	case (u_char) MTPOMSLL2SLALIGNMENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2SlAlignment);
		rval = (u_char *) &StorageTmp->mtpOmSlL2SlAlignment;
		break;
	case (u_char) MTPOMSLL2SIGNUNITSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2SignUnitsReceived);
		rval = (u_char *) &StorageTmp->mtpOmSlL2SignUnitsReceived;
		break;
	case (u_char) MTPOMSLL2NEGACKRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2NegAckReceived);
		rval = (u_char *) &StorageTmp->mtpOmSlL2NegAckReceived;
		break;
	case (u_char) MTPOMSLL2TRANSMITTEDOCTETSSIFSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2TransmittedOctetsSIFSIO);
		rval = (u_char *) &StorageTmp->mtpOmSlL2TransmittedOctetsSIFSIO;
		break;
	case (u_char) MTPOMSLL2RETRANSMITTEDOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2RetransmittedOctets);
		rval = (u_char *) &StorageTmp->mtpOmSlL2RetransmittedOctets;
		break;
	case (u_char) MTPOMSLL2TRANSMITTEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2TransmittedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlL2TransmittedMSUs;
		break;
	case (u_char) MTPOMSLL2RECEIVEDOCTETSSIFSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2ReceivedOctetsSIFSIO);
		rval = (u_char *) &StorageTmp->mtpOmSlL2ReceivedOctetsSIFSIO;
		break;
	case (u_char) MTPOMSLL2RECEIVEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2ReceivedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlL2ReceivedMSUs;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSlL2Int5minTable_row(struct mtpOmSlL2Int5minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSlL2Int5minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSlL2Int5minTable_data *
refresh_mtpOmSlL2Int5minTable_row(struct mtpOmSlL2Int5minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSlL2Int5minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSlL2Int5minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSlL2Int5minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSlL2Int5minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL2Int5minTable(int force)
{
	if (!force && mtpOmSlL2Int5minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSlL2Int5minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSlL2Int5minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSlL2Int5minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL2Int5minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL2Int5minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL2Int5minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSlL2Int5minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSlL2Int5minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSlL2Int5minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLL2INT5MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minTimestamp);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int5minTimestamp;
		break;
	case (u_char) MTPOMSLL2INT5MINSLINSERVICEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minSlInServiceDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int5minSlInServiceDuration;
		break;
	case (u_char) MTPOMSLL2INT5MINSLALIGNMENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minSlAlignment);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int5minSlAlignment;
		break;
	case (u_char) MTPOMSLL2INT5MINSIGNUNITSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minSignUnitsReceived);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int5minSignUnitsReceived;
		break;
	case (u_char) MTPOMSLL2INT5MINNEGACKRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minNegAckReceived);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int5minNegAckReceived;
		break;
	case (u_char) MTPOMSLL2INT5MINTRANSMITTEDOCTETSSIFSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minTransmittedOctetsSIFSIO);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int5minTransmittedOctetsSIFSIO;
		break;
	case (u_char) MTPOMSLL2INT5MINRETRANSMITTEDOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minRetransmittedOctets);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int5minRetransmittedOctets;
		break;
	case (u_char) MTPOMSLL2INT5MINTRANSMITTEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minTransmittedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int5minTransmittedMSUs;
		break;
	case (u_char) MTPOMSLL2INT5MINRECEIVEDOCTETSSIFSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minReceivedOctetsSIFSIO);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int5minReceivedOctetsSIFSIO;
		break;
	case (u_char) MTPOMSLL2INT5MINRECEIVEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int5minReceivedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int5minReceivedMSUs;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSlL2Int15minTable_row(struct mtpOmSlL2Int15minTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSlL2Int15minTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSlL2Int15minTable_data *
refresh_mtpOmSlL2Int15minTable_row(struct mtpOmSlL2Int15minTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSlL2Int15minTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSlL2Int15minTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSlL2Int15minTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSlL2Int15minTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlL2Int15minTable(int force)
{
	if (!force && mtpOmSlL2Int15minTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSlL2Int15minTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSlL2Int15minTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSlL2Int15minTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlL2Int15minTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlL2Int15minTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlL2Int15minTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSlL2Int15minTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSlL2Int15minTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSlL2Int15minTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLL2INT15MINTIMESTAMP:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minTimestamp);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int15minTimestamp;
		break;
	case (u_char) MTPOMSLL2INT15MINSLINSERVICEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minSlInServiceDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int15minSlInServiceDuration;
		break;
	case (u_char) MTPOMSLL2INT15MINSLALIGNMENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minSlAlignment);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int15minSlAlignment;
		break;
	case (u_char) MTPOMSLL2INT15MINSIGNUNITSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minSignUnitsReceived);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int15minSignUnitsReceived;
		break;
	case (u_char) MTPOMSLL2INT15MINNEGACKRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minNegAckReceived);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int15minNegAckReceived;
		break;
	case (u_char) MTPOMSLL2INT15MINTRANSMITTEDOCTETSSIFSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minTransmittedOctetsSIFSIO);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int15minTransmittedOctetsSIFSIO;
		break;
	case (u_char) MTPOMSLL2INT15MINRETRANSMITTEDOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minRetransmittedOctets);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int15minRetransmittedOctets;
		break;
	case (u_char) MTPOMSLL2INT15MINTRANSMITTEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minTransmittedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int15minTransmittedMSUs;
		break;
	case (u_char) MTPOMSLL2INT15MINRECEIVEDOCTETSSIFSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minReceivedOctetsSIFSIO);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int15minReceivedOctetsSIFSIO;
		break;
	case (u_char) MTPOMSLL2INT15MINRECEIVEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlL2Int15minReceivedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlL2Int15minReceivedMSUs;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSdtStatsTable_row(struct mtpOmSdtStatsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSdtStatsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSdtStatsTable_data *
refresh_mtpOmSdtStatsTable_row(struct mtpOmSdtStatsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSdtStatsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSdtStatsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSdtStatsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSdtStatsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSdtStatsTable(int force)
{
	if (!force && mtpOmSdtStatsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSdtStatsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSdtStatsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSdtStatsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSdtStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSdtStatsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSdtStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSdtStatsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSdtStatsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSdtStatsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSDTSTATSTXBYTES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxBytes);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsTxBytes;
		break;
	case (u_char) MTPOMSDTSTATSTXSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxSus);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsTxSus;
		break;
	case (u_char) MTPOMSDTSTATSTXSUSREPEATED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxSusRepeated);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsTxSusRepeated;
		break;
	case (u_char) MTPOMSDTSTATSTXUNDERRUNS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxUnderruns);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsTxUnderruns;
		break;
	case (u_char) MTPOMSDTSTATSTXABORTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxAborts);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsTxAborts;
		break;
	case (u_char) MTPOMSDTSTATSTXBUFFEROVERFLOWS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxBufferOverflows);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsTxBufferOverflows;
		break;
	case (u_char) MTPOMSDTSTATSTXSUSINERROR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsTxSusInError);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsTxSusInError;
		break;
	case (u_char) MTPOMSDTSTATSRXBYTES:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxBytes);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxBytes;
		break;
	case (u_char) MTPOMSDTSTATSRXSUSCOMPRESSED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxSusCompressed);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxSusCompressed;
		break;
	case (u_char) MTPOMSDTSTATSRXOVERRUNS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxOverruns);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxOverruns;
		break;
	case (u_char) MTPOMSDTSTATSRXABORTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxAborts);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxAborts;
		break;
	case (u_char) MTPOMSDTSTATSRXBUFFEROVERFLOWS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxBufferOverflows);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxBufferOverflows;
		break;
	case (u_char) MTPOMSDTSTATSRXSUSINERROR:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxSusInError);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxSusInError;
		break;
	case (u_char) MTPOMSDTSTATSRXSYNCTRANSITIONS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxSyncTransitions);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxSyncTransitions;
		break;
	case (u_char) MTPOMSDTSTATSRXBITSOCTETCOUNTED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxBitsOctetCounted);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxBitsOctetCounted;
		break;
	case (u_char) MTPOMSDTSTATSRXCRCERRORS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxCrcErrors);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxCrcErrors;
		break;
	case (u_char) MTPOMSDTSTATSRXFRAMEERRORS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxFrameErrors);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxFrameErrors;
		break;
	case (u_char) MTPOMSDTSTATSRXFRAMEOVERFLOWS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxFrameOverflows);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxFrameOverflows;
		break;
	case (u_char) MTPOMSDTSTATSRXFRAMETOOLONG:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxFrameTooLong);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxFrameTooLong;
		break;
	case (u_char) MTPOMSDTSTATSRXFRAMETOOSHORT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxFrameTooShort);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxFrameTooShort;
		break;
	case (u_char) MTPOMSDTSTATSRXRESIDUEERRORS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsRxResidueErrors);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsRxResidueErrors;
		break;
	case (u_char) MTPOMSDTSTATSCARRIERCTSLOST:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsCarrierCtsLost);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsCarrierCtsLost;
		break;
	case (u_char) MTPOMSDTSTATSCARRIERDCDLOST:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsCarrierDcdLost);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsCarrierDcdLost;
		break;
	case (u_char) MTPOMSDTSTATSCARRIERLOST:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdtStatsCarrierLost);
		rval = (u_char *) &StorageTmp->mtpOmSdtStatsCarrierLost;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn void refresh_mtpOmSdlStatsTable_row(struct mtpOmSdlStatsTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSdlStatsTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSdlStatsTable_data *
refresh_mtpOmSdlStatsTable_row(struct mtpOmSdlStatsTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSdlStatsTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSdlStatsTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSdlStatsTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSdlStatsTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSdlStatsTable(int force)
{
	if (!force && mtpOmSdlStatsTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSdlStatsTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSdlStatsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSdlStatsTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSdlStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSdlStatsTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSdlStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSdlStatsTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSdlStatsTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSdlStatsTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSDLSTATSRXOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsRxOctets);
		rval = (u_char *) &StorageTmp->mtpOmSdlStatsRxOctets;
		break;
	case (u_char) MTPOMSDLSTATSTXOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsTxOctets);
		rval = (u_char *) &StorageTmp->mtpOmSdlStatsTxOctets;
		break;
	case (u_char) MTPOMSDLSTATSRXOVERRUNS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsRXOverruns);
		rval = (u_char *) &StorageTmp->mtpOmSdlStatsRXOverruns;
		break;
	case (u_char) MTPOMSDLSTATSTXUNDERRUNS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsTxUnderruns);
		rval = (u_char *) &StorageTmp->mtpOmSdlStatsTxUnderruns;
		break;
	case (u_char) MTPOMSDLSTATSRXBUFFEROVERFLOWS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsRxBufferOverflows);
		rval = (u_char *) &StorageTmp->mtpOmSdlStatsRxBufferOverflows;
		break;
	case (u_char) MTPOMSDLSTATSTXBUFFEROVERFLOWS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsTxBufferOverflows);
		rval = (u_char *) &StorageTmp->mtpOmSdlStatsTxBufferOverflows;
		break;
	case (u_char) MTPOMSDLSTATSLEADCTSLOST:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsLeadCtsLost);
		rval = (u_char *) &StorageTmp->mtpOmSdlStatsLeadCtsLost;
		break;
	case (u_char) MTPOMSDLSTATSLEADDCDLOST:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsLeadDcdLost);
		rval = (u_char *) &StorageTmp->mtpOmSdlStatsLeadDcdLost;
		break;
	case (u_char) MTPOMSDLSTATSCARRIERLOST:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsCarrierLost);
		rval = (u_char *) &StorageTmp->mtpOmSdlStatsCarrierLost;
		break;
	case (u_char) MTPOMSDLSTATSBIPOLARVIOLATIONS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSdlStatsBipolarViolations);
		rval = (u_char *) &StorageTmp->mtpOmSdlStatsBipolarViolations;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_mtpOmRsSiValidIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpOmRsSiValidIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpOmRsSiTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmRsSiValidIntervals entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmRsSiTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpOmRsSiStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiValidIntervals: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiValidIntervals not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiValidIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..96 */
		if ((0 > set_value || set_value > 96)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiValidIntervals: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpOmRsSiValidIntervals for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->mtpOmRsSiValidIntervals;
		StorageTmp->mtpOmRsSiValidIntervals = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOmRsSiValidIntervals = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmRsSiTimeDiscontinuity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpOmRsSiTimeDiscontinuity(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct mtpOmRsSiTable_data *StorageTmp = NULL;
	size_t newlen = name_len - 16;
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmRsSiTimeDiscontinuity entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmRsSiTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpOmRsSiStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiTimeDiscontinuity: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_TIMETICKS) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiTimeDiscontinuity not ASN_TIMETICKS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiTimeDiscontinuity: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpOmRsSiTimeDiscontinuity for you to use, and you have just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		old_value = StorageTmp->mtpOmRsSiTimeDiscontinuity;
		StorageTmp->mtpOmRsSiTimeDiscontinuity = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOmRsSiTimeDiscontinuity = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOm1stAndIntervalActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpOm1stAndIntervalActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm1stAndIntervalActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		objid = NULL;
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpOm1stAndIntervalActivate;
		old_length = StorageTmp->mtpOm1stAndIntervalActivateLen;
		StorageTmp->mtpOm1stAndIntervalActivate = objid;
		StorageTmp->mtpOm1stAndIntervalActivateLen = var_val_len / sizeof(oid);
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm1stAndIntervalActivate = old_value;
		StorageTmp->mtpOm1stAndIntervalActivateLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOm1stAndIntervalDeactivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpOm1stAndIntervalDeactivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm1stAndIntervalDeactivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		objid = NULL;
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalDeactivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm1stAndIntervalDeactivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpOm1stAndIntervalDeactivate;
		old_length = StorageTmp->mtpOm1stAndIntervalDeactivateLen;
		StorageTmp->mtpOm1stAndIntervalDeactivate = objid;
		StorageTmp->mtpOm1stAndIntervalDeactivateLen = var_val_len / sizeof(oid);
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm1stAndIntervalDeactivate = old_value;
		StorageTmp->mtpOm1stAndIntervalDeactivateLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOm5MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpOm5MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm5MinActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		objid = NULL;
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpOm5MinActivate;
		old_length = StorageTmp->mtpOm5MinActivateLen;
		StorageTmp->mtpOm5MinActivate = objid;
		StorageTmp->mtpOm5MinActivateLen = var_val_len / sizeof(oid);
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm5MinActivate = old_value;
		StorageTmp->mtpOm5MinActivateLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOm5MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpOm5MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm5MinDeaActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		objid = NULL;
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinDeaActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinDeaActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpOm5MinDeaActivate;
		old_length = StorageTmp->mtpOm5MinDeaActivateLen;
		StorageTmp->mtpOm5MinDeaActivate = objid;
		StorageTmp->mtpOm5MinDeaActivateLen = var_val_len / sizeof(oid);
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm5MinDeaActivate = old_value;
		StorageTmp->mtpOm5MinDeaActivateLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOm15MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpOm15MinActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm15MinActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		objid = NULL;
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpOm15MinActivate;
		old_length = StorageTmp->mtpOm15MinActivateLen;
		StorageTmp->mtpOm15MinActivate = objid;
		StorageTmp->mtpOm15MinActivateLen = var_val_len / sizeof(oid);
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm15MinActivate = old_value;
		StorageTmp->mtpOm15MinActivateLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOm15MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpOm15MinDeaActivate(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm15MinDeaActivate entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		objid = NULL;
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinDeaActivate not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinDeaActivate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the
				   UNDO case */
		old_value = StorageTmp->mtpOm15MinDeaActivate;
		old_length = StorageTmp->mtpOm15MinDeaActivateLen;
		StorageTmp->mtpOm15MinDeaActivate = objid;
		StorageTmp->mtpOm15MinDeaActivateLen = var_val_len / sizeof(oid);
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm15MinDeaActivate = old_value;
		StorageTmp->mtpOm15MinDeaActivateLen = old_length;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOm5MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpOm5MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm5MinMaxIntervals entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinMaxIntervals not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinMaxIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 96 */
		/* Note: ranges 0..288 */
		if ((0 > set_value || set_value > 288)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm5MinMaxIntervals: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpOm5MinMaxIntervals;
		StorageTmp->mtpOm5MinMaxIntervals = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm5MinMaxIntervals = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOm15MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Scalar write routine.
 */
int
write_mtpOm15MinMaxIntervals(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct mtpOmMIB_data *StorageTmp = NULL;
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOm15MinMaxIntervals entering action=%d...  \n", action));
	if ((StorageTmp = mtpOmMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinMaxIntervals not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinMaxIntervals: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 96 */
		/* Note: ranges 0..672 */
		if ((0 > set_value || set_value > 672)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOm15MinMaxIntervals: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in
				   the UNDO case */
		old_value = StorageTmp->mtpOm15MinMaxIntervals;
		StorageTmp->mtpOm15MinMaxIntervals = set_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->mtpOm15MinMaxIntervals = old_value;
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int mtpOmSpTable_consistent(struct mtpOmSpTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSpTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSpTable_consistent(struct mtpOmSpTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSpInt5minTable_consistent(struct mtpOmSpInt5minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSpInt5minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSpInt5minTable_consistent(struct mtpOmSpInt5minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSpInt15minTable_consistent(struct mtpOmSpInt15minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSpInt15minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSpInt15minTable_consistent(struct mtpOmSpInt15minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSpSiTable_consistent(struct mtpOmSpSiTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSpSiTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSpSiTable_consistent(struct mtpOmSpSiTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSpSiInt5minTable_consistent(struct mtpOmSpSiInt5minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSpSiInt5minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSpSiInt5minTable_consistent(struct mtpOmSpSiInt5minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSpSiInt15minTable_consistent(struct mtpOmSpSiInt15minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSpSiInt15minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSpSiInt15minTable_consistent(struct mtpOmSpSiInt15minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSpStudyTable_consistent(struct mtpOmSpStudyTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSpStudyTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSpStudyTable_consistent(struct mtpOmSpStudyTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSpStudyInt5minTable_consistent(struct mtpOmSpStudyInt5minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSpStudyInt5minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSpStudyInt5minTable_consistent(struct mtpOmSpStudyInt5minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSpStudyInt15minTable_consistent(struct mtpOmSpStudyInt15minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSpStudyInt15minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSpStudyInt15minTable_consistent(struct mtpOmSpStudyInt15minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSpStudyMapTable_consistent(struct mtpOmSpStudyMapTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSpStudyMapTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSpStudyMapTable_consistent(struct mtpOmSpStudyMapTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmRsTable_consistent(struct mtpOmRsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmRsTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmRsTable_consistent(struct mtpOmRsTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmRsInt5minTable_consistent(struct mtpOmRsInt5minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmRsInt5minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmRsInt5minTable_consistent(struct mtpOmRsInt5minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmRsInt15minTable_consistent(struct mtpOmRsInt15minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmRsInt15minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmRsInt15minTable_consistent(struct mtpOmRsInt15minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmRsSiTable_consistent(struct mtpOmRsSiTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmRsSiTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmRsSiTable_consistent(struct mtpOmRsSiTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmRsSiInt5minTable_consistent(struct mtpOmRsSiInt5minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmRsSiInt5minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmRsSiInt5minTable_consistent(struct mtpOmRsSiInt5minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmRsSiInt15minTable_consistent(struct mtpOmRsSiInt15minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmRsSiInt15minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmRsSiInt15minTable_consistent(struct mtpOmRsSiInt15minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmLsTable_consistent(struct mtpOmLsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmLsTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmLsTable_consistent(struct mtpOmLsTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmLsInt5minTable_consistent(struct mtpOmLsInt5minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmLsInt5minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmLsInt5minTable_consistent(struct mtpOmLsInt5minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmLsInt15minTable_consistent(struct mtpOmLsInt15minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmLsInt15minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmLsInt15minTable_consistent(struct mtpOmLsInt15minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSlStatsTable_consistent(struct mtpOmSlStatsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSlStatsTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSlStatsTable_consistent(struct mtpOmSlStatsTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSlL3Table_consistent(struct mtpOmSlL3Table_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSlL3Table table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSlL3Table_consistent(struct mtpOmSlL3Table_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSlL3Int5minTable_consistent(struct mtpOmSlL3Int5minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSlL3Int5minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSlL3Int5minTable_consistent(struct mtpOmSlL3Int5minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSlL3Int15minTable_consistent(struct mtpOmSlL3Int15minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSlL3Int15minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSlL3Int15minTable_consistent(struct mtpOmSlL3Int15minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSlL2Table_consistent(struct mtpOmSlL2Table_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSlL2Table table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSlL2Table_consistent(struct mtpOmSlL2Table_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSlL2Int5minTable_consistent(struct mtpOmSlL2Int5minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSlL2Int5minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSlL2Int5minTable_consistent(struct mtpOmSlL2Int5minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSlL2Int15minTable_consistent(struct mtpOmSlL2Int15minTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSlL2Int15minTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSlL2Int15minTable_consistent(struct mtpOmSlL2Int15minTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSdtStatsTable_consistent(struct mtpOmSdtStatsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSdtStatsTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSdtStatsTable_consistent(struct mtpOmSdtStatsTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int mtpOmSdlStatsTable_consistent(struct mtpOmSdlStatsTable_data *thedata)
 * @param thedata the row data to check for consistency.
 * @brief check the internal consistency of a table row.
 *
 * This function checks the internal consistency of a table row for the mtpOmSdlStatsTable table.  If the
 * table row is internally consistent, then this function returns SNMP_ERR_NOERROR, otherwise the
 * function returns an SNMP error code and it will not be possible to activate the row until the
 * row's internal consistency is corrected.  This function might use a 'test' operation against the
 * driver to ensure that the commit phase will succeed.
 */
int
mtpOmSdlStatsTable_consistent(struct mtpOmSdlStatsTable_data *thedata)
{
	/* XXX: check row consistency return SNMP_ERR_NOERROR if consistent, or an SNMP error code if not. */
	return (SNMP_ERR_NOERROR);
}

/**
 * @fn int write_mtpOmSpSiStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmSpSiStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmSpSiTable_data *StorageTmp = NULL;
	static struct mtpOmSpSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmSpSiStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmSpSiTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSpSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSpSiStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmSpSiStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmSpSiTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmSpSiTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmSpSiCode */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmSpSiCode */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmSpSiCode: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			switch ((long) *vp->val.integer) {
			case MTPOMSPSICODE_SNMM:
			case MTPOMSPSICODE_SNTM:
			case MTPOMSPSICODE_SNSM:
			case MTPOMSPSICODE_SCCP:
			case MTPOMSPSICODE_TUP:
			case MTPOMSPSICODE_ISUP:
			case MTPOMSPSICODE_DUP1:
			case MTPOMSPSICODE_DUP2:
			case MTPOMSPSICODE_MTUP:
			case MTPOMSPSICODE_BISUP:
			case MTPOMSPSICODE_SIUP:
			case MTPOMSPSICODE_SPNEUP:
			case MTPOMSPSICODE_STC:
			case MTPOMSPSICODE_USER13:
			case MTPOMSPSICODE_USER14:
			case MTPOMSPSICODE_USER15:
				break;
			default:
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmSpSiCode: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmSpSiTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmSpSiCode = (long) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmSpSiTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmSpSiTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = mtpOmSpSiTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->mtpOmSpSiStatus;
			StorageTmp->mtpOmSpSiStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = mtpOmSpSiTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->mtpOmSpSiStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpOmSpSiStatus;
			StorageTmp->mtpOmSpSiStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->mtpOmSpSiStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->mtpOmSpSiStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpOmSpSiTable_destroy(&StorageDel);
			/* mtpOmSpSiTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpOmSpSiStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmSpSiTable_del(StorageNew);
				mtpOmSpSiTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmSpSiTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmSpStudyStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmSpStudyStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmSpStudyTable_data *StorageTmp = NULL;
	static struct mtpOmSpStudyTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmSpStudyStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmSpStudyTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSpStudyStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSpStudyStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmSpStudyStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmSpStudyTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmSpStudyTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpOmSpStudyId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpOmSpStudyId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmSpStudyId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmSpStudyTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpOmSpStudyId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmSpStudyTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmSpStudyTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = mtpOmSpStudyTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->mtpOmSpStudyStatus;
			StorageTmp->mtpOmSpStudyStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = mtpOmSpStudyTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->mtpOmSpStudyStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpOmSpStudyStatus;
			StorageTmp->mtpOmSpStudyStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->mtpOmSpStudyStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->mtpOmSpStudyStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpOmSpStudyTable_destroy(&StorageDel);
			/* mtpOmSpStudyTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpOmSpStudyStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmSpStudyTable_del(StorageNew);
				mtpOmSpStudyTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmSpStudyTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmSpStudyMapStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmSpStudyMapStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmSpStudyMapTable_data *StorageTmp = NULL;
	static struct mtpOmSpStudyMapTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmSpStudyMapStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmSpStudyMapTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSpStudyMapStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSpStudyMapStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmSpStudyMapStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmSpStudyMapTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmSpStudyMapTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmSpSiCode */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmSpStudyId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmOpcRsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmDpcRsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmSpSiCode */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmSpSiCode: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			switch ((long) *vp->val.integer) {
			case MTPOMSPSICODE_SNMM:
			case MTPOMSPSICODE_SNTM:
			case MTPOMSPSICODE_SNSM:
			case MTPOMSPSICODE_SCCP:
			case MTPOMSPSICODE_TUP:
			case MTPOMSPSICODE_ISUP:
			case MTPOMSPSICODE_DUP1:
			case MTPOMSPSICODE_DUP2:
			case MTPOMSPSICODE_MTUP:
			case MTPOMSPSICODE_BISUP:
			case MTPOMSPSICODE_SIUP:
			case MTPOMSPSICODE_SPNEUP:
			case MTPOMSPSICODE_STC:
			case MTPOMSPSICODE_USER13:
			case MTPOMSPSICODE_USER14:
			case MTPOMSPSICODE_USER15:
				break;
			default:
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmSpSiCode: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmSpStudyId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmSpStudyId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmOpcRsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmOpcRsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmDpcRsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmDpcRsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmSpStudyMapTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmSpSiCode = (long) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmSpStudyId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmOpcRsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmDpcRsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmSpStudyMapTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmSpStudyMapTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = mtpOmSpStudyMapTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->mtpOmSpStudyMapStatus;
			StorageTmp->mtpOmSpStudyMapStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = mtpOmSpStudyMapTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->mtpOmSpStudyMapStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpOmSpStudyMapStatus;
			StorageTmp->mtpOmSpStudyMapStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->mtpOmSpStudyMapStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->mtpOmSpStudyMapStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpOmSpStudyMapTable_destroy(&StorageDel);
			/* mtpOmSpStudyMapTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpOmSpStudyMapStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmSpStudyMapTable_del(StorageNew);
				mtpOmSpStudyMapTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmSpStudyMapTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmRsSiStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmRsSiStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmRsSiTable_data *StorageTmp = NULL;
	static struct mtpOmRsSiTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 16;
	static int old_value;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmRsSiStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmRsSiTableStorage, NULL, &name[16], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmRsSiStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmRsSiStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmRsSiTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmRsSiTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpRsId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmRsSiCode */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[16]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpRsId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpRsId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmRsSiCode */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmRsSiCode: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			switch ((long) *vp->val.integer) {
			case MTPOMRSSICODE_SNMM:
			case MTPOMRSSICODE_SNTM:
			case MTPOMRSSICODE_SNSM:
			case MTPOMRSSICODE_SCCP:
			case MTPOMRSSICODE_TUP:
			case MTPOMRSSICODE_ISUP:
			case MTPOMRSSICODE_DUP1:
			case MTPOMRSSICODE_DUP2:
			case MTPOMRSSICODE_MTUP:
			case MTPOMRSSICODE_BISUP:
			case MTPOMRSSICODE_SIUP:
			case MTPOMRSSICODE_SPNEUP:
			case MTPOMRSSICODE_STC:
			case MTPOMRSSICODE_USER13:
			case MTPOMRSSICODE_USER14:
			case MTPOMRSSICODE_USER15:
				break;
			default:
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmRsSiCode: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmRsSiTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			vp = vars;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpRsId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmRsSiCode = (long) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmRsSiTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmRsSiTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = mtpOmRsSiTable_consistent(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			/* row does not have to be consistent */
			break;
		case RS_ACTIVE:
			old_value = StorageTmp->mtpOmRsSiStatus;
			StorageTmp->mtpOmRsSiStatus = set_value;
			if (old_value != RS_ACTIVE) {
				/* check that activation is possible */
				if ((ret = mtpOmRsSiTable_consistent(StorageTmp)) != SNMP_ERR_NOERROR) {
					StorageTmp->mtpOmRsSiStatus = old_value;
					return (ret);
				}
			}
			break;
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->mtpOmRsSiStatus;
			StorageTmp->mtpOmRsSiStatus = set_value;
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: commit creation to underlying device */
			/* XXX: activate with underlying device */
			StorageNew->mtpOmRsSiStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			StorageNew->mtpOmRsSiStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (old_value != set_value) {
				switch (set_value) {
				case RS_ACTIVE:
					/* XXX: activate with underlying device */
					break;
				case RS_NOTINSERVICE:
					/* XXX: deactivate with underlying device */
					break;
				}
			}
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			mtpOmRsSiTable_destroy(&StorageDel);
			/* mtpOmRsSiTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->mtpOmRsSiStatus = old_value;
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmRsSiTable_del(StorageNew);
				mtpOmRsSiTable_destroy(&StorageNew);
			}
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmRsSiTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn void mtpOmMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
mtpOmMIB_loop_handler(int sig)
{
	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (mtpOmMIBold_signal_handler != NULL)
		(*mtpOmMIBold_signal_handler) (sig);
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/**
 * @fn void mtpOmMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
mtpOmMIB_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return;
}
