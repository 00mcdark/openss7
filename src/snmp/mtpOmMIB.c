/*****************************************************************************

 @(#) src/snmp/mtpOmMIB.c

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2015  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 *****************************************************************************/

static char const ident[] = "src/snmp/mtpOmMIB.c (" PACKAGE_ENVR ") " PACKAGE_DATE;

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/agent_trap.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declare header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NETSNMP_MEMDUP
#include "ucd_memdup.h"
#endif
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "mtpOmMIB.h"
#undef MASTER
#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if defined MODULE
#if defined MASTER
const char sa_program[] = "mtpOmMIB";
int sa_fclose = 1;			/* default close files between requests */
int sa_changed = 1;			/* indication to reread MIB configuration */
int sa_stats_refresh = 1;		/* indications that statistics, the mib or its tables need to be refreshed */
int sa_request = 1;			/* request number for per-request actions */
int sa_dump = 0;			/* default packet dump */
int sa_debug = 0;			/* default no debug */
#endif				/* defined MASTER */
#endif				/* defined MODULE */
static int my_fd = -1;			/* file descriptor for this MIB's use */
static int my_readfd = -1;		/* file descriptor for autonomnous events */
volatile int mtpOmMIB_refresh = 1;
volatile int mtpOmHandledMSUsOpcDpcSioTable_refresh = 1;
volatile int mtpOmHandledOctetsOpcDpcSioTable_refresh = 1;
volatile int mtpOmHandledOctetsSIOTable_refresh = 1;
volatile int mtpOmOblSpUtilizationTable_refresh = 1;
volatile int mtpOmAllSpUtilizationTable_refresh = 1;
volatile int mtpOmReceivedOctetsOPCTable_refresh = 1;
volatile int mtpOmReceivedOctetsOpcSioTable_refresh = 1;
volatile int mtpOmSpDataTable_refresh = 1;
volatile int mtpOmTransmittedOctetsDPCTable_refresh = 1;
volatile int mtpOmTransmittedOctetsDpcSioTable_refresh = 1;
volatile int mtpOmSignRsInformationTable_refresh = 1;
volatile int mtpOmSlsDurationTable_refresh = 1;
volatile int mtpOmAll5And30MinSlDurationTable_refresh = 1;
volatile int mtpOmOblSlDurationTable_refresh = 1;
volatile int mtpOmAll30MinSlDurationTable_refresh = 1;
volatile int mtpOmOblSlUtilizationTable_refresh = 1;
volatile int mtpOmAllSlUtilizationTable_refresh = 1;
volatile int mtpOmSlCongestionTable_refresh = 1;

/*
 * mtpOmMIB_variables_oid: object identifier for mtpOmMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid mtpOmMIB_variables_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1 };
oid mtpOmHandledMSUsOpcDpcSioTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 1, 1 };
oid mtpOmHandledOctetsOpcDpcSioTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 2, 1 };
oid mtpOmAllSpUtilizationTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 5, 1 };
oid mtpOmReceivedOctetsOPCTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 6, 1 };
oid mtpOmReceivedOctetsOpcSioTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 7, 1 };
oid mtpOmTransmittedOctetsDPCTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 9, 1 };
oid mtpOmTransmittedOctetsDpcSioTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 10, 1 };
oid mtpOmAll5And30MinSlDurationTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 13, 1 };
oid mtpOmAll30MinSlDurationTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 15, 1 };
oid mtpOmAllSlUtilizationTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 17, 1 };
oid mtpOmSlCongestionTable_variables_oid[14] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 1, 1, 18, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */

/*
 * Oids accessible only for notify defined in this MIB.
 */

/*
 * Other oids defined in this MIB.
 */
oid mtpOmGeneralCompliance_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 2, 1, 1 };
oid mtpOmObjectGroup_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 17, 752, 1, 2, 2, 1 };
static oid zeroDotZero_oid[2] = { 0, 0 };
static oid snmpTrapOID_oid[11] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };

/*
 * variable7 mtpOmMIB_variables: tree for mtpOmMIB
 * This variable defines function callbacks and type return information for the mtpOmMIB mib section
 */
struct variable7 mtpOmMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   MTPOMHANDLEDMSUSOPCDPCSIO  1
	{(u_char) MTPOMHANDLEDMSUSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpOmHandledMSUsOpcDpcSioTable, 5, {1, 1, 1, 1, 4}},
#define   MTPOMHANDLEDMSUSOPCDPCSIOROWSTATUS  2
	{(u_char) MTPOMHANDLEDMSUSOPCDPCSIOROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmHandledMSUsOpcDpcSioTable, 5, {1, 1, 1, 1, 5}},
#define   MTPOMHANDLEDOCTETSOPCDPCSIOINTERVAL  3
	{(u_char) MTPOMHANDLEDOCTETSOPCDPCSIOINTERVAL, ASN_INTEGER, RWRITE, var_mtpOmHandledOctetsOpcDpcSioTable, 5, {1, 1, 2, 1, 1}},
#define   MTPOMHANDLEDOCTETSOPCDPCSIO  4
	{(u_char) MTPOMHANDLEDOCTETSOPCDPCSIO, ASN_GAUGE, RONLY, var_mtpOmHandledOctetsOpcDpcSioTable, 5, {1, 1, 2, 1, 2}},
#define   MTPOMHANDLEDOCTETSOPCDPCSIOROWSTATUS  5
	{(u_char) MTPOMHANDLEDOCTETSOPCDPCSIOROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmHandledOctetsOpcDpcSioTable, 5, {1, 1, 2, 1, 3}},
#define   MTPOMHANDLEDOCTETSSIO  6
	{(u_char) MTPOMHANDLEDOCTETSSIO, ASN_GAUGE, RONLY, var_mtpOmHandledOctetsSIOTable, 5, {1, 1, 3, 1, 1}},
#define   MTPOMADJACENTINACCESSIBLEDURATION  7
	{(u_char) MTPOMADJACENTINACCESSIBLEDURATION, ASN_INTEGER, RONLY, var_mtpOmOblSpUtilizationTable, 5, {1, 1, 4, 1, 1}},
#define   MTPOMADJACENTINACCESSIBLEEVENTS  8
	{(u_char) MTPOMADJACENTINACCESSIBLEEVENTS, ASN_GAUGE, RONLY, var_mtpOmAllSpUtilizationTable, 5, {1, 1, 5, 1, 1}},
#define   MTPOMALLSPUTILIZATIONROWSTATUS  9
	{(u_char) MTPOMALLSPUTILIZATIONROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmAllSpUtilizationTable, 5, {1, 1, 5, 1, 2}},
#define   MTPOMRECEIVEDOCTETSOPCINTERVAL  10
	{(u_char) MTPOMRECEIVEDOCTETSOPCINTERVAL, ASN_INTEGER, RWRITE, var_mtpOmReceivedOctetsOPCTable, 5, {1, 1, 6, 1, 1}},
#define   MTPOMRECEIVEDOCTETSOPC  11
	{(u_char) MTPOMRECEIVEDOCTETSOPC, ASN_GAUGE, RONLY, var_mtpOmReceivedOctetsOPCTable, 5, {1, 1, 6, 1, 2}},
#define   MTPOMRECEIVEDOCTETSOPCROWSTATUS  12
	{(u_char) MTPOMRECEIVEDOCTETSOPCROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmReceivedOctetsOPCTable, 5, {1, 1, 6, 1, 3}},
#define   MTPOMRECEIVEDOCTETSOPCSIOINTERVAL  13
	{(u_char) MTPOMRECEIVEDOCTETSOPCSIOINTERVAL, ASN_INTEGER, RWRITE, var_mtpOmReceivedOctetsOpcSioTable, 5, {1, 1, 7, 1, 1}},
#define   MTPOMRECEIVEDOCTETSOPCSIO  14
	{(u_char) MTPOMRECEIVEDOCTETSOPCSIO, ASN_GAUGE, RONLY, var_mtpOmReceivedOctetsOpcSioTable, 5, {1, 1, 7, 1, 2}},
#define   MTPOMRECEIVEDOCTETSOPCSIOROWSTATUS  15
	{(u_char) MTPOMRECEIVEDOCTETSOPCSIOROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmReceivedOctetsOpcSioTable, 5, {1, 1, 7, 1, 3}},
#define   MTPOMSPDISCARDEDMSUS  16
	{(u_char) MTPOMSPDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpOmSpDataTable, 5, {1, 1, 8, 1, 3}},
#define   MTPOMSPTRANSMITTEDUPUNAVAILABLE  17
	{(u_char) MTPOMSPTRANSMITTEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSpDataTable, 5, {1, 1, 8, 1, 4}},
#define   MTPOMSPRECEIVEDUPUNAVAILABLE  18
	{(u_char) MTPOMSPRECEIVEDUPUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSpDataTable, 5, {1, 1, 8, 1, 5}},
#define   MTPOMSPRECEIVEDTFC    19
	{(u_char) MTPOMSPRECEIVEDTFC, ASN_GAUGE, RONLY, var_mtpOmSpDataTable, 5, {1, 1, 8, 1, 6}},
#define   MTPOMSPRECEIVEDTFCLEVEL0  20
	{(u_char) MTPOMSPRECEIVEDTFCLEVEL0, ASN_GAUGE, RONLY, var_mtpOmSpDataTable, 5, {1, 1, 8, 1, 7}},
#define   MTPOMSPRECEIVEDTFCLEVEL1  21
	{(u_char) MTPOMSPRECEIVEDTFCLEVEL1, ASN_GAUGE, RONLY, var_mtpOmSpDataTable, 5, {1, 1, 8, 1, 8}},
#define   MTPOMSPRECEIVEDTFCLEVEL2  22
	{(u_char) MTPOMSPRECEIVEDTFCLEVEL2, ASN_GAUGE, RONLY, var_mtpOmSpDataTable, 5, {1, 1, 8, 1, 9}},
#define   MTPOMSPRECEIVEDTFCLEVEL3  23
	{(u_char) MTPOMSPRECEIVEDTFCLEVEL3, ASN_GAUGE, RONLY, var_mtpOmSpDataTable, 5, {1, 1, 8, 1, 10}},
#define   MTPOMTRANSMITTEDOCTETSDPC  24
	{(u_char) MTPOMTRANSMITTEDOCTETSDPC, ASN_GAUGE, RONLY, var_mtpOmTransmittedOctetsDPCTable, 5, {1, 1, 9, 1, 1}},
#define   MTPOMTRANSMITTEDOCTETSDPCROWSTATUS  25
	{(u_char) MTPOMTRANSMITTEDOCTETSDPCROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmTransmittedOctetsDPCTable, 5, {1, 1, 9, 1, 2}},
#define   MTPOMTRANSMITTEDOCTETSDPCSIO  26
	{(u_char) MTPOMTRANSMITTEDOCTETSDPCSIO, ASN_GAUGE, RONLY, var_mtpOmTransmittedOctetsDpcSioTable, 5, {1, 1, 10, 1, 1}},
#define   MTPOMTRANSMITTEDOCTETSDPCSIOROWSTATUS  27
	{(u_char) MTPOMTRANSMITTEDOCTETSDPCSIOROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmTransmittedOctetsDpcSioTable, 5, {1, 1, 10, 1, 2}},
#define   MTPOMROUTESETUNAVAILABLE  28
	{(u_char) MTPOMROUTESETUNAVAILABLE, ASN_GAUGE, RONLY, var_mtpOmSignRsInformationTable, 5, {1, 1, 11, 1, 1}},
#define   MTPOMROUTESETUNAVAILABLEDURATION  29
	{(u_char) MTPOMROUTESETUNAVAILABLEDURATION, ASN_INTEGER, RONLY, var_mtpOmSignRsInformationTable, 5, {1, 1, 11, 1, 2}},
#define   MTPOMSLSUNAVAILABLE   30
	{(u_char) MTPOMSLSUNAVAILABLE, ASN_INTEGER, RONLY, var_mtpOmSlsDurationTable, 5, {1, 1, 12, 1, 1}},
#define   MTPOMALL5AND30MINSLDURATIONINTERVAL  31
	{(u_char) MTPOMALL5AND30MINSLDURATIONINTERVAL, ASN_INTEGER, RWRITE, var_mtpOmAll5And30MinSlDurationTable, 5, {1, 1, 13, 1, 1}},
#define   MTPOMLOCALMGNTINHIBIT  32
	{(u_char) MTPOMLOCALMGNTINHIBIT, ASN_INTEGER, RONLY, var_mtpOmAll5And30MinSlDurationTable, 5, {1, 1, 13, 1, 2}},
#define   MTPOMLOCALMGNTUNINHIBIT  33
	{(u_char) MTPOMLOCALMGNTUNINHIBIT, ASN_INTEGER, RONLY, var_mtpOmAll5And30MinSlDurationTable, 5, {1, 1, 13, 1, 3}},
#define   MTPOMLOCALBUSY        34
	{(u_char) MTPOMLOCALBUSY, ASN_GAUGE, RONLY, var_mtpOmAll5And30MinSlDurationTable, 5, {1, 1, 13, 1, 4}},
#define   MTPOMALL5AND30MINSLDURATIONROWSTATUS  35
	{(u_char) MTPOMALL5AND30MINSLDURATIONROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmAll5And30MinSlDurationTable, 5, {1, 1, 13, 1, 5}},
#define   MTPOMSLUNAVAILABILITYDURATION  36
	{(u_char) MTPOMSLUNAVAILABILITYDURATION, ASN_INTEGER, RONLY, var_mtpOmOblSlDurationTable, 5, {1, 1, 14, 1, 1}},
#define   MTPOMSLINSERVICEDURATION  37
	{(u_char) MTPOMSLINSERVICEDURATION, ASN_INTEGER, RONLY, var_mtpOmOblSlDurationTable, 5, {1, 1, 14, 1, 2}},
#define   MTPOMALL30MINSLDURATIONINTERVAL  38
	{(u_char) MTPOMALL30MINSLDURATIONINTERVAL, ASN_INTEGER, RWRITE, var_mtpOmAll30MinSlDurationTable, 5, {1, 1, 15, 1, 1}},
#define   MTPOMSLLOCALINHIBITION  39
	{(u_char) MTPOMSLLOCALINHIBITION, ASN_INTEGER, RONLY, var_mtpOmAll30MinSlDurationTable, 5, {1, 1, 15, 1, 2}},
#define   MTPOMSLREMOTEINHIBITION  40
	{(u_char) MTPOMSLREMOTEINHIBITION, ASN_INTEGER, RONLY, var_mtpOmAll30MinSlDurationTable, 5, {1, 1, 15, 1, 3}},
#define   MTPOMSLFAILED         41
	{(u_char) MTPOMSLFAILED, ASN_INTEGER, RONLY, var_mtpOmAll30MinSlDurationTable, 5, {1, 1, 15, 1, 4}},
#define   MTPOMSLREMOTEPROCOUTAGE  42
	{(u_char) MTPOMSLREMOTEPROCOUTAGE, ASN_INTEGER, RONLY, var_mtpOmAll30MinSlDurationTable, 5, {1, 1, 15, 1, 5}},
#define   MTPOMALL30MINSLDURATIONROWSTATUS  43
	{(u_char) MTPOMALL30MINSLDURATIONROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmAll30MinSlDurationTable, 5, {1, 1, 15, 1, 6}},
#define   MTPOMSLSIGNUNITSRECEIVED  44
	{(u_char) MTPOMSLSIGNUNITSRECEIVED, ASN_GAUGE, RONLY, var_mtpOmOblSlUtilizationTable, 5, {1, 1, 16, 1, 1}},
#define   MTPOMSLTRANSMITTEDOCTETSSIFSIO  45
	{(u_char) MTPOMSLTRANSMITTEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpOmOblSlUtilizationTable, 5, {1, 1, 16, 1, 2}},
#define   MTPOMSLRECEIVEDOCTETSSIFSIO  46
	{(u_char) MTPOMSLRECEIVEDOCTETSSIFSIO, ASN_GAUGE, RONLY, var_mtpOmOblSlUtilizationTable, 5, {1, 1, 16, 1, 3}},
#define   MTPOMSLDISCARDEDMSUS  47
	{(u_char) MTPOMSLDISCARDEDMSUS, ASN_GAUGE, RONLY, var_mtpOmOblSlUtilizationTable, 5, {1, 1, 16, 1, 4}},
#define   MTPOMSLALIGNMENT      48
	{(u_char) MTPOMSLALIGNMENT, ASN_GAUGE, RONLY, var_mtpOmAllSlUtilizationTable, 5, {1, 1, 17, 1, 1}},
#define   MTPOMSLNEGACKRECEIVED  49
	{(u_char) MTPOMSLNEGACKRECEIVED, ASN_GAUGE, RONLY, var_mtpOmAllSlUtilizationTable, 5, {1, 1, 17, 1, 2}},
#define   MTPOMSLRETRANSMITTEDOCTETS  50
	{(u_char) MTPOMSLRETRANSMITTEDOCTETS, ASN_GAUGE, RONLY, var_mtpOmAllSlUtilizationTable, 5, {1, 1, 17, 1, 3}},
#define   MTPOMSLTRANSMITTEDMSUS  51
	{(u_char) MTPOMSLTRANSMITTEDMSUS, ASN_GAUGE, RONLY, var_mtpOmAllSlUtilizationTable, 5, {1, 1, 17, 1, 4}},
#define   MTPOMSLRECEIVEDMSUS   52
	{(u_char) MTPOMSLRECEIVEDMSUS, ASN_GAUGE, RONLY, var_mtpOmAllSlUtilizationTable, 5, {1, 1, 17, 1, 5}},
#define   MTPOMALLSLUTILIZATIONROWSTATUS  53
	{(u_char) MTPOMALLSLUTILIZATIONROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmAllSlUtilizationTable, 5, {1, 1, 17, 1, 6}},
#define   MTPOMSLCONGESTIONFIRST  54
	{(u_char) MTPOMSLCONGESTIONFIRST, ASN_INTEGER, RWRITE, var_mtpOmSlCongestionTable, 5, {1, 1, 18, 1, 1}},
#define   MTPOMSLCONGESTIONINTERVAL  55
	{(u_char) MTPOMSLCONGESTIONINTERVAL, ASN_INTEGER, RWRITE, var_mtpOmSlCongestionTable, 5, {1, 1, 18, 1, 2}},
#define   MTPOMSLCONGESTIONSTARTS  56
	{(u_char) MTPOMSLCONGESTIONSTARTS, ASN_GAUGE, RONLY, var_mtpOmSlCongestionTable, 5, {1, 1, 18, 1, 3}},
#define   MTPOMSLCONGESTIONSTOPS  57
	{(u_char) MTPOMSLCONGESTIONSTOPS, ASN_GAUGE, RONLY, var_mtpOmSlCongestionTable, 5, {1, 1, 18, 1, 4}},
#define   MTPOMSLCONGESTIONEVENTSMSULOSS  58
	{(u_char) MTPOMSLCONGESTIONEVENTSMSULOSS, ASN_GAUGE, RONLY, var_mtpOmSlCongestionTable, 5, {1, 1, 18, 1, 5}},
#define   MTPOMSLCONGESTIONROWSTATUS  59
	{(u_char) MTPOMSLCONGESTIONROWSTATUS, ASN_INTEGER, RWRITE, var_mtpOmSlCongestionTable, 5, {1, 1, 18, 1, 6}},
};

/* (L = length of the oidsuffix) */
struct mtpOmMIB_data *mtpOmMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *mtpOmHandledMSUsOpcDpcSioTableStorage = NULL;
struct header_complex_index *mtpOmHandledOctetsOpcDpcSioTableStorage = NULL;
struct header_complex_index *mtpOmHandledOctetsSIOTableStorage = NULL;
struct header_complex_index *mtpOmOblSpUtilizationTableStorage = NULL;
struct header_complex_index *mtpOmAllSpUtilizationTableStorage = NULL;
struct header_complex_index *mtpOmReceivedOctetsOPCTableStorage = NULL;
struct header_complex_index *mtpOmReceivedOctetsOpcSioTableStorage = NULL;
struct header_complex_index *mtpOmSpDataTableStorage = NULL;
struct header_complex_index *mtpOmTransmittedOctetsDPCTableStorage = NULL;
struct header_complex_index *mtpOmTransmittedOctetsDpcSioTableStorage = NULL;
struct header_complex_index *mtpOmSignRsInformationTableStorage = NULL;
struct header_complex_index *mtpOmSlsDurationTableStorage = NULL;
struct header_complex_index *mtpOmAll5And30MinSlDurationTableStorage = NULL;
struct header_complex_index *mtpOmOblSlDurationTableStorage = NULL;
struct header_complex_index *mtpOmAll30MinSlDurationTableStorage = NULL;
struct header_complex_index *mtpOmOblSlUtilizationTableStorage = NULL;
struct header_complex_index *mtpOmAllSlUtilizationTableStorage = NULL;
struct header_complex_index *mtpOmSlCongestionTableStorage = NULL;

void (*mtpOmMIBold_signal_handler) (int) = NULL;	/* save old signal handler just in case */
void mtpOmMIB_loop_handler(int);
void mtpOmMIB_fd_handler(int, void *);

/**
 * @fn void init_mtpOmMIB(void)
 * @brief mtpOmMIB initialization routine.
 *
 * This is called when the agent starts up.  At a minimum, registration of the MIB variables
 * structure (mtpOmMIB_variables) should take place here.  By default the function also
 * registers the configuration handler and configuration store callbacks.
 *
 * Additional registrations that may be considered here are calls to regsiter_readfd(),
 * register_writefd() and register_exceptfd() for hooking into the snmpd event loop, but only when
 * used as a loadable module.  By default this function establishes a single file descriptor to
 * read, or upon which to handle exceptions.  Note that the snmpd only supports a maximum of 32
 * extneral file descriptors, so these should be used sparingly.
 *
 * When running as a loadable module, it is also necessary to hook into the snmpd event loop so that
 * the current request number can be deteremined.  This is accomplished by using a trick of the
 * external_signal_scheduled and external_signal_handler mechanism which is called on each event
 * loop when external_signal_scheduled is non-zero.  This is used to increment the sa_request value
 * on each snmpd event loop interation so that calls to MIB tree functions can determine whether
 * they belong to a fresh request or not (primarily for cacheing and possibly to clean up non-polled
 * file descriptors).
 */
void
init_mtpOmMIB(void)
{
	(void) my_fd;
	(void) zeroDotZero_oid;
	(void) snmpTrapOID_oid;
	DEBUGMSGTL(("mtpOmMIB", "init_mtpOmMIB: initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("mtpOmMIB", mtpOmMIB_variables, variable7, mtpOmMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_mtpOmMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("mtpOmMIB", parse_mtpOmMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmHandledMSUsOpcDpcSioTable", parse_mtpOmHandledMSUsOpcDpcSioTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmHandledOctetsOpcDpcSioTable", parse_mtpOmHandledOctetsOpcDpcSioTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmHandledOctetsSIOTable", parse_mtpOmHandledOctetsSIOTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmOblSpUtilizationTable", parse_mtpOmOblSpUtilizationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmAllSpUtilizationTable", parse_mtpOmAllSpUtilizationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmReceivedOctetsOPCTable", parse_mtpOmReceivedOctetsOPCTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmReceivedOctetsOpcSioTable", parse_mtpOmReceivedOctetsOpcSioTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSpDataTable", parse_mtpOmSpDataTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmTransmittedOctetsDPCTable", parse_mtpOmTransmittedOctetsDPCTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmTransmittedOctetsDpcSioTable", parse_mtpOmTransmittedOctetsDpcSioTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSignRsInformationTable", parse_mtpOmSignRsInformationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlsDurationTable", parse_mtpOmSlsDurationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmAll5And30MinSlDurationTable", parse_mtpOmAll5And30MinSlDurationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmOblSlDurationTable", parse_mtpOmOblSlDurationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmAll30MinSlDurationTable", parse_mtpOmAll30MinSlDurationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmOblSlUtilizationTable", parse_mtpOmOblSlUtilizationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmAllSlUtilizationTable", parse_mtpOmAllSlUtilizationTable, NULL, "HELP STRING");
	snmpd_register_config_handler("mtpOmSlCongestionTable", parse_mtpOmSlCongestionTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmHandledMSUsOpcDpcSioTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmHandledOctetsOpcDpcSioTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmHandledOctetsSIOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmOblSpUtilizationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmAllSpUtilizationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmReceivedOctetsOPCTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmReceivedOctetsOpcSioTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSpDataTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmTransmittedOctetsDPCTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmTransmittedOctetsDpcSioTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSignRsInformationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlsDurationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmAll5And30MinSlDurationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmOblSlDurationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmAll30MinSlDurationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmOblSlUtilizationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmAllSlUtilizationTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_mtpOmSlCongestionTable, NULL);

	/* place any other initialization junk you need here */
	if (my_readfd >= 0) {
		register_readfd(my_readfd, mtpOmMIB_fd_handler, (void *) 0);
		register_exceptfd(my_readfd, mtpOmMIB_fd_handler, (void *) 1);
	}
	mtpOmMIBold_signal_handler = external_signal_handler[SIGCHLD];
	external_signal_handler[SIGCHLD] = &mtpOmMIB_loop_handler;
	external_signal_scheduled[SIGCHLD] = 1;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/**
 * @fn void deinit_mtpOmMIB(void)
 * @brief deinitialization routine.
 *
 * This is called before the agent is unloaded.  At a minimum, deregistration of the MIB variables
 * structure (mtpOmMIB_variables) should take place here.  By default, the function also
 * deregisters the the configuration file handlers for the MIB variables and table rows.
 *
 * Additional deregistrations that may be required here are calls to unregister_readfd(),
 * unregister_writefd() and unregsiter_exceptfd() for unhooking from the snmpd event loop, but only
 * when used as a loadable module.  By default if a read file descriptor exists, it is unregistered.
 */
void
deinit_mtpOmMIB(void)
{
	DEBUGMSGTL(("mtpOmMIB", "deinit_mtpOmMIB: deinitializating...  "));
	external_signal_handler[SIGCHLD] = mtpOmMIBold_signal_handler;
	if (my_readfd >= 0) {
		unregister_exceptfd(my_readfd);
		unregister_readfd(my_readfd);
		close(my_readfd);
		my_readfd = -1;
	}
	unregister_mib(mtpOmMIB_variables_oid, sizeof(mtpOmMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("mtpOmMIB");
	snmpd_unregister_config_handler("mtpOmHandledMSUsOpcDpcSioTable");
	snmpd_unregister_config_handler("mtpOmHandledOctetsOpcDpcSioTable");
	snmpd_unregister_config_handler("mtpOmHandledOctetsSIOTable");
	snmpd_unregister_config_handler("mtpOmOblSpUtilizationTable");
	snmpd_unregister_config_handler("mtpOmAllSpUtilizationTable");
	snmpd_unregister_config_handler("mtpOmReceivedOctetsOPCTable");
	snmpd_unregister_config_handler("mtpOmReceivedOctetsOpcSioTable");
	snmpd_unregister_config_handler("mtpOmSpDataTable");
	snmpd_unregister_config_handler("mtpOmTransmittedOctetsDPCTable");
	snmpd_unregister_config_handler("mtpOmTransmittedOctetsDpcSioTable");
	snmpd_unregister_config_handler("mtpOmSignRsInformationTable");
	snmpd_unregister_config_handler("mtpOmSlsDurationTable");
	snmpd_unregister_config_handler("mtpOmAll5And30MinSlDurationTable");
	snmpd_unregister_config_handler("mtpOmOblSlDurationTable");
	snmpd_unregister_config_handler("mtpOmAll30MinSlDurationTable");
	snmpd_unregister_config_handler("mtpOmOblSlUtilizationTable");
	snmpd_unregister_config_handler("mtpOmAllSlUtilizationTable");
	snmpd_unregister_config_handler("mtpOmSlCongestionTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

int
term_mtpOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	DEBUGMSGTL(("mtpOmMIB", "term_mtpOmMIB: terminating...  "));
	deinit_mtpOmMIB();
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return 0;
}

/**
 * @fn struct mtpOmMIB_data *mtpOmMIB_create(void)
 * @brief create a fresh data structure representing scalars in mtpOmMIB.
 *
 * Creates a new mtpOmMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in mtpOmMIB.
 */
struct mtpOmMIB_data *
mtpOmMIB_create(void)
{
	struct mtpOmMIB_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmMIB_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_create: creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */

	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmMIB_data *mtpOmMIB_duplicate(struct mtpOmMIB_data *thedata)
 * @param thedata the mib structure to duplicate
 * @brief duplicate a mib structure for the mib
 *
 * Duplicates the specified mib structure @param thedata and returns a pointer to the newly
 * allocated mib structure on success, or NULL on failure.
 */
struct mtpOmMIB_data *
mtpOmMIB_duplicate(struct mtpOmMIB_data *thedata)
{
	struct mtpOmMIB_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmMIB_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_duplicate: duplicating mib... "));
	if (StorageNew != NULL) {
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmMIB_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmMIB_destroy(struct mtpOmMIB_data **thedata)
 * @param thedata pointer to the data structure in mtpOmMIB.
 * @brief delete a scalars structure from mtpOmMIB.
 *
 * Frees scalars that were previously removed from mtpOmMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmMIB_destroy(struct mtpOmMIB_data **thedata)
{
	struct mtpOmMIB_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_destroy: deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmMIB_add(struct mtpOmMIB_data *thedata)
 * @param thedata the structure representing mtpOmMIB scalars.
 * @brief adds node to the mtpOmMIB scalar data set.
 *
 * Adds a scalar structure to the mtpOmMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
mtpOmMIB_add(struct mtpOmMIB_data *thedata)
{
	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_add: adding data...  "));
	if (thedata)
		mtpOmMIBStorage = thedata;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmMIB entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_mtpOmMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmMIB_data *StorageTmp = mtpOmMIB_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmMIB: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	mtpOmMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmMIB_data *StorageTmp;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmMIB: storing data...  "));
	refresh_mtpOmMIB(1);
	if ((StorageTmp = mtpOmMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpOmMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "mtpOmMIB ");
		cptr = line + strlen(line);
		(void) cptr;
		/* XXX: remove individual scalars that are not persistent */
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int check_mtpOmMIB(struct mtpOmMIB_data *StorageTmp, struct mtpOmMIB_data *StorageOld)
 * @param StorageTmp the data as updated
 * @param StorageOld the data previous to update
 *
 * This function is used by mibs.  It is used to check, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the ACTION phase.  The COMMIT phase does not ensue unless this check passes.  This function can
 * return SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before
 * the varbinds on the mib were applied; the values in StorageTmp are the new values.  The function
 * is permitted to change the values in StorageTmp to correct them; however, preferences should be
 * made for setting values that were not in the varbinds.
 */
int
check_mtpOmMIB(struct mtpOmMIB_data *StorageTmp, struct mtpOmMIB_data *StorageOld)
{
	/* XXX: provide code to check the scalars for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmMIB(struct mtpOmMIB_data *StorageTmp, struct mtpOmMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase)
 *
 * This function is used by mibs.  It is used to update, all scalars at a time, the varbinds
 * belonging to the mib.  This function is called for the first varbind in a mib at the beginning of
 * the COMMIT phase.  The start of the ACTION phase performs a consistency check on the mib before
 * allowing the request to proceed to the COMMIT phase.  The COMMIT phase then arrives here with
 * consistency already checked (see check_mtpOmMIB()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the mib were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmMIB(struct mtpOmMIB_data *StorageTmp, struct mtpOmMIB_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmMIB_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn revert_mtpOmMIB(struct 
 * @fn void revert_mtpOmMIB(struct mtpOmMIB_data *StorageTmp, struct mtpOmMIB_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase)
 */
void
revert_mtpOmMIB(struct mtpOmMIB_data *StorageTmp, struct mtpOmMIB_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmMIB(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmMIB(int force)
 * @param force forced refresh when non-zero.
 * @brief refresh the scalar values of mtpOmMIB.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_mtpOmMIB(int force)
{
	if (mtpOmMIBStorage == NULL) {
		struct mtpOmMIB_data *StorageNew;

		if ((StorageNew = mtpOmMIB_create()) == NULL)
			return;
		mtpOmMIBStorage = StorageNew;
		mtpOmMIB_refresh = 1;
	}
	if (!force && mtpOmMIB_refresh == 0)
		return;
	DEBUGMSGTL(("mtpOmMIB", "refresh_mtpOmMIB: refreshing...  "));
	/* XXX: Update scalars as required here... */
	mtpOmMIB_refresh = 0;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/**
 * @fn u_char * var_mtpOmMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @param vp a pointer to the entry in the variables table for the requested variable.
 * @param name the object identifier for which to find.
 * @param length the length of the object identifier.
 * @param exact whether the name is exact.
 * @param var_len a pointer to the length of the representation of the object.
 * @param write_method a pointer to a write method for the object.
 * @brief locate variables in mtpOmMIB.
 *
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
u_char *
var_mtpOmMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmMIB_data *StorageTmp;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmMIB: lookup up varbind...  "));
	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_mtpOmMIB(0);
	if ((StorageTmp = mtpOmMIBStorage) == NULL) {
		DEBUGMSGTL(("mtpOmMIB", "no datastructure.\n"));
		return NULL;
	}
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	if (rval)
		DEBUGMSGTL(("mtpOmMIB", "found.\n"));
	else
		DEBUGMSGTL(("mtpOmMIB", "not found.\n"));
	return (rval);
}

/**
 * @fn struct mtpOmHandledMSUsOpcDpcSioTable_data *mtpOmHandledMSUsOpcDpcSioTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmHandledMSUsOpcDpcSioTable table.
 *
 * Creates a new mtpOmHandledMSUsOpcDpcSioTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmHandledMSUsOpcDpcSioTable_data *
mtpOmHandledMSUsOpcDpcSioTable_create(void)
{
	struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmHandledMSUsOpcDpcSioTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledMSUsOpcDpcSioTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmHandledMSUsOpcDpcSio = 0;
		StorageNew->mtpOmHandledMSUsOpcDpcSioRowStatus = 0;
		StorageNew->mtpOmHandledMSUsOpcDpcSioRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmHandledMSUsOpcDpcSioTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmHandledMSUsOpcDpcSioTable_data *mtpOmHandledMSUsOpcDpcSioTable_duplicate(struct mtpOmHandledMSUsOpcDpcSioTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmHandledMSUsOpcDpcSioTable_data *
mtpOmHandledMSUsOpcDpcSioTable_duplicate(struct mtpOmHandledMSUsOpcDpcSioTable_data *thedata)
{
	struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmHandledMSUsOpcDpcSioTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledMSUsOpcDpcSioTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmHandledMSUsOpcDpcSioTable_id = thedata->mtpOmHandledMSUsOpcDpcSioTable_id;
		StorageNew->mtpSpId = thedata->mtpSpId;
		if (!(StorageNew->mtpOmOpc = malloc(thedata->mtpOmOpcLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmOpc, thedata->mtpOmOpc, thedata->mtpOmOpcLen);
		StorageNew->mtpOmOpcLen = thedata->mtpOmOpcLen;
		StorageNew->mtpOmOpc[StorageNew->mtpOmOpcLen] = 0;
		if (!(StorageNew->mtpOmDpc = malloc(thedata->mtpOmDpcLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmDpc, thedata->mtpOmDpc, thedata->mtpOmDpcLen);
		StorageNew->mtpOmDpcLen = thedata->mtpOmDpcLen;
		StorageNew->mtpOmDpc[StorageNew->mtpOmDpcLen] = 0;
		if (!(StorageNew->mtpOmSio = malloc(thedata->mtpOmSioLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmSio, thedata->mtpOmSio, thedata->mtpOmSioLen);
		StorageNew->mtpOmSioLen = thedata->mtpOmSioLen;
		StorageNew->mtpOmSio[StorageNew->mtpOmSioLen] = 0;
		StorageNew->mtpOmHandledMSUsOpcDpcSio = thedata->mtpOmHandledMSUsOpcDpcSio;
		StorageNew->mtpOmHandledMSUsOpcDpcSioRowStatus = thedata->mtpOmHandledMSUsOpcDpcSioRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmHandledMSUsOpcDpcSioTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmHandledMSUsOpcDpcSioTable_destroy(struct mtpOmHandledMSUsOpcDpcSioTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmHandledMSUsOpcDpcSioTable_destroy(struct mtpOmHandledMSUsOpcDpcSioTable_data **thedata)
{
	struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledMSUsOpcDpcSioTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpOmOpc);
		StorageDel->mtpOmOpcLen = 0;
		SNMP_FREE(StorageDel->mtpOmDpc);
		StorageDel->mtpOmDpcLen = 0;
		SNMP_FREE(StorageDel->mtpOmSio);
		StorageDel->mtpOmSioLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmHandledMSUsOpcDpcSioTable_add(struct mtpOmHandledMSUsOpcDpcSioTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmHandledMSUsOpcDpcSioTable table data set.
 *
 * Adds a table row structure to the mtpOmHandledMSUsOpcDpcSioTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmHandledMSUsOpcDpcSioTable_add(struct mtpOmHandledMSUsOpcDpcSioTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledMSUsOpcDpcSioTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmOpc */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmOpc, thedata->mtpOmOpcLen);
		/* mtpOmDpc */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmDpc, thedata->mtpOmDpcLen);
		/* mtpOmSio */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmSio, thedata->mtpOmSioLen);
		header_complex_add_data(&mtpOmHandledMSUsOpcDpcSioTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmHandledMSUsOpcDpcSioTable_del(struct mtpOmHandledMSUsOpcDpcSioTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmHandledMSUsOpcDpcSioTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmHandledMSUsOpcDpcSioTable_del(struct mtpOmHandledMSUsOpcDpcSioTable_data *thedata)
{
	struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledMSUsOpcDpcSioTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmHandledMSUsOpcDpcSioTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmHandledMSUsOpcDpcSioTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmHandledMSUsOpcDpcSioTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmHandledMSUsOpcDpcSioTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmHandledMSUsOpcDpcSioTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmHandledMSUsOpcDpcSioTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp = mtpOmHandledMSUsOpcDpcSioTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmHandledMSUsOpcDpcSioTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpOmOpc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmOpc, &StorageTmp->mtpOmOpcLen);
	if (StorageTmp->mtpOmOpc == NULL) {
		config_perror("invalid specification for mtpOmOpc");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOmDpc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmDpc, &StorageTmp->mtpOmDpcLen);
	if (StorageTmp->mtpOmDpc == NULL) {
		config_perror("invalid specification for mtpOmDpc");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOmSio);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmSio, &StorageTmp->mtpOmSioLen);
	if (StorageTmp->mtpOmSio == NULL) {
		config_perror("invalid specification for mtpOmSio");
		return;
	}
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmHandledMSUsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus, &tmpsize);
	mtpOmHandledMSUsOpcDpcSioTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmHandledMSUsOpcDpcSioTable(): store configuraiton file for mtpOmHandledMSUsOpcDpcSioTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmHandledMSUsOpcDpcSioTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmHandledMSUsOpcDpcSioTable: storing data...  "));
	refresh_mtpOmHandledMSUsOpcDpcSioTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmHandledMSUsOpcDpcSioTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmHandledMSUsOpcDpcSioTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmHandledMSUsOpcDpcSioTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmOpc, &StorageTmp->mtpOmOpcLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmDpc, &StorageTmp->mtpOmDpcLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmSio, &StorageTmp->mtpOmSioLen);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmHandledMSUsOpcDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmHandledOctetsOpcDpcSioTable_data *mtpOmHandledOctetsOpcDpcSioTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmHandledOctetsOpcDpcSioTable table.
 *
 * Creates a new mtpOmHandledOctetsOpcDpcSioTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmHandledOctetsOpcDpcSioTable_data *
mtpOmHandledOctetsOpcDpcSioTable_create(void)
{
	struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmHandledOctetsOpcDpcSioTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledOctetsOpcDpcSioTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		if ((StorageNew->mtpOmOpc = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpOmOpcLen = 0;
		StorageNew->mtpOmOpc[StorageNew->mtpOmOpcLen] = 0;
		if ((StorageNew->mtpOmDpc = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpOmDpcLen = 0;
		StorageNew->mtpOmDpc[StorageNew->mtpOmDpcLen] = 0;
		if ((StorageNew->mtpOmSio = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpOmSioLen = 0;
		StorageNew->mtpOmSio[StorageNew->mtpOmSioLen] = 0;
		StorageNew->mtpOmHandledOctetsOpcDpcSioInterval = 180000;
		StorageNew->mtpOmHandledOctetsOpcDpcSio = 0;
		StorageNew->mtpOmHandledOctetsOpcDpcSioRowStatus = 0;
		StorageNew->mtpOmHandledOctetsOpcDpcSioRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmHandledOctetsOpcDpcSioTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmHandledOctetsOpcDpcSioTable_data *mtpOmHandledOctetsOpcDpcSioTable_duplicate(struct mtpOmHandledOctetsOpcDpcSioTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmHandledOctetsOpcDpcSioTable_data *
mtpOmHandledOctetsOpcDpcSioTable_duplicate(struct mtpOmHandledOctetsOpcDpcSioTable_data *thedata)
{
	struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmHandledOctetsOpcDpcSioTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledOctetsOpcDpcSioTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmHandledOctetsOpcDpcSioTable_id = thedata->mtpOmHandledOctetsOpcDpcSioTable_id;
		StorageNew->mtpSpId = thedata->mtpSpId;
		if (!(StorageNew->mtpOmOpc = malloc(thedata->mtpOmOpcLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmOpc, thedata->mtpOmOpc, thedata->mtpOmOpcLen);
		StorageNew->mtpOmOpcLen = thedata->mtpOmOpcLen;
		StorageNew->mtpOmOpc[StorageNew->mtpOmOpcLen] = 0;
		if (!(StorageNew->mtpOmDpc = malloc(thedata->mtpOmDpcLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmDpc, thedata->mtpOmDpc, thedata->mtpOmDpcLen);
		StorageNew->mtpOmDpcLen = thedata->mtpOmDpcLen;
		StorageNew->mtpOmDpc[StorageNew->mtpOmDpcLen] = 0;
		if (!(StorageNew->mtpOmSio = malloc(thedata->mtpOmSioLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmSio, thedata->mtpOmSio, thedata->mtpOmSioLen);
		StorageNew->mtpOmSioLen = thedata->mtpOmSioLen;
		StorageNew->mtpOmSio[StorageNew->mtpOmSioLen] = 0;
		StorageNew->mtpOmHandledOctetsOpcDpcSioInterval = thedata->mtpOmHandledOctetsOpcDpcSioInterval;
		StorageNew->mtpOmHandledOctetsOpcDpcSio = thedata->mtpOmHandledOctetsOpcDpcSio;
		StorageNew->mtpOmHandledOctetsOpcDpcSioRowStatus = thedata->mtpOmHandledOctetsOpcDpcSioRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmHandledOctetsOpcDpcSioTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmHandledOctetsOpcDpcSioTable_destroy(struct mtpOmHandledOctetsOpcDpcSioTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmHandledOctetsOpcDpcSioTable_destroy(struct mtpOmHandledOctetsOpcDpcSioTable_data **thedata)
{
	struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledOctetsOpcDpcSioTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpOmOpc);
		StorageDel->mtpOmOpcLen = 0;
		SNMP_FREE(StorageDel->mtpOmDpc);
		StorageDel->mtpOmDpcLen = 0;
		SNMP_FREE(StorageDel->mtpOmSio);
		StorageDel->mtpOmSioLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmHandledOctetsOpcDpcSioTable_add(struct mtpOmHandledOctetsOpcDpcSioTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmHandledOctetsOpcDpcSioTable table data set.
 *
 * Adds a table row structure to the mtpOmHandledOctetsOpcDpcSioTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmHandledOctetsOpcDpcSioTable_add(struct mtpOmHandledOctetsOpcDpcSioTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledOctetsOpcDpcSioTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmOpc */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmOpc, thedata->mtpOmOpcLen);
		/* mtpOmDpc */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmDpc, thedata->mtpOmDpcLen);
		/* mtpOmSio */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmSio, thedata->mtpOmSioLen);
		header_complex_add_data(&mtpOmHandledOctetsOpcDpcSioTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmHandledOctetsOpcDpcSioTable_del(struct mtpOmHandledOctetsOpcDpcSioTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmHandledOctetsOpcDpcSioTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmHandledOctetsOpcDpcSioTable_del(struct mtpOmHandledOctetsOpcDpcSioTable_data *thedata)
{
	struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledOctetsOpcDpcSioTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmHandledOctetsOpcDpcSioTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmHandledOctetsOpcDpcSioTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmHandledOctetsOpcDpcSioTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmHandledOctetsOpcDpcSioTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmHandledOctetsOpcDpcSioTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmHandledOctetsOpcDpcSioTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp = mtpOmHandledOctetsOpcDpcSioTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmHandledOctetsOpcDpcSioTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpOmOpc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmOpc, &StorageTmp->mtpOmOpcLen);
	if (StorageTmp->mtpOmOpc == NULL) {
		config_perror("invalid specification for mtpOmOpc");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOmDpc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmDpc, &StorageTmp->mtpOmDpcLen);
	if (StorageTmp->mtpOmDpc == NULL) {
		config_perror("invalid specification for mtpOmDpc");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOmSio);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmSio, &StorageTmp->mtpOmSioLen);
	if (StorageTmp->mtpOmSio == NULL) {
		config_perror("invalid specification for mtpOmSio");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmHandledOctetsOpcDpcSioInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmHandledOctetsOpcDpcSio, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus, &tmpsize);
	mtpOmHandledOctetsOpcDpcSioTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmHandledOctetsOpcDpcSioTable(): store configuraiton file for mtpOmHandledOctetsOpcDpcSioTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmHandledOctetsOpcDpcSioTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmHandledOctetsOpcDpcSioTable: storing data...  "));
	refresh_mtpOmHandledOctetsOpcDpcSioTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmHandledOctetsOpcDpcSioTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmHandledOctetsOpcDpcSioTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmHandledOctetsOpcDpcSioTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmOpc, &StorageTmp->mtpOmOpcLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmDpc, &StorageTmp->mtpOmDpcLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmSio, &StorageTmp->mtpOmSioLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmHandledOctetsOpcDpcSioInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmHandledOctetsOpcDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmHandledOctetsSIOTable_data *mtpOmHandledOctetsSIOTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmHandledOctetsSIOTable table.
 *
 * Creates a new mtpOmHandledOctetsSIOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmHandledOctetsSIOTable_data *
mtpOmHandledOctetsSIOTable_create(void)
{
	struct mtpOmHandledOctetsSIOTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmHandledOctetsSIOTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledOctetsSIOTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		if ((StorageNew->mtpOmSio = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpOmSioLen = 0;
		StorageNew->mtpOmSio[StorageNew->mtpOmSioLen] = 0;
		StorageNew->mtpOmHandledOctetsSIO = 0;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmHandledOctetsSIOTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmHandledOctetsSIOTable_data *mtpOmHandledOctetsSIOTable_duplicate(struct mtpOmHandledOctetsSIOTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmHandledOctetsSIOTable_data *
mtpOmHandledOctetsSIOTable_duplicate(struct mtpOmHandledOctetsSIOTable_data *thedata)
{
	struct mtpOmHandledOctetsSIOTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmHandledOctetsSIOTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledOctetsSIOTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmHandledOctetsSIOTable_id = thedata->mtpOmHandledOctetsSIOTable_id;
		StorageNew->mtpSpId = thedata->mtpSpId;
		if (!(StorageNew->mtpOmSio = malloc(thedata->mtpOmSioLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmSio, thedata->mtpOmSio, thedata->mtpOmSioLen);
		StorageNew->mtpOmSioLen = thedata->mtpOmSioLen;
		StorageNew->mtpOmSio[StorageNew->mtpOmSioLen] = 0;
		StorageNew->mtpOmHandledOctetsSIO = thedata->mtpOmHandledOctetsSIO;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmHandledOctetsSIOTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmHandledOctetsSIOTable_destroy(struct mtpOmHandledOctetsSIOTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmHandledOctetsSIOTable_destroy(struct mtpOmHandledOctetsSIOTable_data **thedata)
{
	struct mtpOmHandledOctetsSIOTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledOctetsSIOTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpOmSio);
		StorageDel->mtpOmSioLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmHandledOctetsSIOTable_add(struct mtpOmHandledOctetsSIOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmHandledOctetsSIOTable table data set.
 *
 * Adds a table row structure to the mtpOmHandledOctetsSIOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmHandledOctetsSIOTable_add(struct mtpOmHandledOctetsSIOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledOctetsSIOTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmSio */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmSio, thedata->mtpOmSioLen);
		header_complex_add_data(&mtpOmHandledOctetsSIOTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmHandledOctetsSIOTable_del(struct mtpOmHandledOctetsSIOTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmHandledOctetsSIOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmHandledOctetsSIOTable_del(struct mtpOmHandledOctetsSIOTable_data *thedata)
{
	struct mtpOmHandledOctetsSIOTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmHandledOctetsSIOTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmHandledOctetsSIOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmHandledOctetsSIOTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmHandledOctetsSIOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmHandledOctetsSIOTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmHandledOctetsSIOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmHandledOctetsSIOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmHandledOctetsSIOTable_data *StorageTmp = mtpOmHandledOctetsSIOTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmHandledOctetsSIOTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpOmSio);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmSio, &StorageTmp->mtpOmSioLen);
	if (StorageTmp->mtpOmSio == NULL) {
		config_perror("invalid specification for mtpOmSio");
		return;
	}
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmHandledOctetsSIO, &tmpsize);
	mtpOmHandledOctetsSIOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmHandledOctetsSIOTable(): store configuraiton file for mtpOmHandledOctetsSIOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmHandledOctetsSIOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmHandledOctetsSIOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmHandledOctetsSIOTable: storing data...  "));
	refresh_mtpOmHandledOctetsSIOTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmHandledOctetsSIOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmHandledOctetsSIOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmHandledOctetsSIOTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmSio, &StorageTmp->mtpOmSioLen);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmHandledOctetsSIO, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmOblSpUtilizationTable_data *mtpOmOblSpUtilizationTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmOblSpUtilizationTable table.
 *
 * Creates a new mtpOmOblSpUtilizationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmOblSpUtilizationTable_data *
mtpOmOblSpUtilizationTable_create(void)
{
	struct mtpOmOblSpUtilizationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmOblSpUtilizationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSpUtilizationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmAdjacentInaccessibleDuration = 0;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmOblSpUtilizationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmOblSpUtilizationTable_data *mtpOmOblSpUtilizationTable_duplicate(struct mtpOmOblSpUtilizationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmOblSpUtilizationTable_data *
mtpOmOblSpUtilizationTable_duplicate(struct mtpOmOblSpUtilizationTable_data *thedata)
{
	struct mtpOmOblSpUtilizationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmOblSpUtilizationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSpUtilizationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmOblSpUtilizationTable_id = thedata->mtpOmOblSpUtilizationTable_id;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpOmAdjacentInaccessibleDuration = thedata->mtpOmAdjacentInaccessibleDuration;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmOblSpUtilizationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmOblSpUtilizationTable_destroy(struct mtpOmOblSpUtilizationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmOblSpUtilizationTable_destroy(struct mtpOmOblSpUtilizationTable_data **thedata)
{
	struct mtpOmOblSpUtilizationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSpUtilizationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmOblSpUtilizationTable_add(struct mtpOmOblSpUtilizationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmOblSpUtilizationTable table data set.
 *
 * Adds a table row structure to the mtpOmOblSpUtilizationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmOblSpUtilizationTable_add(struct mtpOmOblSpUtilizationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSpUtilizationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		header_complex_add_data(&mtpOmOblSpUtilizationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmOblSpUtilizationTable_del(struct mtpOmOblSpUtilizationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmOblSpUtilizationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmOblSpUtilizationTable_del(struct mtpOmOblSpUtilizationTable_data *thedata)
{
	struct mtpOmOblSpUtilizationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSpUtilizationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmOblSpUtilizationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmOblSpUtilizationTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmOblSpUtilizationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmOblSpUtilizationTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmOblSpUtilizationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmOblSpUtilizationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmOblSpUtilizationTable_data *StorageTmp = mtpOmOblSpUtilizationTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmOblSpUtilizationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmAdjacentInaccessibleDuration, &tmpsize);
	mtpOmOblSpUtilizationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmOblSpUtilizationTable(): store configuraiton file for mtpOmOblSpUtilizationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmOblSpUtilizationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmOblSpUtilizationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmOblSpUtilizationTable: storing data...  "));
	refresh_mtpOmOblSpUtilizationTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmOblSpUtilizationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmOblSpUtilizationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmOblSpUtilizationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmAdjacentInaccessibleDuration, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmAllSpUtilizationTable_data *mtpOmAllSpUtilizationTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmAllSpUtilizationTable table.
 *
 * Creates a new mtpOmAllSpUtilizationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmAllSpUtilizationTable_data *
mtpOmAllSpUtilizationTable_create(void)
{
	struct mtpOmAllSpUtilizationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmAllSpUtilizationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAllSpUtilizationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmAdjacentInaccessibleEvents = 0;
		StorageNew->mtpOmAllSpUtilizationRowStatus = 0;
		StorageNew->mtpOmAllSpUtilizationRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmAllSpUtilizationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmAllSpUtilizationTable_data *mtpOmAllSpUtilizationTable_duplicate(struct mtpOmAllSpUtilizationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmAllSpUtilizationTable_data *
mtpOmAllSpUtilizationTable_duplicate(struct mtpOmAllSpUtilizationTable_data *thedata)
{
	struct mtpOmAllSpUtilizationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmAllSpUtilizationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAllSpUtilizationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmAllSpUtilizationTable_id = thedata->mtpOmAllSpUtilizationTable_id;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpOmAdjacentInaccessibleEvents = thedata->mtpOmAdjacentInaccessibleEvents;
		StorageNew->mtpOmAllSpUtilizationRowStatus = thedata->mtpOmAllSpUtilizationRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmAllSpUtilizationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmAllSpUtilizationTable_destroy(struct mtpOmAllSpUtilizationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmAllSpUtilizationTable_destroy(struct mtpOmAllSpUtilizationTable_data **thedata)
{
	struct mtpOmAllSpUtilizationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAllSpUtilizationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmAllSpUtilizationTable_add(struct mtpOmAllSpUtilizationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmAllSpUtilizationTable table data set.
 *
 * Adds a table row structure to the mtpOmAllSpUtilizationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmAllSpUtilizationTable_add(struct mtpOmAllSpUtilizationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAllSpUtilizationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		header_complex_add_data(&mtpOmAllSpUtilizationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmAllSpUtilizationTable_del(struct mtpOmAllSpUtilizationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmAllSpUtilizationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmAllSpUtilizationTable_del(struct mtpOmAllSpUtilizationTable_data *thedata)
{
	struct mtpOmAllSpUtilizationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAllSpUtilizationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmAllSpUtilizationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmAllSpUtilizationTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmAllSpUtilizationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmAllSpUtilizationTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmAllSpUtilizationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmAllSpUtilizationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmAllSpUtilizationTable_data *StorageTmp = mtpOmAllSpUtilizationTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmAllSpUtilizationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmAdjacentInaccessibleEvents, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmAllSpUtilizationRowStatus, &tmpsize);
	mtpOmAllSpUtilizationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmAllSpUtilizationTable(): store configuraiton file for mtpOmAllSpUtilizationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmAllSpUtilizationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmAllSpUtilizationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmAllSpUtilizationTable: storing data...  "));
	refresh_mtpOmAllSpUtilizationTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmAllSpUtilizationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmAllSpUtilizationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmAllSpUtilizationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmAdjacentInaccessibleEvents, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmAllSpUtilizationRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmReceivedOctetsOPCTable_data *mtpOmReceivedOctetsOPCTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmReceivedOctetsOPCTable table.
 *
 * Creates a new mtpOmReceivedOctetsOPCTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmReceivedOctetsOPCTable_data *
mtpOmReceivedOctetsOPCTable_create(void)
{
	struct mtpOmReceivedOctetsOPCTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmReceivedOctetsOPCTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmReceivedOctetsOPCTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		if ((StorageNew->mtpOmOpc = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpOmOpcLen = 0;
		StorageNew->mtpOmOpc[StorageNew->mtpOmOpcLen] = 0;
		StorageNew->mtpOmReceivedOctetsOPCInterval = 0;
		StorageNew->mtpOmReceivedOctetsOPC = 0;
		StorageNew->mtpOmReceivedOctetsOPCRowStatus = 0;
		StorageNew->mtpOmReceivedOctetsOPCRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmReceivedOctetsOPCTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmReceivedOctetsOPCTable_data *mtpOmReceivedOctetsOPCTable_duplicate(struct mtpOmReceivedOctetsOPCTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmReceivedOctetsOPCTable_data *
mtpOmReceivedOctetsOPCTable_duplicate(struct mtpOmReceivedOctetsOPCTable_data *thedata)
{
	struct mtpOmReceivedOctetsOPCTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmReceivedOctetsOPCTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmReceivedOctetsOPCTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmReceivedOctetsOPCTable_id = thedata->mtpOmReceivedOctetsOPCTable_id;
		StorageNew->mtpSpId = thedata->mtpSpId;
		if (!(StorageNew->mtpOmOpc = malloc(thedata->mtpOmOpcLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmOpc, thedata->mtpOmOpc, thedata->mtpOmOpcLen);
		StorageNew->mtpOmOpcLen = thedata->mtpOmOpcLen;
		StorageNew->mtpOmOpc[StorageNew->mtpOmOpcLen] = 0;
		StorageNew->mtpOmReceivedOctetsOPCInterval = thedata->mtpOmReceivedOctetsOPCInterval;
		StorageNew->mtpOmReceivedOctetsOPC = thedata->mtpOmReceivedOctetsOPC;
		StorageNew->mtpOmReceivedOctetsOPCRowStatus = thedata->mtpOmReceivedOctetsOPCRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmReceivedOctetsOPCTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmReceivedOctetsOPCTable_destroy(struct mtpOmReceivedOctetsOPCTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmReceivedOctetsOPCTable_destroy(struct mtpOmReceivedOctetsOPCTable_data **thedata)
{
	struct mtpOmReceivedOctetsOPCTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmReceivedOctetsOPCTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpOmOpc);
		StorageDel->mtpOmOpcLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmReceivedOctetsOPCTable_add(struct mtpOmReceivedOctetsOPCTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmReceivedOctetsOPCTable table data set.
 *
 * Adds a table row structure to the mtpOmReceivedOctetsOPCTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmReceivedOctetsOPCTable_add(struct mtpOmReceivedOctetsOPCTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmReceivedOctetsOPCTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmOpc */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmOpc, thedata->mtpOmOpcLen);
		header_complex_add_data(&mtpOmReceivedOctetsOPCTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmReceivedOctetsOPCTable_del(struct mtpOmReceivedOctetsOPCTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmReceivedOctetsOPCTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmReceivedOctetsOPCTable_del(struct mtpOmReceivedOctetsOPCTable_data *thedata)
{
	struct mtpOmReceivedOctetsOPCTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmReceivedOctetsOPCTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmReceivedOctetsOPCTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmReceivedOctetsOPCTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmReceivedOctetsOPCTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmReceivedOctetsOPCTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmReceivedOctetsOPCTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmReceivedOctetsOPCTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmReceivedOctetsOPCTable_data *StorageTmp = mtpOmReceivedOctetsOPCTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmReceivedOctetsOPCTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpOmOpc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmOpc, &StorageTmp->mtpOmOpcLen);
	if (StorageTmp->mtpOmOpc == NULL) {
		config_perror("invalid specification for mtpOmOpc");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmReceivedOctetsOPCInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmReceivedOctetsOPC, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmReceivedOctetsOPCRowStatus, &tmpsize);
	mtpOmReceivedOctetsOPCTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmReceivedOctetsOPCTable(): store configuraiton file for mtpOmReceivedOctetsOPCTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmReceivedOctetsOPCTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmReceivedOctetsOPCTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmReceivedOctetsOPCTable: storing data...  "));
	refresh_mtpOmReceivedOctetsOPCTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmReceivedOctetsOPCTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmReceivedOctetsOPCTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmReceivedOctetsOPCTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmOpc, &StorageTmp->mtpOmOpcLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmReceivedOctetsOPCInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmReceivedOctetsOPC, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmReceivedOctetsOPCRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmReceivedOctetsOpcSioTable_data *mtpOmReceivedOctetsOpcSioTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmReceivedOctetsOpcSioTable table.
 *
 * Creates a new mtpOmReceivedOctetsOpcSioTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmReceivedOctetsOpcSioTable_data *
mtpOmReceivedOctetsOpcSioTable_create(void)
{
	struct mtpOmReceivedOctetsOpcSioTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmReceivedOctetsOpcSioTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmReceivedOctetsOpcSioTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		if ((StorageNew->mtpOmOpc = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpOmOpcLen = 0;
		StorageNew->mtpOmOpc[StorageNew->mtpOmOpcLen] = 0;
		if ((StorageNew->mtpOmSio = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpOmSioLen = 0;
		StorageNew->mtpOmSio[StorageNew->mtpOmSioLen] = 0;
		StorageNew->mtpOmReceivedOctetsOpcSioInterval = 180000;
		StorageNew->mtpOmReceivedOctetsOpcSio = 0;
		StorageNew->mtpOmReceivedOctetsOpcSioRowStatus = 0;
		StorageNew->mtpOmReceivedOctetsOpcSioRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmReceivedOctetsOpcSioTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmReceivedOctetsOpcSioTable_data *mtpOmReceivedOctetsOpcSioTable_duplicate(struct mtpOmReceivedOctetsOpcSioTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmReceivedOctetsOpcSioTable_data *
mtpOmReceivedOctetsOpcSioTable_duplicate(struct mtpOmReceivedOctetsOpcSioTable_data *thedata)
{
	struct mtpOmReceivedOctetsOpcSioTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmReceivedOctetsOpcSioTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmReceivedOctetsOpcSioTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmReceivedOctetsOpcSioTable_id = thedata->mtpOmReceivedOctetsOpcSioTable_id;
		StorageNew->mtpSpId = thedata->mtpSpId;
		if (!(StorageNew->mtpOmOpc = malloc(thedata->mtpOmOpcLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmOpc, thedata->mtpOmOpc, thedata->mtpOmOpcLen);
		StorageNew->mtpOmOpcLen = thedata->mtpOmOpcLen;
		StorageNew->mtpOmOpc[StorageNew->mtpOmOpcLen] = 0;
		if (!(StorageNew->mtpOmSio = malloc(thedata->mtpOmSioLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmSio, thedata->mtpOmSio, thedata->mtpOmSioLen);
		StorageNew->mtpOmSioLen = thedata->mtpOmSioLen;
		StorageNew->mtpOmSio[StorageNew->mtpOmSioLen] = 0;
		StorageNew->mtpOmReceivedOctetsOpcSioInterval = thedata->mtpOmReceivedOctetsOpcSioInterval;
		StorageNew->mtpOmReceivedOctetsOpcSio = thedata->mtpOmReceivedOctetsOpcSio;
		StorageNew->mtpOmReceivedOctetsOpcSioRowStatus = thedata->mtpOmReceivedOctetsOpcSioRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmReceivedOctetsOpcSioTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmReceivedOctetsOpcSioTable_destroy(struct mtpOmReceivedOctetsOpcSioTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmReceivedOctetsOpcSioTable_destroy(struct mtpOmReceivedOctetsOpcSioTable_data **thedata)
{
	struct mtpOmReceivedOctetsOpcSioTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmReceivedOctetsOpcSioTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpOmOpc);
		StorageDel->mtpOmOpcLen = 0;
		SNMP_FREE(StorageDel->mtpOmSio);
		StorageDel->mtpOmSioLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmReceivedOctetsOpcSioTable_add(struct mtpOmReceivedOctetsOpcSioTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmReceivedOctetsOpcSioTable table data set.
 *
 * Adds a table row structure to the mtpOmReceivedOctetsOpcSioTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmReceivedOctetsOpcSioTable_add(struct mtpOmReceivedOctetsOpcSioTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmReceivedOctetsOpcSioTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmOpc */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmOpc, thedata->mtpOmOpcLen);
		/* mtpOmSio */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmSio, thedata->mtpOmSioLen);
		header_complex_add_data(&mtpOmReceivedOctetsOpcSioTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmReceivedOctetsOpcSioTable_del(struct mtpOmReceivedOctetsOpcSioTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmReceivedOctetsOpcSioTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmReceivedOctetsOpcSioTable_del(struct mtpOmReceivedOctetsOpcSioTable_data *thedata)
{
	struct mtpOmReceivedOctetsOpcSioTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmReceivedOctetsOpcSioTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmReceivedOctetsOpcSioTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmReceivedOctetsOpcSioTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmReceivedOctetsOpcSioTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmReceivedOctetsOpcSioTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmReceivedOctetsOpcSioTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmReceivedOctetsOpcSioTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp = mtpOmReceivedOctetsOpcSioTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmReceivedOctetsOpcSioTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpOmOpc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmOpc, &StorageTmp->mtpOmOpcLen);
	if (StorageTmp->mtpOmOpc == NULL) {
		config_perror("invalid specification for mtpOmOpc");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOmSio);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmSio, &StorageTmp->mtpOmSioLen);
	if (StorageTmp->mtpOmSio == NULL) {
		config_perror("invalid specification for mtpOmSio");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmReceivedOctetsOpcSioInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmReceivedOctetsOpcSio, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus, &tmpsize);
	mtpOmReceivedOctetsOpcSioTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmReceivedOctetsOpcSioTable(): store configuraiton file for mtpOmReceivedOctetsOpcSioTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmReceivedOctetsOpcSioTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmReceivedOctetsOpcSioTable: storing data...  "));
	refresh_mtpOmReceivedOctetsOpcSioTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmReceivedOctetsOpcSioTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmReceivedOctetsOpcSioTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmReceivedOctetsOpcSioTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmOpc, &StorageTmp->mtpOmOpcLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmSio, &StorageTmp->mtpOmSioLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmReceivedOctetsOpcSioInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmReceivedOctetsOpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSpDataTable_data *mtpOmSpDataTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSpDataTable table.
 *
 * Creates a new mtpOmSpDataTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSpDataTable_data *
mtpOmSpDataTable_create(void)
{
	struct mtpOmSpDataTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpDataTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpDataTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		StorageNew->mtpOmSpDiscardedMSUs = 0;
		StorageNew->mtpOmSpTransmittedUPUnavailable = 0;
		StorageNew->mtpOmSpReceivedUPUnavailable = 0;
		StorageNew->mtpOmSpReceivedTFC = 0;
		StorageNew->mtpOmSpReceivedTFCLevel0 = 0;
		StorageNew->mtpOmSpReceivedTFCLevel1 = 0;
		StorageNew->mtpOmSpReceivedTFCLevel2 = 0;
		StorageNew->mtpOmSpReceivedTFCLevel3 = 0;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmSpDataTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmSpDataTable_data *mtpOmSpDataTable_duplicate(struct mtpOmSpDataTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSpDataTable_data *
mtpOmSpDataTable_duplicate(struct mtpOmSpDataTable_data *thedata)
{
	struct mtpOmSpDataTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSpDataTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpDataTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmSpDataTable_id = thedata->mtpOmSpDataTable_id;
		StorageNew->mtpSpId = thedata->mtpSpId;
		StorageNew->mtpOmUserPart = thedata->mtpOmUserPart;
		StorageNew->mtpOmCongestionLevel = thedata->mtpOmCongestionLevel;
		StorageNew->mtpOmSpDiscardedMSUs = thedata->mtpOmSpDiscardedMSUs;
		StorageNew->mtpOmSpTransmittedUPUnavailable = thedata->mtpOmSpTransmittedUPUnavailable;
		StorageNew->mtpOmSpReceivedUPUnavailable = thedata->mtpOmSpReceivedUPUnavailable;
		StorageNew->mtpOmSpReceivedTFC = thedata->mtpOmSpReceivedTFC;
		StorageNew->mtpOmSpReceivedTFCLevel0 = thedata->mtpOmSpReceivedTFCLevel0;
		StorageNew->mtpOmSpReceivedTFCLevel1 = thedata->mtpOmSpReceivedTFCLevel1;
		StorageNew->mtpOmSpReceivedTFCLevel2 = thedata->mtpOmSpReceivedTFCLevel2;
		StorageNew->mtpOmSpReceivedTFCLevel3 = thedata->mtpOmSpReceivedTFCLevel3;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSpDataTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSpDataTable_destroy(struct mtpOmSpDataTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSpDataTable_destroy(struct mtpOmSpDataTable_data **thedata)
{
	struct mtpOmSpDataTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpDataTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpDataTable_add(struct mtpOmSpDataTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSpDataTable table data set.
 *
 * Adds a table row structure to the mtpOmSpDataTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSpDataTable_add(struct mtpOmSpDataTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpDataTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmUserPart */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpOmUserPart, sizeof(thedata->mtpOmUserPart));
		/* mtpOmCongestionLevel */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpOmCongestionLevel, sizeof(thedata->mtpOmCongestionLevel));
		header_complex_add_data(&mtpOmSpDataTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSpDataTable_del(struct mtpOmSpDataTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSpDataTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSpDataTable_del(struct mtpOmSpDataTable_data *thedata)
{
	struct mtpOmSpDataTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSpDataTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSpDataTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSpDataTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSpDataTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSpDataTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSpDataTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSpDataTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSpDataTable_data *StorageTmp = mtpOmSpDataTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSpDataTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmUserPart, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmCongestionLevel, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpDiscardedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpTransmittedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpReceivedUPUnavailable, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpReceivedTFC, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpReceivedTFCLevel0, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpReceivedTFCLevel1, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpReceivedTFCLevel2, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSpReceivedTFCLevel3, &tmpsize);
	mtpOmSpDataTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSpDataTable(): store configuraiton file for mtpOmSpDataTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSpDataTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSpDataTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSpDataTable: storing data...  "));
	refresh_mtpOmSpDataTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSpDataTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSpDataTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSpDataTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmUserPart, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpDiscardedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpTransmittedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpReceivedUPUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpReceivedTFC, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpReceivedTFCLevel0, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpReceivedTFCLevel1, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpReceivedTFCLevel2, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSpReceivedTFCLevel3, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmTransmittedOctetsDPCTable_data *mtpOmTransmittedOctetsDPCTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmTransmittedOctetsDPCTable table.
 *
 * Creates a new mtpOmTransmittedOctetsDPCTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmTransmittedOctetsDPCTable_data *
mtpOmTransmittedOctetsDPCTable_create(void)
{
	struct mtpOmTransmittedOctetsDPCTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmTransmittedOctetsDPCTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmTransmittedOctetsDPCTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		if ((StorageNew->mtpOmDpc = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpOmDpcLen = 0;
		StorageNew->mtpOmDpc[StorageNew->mtpOmDpcLen] = 0;
		StorageNew->mtpOmTransmittedOctetsDPC = 0;
		StorageNew->mtpOmTransmittedOctetsDPCRowStatus = 0;
		StorageNew->mtpOmTransmittedOctetsDPCRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmTransmittedOctetsDPCTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmTransmittedOctetsDPCTable_data *mtpOmTransmittedOctetsDPCTable_duplicate(struct mtpOmTransmittedOctetsDPCTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmTransmittedOctetsDPCTable_data *
mtpOmTransmittedOctetsDPCTable_duplicate(struct mtpOmTransmittedOctetsDPCTable_data *thedata)
{
	struct mtpOmTransmittedOctetsDPCTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmTransmittedOctetsDPCTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmTransmittedOctetsDPCTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmTransmittedOctetsDPCTable_id = thedata->mtpOmTransmittedOctetsDPCTable_id;
		StorageNew->mtpSpId = thedata->mtpSpId;
		if (!(StorageNew->mtpOmDpc = malloc(thedata->mtpOmDpcLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmDpc, thedata->mtpOmDpc, thedata->mtpOmDpcLen);
		StorageNew->mtpOmDpcLen = thedata->mtpOmDpcLen;
		StorageNew->mtpOmDpc[StorageNew->mtpOmDpcLen] = 0;
		StorageNew->mtpOmTransmittedOctetsDPC = thedata->mtpOmTransmittedOctetsDPC;
		StorageNew->mtpOmTransmittedOctetsDPCRowStatus = thedata->mtpOmTransmittedOctetsDPCRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmTransmittedOctetsDPCTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmTransmittedOctetsDPCTable_destroy(struct mtpOmTransmittedOctetsDPCTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmTransmittedOctetsDPCTable_destroy(struct mtpOmTransmittedOctetsDPCTable_data **thedata)
{
	struct mtpOmTransmittedOctetsDPCTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmTransmittedOctetsDPCTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpOmDpc);
		StorageDel->mtpOmDpcLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmTransmittedOctetsDPCTable_add(struct mtpOmTransmittedOctetsDPCTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmTransmittedOctetsDPCTable table data set.
 *
 * Adds a table row structure to the mtpOmTransmittedOctetsDPCTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmTransmittedOctetsDPCTable_add(struct mtpOmTransmittedOctetsDPCTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmTransmittedOctetsDPCTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmDpc */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmDpc, thedata->mtpOmDpcLen);
		header_complex_add_data(&mtpOmTransmittedOctetsDPCTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmTransmittedOctetsDPCTable_del(struct mtpOmTransmittedOctetsDPCTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmTransmittedOctetsDPCTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmTransmittedOctetsDPCTable_del(struct mtpOmTransmittedOctetsDPCTable_data *thedata)
{
	struct mtpOmTransmittedOctetsDPCTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmTransmittedOctetsDPCTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmTransmittedOctetsDPCTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmTransmittedOctetsDPCTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmTransmittedOctetsDPCTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmTransmittedOctetsDPCTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmTransmittedOctetsDPCTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmTransmittedOctetsDPCTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp = mtpOmTransmittedOctetsDPCTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmTransmittedOctetsDPCTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpOmDpc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmDpc, &StorageTmp->mtpOmDpcLen);
	if (StorageTmp->mtpOmDpc == NULL) {
		config_perror("invalid specification for mtpOmDpc");
		return;
	}
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmTransmittedOctetsDPC, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmTransmittedOctetsDPCRowStatus, &tmpsize);
	mtpOmTransmittedOctetsDPCTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmTransmittedOctetsDPCTable(): store configuraiton file for mtpOmTransmittedOctetsDPCTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmTransmittedOctetsDPCTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmTransmittedOctetsDPCTable: storing data...  "));
	refresh_mtpOmTransmittedOctetsDPCTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmTransmittedOctetsDPCTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmTransmittedOctetsDPCTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmTransmittedOctetsDPCTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmDpc, &StorageTmp->mtpOmDpcLen);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmTransmittedOctetsDPC, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmTransmittedOctetsDPCRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmTransmittedOctetsDpcSioTable_data *mtpOmTransmittedOctetsDpcSioTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmTransmittedOctetsDpcSioTable table.
 *
 * Creates a new mtpOmTransmittedOctetsDpcSioTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmTransmittedOctetsDpcSioTable_data *
mtpOmTransmittedOctetsDpcSioTable_create(void)
{
	struct mtpOmTransmittedOctetsDpcSioTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmTransmittedOctetsDpcSioTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmTransmittedOctetsDpcSioTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSpId = 0;
		if ((StorageNew->mtpOmDpc = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpOmDpcLen = 0;
		StorageNew->mtpOmDpc[StorageNew->mtpOmDpcLen] = 0;
		if ((StorageNew->mtpOmSio = malloc(1)) == NULL)
			goto nomem;
		StorageNew->mtpOmSioLen = 0;
		StorageNew->mtpOmSio[StorageNew->mtpOmSioLen] = 0;
		StorageNew->mtpOmTransmittedOctetsDpcSio = 0;
		StorageNew->mtpOmTransmittedOctetsDpcSioRowStatus = 0;
		StorageNew->mtpOmTransmittedOctetsDpcSioRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmTransmittedOctetsDpcSioTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmTransmittedOctetsDpcSioTable_data *mtpOmTransmittedOctetsDpcSioTable_duplicate(struct mtpOmTransmittedOctetsDpcSioTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmTransmittedOctetsDpcSioTable_data *
mtpOmTransmittedOctetsDpcSioTable_duplicate(struct mtpOmTransmittedOctetsDpcSioTable_data *thedata)
{
	struct mtpOmTransmittedOctetsDpcSioTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmTransmittedOctetsDpcSioTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmTransmittedOctetsDpcSioTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmTransmittedOctetsDpcSioTable_id = thedata->mtpOmTransmittedOctetsDpcSioTable_id;
		StorageNew->mtpSpId = thedata->mtpSpId;
		if (!(StorageNew->mtpOmDpc = malloc(thedata->mtpOmDpcLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmDpc, thedata->mtpOmDpc, thedata->mtpOmDpcLen);
		StorageNew->mtpOmDpcLen = thedata->mtpOmDpcLen;
		StorageNew->mtpOmDpc[StorageNew->mtpOmDpcLen] = 0;
		if (!(StorageNew->mtpOmSio = malloc(thedata->mtpOmSioLen + 1)))
			goto destroy;
		memcpy(StorageNew->mtpOmSio, thedata->mtpOmSio, thedata->mtpOmSioLen);
		StorageNew->mtpOmSioLen = thedata->mtpOmSioLen;
		StorageNew->mtpOmSio[StorageNew->mtpOmSioLen] = 0;
		StorageNew->mtpOmTransmittedOctetsDpcSio = thedata->mtpOmTransmittedOctetsDpcSio;
		StorageNew->mtpOmTransmittedOctetsDpcSioRowStatus = thedata->mtpOmTransmittedOctetsDpcSioRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmTransmittedOctetsDpcSioTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmTransmittedOctetsDpcSioTable_destroy(struct mtpOmTransmittedOctetsDpcSioTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmTransmittedOctetsDpcSioTable_destroy(struct mtpOmTransmittedOctetsDpcSioTable_data **thedata)
{
	struct mtpOmTransmittedOctetsDpcSioTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmTransmittedOctetsDpcSioTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->mtpOmDpc);
		StorageDel->mtpOmDpcLen = 0;
		SNMP_FREE(StorageDel->mtpOmSio);
		StorageDel->mtpOmSioLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmTransmittedOctetsDpcSioTable_add(struct mtpOmTransmittedOctetsDpcSioTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmTransmittedOctetsDpcSioTable table data set.
 *
 * Adds a table row structure to the mtpOmTransmittedOctetsDpcSioTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmTransmittedOctetsDpcSioTable_add(struct mtpOmTransmittedOctetsDpcSioTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmTransmittedOctetsDpcSioTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSpId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSpId, sizeof(thedata->mtpSpId));
		/* mtpOmDpc */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmDpc, thedata->mtpOmDpcLen);
		/* mtpOmSio */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->mtpOmSio, thedata->mtpOmSioLen);
		header_complex_add_data(&mtpOmTransmittedOctetsDpcSioTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmTransmittedOctetsDpcSioTable_del(struct mtpOmTransmittedOctetsDpcSioTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmTransmittedOctetsDpcSioTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmTransmittedOctetsDpcSioTable_del(struct mtpOmTransmittedOctetsDpcSioTable_data *thedata)
{
	struct mtpOmTransmittedOctetsDpcSioTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmTransmittedOctetsDpcSioTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmTransmittedOctetsDpcSioTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmTransmittedOctetsDpcSioTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmTransmittedOctetsDpcSioTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmTransmittedOctetsDpcSioTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmTransmittedOctetsDpcSioTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmTransmittedOctetsDpcSioTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp = mtpOmTransmittedOctetsDpcSioTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmTransmittedOctetsDpcSioTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSpId, &tmpsize);
	SNMP_FREE(StorageTmp->mtpOmDpc);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmDpc, &StorageTmp->mtpOmDpcLen);
	if (StorageTmp->mtpOmDpc == NULL) {
		config_perror("invalid specification for mtpOmDpc");
		return;
	}
	SNMP_FREE(StorageTmp->mtpOmSio);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->mtpOmSio, &StorageTmp->mtpOmSioLen);
	if (StorageTmp->mtpOmSio == NULL) {
		config_perror("invalid specification for mtpOmSio");
		return;
	}
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmTransmittedOctetsDpcSio, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus, &tmpsize);
	mtpOmTransmittedOctetsDpcSioTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmTransmittedOctetsDpcSioTable(): store configuraiton file for mtpOmTransmittedOctetsDpcSioTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmTransmittedOctetsDpcSioTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmTransmittedOctetsDpcSioTable: storing data...  "));
	refresh_mtpOmTransmittedOctetsDpcSioTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmTransmittedOctetsDpcSioTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmTransmittedOctetsDpcSioTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmTransmittedOctetsDpcSioTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSpId, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmDpc, &StorageTmp->mtpOmDpcLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->mtpOmSio, &StorageTmp->mtpOmSioLen);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmTransmittedOctetsDpcSio, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSignRsInformationTable_data *mtpOmSignRsInformationTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSignRsInformationTable table.
 *
 * Creates a new mtpOmSignRsInformationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSignRsInformationTable_data *
mtpOmSignRsInformationTable_create(void)
{
	struct mtpOmSignRsInformationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSignRsInformationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSignRsInformationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpRsId = 0;
		StorageNew->mtpOmRouteSetUnavailable = 0;
		StorageNew->mtpOmRouteSetUnavailableDuration = 0;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmSignRsInformationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmSignRsInformationTable_data *mtpOmSignRsInformationTable_duplicate(struct mtpOmSignRsInformationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSignRsInformationTable_data *
mtpOmSignRsInformationTable_duplicate(struct mtpOmSignRsInformationTable_data *thedata)
{
	struct mtpOmSignRsInformationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSignRsInformationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSignRsInformationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmSignRsInformationTable_id = thedata->mtpOmSignRsInformationTable_id;
		StorageNew->mtpRsId = thedata->mtpRsId;
		StorageNew->mtpOmRouteSetUnavailable = thedata->mtpOmRouteSetUnavailable;
		StorageNew->mtpOmRouteSetUnavailableDuration = thedata->mtpOmRouteSetUnavailableDuration;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSignRsInformationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSignRsInformationTable_destroy(struct mtpOmSignRsInformationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSignRsInformationTable_destroy(struct mtpOmSignRsInformationTable_data **thedata)
{
	struct mtpOmSignRsInformationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSignRsInformationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSignRsInformationTable_add(struct mtpOmSignRsInformationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSignRsInformationTable table data set.
 *
 * Adds a table row structure to the mtpOmSignRsInformationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSignRsInformationTable_add(struct mtpOmSignRsInformationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSignRsInformationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpRsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpRsId, sizeof(thedata->mtpRsId));
		header_complex_add_data(&mtpOmSignRsInformationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSignRsInformationTable_del(struct mtpOmSignRsInformationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSignRsInformationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSignRsInformationTable_del(struct mtpOmSignRsInformationTable_data *thedata)
{
	struct mtpOmSignRsInformationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSignRsInformationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSignRsInformationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSignRsInformationTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSignRsInformationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSignRsInformationTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSignRsInformationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSignRsInformationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSignRsInformationTable_data *StorageTmp = mtpOmSignRsInformationTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSignRsInformationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpRsId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmRouteSetUnavailable, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmRouteSetUnavailableDuration, &tmpsize);
	mtpOmSignRsInformationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSignRsInformationTable(): store configuraiton file for mtpOmSignRsInformationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSignRsInformationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSignRsInformationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSignRsInformationTable: storing data...  "));
	refresh_mtpOmSignRsInformationTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSignRsInformationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSignRsInformationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSignRsInformationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpRsId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmRouteSetUnavailable, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmRouteSetUnavailableDuration, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSlsDurationTable_data *mtpOmSlsDurationTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSlsDurationTable table.
 *
 * Creates a new mtpOmSlsDurationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSlsDurationTable_data *
mtpOmSlsDurationTable_create(void)
{
	struct mtpOmSlsDurationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlsDurationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlsDurationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpLsId = 0;
		StorageNew->mtpOmSlsUnavailable = 0;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmSlsDurationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmSlsDurationTable_data *mtpOmSlsDurationTable_duplicate(struct mtpOmSlsDurationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSlsDurationTable_data *
mtpOmSlsDurationTable_duplicate(struct mtpOmSlsDurationTable_data *thedata)
{
	struct mtpOmSlsDurationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlsDurationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlsDurationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmSlsDurationTable_id = thedata->mtpOmSlsDurationTable_id;
		StorageNew->mtpLsId = thedata->mtpLsId;
		StorageNew->mtpOmSlsUnavailable = thedata->mtpOmSlsUnavailable;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSlsDurationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSlsDurationTable_destroy(struct mtpOmSlsDurationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSlsDurationTable_destroy(struct mtpOmSlsDurationTable_data **thedata)
{
	struct mtpOmSlsDurationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlsDurationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlsDurationTable_add(struct mtpOmSlsDurationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSlsDurationTable table data set.
 *
 * Adds a table row structure to the mtpOmSlsDurationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSlsDurationTable_add(struct mtpOmSlsDurationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlsDurationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpLsId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpLsId, sizeof(thedata->mtpLsId));
		header_complex_add_data(&mtpOmSlsDurationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlsDurationTable_del(struct mtpOmSlsDurationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSlsDurationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSlsDurationTable_del(struct mtpOmSlsDurationTable_data *thedata)
{
	struct mtpOmSlsDurationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlsDurationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSlsDurationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSlsDurationTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSlsDurationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSlsDurationTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSlsDurationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSlsDurationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlsDurationTable_data *StorageTmp = mtpOmSlsDurationTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSlsDurationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpLsId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlsUnavailable, &tmpsize);
	mtpOmSlsDurationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSlsDurationTable(): store configuraiton file for mtpOmSlsDurationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlsDurationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlsDurationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSlsDurationTable: storing data...  "));
	refresh_mtpOmSlsDurationTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSlsDurationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlsDurationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlsDurationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpLsId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlsUnavailable, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmAll5And30MinSlDurationTable_data *mtpOmAll5And30MinSlDurationTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmAll5And30MinSlDurationTable table.
 *
 * Creates a new mtpOmAll5And30MinSlDurationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmAll5And30MinSlDurationTable_data *
mtpOmAll5And30MinSlDurationTable_create(void)
{
	struct mtpOmAll5And30MinSlDurationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmAll5And30MinSlDurationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAll5And30MinSlDurationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlId = 0;
		StorageNew->mtpOmAll5And30MinSlDurationInterval = 0;
		StorageNew->mtpOmLocalMgntInhibit = 0;
		StorageNew->mtpOmLocalMgntUninhibit = 0;
		StorageNew->mtpOmLocalBusy = 0;
		StorageNew->mtpOmAll5And30MinSlDurationRowStatus = 0;
		StorageNew->mtpOmAll5And30MinSlDurationRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmAll5And30MinSlDurationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmAll5And30MinSlDurationTable_data *mtpOmAll5And30MinSlDurationTable_duplicate(struct mtpOmAll5And30MinSlDurationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmAll5And30MinSlDurationTable_data *
mtpOmAll5And30MinSlDurationTable_duplicate(struct mtpOmAll5And30MinSlDurationTable_data *thedata)
{
	struct mtpOmAll5And30MinSlDurationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmAll5And30MinSlDurationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAll5And30MinSlDurationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmAll5And30MinSlDurationTable_id = thedata->mtpOmAll5And30MinSlDurationTable_id;
		StorageNew->mtpSlId = thedata->mtpSlId;
		StorageNew->mtpOmAll5And30MinSlDurationInterval = thedata->mtpOmAll5And30MinSlDurationInterval;
		StorageNew->mtpOmLocalMgntInhibit = thedata->mtpOmLocalMgntInhibit;
		StorageNew->mtpOmLocalMgntUninhibit = thedata->mtpOmLocalMgntUninhibit;
		StorageNew->mtpOmLocalBusy = thedata->mtpOmLocalBusy;
		StorageNew->mtpOmAll5And30MinSlDurationRowStatus = thedata->mtpOmAll5And30MinSlDurationRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmAll5And30MinSlDurationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmAll5And30MinSlDurationTable_destroy(struct mtpOmAll5And30MinSlDurationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmAll5And30MinSlDurationTable_destroy(struct mtpOmAll5And30MinSlDurationTable_data **thedata)
{
	struct mtpOmAll5And30MinSlDurationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAll5And30MinSlDurationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmAll5And30MinSlDurationTable_add(struct mtpOmAll5And30MinSlDurationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmAll5And30MinSlDurationTable table data set.
 *
 * Adds a table row structure to the mtpOmAll5And30MinSlDurationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmAll5And30MinSlDurationTable_add(struct mtpOmAll5And30MinSlDurationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAll5And30MinSlDurationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
		header_complex_add_data(&mtpOmAll5And30MinSlDurationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmAll5And30MinSlDurationTable_del(struct mtpOmAll5And30MinSlDurationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmAll5And30MinSlDurationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmAll5And30MinSlDurationTable_del(struct mtpOmAll5And30MinSlDurationTable_data *thedata)
{
	struct mtpOmAll5And30MinSlDurationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAll5And30MinSlDurationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmAll5And30MinSlDurationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmAll5And30MinSlDurationTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmAll5And30MinSlDurationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmAll5And30MinSlDurationTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmAll5And30MinSlDurationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmAll5And30MinSlDurationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp = mtpOmAll5And30MinSlDurationTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmAll5And30MinSlDurationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmAll5And30MinSlDurationInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmLocalMgntInhibit, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmLocalMgntUninhibit, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmLocalBusy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmAll5And30MinSlDurationRowStatus, &tmpsize);
	mtpOmAll5And30MinSlDurationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmAll5And30MinSlDurationTable(): store configuraiton file for mtpOmAll5And30MinSlDurationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmAll5And30MinSlDurationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmAll5And30MinSlDurationTable: storing data...  "));
	refresh_mtpOmAll5And30MinSlDurationTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmAll5And30MinSlDurationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmAll5And30MinSlDurationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmAll5And30MinSlDurationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmAll5And30MinSlDurationInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmLocalMgntInhibit, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmLocalMgntUninhibit, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmLocalBusy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmAll5And30MinSlDurationRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmOblSlDurationTable_data *mtpOmOblSlDurationTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmOblSlDurationTable table.
 *
 * Creates a new mtpOmOblSlDurationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmOblSlDurationTable_data *
mtpOmOblSlDurationTable_create(void)
{
	struct mtpOmOblSlDurationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmOblSlDurationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSlDurationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlId = 0;
		StorageNew->mtpOmSlUnavailabilityDuration = 0;
		StorageNew->mtpOmSlInServiceDuration = 0;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmOblSlDurationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmOblSlDurationTable_data *mtpOmOblSlDurationTable_duplicate(struct mtpOmOblSlDurationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmOblSlDurationTable_data *
mtpOmOblSlDurationTable_duplicate(struct mtpOmOblSlDurationTable_data *thedata)
{
	struct mtpOmOblSlDurationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmOblSlDurationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSlDurationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmOblSlDurationTable_id = thedata->mtpOmOblSlDurationTable_id;
		StorageNew->mtpSlId = thedata->mtpSlId;
		StorageNew->mtpOmSlUnavailabilityDuration = thedata->mtpOmSlUnavailabilityDuration;
		StorageNew->mtpOmSlInServiceDuration = thedata->mtpOmSlInServiceDuration;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmOblSlDurationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmOblSlDurationTable_destroy(struct mtpOmOblSlDurationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmOblSlDurationTable_destroy(struct mtpOmOblSlDurationTable_data **thedata)
{
	struct mtpOmOblSlDurationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSlDurationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmOblSlDurationTable_add(struct mtpOmOblSlDurationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmOblSlDurationTable table data set.
 *
 * Adds a table row structure to the mtpOmOblSlDurationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmOblSlDurationTable_add(struct mtpOmOblSlDurationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSlDurationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
		header_complex_add_data(&mtpOmOblSlDurationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmOblSlDurationTable_del(struct mtpOmOblSlDurationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmOblSlDurationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmOblSlDurationTable_del(struct mtpOmOblSlDurationTable_data *thedata)
{
	struct mtpOmOblSlDurationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSlDurationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmOblSlDurationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmOblSlDurationTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmOblSlDurationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmOblSlDurationTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmOblSlDurationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmOblSlDurationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmOblSlDurationTable_data *StorageTmp = mtpOmOblSlDurationTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmOblSlDurationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlUnavailabilityDuration, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlInServiceDuration, &tmpsize);
	mtpOmOblSlDurationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmOblSlDurationTable(): store configuraiton file for mtpOmOblSlDurationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmOblSlDurationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmOblSlDurationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmOblSlDurationTable: storing data...  "));
	refresh_mtpOmOblSlDurationTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmOblSlDurationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmOblSlDurationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmOblSlDurationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlUnavailabilityDuration, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlInServiceDuration, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmAll30MinSlDurationTable_data *mtpOmAll30MinSlDurationTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmAll30MinSlDurationTable table.
 *
 * Creates a new mtpOmAll30MinSlDurationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmAll30MinSlDurationTable_data *
mtpOmAll30MinSlDurationTable_create(void)
{
	struct mtpOmAll30MinSlDurationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmAll30MinSlDurationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAll30MinSlDurationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlId = 0;
		StorageNew->mtpOmAll30MinSlDurationInterval = 180000;
		StorageNew->mtpOmSlLocalInhibition = 0;
		StorageNew->mtpOmSlRemoteInhibition = 0;
		StorageNew->mtpOmSlFailed = 0;
		StorageNew->mtpOmSlRemoteProcOutage = 0;
		StorageNew->mtpOmAll30MinSlDurationRowStatus = 0;
		StorageNew->mtpOmAll30MinSlDurationRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmAll30MinSlDurationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmAll30MinSlDurationTable_data *mtpOmAll30MinSlDurationTable_duplicate(struct mtpOmAll30MinSlDurationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmAll30MinSlDurationTable_data *
mtpOmAll30MinSlDurationTable_duplicate(struct mtpOmAll30MinSlDurationTable_data *thedata)
{
	struct mtpOmAll30MinSlDurationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmAll30MinSlDurationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAll30MinSlDurationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmAll30MinSlDurationTable_id = thedata->mtpOmAll30MinSlDurationTable_id;
		StorageNew->mtpSlId = thedata->mtpSlId;
		StorageNew->mtpOmAll30MinSlDurationInterval = thedata->mtpOmAll30MinSlDurationInterval;
		StorageNew->mtpOmSlLocalInhibition = thedata->mtpOmSlLocalInhibition;
		StorageNew->mtpOmSlRemoteInhibition = thedata->mtpOmSlRemoteInhibition;
		StorageNew->mtpOmSlFailed = thedata->mtpOmSlFailed;
		StorageNew->mtpOmSlRemoteProcOutage = thedata->mtpOmSlRemoteProcOutage;
		StorageNew->mtpOmAll30MinSlDurationRowStatus = thedata->mtpOmAll30MinSlDurationRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmAll30MinSlDurationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmAll30MinSlDurationTable_destroy(struct mtpOmAll30MinSlDurationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmAll30MinSlDurationTable_destroy(struct mtpOmAll30MinSlDurationTable_data **thedata)
{
	struct mtpOmAll30MinSlDurationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAll30MinSlDurationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmAll30MinSlDurationTable_add(struct mtpOmAll30MinSlDurationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmAll30MinSlDurationTable table data set.
 *
 * Adds a table row structure to the mtpOmAll30MinSlDurationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmAll30MinSlDurationTable_add(struct mtpOmAll30MinSlDurationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAll30MinSlDurationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
		header_complex_add_data(&mtpOmAll30MinSlDurationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmAll30MinSlDurationTable_del(struct mtpOmAll30MinSlDurationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmAll30MinSlDurationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmAll30MinSlDurationTable_del(struct mtpOmAll30MinSlDurationTable_data *thedata)
{
	struct mtpOmAll30MinSlDurationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAll30MinSlDurationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmAll30MinSlDurationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmAll30MinSlDurationTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmAll30MinSlDurationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmAll30MinSlDurationTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmAll30MinSlDurationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmAll30MinSlDurationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmAll30MinSlDurationTable_data *StorageTmp = mtpOmAll30MinSlDurationTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmAll30MinSlDurationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmAll30MinSlDurationInterval, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlLocalInhibition, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlRemoteInhibition, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlFailed, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlRemoteProcOutage, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmAll30MinSlDurationRowStatus, &tmpsize);
	mtpOmAll30MinSlDurationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmAll30MinSlDurationTable(): store configuraiton file for mtpOmAll30MinSlDurationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmAll30MinSlDurationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmAll30MinSlDurationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmAll30MinSlDurationTable: storing data...  "));
	refresh_mtpOmAll30MinSlDurationTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmAll30MinSlDurationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmAll30MinSlDurationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmAll30MinSlDurationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmAll30MinSlDurationInterval, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlLocalInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlRemoteInhibition, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlFailed, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlRemoteProcOutage, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmAll30MinSlDurationRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmOblSlUtilizationTable_data *mtpOmOblSlUtilizationTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmOblSlUtilizationTable table.
 *
 * Creates a new mtpOmOblSlUtilizationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmOblSlUtilizationTable_data *
mtpOmOblSlUtilizationTable_create(void)
{
	struct mtpOmOblSlUtilizationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmOblSlUtilizationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSlUtilizationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlId = 0;
		StorageNew->mtpOmSlSignUnitsReceived = 0;
		StorageNew->mtpOmSlTransmittedOctetsSIFSIO = 0;
		StorageNew->mtpOmSlReceivedOctetsSIFSIO = 0;
		StorageNew->mtpOmSlDiscardedMSUs = 0;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmOblSlUtilizationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmOblSlUtilizationTable_data *mtpOmOblSlUtilizationTable_duplicate(struct mtpOmOblSlUtilizationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmOblSlUtilizationTable_data *
mtpOmOblSlUtilizationTable_duplicate(struct mtpOmOblSlUtilizationTable_data *thedata)
{
	struct mtpOmOblSlUtilizationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmOblSlUtilizationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSlUtilizationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmOblSlUtilizationTable_id = thedata->mtpOmOblSlUtilizationTable_id;
		StorageNew->mtpSlId = thedata->mtpSlId;
		StorageNew->mtpOmSlSignUnitsReceived = thedata->mtpOmSlSignUnitsReceived;
		StorageNew->mtpOmSlTransmittedOctetsSIFSIO = thedata->mtpOmSlTransmittedOctetsSIFSIO;
		StorageNew->mtpOmSlReceivedOctetsSIFSIO = thedata->mtpOmSlReceivedOctetsSIFSIO;
		StorageNew->mtpOmSlDiscardedMSUs = thedata->mtpOmSlDiscardedMSUs;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmOblSlUtilizationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmOblSlUtilizationTable_destroy(struct mtpOmOblSlUtilizationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmOblSlUtilizationTable_destroy(struct mtpOmOblSlUtilizationTable_data **thedata)
{
	struct mtpOmOblSlUtilizationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSlUtilizationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmOblSlUtilizationTable_add(struct mtpOmOblSlUtilizationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmOblSlUtilizationTable table data set.
 *
 * Adds a table row structure to the mtpOmOblSlUtilizationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmOblSlUtilizationTable_add(struct mtpOmOblSlUtilizationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSlUtilizationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
		header_complex_add_data(&mtpOmOblSlUtilizationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmOblSlUtilizationTable_del(struct mtpOmOblSlUtilizationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmOblSlUtilizationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmOblSlUtilizationTable_del(struct mtpOmOblSlUtilizationTable_data *thedata)
{
	struct mtpOmOblSlUtilizationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmOblSlUtilizationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmOblSlUtilizationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmOblSlUtilizationTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmOblSlUtilizationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmOblSlUtilizationTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmOblSlUtilizationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmOblSlUtilizationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmOblSlUtilizationTable_data *StorageTmp = mtpOmOblSlUtilizationTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmOblSlUtilizationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlSignUnitsReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlTransmittedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlReceivedOctetsSIFSIO, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlDiscardedMSUs, &tmpsize);
	mtpOmOblSlUtilizationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmOblSlUtilizationTable(): store configuraiton file for mtpOmOblSlUtilizationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmOblSlUtilizationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmOblSlUtilizationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmOblSlUtilizationTable: storing data...  "));
	refresh_mtpOmOblSlUtilizationTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmOblSlUtilizationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmOblSlUtilizationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmOblSlUtilizationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlSignUnitsReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlTransmittedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlReceivedOctetsSIFSIO, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlDiscardedMSUs, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmAllSlUtilizationTable_data *mtpOmAllSlUtilizationTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmAllSlUtilizationTable table.
 *
 * Creates a new mtpOmAllSlUtilizationTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmAllSlUtilizationTable_data *
mtpOmAllSlUtilizationTable_create(void)
{
	struct mtpOmAllSlUtilizationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmAllSlUtilizationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAllSlUtilizationTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlId = 0;
		StorageNew->mtpOmSlAlignment = 0;
		StorageNew->mtpOmSlNegAckReceived = 0;
		StorageNew->mtpOmSlRetransmittedOctets = 0;
		StorageNew->mtpOmSlTransmittedMSUs = 0;
		StorageNew->mtpOmSlReceivedMSUs = 0;
		StorageNew->mtpOmAllSlUtilizationRowStatus = 0;
		StorageNew->mtpOmAllSlUtilizationRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmAllSlUtilizationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmAllSlUtilizationTable_data *mtpOmAllSlUtilizationTable_duplicate(struct mtpOmAllSlUtilizationTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmAllSlUtilizationTable_data *
mtpOmAllSlUtilizationTable_duplicate(struct mtpOmAllSlUtilizationTable_data *thedata)
{
	struct mtpOmAllSlUtilizationTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmAllSlUtilizationTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAllSlUtilizationTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmAllSlUtilizationTable_id = thedata->mtpOmAllSlUtilizationTable_id;
		StorageNew->mtpSlId = thedata->mtpSlId;
		StorageNew->mtpOmSlAlignment = thedata->mtpOmSlAlignment;
		StorageNew->mtpOmSlNegAckReceived = thedata->mtpOmSlNegAckReceived;
		StorageNew->mtpOmSlRetransmittedOctets = thedata->mtpOmSlRetransmittedOctets;
		StorageNew->mtpOmSlTransmittedMSUs = thedata->mtpOmSlTransmittedMSUs;
		StorageNew->mtpOmSlReceivedMSUs = thedata->mtpOmSlReceivedMSUs;
		StorageNew->mtpOmAllSlUtilizationRowStatus = thedata->mtpOmAllSlUtilizationRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmAllSlUtilizationTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmAllSlUtilizationTable_destroy(struct mtpOmAllSlUtilizationTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmAllSlUtilizationTable_destroy(struct mtpOmAllSlUtilizationTable_data **thedata)
{
	struct mtpOmAllSlUtilizationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAllSlUtilizationTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmAllSlUtilizationTable_add(struct mtpOmAllSlUtilizationTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmAllSlUtilizationTable table data set.
 *
 * Adds a table row structure to the mtpOmAllSlUtilizationTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmAllSlUtilizationTable_add(struct mtpOmAllSlUtilizationTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAllSlUtilizationTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
		header_complex_add_data(&mtpOmAllSlUtilizationTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmAllSlUtilizationTable_del(struct mtpOmAllSlUtilizationTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmAllSlUtilizationTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmAllSlUtilizationTable_del(struct mtpOmAllSlUtilizationTable_data *thedata)
{
	struct mtpOmAllSlUtilizationTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmAllSlUtilizationTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmAllSlUtilizationTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmAllSlUtilizationTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmAllSlUtilizationTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmAllSlUtilizationTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmAllSlUtilizationTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmAllSlUtilizationTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmAllSlUtilizationTable_data *StorageTmp = mtpOmAllSlUtilizationTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmAllSlUtilizationTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlAlignment, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlNegAckReceived, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlRetransmittedOctets, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlTransmittedMSUs, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlReceivedMSUs, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmAllSlUtilizationRowStatus, &tmpsize);
	mtpOmAllSlUtilizationTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmAllSlUtilizationTable(): store configuraiton file for mtpOmAllSlUtilizationTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmAllSlUtilizationTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmAllSlUtilizationTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmAllSlUtilizationTable: storing data...  "));
	refresh_mtpOmAllSlUtilizationTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmAllSlUtilizationTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmAllSlUtilizationTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmAllSlUtilizationTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlAlignment, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlNegAckReceived, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlRetransmittedOctets, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlTransmittedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlReceivedMSUs, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmAllSlUtilizationRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct mtpOmSlCongestionTable_data *mtpOmSlCongestionTable_create(void)
 * @brief create a fresh data structure representing a new row in the mtpOmSlCongestionTable table.
 *
 * Creates a new mtpOmSlCongestionTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct mtpOmSlCongestionTable_data *
mtpOmSlCongestionTable_create(void)
{
	struct mtpOmSlCongestionTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlCongestionTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlCongestionTable_create: creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->mtpSlId = 0;
		StorageNew->mtpOmCongestionLevel = 0;
		StorageNew->mtpOmSlCongestionFirst = TV_FALSE;
		StorageNew->mtpOmSlCongestionInterval = 180000;
		StorageNew->mtpOmSlCongestionStarts = 0;
		StorageNew->mtpOmSlCongestionStops = 0;
		StorageNew->mtpOmSlCongestionEventsMSULoss = 0;
		StorageNew->mtpOmSlCongestionRowStatus = 0;
		StorageNew->mtpOmSlCongestionRowStatus = RS_NOTREADY;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto nomem;
      nomem:
	mtpOmSlCongestionTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn struct mtpOmSlCongestionTable_data *mtpOmSlCongestionTable_duplicate(struct mtpOmSlCongestionTable_data *thedata)
 * @param thedata the row structure to duplicate.
 * @brief duplicate a row structure for a table.
 *
 * Duplicates the specified row structure @param thedata and returns a pointer to the newly
 * allocated row structure on success, or NULL on failure.
 */
struct mtpOmSlCongestionTable_data *
mtpOmSlCongestionTable_duplicate(struct mtpOmSlCongestionTable_data *thedata)
{
	struct mtpOmSlCongestionTable_data *StorageNew = SNMP_MALLOC_STRUCT(mtpOmSlCongestionTable_data);

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlCongestionTable_duplicate: duplicating row...  "));
	if (StorageNew != NULL) {
		StorageNew->mtpOmSlCongestionTable_id = thedata->mtpOmSlCongestionTable_id;
		StorageNew->mtpSlId = thedata->mtpSlId;
		StorageNew->mtpOmCongestionLevel = thedata->mtpOmCongestionLevel;
		StorageNew->mtpOmSlCongestionFirst = thedata->mtpOmSlCongestionFirst;
		StorageNew->mtpOmSlCongestionInterval = thedata->mtpOmSlCongestionInterval;
		StorageNew->mtpOmSlCongestionStarts = thedata->mtpOmSlCongestionStarts;
		StorageNew->mtpOmSlCongestionStops = thedata->mtpOmSlCongestionStops;
		StorageNew->mtpOmSlCongestionEventsMSULoss = thedata->mtpOmSlCongestionEventsMSULoss;
		StorageNew->mtpOmSlCongestionRowStatus = thedata->mtpOmSlCongestionRowStatus;
	}
      done:
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return (StorageNew);
	goto destroy;
      destroy:
	mtpOmSlCongestionTable_destroy(&StorageNew);
	goto done;
}

/**
 * @fn int mtpOmSlCongestionTable_destroy(struct mtpOmSlCongestionTable_data **thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
 * NULL.
 */
int
mtpOmSlCongestionTable_destroy(struct mtpOmSlCongestionTable_data **thedata)
{
	struct mtpOmSlCongestionTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlCongestionTable_destroy: deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlCongestionTable_add(struct mtpOmSlCongestionTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the mtpOmSlCongestionTable table data set.
 *
 * Adds a table row structure to the mtpOmSlCongestionTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
mtpOmSlCongestionTable_add(struct mtpOmSlCongestionTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlCongestionTable_add: adding data...  "));
	if (thedata) {
		/* add the index variables to the varbind list, which is used by header_complex to index the data */
		/* mtpSlId */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->mtpSlId, sizeof(thedata->mtpSlId));
		/* mtpOmCongestionLevel */
		snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, (u_char *) &thedata->mtpOmCongestionLevel, sizeof(thedata->mtpOmCongestionLevel));
		header_complex_add_data(&mtpOmSlCongestionTableStorage, vars, thedata);
	}
	DEBUGMSGTL(("mtpOmMIB", "registered an entry.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int mtpOmSlCongestionTable_del(struct mtpOmSlCongestionTable_data *thedata)
 * @param thedata pointer to the extracted or existing data structure in the table.
 * @brief delete a row structure from a table.
 *
 * Deletes a table row structure from the mtpOmSlCongestionTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
mtpOmSlCongestionTable_del(struct mtpOmSlCongestionTable_data *thedata)
{
	struct mtpOmSlCongestionTable_data *StorageDel;

	DEBUGMSGTL(("mtpOmMIB", "mtpOmSlCongestionTable_data: deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(mtpOmSlCongestionTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&mtpOmSlCongestionTableStorage, hciptr);
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_mtpOmSlCongestionTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for mtpOmSlCongestionTable entries.
 *
 * This callback is called by UCD-SNMP when it parses a configuration file and finds a configuration
 * file line for the registsred token (in this case mtpOmSlCongestionTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_mtpOmSlCongestionTable(const char *token, char *line)
{
	size_t tmpsize;
	struct mtpOmSlCongestionTable_data *StorageTmp = mtpOmSlCongestionTable_create();

	DEBUGMSGTL(("mtpOmMIB", "parse_mtpOmSlCongestionTable: parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->mtpSlId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmCongestionLevel, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlCongestionFirst, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlCongestionInterval, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlCongestionStarts, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlCongestionStops, &tmpsize);
	line = read_config_read_data(ASN_GAUGE, line, &StorageTmp->mtpOmSlCongestionEventsMSULoss, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->mtpOmSlCongestionRowStatus, &tmpsize);
	mtpOmSlCongestionTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/*
 * store_mtpOmSlCongestionTable(): store configuraiton file for mtpOmSlCongestionTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_mtpOmSlCongestionTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct mtpOmSlCongestionTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("mtpOmMIB", "store_mtpOmSlCongestionTable: storing data...  "));
	refresh_mtpOmSlCongestionTable(1);
	(void) tmpsize;
	for (hcindex = mtpOmSlCongestionTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct mtpOmSlCongestionTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "mtpOmSlCongestionTable ");
			cptr = line + strlen(line);
			(void) cptr;
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->mtpSlId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlCongestionFirst, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlCongestionInterval, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlCongestionStarts, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlCongestionStops, &tmpsize);
			cptr = read_config_store_data(ASN_GAUGE, cptr, &StorageTmp->mtpOmSlCongestionEventsMSULoss, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->mtpOmSlCongestionRowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int activate_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int activate_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp)
 * @param StorageTmp the data row to activate
 * @brief commit activation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_NOTINSERVICE state to the RS_ACTIVE state.  It is also used when transitioning from the
 * RS_CREATEANDGO state to the RS_ACTIVE state.  If activation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
activate_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp)
{
	/* XXX: provide code to activate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int deactivate_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp)
 * @param StorageTmp the data row to deactivate
 * @brief commit deactivation of a row to the underlying device
 *
 * This function is used by tables that contain a RowStatus object.  It is used to move the row from
 * the RS_ACTIVE state to the RS_NOTINSERVICE state.  It is also used when transitioning from the
 * RS_ACTIVE state to the RS_DESTROY state.  If deactivation fails, the function should return
 * SNMP_ERR_COMMITFAILED; otherwise, SNMP_ERR_NOERROR.
 */
int
deactivate_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp)
{
	/* XXX: provide code to deactivate the row with the underlying device */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int check_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmHandledMSUsOpcDpcSioTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmHandledMSUsOpcDpcSioTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmHandledMSUsOpcDpcSioTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmHandledMSUsOpcDpcSioTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmHandledMSUsOpcDpcSioTable_data *
refresh_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmHandledMSUsOpcDpcSioTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmHandledMSUsOpcDpcSioTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmHandledMSUsOpcDpcSioTable(int force)
{
	if (!force && mtpOmHandledMSUsOpcDpcSioTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmHandledMSUsOpcDpcSioTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmHandledMSUsOpcDpcSioTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmHandledMSUsOpcDpcSioTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmHandledMSUsOpcDpcSioTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmHandledMSUsOpcDpcSioTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmHandledMSUsOpcDpcSioTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmHandledMSUsOpcDpcSioTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmHandledMSUsOpcDpcSioTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMHANDLEDMSUSOPCDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmHandledMSUsOpcDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmHandledMSUsOpcDpcSio;
		break;
	case (u_char) MTPOMHANDLEDMSUSOPCDPCSIOROWSTATUS:	/* Create */
		*write_method = write_mtpOmHandledMSUsOpcDpcSioRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmHandledOctetsOpcDpcSioTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmHandledOctetsOpcDpcSioTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp, struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmHandledOctetsOpcDpcSioTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmHandledOctetsOpcDpcSioTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmHandledOctetsOpcDpcSioTable_data *
refresh_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmHandledOctetsOpcDpcSioTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmHandledOctetsOpcDpcSioTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmHandledOctetsOpcDpcSioTable(int force)
{
	if (!force && mtpOmHandledOctetsOpcDpcSioTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmHandledOctetsOpcDpcSioTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmHandledOctetsOpcDpcSioTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmHandledOctetsOpcDpcSioTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmHandledOctetsOpcDpcSioTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmHandledOctetsOpcDpcSioTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmHandledOctetsOpcDpcSioTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmHandledOctetsOpcDpcSioTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMHANDLEDOCTETSOPCDPCSIOINTERVAL:	/* Create */
		*write_method = write_mtpOmHandledOctetsOpcDpcSioInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmHandledOctetsOpcDpcSioInterval);
		rval = (u_char *) &StorageTmp->mtpOmHandledOctetsOpcDpcSioInterval;
		break;
	case (u_char) MTPOMHANDLEDOCTETSOPCDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmHandledOctetsOpcDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmHandledOctetsOpcDpcSio;
		break;
	case (u_char) MTPOMHANDLEDOCTETSOPCDPCSIOROWSTATUS:	/* Create */
		*write_method = write_mtpOmHandledOctetsOpcDpcSioRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmHandledOctetsSIOTable_row(struct mtpOmHandledOctetsSIOTable_data *StorageTmp, struct mtpOmHandledOctetsSIOTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmHandledOctetsSIOTable_row(struct mtpOmHandledOctetsSIOTable_data *StorageTmp, struct mtpOmHandledOctetsSIOTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmHandledOctetsSIOTable_row(struct mtpOmHandledOctetsSIOTable_data *StorageTmp, struct mtpOmHandledOctetsSIOTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmHandledOctetsSIOTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmHandledOctetsSIOTable_row(struct mtpOmHandledOctetsSIOTable_data *StorageTmp, struct mtpOmHandledOctetsSIOTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmHandledOctetsSIOTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmHandledOctetsSIOTable_row(struct mtpOmHandledOctetsSIOTable_data *StorageTmp, struct mtpOmHandledOctetsSIOTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmHandledOctetsSIOTable_row(struct mtpOmHandledOctetsSIOTable_data *StorageTmp, struct mtpOmHandledOctetsSIOTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmHandledOctetsSIOTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmHandledOctetsSIOTable_row(struct mtpOmHandledOctetsSIOTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmHandledOctetsSIOTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmHandledOctetsSIOTable_data *
refresh_mtpOmHandledOctetsSIOTable_row(struct mtpOmHandledOctetsSIOTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmHandledOctetsSIOTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmHandledOctetsSIOTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmHandledOctetsSIOTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmHandledOctetsSIOTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmHandledOctetsSIOTable(int force)
{
	if (!force && mtpOmHandledOctetsSIOTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmHandledOctetsSIOTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmHandledOctetsSIOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmHandledOctetsSIOTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmHandledOctetsSIOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmHandledOctetsSIOTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmHandledOctetsSIOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmHandledOctetsSIOTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmHandledOctetsSIOTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmHandledOctetsSIOTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMHANDLEDOCTETSSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmHandledOctetsSIO);
		rval = (u_char *) &StorageTmp->mtpOmHandledOctetsSIO;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmOblSpUtilizationTable_row(struct mtpOmOblSpUtilizationTable_data *StorageTmp, struct mtpOmOblSpUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmOblSpUtilizationTable_row(struct mtpOmOblSpUtilizationTable_data *StorageTmp, struct mtpOmOblSpUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmOblSpUtilizationTable_row(struct mtpOmOblSpUtilizationTable_data *StorageTmp, struct mtpOmOblSpUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmOblSpUtilizationTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmOblSpUtilizationTable_row(struct mtpOmOblSpUtilizationTable_data *StorageTmp, struct mtpOmOblSpUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmOblSpUtilizationTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmOblSpUtilizationTable_row(struct mtpOmOblSpUtilizationTable_data *StorageTmp, struct mtpOmOblSpUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmOblSpUtilizationTable_row(struct mtpOmOblSpUtilizationTable_data *StorageTmp, struct mtpOmOblSpUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmOblSpUtilizationTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmOblSpUtilizationTable_row(struct mtpOmOblSpUtilizationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmOblSpUtilizationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmOblSpUtilizationTable_data *
refresh_mtpOmOblSpUtilizationTable_row(struct mtpOmOblSpUtilizationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmOblSpUtilizationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmOblSpUtilizationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmOblSpUtilizationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmOblSpUtilizationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmOblSpUtilizationTable(int force)
{
	if (!force && mtpOmOblSpUtilizationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmOblSpUtilizationTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmOblSpUtilizationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmOblSpUtilizationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmOblSpUtilizationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmOblSpUtilizationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmOblSpUtilizationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmOblSpUtilizationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmOblSpUtilizationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmOblSpUtilizationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMADJACENTINACCESSIBLEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmAdjacentInaccessibleDuration);
		rval = (u_char *) &StorageTmp->mtpOmAdjacentInaccessibleDuration;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp, struct mtpOmAllSpUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp, struct mtpOmAllSpUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp, struct mtpOmAllSpUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmAllSpUtilizationTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp, struct mtpOmAllSpUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmAllSpUtilizationTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp, struct mtpOmAllSpUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp, struct mtpOmAllSpUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmAllSpUtilizationTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmAllSpUtilizationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmAllSpUtilizationTable_data *
refresh_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmAllSpUtilizationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmAllSpUtilizationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmAllSpUtilizationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmAllSpUtilizationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmAllSpUtilizationTable(int force)
{
	if (!force && mtpOmAllSpUtilizationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmAllSpUtilizationTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmAllSpUtilizationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmAllSpUtilizationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmAllSpUtilizationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmAllSpUtilizationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmAllSpUtilizationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmAllSpUtilizationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmAllSpUtilizationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmAllSpUtilizationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMADJACENTINACCESSIBLEEVENTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmAdjacentInaccessibleEvents);
		rval = (u_char *) &StorageTmp->mtpOmAdjacentInaccessibleEvents;
		break;
	case (u_char) MTPOMALLSPUTILIZATIONROWSTATUS:	/* Create */
		*write_method = write_mtpOmAllSpUtilizationRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmAllSpUtilizationRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmAllSpUtilizationRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp, struct mtpOmReceivedOctetsOPCTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp, struct mtpOmReceivedOctetsOPCTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp, struct mtpOmReceivedOctetsOPCTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmReceivedOctetsOPCTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp, struct mtpOmReceivedOctetsOPCTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmReceivedOctetsOPCTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp, struct mtpOmReceivedOctetsOPCTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp, struct mtpOmReceivedOctetsOPCTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmReceivedOctetsOPCTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmReceivedOctetsOPCTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmReceivedOctetsOPCTable_data *
refresh_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmReceivedOctetsOPCTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmReceivedOctetsOPCTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmReceivedOctetsOPCTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmReceivedOctetsOPCTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmReceivedOctetsOPCTable(int force)
{
	if (!force && mtpOmReceivedOctetsOPCTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmReceivedOctetsOPCTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmReceivedOctetsOPCTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmReceivedOctetsOPCTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmReceivedOctetsOPCTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmReceivedOctetsOPCTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmReceivedOctetsOPCTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmReceivedOctetsOPCTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmReceivedOctetsOPCTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmReceivedOctetsOPCTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMRECEIVEDOCTETSOPCINTERVAL:	/* Create */
		*write_method = write_mtpOmReceivedOctetsOPCInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmReceivedOctetsOPCInterval);
		rval = (u_char *) &StorageTmp->mtpOmReceivedOctetsOPCInterval;
		break;
	case (u_char) MTPOMRECEIVEDOCTETSOPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmReceivedOctetsOPC);
		rval = (u_char *) &StorageTmp->mtpOmReceivedOctetsOPC;
		break;
	case (u_char) MTPOMRECEIVEDOCTETSOPCROWSTATUS:	/* Create */
		*write_method = write_mtpOmReceivedOctetsOPCRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmReceivedOctetsOPCRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmReceivedOctetsOPCRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp, struct mtpOmReceivedOctetsOpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp, struct mtpOmReceivedOctetsOpcSioTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp, struct mtpOmReceivedOctetsOpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmReceivedOctetsOpcSioTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp, struct mtpOmReceivedOctetsOpcSioTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmReceivedOctetsOpcSioTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp, struct mtpOmReceivedOctetsOpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp, struct mtpOmReceivedOctetsOpcSioTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmReceivedOctetsOpcSioTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmReceivedOctetsOpcSioTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmReceivedOctetsOpcSioTable_data *
refresh_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmReceivedOctetsOpcSioTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmReceivedOctetsOpcSioTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmReceivedOctetsOpcSioTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmReceivedOctetsOpcSioTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmReceivedOctetsOpcSioTable(int force)
{
	if (!force && mtpOmReceivedOctetsOpcSioTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmReceivedOctetsOpcSioTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmReceivedOctetsOpcSioTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmReceivedOctetsOpcSioTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmReceivedOctetsOpcSioTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmReceivedOctetsOpcSioTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmReceivedOctetsOpcSioTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmReceivedOctetsOpcSioTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMRECEIVEDOCTETSOPCSIOINTERVAL:	/* Create */
		*write_method = write_mtpOmReceivedOctetsOpcSioInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmReceivedOctetsOpcSioInterval);
		rval = (u_char *) &StorageTmp->mtpOmReceivedOctetsOpcSioInterval;
		break;
	case (u_char) MTPOMRECEIVEDOCTETSOPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmReceivedOctetsOpcSio);
		rval = (u_char *) &StorageTmp->mtpOmReceivedOctetsOpcSio;
		break;
	case (u_char) MTPOMRECEIVEDOCTETSOPCSIOROWSTATUS:	/* Create */
		*write_method = write_mtpOmReceivedOctetsOpcSioRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmSpDataTable_row(struct mtpOmSpDataTable_data *StorageTmp, struct mtpOmSpDataTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmSpDataTable_row(struct mtpOmSpDataTable_data *StorageTmp, struct mtpOmSpDataTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmSpDataTable_row(struct mtpOmSpDataTable_data *StorageTmp, struct mtpOmSpDataTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmSpDataTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmSpDataTable_row(struct mtpOmSpDataTable_data *StorageTmp, struct mtpOmSpDataTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmSpDataTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmSpDataTable_row(struct mtpOmSpDataTable_data *StorageTmp, struct mtpOmSpDataTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmSpDataTable_row(struct mtpOmSpDataTable_data *StorageTmp, struct mtpOmSpDataTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmSpDataTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmSpDataTable_row(struct mtpOmSpDataTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSpDataTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSpDataTable_data *
refresh_mtpOmSpDataTable_row(struct mtpOmSpDataTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSpDataTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSpDataTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSpDataTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSpDataTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSpDataTable(int force)
{
	if (!force && mtpOmSpDataTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSpDataTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSpDataTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSpDataTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSpDataTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSpDataTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSpDataTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSpDataTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSpDataTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSpDataTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSPDISCARDEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpDiscardedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSpDiscardedMSUs;
		break;
	case (u_char) MTPOMSPTRANSMITTEDUPUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpTransmittedUPUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmSpTransmittedUPUnavailable;
		break;
	case (u_char) MTPOMSPRECEIVEDUPUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedUPUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmSpReceivedUPUnavailable;
		break;
	case (u_char) MTPOMSPRECEIVEDTFC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFC);
		rval = (u_char *) &StorageTmp->mtpOmSpReceivedTFC;
		break;
	case (u_char) MTPOMSPRECEIVEDTFCLEVEL0:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFCLevel0);
		rval = (u_char *) &StorageTmp->mtpOmSpReceivedTFCLevel0;
		break;
	case (u_char) MTPOMSPRECEIVEDTFCLEVEL1:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFCLevel1);
		rval = (u_char *) &StorageTmp->mtpOmSpReceivedTFCLevel1;
		break;
	case (u_char) MTPOMSPRECEIVEDTFCLEVEL2:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFCLevel2);
		rval = (u_char *) &StorageTmp->mtpOmSpReceivedTFCLevel2;
		break;
	case (u_char) MTPOMSPRECEIVEDTFCLEVEL3:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSpReceivedTFCLevel3);
		rval = (u_char *) &StorageTmp->mtpOmSpReceivedTFCLevel3;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp, struct mtpOmTransmittedOctetsDPCTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp, struct mtpOmTransmittedOctetsDPCTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp, struct mtpOmTransmittedOctetsDPCTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmTransmittedOctetsDPCTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp, struct mtpOmTransmittedOctetsDPCTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmTransmittedOctetsDPCTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp, struct mtpOmTransmittedOctetsDPCTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp, struct mtpOmTransmittedOctetsDPCTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmTransmittedOctetsDPCTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmTransmittedOctetsDPCTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmTransmittedOctetsDPCTable_data *
refresh_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmTransmittedOctetsDPCTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmTransmittedOctetsDPCTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmTransmittedOctetsDPCTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmTransmittedOctetsDPCTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmTransmittedOctetsDPCTable(int force)
{
	if (!force && mtpOmTransmittedOctetsDPCTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmTransmittedOctetsDPCTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmTransmittedOctetsDPCTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmTransmittedOctetsDPCTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmTransmittedOctetsDPCTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmTransmittedOctetsDPCTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmTransmittedOctetsDPCTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmTransmittedOctetsDPCTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmTransmittedOctetsDPCTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMTRANSMITTEDOCTETSDPC:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmTransmittedOctetsDPC);
		rval = (u_char *) &StorageTmp->mtpOmTransmittedOctetsDPC;
		break;
	case (u_char) MTPOMTRANSMITTEDOCTETSDPCROWSTATUS:	/* Create */
		*write_method = write_mtpOmTransmittedOctetsDPCRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmTransmittedOctetsDPCRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmTransmittedOctetsDPCRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp, struct mtpOmTransmittedOctetsDpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp, struct mtpOmTransmittedOctetsDpcSioTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp, struct mtpOmTransmittedOctetsDpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmTransmittedOctetsDpcSioTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp, struct mtpOmTransmittedOctetsDpcSioTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmTransmittedOctetsDpcSioTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp, struct mtpOmTransmittedOctetsDpcSioTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp, struct mtpOmTransmittedOctetsDpcSioTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmTransmittedOctetsDpcSioTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmTransmittedOctetsDpcSioTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmTransmittedOctetsDpcSioTable_data *
refresh_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmTransmittedOctetsDpcSioTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmTransmittedOctetsDpcSioTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmTransmittedOctetsDpcSioTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmTransmittedOctetsDpcSioTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmTransmittedOctetsDpcSioTable(int force)
{
	if (!force && mtpOmTransmittedOctetsDpcSioTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmTransmittedOctetsDpcSioTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmTransmittedOctetsDpcSioTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmTransmittedOctetsDpcSioTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmTransmittedOctetsDpcSioTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmTransmittedOctetsDpcSioTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmTransmittedOctetsDpcSioTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmTransmittedOctetsDpcSioTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmTransmittedOctetsDpcSioTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMTRANSMITTEDOCTETSDPCSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmTransmittedOctetsDpcSio);
		rval = (u_char *) &StorageTmp->mtpOmTransmittedOctetsDpcSio;
		break;
	case (u_char) MTPOMTRANSMITTEDOCTETSDPCSIOROWSTATUS:	/* Create */
		*write_method = write_mtpOmTransmittedOctetsDpcSioRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmSignRsInformationTable_row(struct mtpOmSignRsInformationTable_data *StorageTmp, struct mtpOmSignRsInformationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmSignRsInformationTable_row(struct mtpOmSignRsInformationTable_data *StorageTmp, struct mtpOmSignRsInformationTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmSignRsInformationTable_row(struct mtpOmSignRsInformationTable_data *StorageTmp, struct mtpOmSignRsInformationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmSignRsInformationTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmSignRsInformationTable_row(struct mtpOmSignRsInformationTable_data *StorageTmp, struct mtpOmSignRsInformationTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmSignRsInformationTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmSignRsInformationTable_row(struct mtpOmSignRsInformationTable_data *StorageTmp, struct mtpOmSignRsInformationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmSignRsInformationTable_row(struct mtpOmSignRsInformationTable_data *StorageTmp, struct mtpOmSignRsInformationTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmSignRsInformationTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmSignRsInformationTable_row(struct mtpOmSignRsInformationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSignRsInformationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSignRsInformationTable_data *
refresh_mtpOmSignRsInformationTable_row(struct mtpOmSignRsInformationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSignRsInformationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSignRsInformationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSignRsInformationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSignRsInformationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSignRsInformationTable(int force)
{
	if (!force && mtpOmSignRsInformationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSignRsInformationTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSignRsInformationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSignRsInformationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSignRsInformationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSignRsInformationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSignRsInformationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSignRsInformationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSignRsInformationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSignRsInformationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMROUTESETUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRouteSetUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmRouteSetUnavailable;
		break;
	case (u_char) MTPOMROUTESETUNAVAILABLEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmRouteSetUnavailableDuration);
		rval = (u_char *) &StorageTmp->mtpOmRouteSetUnavailableDuration;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmSlsDurationTable_row(struct mtpOmSlsDurationTable_data *StorageTmp, struct mtpOmSlsDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmSlsDurationTable_row(struct mtpOmSlsDurationTable_data *StorageTmp, struct mtpOmSlsDurationTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmSlsDurationTable_row(struct mtpOmSlsDurationTable_data *StorageTmp, struct mtpOmSlsDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmSlsDurationTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmSlsDurationTable_row(struct mtpOmSlsDurationTable_data *StorageTmp, struct mtpOmSlsDurationTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmSlsDurationTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmSlsDurationTable_row(struct mtpOmSlsDurationTable_data *StorageTmp, struct mtpOmSlsDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmSlsDurationTable_row(struct mtpOmSlsDurationTable_data *StorageTmp, struct mtpOmSlsDurationTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmSlsDurationTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmSlsDurationTable_row(struct mtpOmSlsDurationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSlsDurationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSlsDurationTable_data *
refresh_mtpOmSlsDurationTable_row(struct mtpOmSlsDurationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSlsDurationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSlsDurationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSlsDurationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSlsDurationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlsDurationTable(int force)
{
	if (!force && mtpOmSlsDurationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSlsDurationTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSlsDurationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSlsDurationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlsDurationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlsDurationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlsDurationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSlsDurationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSlsDurationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSlsDurationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLSUNAVAILABLE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlsUnavailable);
		rval = (u_char *) &StorageTmp->mtpOmSlsUnavailable;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp, struct mtpOmAll5And30MinSlDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp, struct mtpOmAll5And30MinSlDurationTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp, struct mtpOmAll5And30MinSlDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmAll5And30MinSlDurationTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp, struct mtpOmAll5And30MinSlDurationTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmAll5And30MinSlDurationTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp, struct mtpOmAll5And30MinSlDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp, struct mtpOmAll5And30MinSlDurationTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmAll5And30MinSlDurationTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmAll5And30MinSlDurationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmAll5And30MinSlDurationTable_data *
refresh_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmAll5And30MinSlDurationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmAll5And30MinSlDurationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmAll5And30MinSlDurationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmAll5And30MinSlDurationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmAll5And30MinSlDurationTable(int force)
{
	if (!force && mtpOmAll5And30MinSlDurationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmAll5And30MinSlDurationTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmAll5And30MinSlDurationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmAll5And30MinSlDurationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmAll5And30MinSlDurationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmAll5And30MinSlDurationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmAll5And30MinSlDurationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmAll5And30MinSlDurationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmAll5And30MinSlDurationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMALL5AND30MINSLDURATIONINTERVAL:	/* Create */
		*write_method = write_mtpOmAll5And30MinSlDurationInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmAll5And30MinSlDurationInterval);
		rval = (u_char *) &StorageTmp->mtpOmAll5And30MinSlDurationInterval;
		break;
	case (u_char) MTPOMLOCALMGNTINHIBIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLocalMgntInhibit);
		rval = (u_char *) &StorageTmp->mtpOmLocalMgntInhibit;
		break;
	case (u_char) MTPOMLOCALMGNTUNINHIBIT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLocalMgntUninhibit);
		rval = (u_char *) &StorageTmp->mtpOmLocalMgntUninhibit;
		break;
	case (u_char) MTPOMLOCALBUSY:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmLocalBusy);
		rval = (u_char *) &StorageTmp->mtpOmLocalBusy;
		break;
	case (u_char) MTPOMALL5AND30MINSLDURATIONROWSTATUS:	/* Create */
		*write_method = write_mtpOmAll5And30MinSlDurationRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmAll5And30MinSlDurationRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmAll5And30MinSlDurationRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmOblSlDurationTable_row(struct mtpOmOblSlDurationTable_data *StorageTmp, struct mtpOmOblSlDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmOblSlDurationTable_row(struct mtpOmOblSlDurationTable_data *StorageTmp, struct mtpOmOblSlDurationTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmOblSlDurationTable_row(struct mtpOmOblSlDurationTable_data *StorageTmp, struct mtpOmOblSlDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmOblSlDurationTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmOblSlDurationTable_row(struct mtpOmOblSlDurationTable_data *StorageTmp, struct mtpOmOblSlDurationTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmOblSlDurationTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmOblSlDurationTable_row(struct mtpOmOblSlDurationTable_data *StorageTmp, struct mtpOmOblSlDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmOblSlDurationTable_row(struct mtpOmOblSlDurationTable_data *StorageTmp, struct mtpOmOblSlDurationTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmOblSlDurationTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmOblSlDurationTable_row(struct mtpOmOblSlDurationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmOblSlDurationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmOblSlDurationTable_data *
refresh_mtpOmOblSlDurationTable_row(struct mtpOmOblSlDurationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmOblSlDurationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmOblSlDurationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmOblSlDurationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmOblSlDurationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmOblSlDurationTable(int force)
{
	if (!force && mtpOmOblSlDurationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmOblSlDurationTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmOblSlDurationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmOblSlDurationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmOblSlDurationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmOblSlDurationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmOblSlDurationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmOblSlDurationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmOblSlDurationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmOblSlDurationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLUNAVAILABILITYDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlUnavailabilityDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlUnavailabilityDuration;
		break;
	case (u_char) MTPOMSLINSERVICEDURATION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlInServiceDuration);
		rval = (u_char *) &StorageTmp->mtpOmSlInServiceDuration;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp, struct mtpOmAll30MinSlDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp, struct mtpOmAll30MinSlDurationTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp, struct mtpOmAll30MinSlDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmAll30MinSlDurationTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp, struct mtpOmAll30MinSlDurationTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmAll30MinSlDurationTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp, struct mtpOmAll30MinSlDurationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp, struct mtpOmAll30MinSlDurationTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmAll30MinSlDurationTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmAll30MinSlDurationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmAll30MinSlDurationTable_data *
refresh_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmAll30MinSlDurationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmAll30MinSlDurationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmAll30MinSlDurationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmAll30MinSlDurationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmAll30MinSlDurationTable(int force)
{
	if (!force && mtpOmAll30MinSlDurationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmAll30MinSlDurationTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmAll30MinSlDurationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmAll30MinSlDurationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmAll30MinSlDurationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmAll30MinSlDurationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmAll30MinSlDurationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmAll30MinSlDurationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmAll30MinSlDurationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmAll30MinSlDurationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMALL30MINSLDURATIONINTERVAL:	/* Create */
		*write_method = write_mtpOmAll30MinSlDurationInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmAll30MinSlDurationInterval);
		rval = (u_char *) &StorageTmp->mtpOmAll30MinSlDurationInterval;
		break;
	case (u_char) MTPOMSLLOCALINHIBITION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlLocalInhibition);
		rval = (u_char *) &StorageTmp->mtpOmSlLocalInhibition;
		break;
	case (u_char) MTPOMSLREMOTEINHIBITION:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlRemoteInhibition);
		rval = (u_char *) &StorageTmp->mtpOmSlRemoteInhibition;
		break;
	case (u_char) MTPOMSLFAILED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlFailed);
		rval = (u_char *) &StorageTmp->mtpOmSlFailed;
		break;
	case (u_char) MTPOMSLREMOTEPROCOUTAGE:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlRemoteProcOutage);
		rval = (u_char *) &StorageTmp->mtpOmSlRemoteProcOutage;
		break;
	case (u_char) MTPOMALL30MINSLDURATIONROWSTATUS:	/* Create */
		*write_method = write_mtpOmAll30MinSlDurationRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmAll30MinSlDurationRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmAll30MinSlDurationRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmOblSlUtilizationTable_row(struct mtpOmOblSlUtilizationTable_data *StorageTmp, struct mtpOmOblSlUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmOblSlUtilizationTable_row(struct mtpOmOblSlUtilizationTable_data *StorageTmp, struct mtpOmOblSlUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmOblSlUtilizationTable_row(struct mtpOmOblSlUtilizationTable_data *StorageTmp, struct mtpOmOblSlUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmOblSlUtilizationTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmOblSlUtilizationTable_row(struct mtpOmOblSlUtilizationTable_data *StorageTmp, struct mtpOmOblSlUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmOblSlUtilizationTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmOblSlUtilizationTable_row(struct mtpOmOblSlUtilizationTable_data *StorageTmp, struct mtpOmOblSlUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmOblSlUtilizationTable_row(struct mtpOmOblSlUtilizationTable_data *StorageTmp, struct mtpOmOblSlUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmOblSlUtilizationTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmOblSlUtilizationTable_row(struct mtpOmOblSlUtilizationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmOblSlUtilizationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmOblSlUtilizationTable_data *
refresh_mtpOmOblSlUtilizationTable_row(struct mtpOmOblSlUtilizationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmOblSlUtilizationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmOblSlUtilizationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmOblSlUtilizationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmOblSlUtilizationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmOblSlUtilizationTable(int force)
{
	if (!force && mtpOmOblSlUtilizationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmOblSlUtilizationTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmOblSlUtilizationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmOblSlUtilizationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmOblSlUtilizationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmOblSlUtilizationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmOblSlUtilizationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmOblSlUtilizationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmOblSlUtilizationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmOblSlUtilizationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLSIGNUNITSRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlSignUnitsReceived);
		rval = (u_char *) &StorageTmp->mtpOmSlSignUnitsReceived;
		break;
	case (u_char) MTPOMSLTRANSMITTEDOCTETSSIFSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlTransmittedOctetsSIFSIO);
		rval = (u_char *) &StorageTmp->mtpOmSlTransmittedOctetsSIFSIO;
		break;
	case (u_char) MTPOMSLRECEIVEDOCTETSSIFSIO:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlReceivedOctetsSIFSIO);
		rval = (u_char *) &StorageTmp->mtpOmSlReceivedOctetsSIFSIO;
		break;
	case (u_char) MTPOMSLDISCARDEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlDiscardedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlDiscardedMSUs;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp, struct mtpOmAllSlUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp, struct mtpOmAllSlUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp, struct mtpOmAllSlUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmAllSlUtilizationTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp, struct mtpOmAllSlUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmAllSlUtilizationTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp, struct mtpOmAllSlUtilizationTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp, struct mtpOmAllSlUtilizationTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmAllSlUtilizationTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmAllSlUtilizationTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmAllSlUtilizationTable_data *
refresh_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmAllSlUtilizationTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmAllSlUtilizationTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmAllSlUtilizationTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmAllSlUtilizationTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmAllSlUtilizationTable(int force)
{
	if (!force && mtpOmAllSlUtilizationTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmAllSlUtilizationTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmAllSlUtilizationTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmAllSlUtilizationTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmAllSlUtilizationTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmAllSlUtilizationTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmAllSlUtilizationTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmAllSlUtilizationTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmAllSlUtilizationTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmAllSlUtilizationTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLALIGNMENT:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlAlignment);
		rval = (u_char *) &StorageTmp->mtpOmSlAlignment;
		break;
	case (u_char) MTPOMSLNEGACKRECEIVED:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlNegAckReceived);
		rval = (u_char *) &StorageTmp->mtpOmSlNegAckReceived;
		break;
	case (u_char) MTPOMSLRETRANSMITTEDOCTETS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlRetransmittedOctets);
		rval = (u_char *) &StorageTmp->mtpOmSlRetransmittedOctets;
		break;
	case (u_char) MTPOMSLTRANSMITTEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlTransmittedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlTransmittedMSUs;
		break;
	case (u_char) MTPOMSLRECEIVEDMSUS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlReceivedMSUs);
		rval = (u_char *) &StorageTmp->mtpOmSlReceivedMSUs;
		break;
	case (u_char) MTPOMALLSLUTILIZATIONROWSTATUS:	/* Create */
		*write_method = write_mtpOmAllSlUtilizationRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmAllSlUtilizationRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmAllSlUtilizationRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int check_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp, struct mtpOmSlCongestionTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to check, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the ACTION phase.  The start of the ACTION pahse performs this consitency check
 * on the row before allowing the request to proceed to the COMMIT phase.  This function can return
 * SNMP_ERR_NOERR or a specific SNMP error value.  Values in StorageOld are the values before the
 * varbinds on the mib were applied; the values in StorageTmp are the new values.  The function is
 * permitted to change the values in StorageTmp to correct them; however, preference should be made
 * for setting values where were not in the varbinds.
 */
int
check_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp, struct mtpOmSlCongestionTable_data *StorageOld)
{
	/* XXX: provide code to check the row for consistency */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int update_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp, struct mtpOmSlCongestionTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the set operation (ACTION phase) on a row
 *
 * This function is used both by tables that do and do not contain a RowStatus object.  It is used
 * to update, row-at-a-time, the varbinds belonging to the row.  Note that this function is not used
 * when rows are created or destroyed.  This function is called for the first varbind in a row at
 * the beginning of the COMMIT phase.  The start of the ACTION phase performs a consistency check on
 * the row before allowing the request to proceed to the COMMIT phase.  The COMMIT phase then
 * arrives here with consistency already checked (see check_mtpOmSlCongestionTable_row()).  This function can
 * return SNMP_ERR_NOERROR or SNMP_ERR_COMMITFAILED.  Values in StorageOld are the values before the
 * varbinds on the row were applied: the values in StorageTmp are the new values.
 */
int
update_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp, struct mtpOmSlCongestionTable_data *StorageOld)
{
	/* XXX: provide code to update the row with the underlying device */
	mtpOmSlCongestionTable_refresh = 1;
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int revert_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp, struct mtpOmSlCongestionTable_data *StorageOld)
 * @param StorageTmp the data as updated.
 * @param StorageOld the data previous to update.
 * @brief perform the undo operation (UNDO phase) on a row
 */
void
revert_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp, struct mtpOmSlCongestionTable_data *StorageOld)
{
	/* XXX: provide code to revert the row with the underlying device */
	update_mtpOmSlCongestionTable_row(StorageOld, NULL);
}

/**
 * @fn void refresh_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp, int force)
 * @param StorageTmp the data row to refresh.
 * @param force force refresh if non-zero.
 * @brief refresh the contents of the mtpOmSlCongestionTable row.
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
struct mtpOmSlCongestionTable_data *
refresh_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp, int force)
{
	if (!StorageTmp || (!force && StorageTmp->mtpOmSlCongestionTable_request == sa_request))
		return (StorageTmp);
	/* XXX: update row; delete it and return NULL if the row has disappeared */
	StorageTmp->mtpOmSlCongestionTable_request = sa_request;
	return (StorageTmp);
}

/**
 * @fn void refresh_mtpOmSlCongestionTable(int force)
 * @param force force refresh if non-zero.
 * @brief refresh the scalar values of the mtpOmSlCongestionTable.
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_mtpOmSlCongestionTable(int force)
{
	if (!force && mtpOmSlCongestionTable_refresh == 0)
		return;
	/* XXX: Here, update the table as required... */
	mtpOmSlCongestionTable_refresh = 0;
}

/**
 * @fn u_char *var_mtpOmSlCongestionTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in mtpOmSlCongestionTable.
 *
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_mtpOmMIB above.
 */
u_char *
var_mtpOmSlCongestionTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct mtpOmSlCongestionTable_data *StorageTmp = NULL;
	u_char *rval;

	DEBUGMSGTL(("mtpOmMIB", "var_mtpOmSlCongestionTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the header. */
	refresh_mtpOmSlCongestionTable(0);
	/* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
	while ((StorageTmp = header_complex(mtpOmSlCongestionTableStorage, vp, name, length, exact, var_len, write_method)))
		if ((StorageTmp = refresh_mtpOmSlCongestionTable_row(StorageTmp, 0)) || exact)
			break;
	*write_method = NULL;
	*var_len = 0;
	rval = NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case (u_char) MTPOMSLCONGESTIONFIRST:	/* Create */
		*write_method = write_mtpOmSlCongestionFirst;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlCongestionFirst);
		rval = (u_char *) &StorageTmp->mtpOmSlCongestionFirst;
		break;
	case (u_char) MTPOMSLCONGESTIONINTERVAL:	/* Create */
		*write_method = write_mtpOmSlCongestionInterval;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlCongestionInterval);
		rval = (u_char *) &StorageTmp->mtpOmSlCongestionInterval;
		break;
	case (u_char) MTPOMSLCONGESTIONSTARTS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlCongestionStarts);
		rval = (u_char *) &StorageTmp->mtpOmSlCongestionStarts;
		break;
	case (u_char) MTPOMSLCONGESTIONSTOPS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlCongestionStops);
		rval = (u_char *) &StorageTmp->mtpOmSlCongestionStops;
		break;
	case (u_char) MTPOMSLCONGESTIONEVENTSMSULOSS:	/* ReadOnly */
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlCongestionEventsMSULoss);
		rval = (u_char *) &StorageTmp->mtpOmSlCongestionEventsMSULoss;
		break;
	case (u_char) MTPOMSLCONGESTIONROWSTATUS:	/* Create */
		*write_method = write_mtpOmSlCongestionRowStatus;
		if (!StorageTmp)
			break;
		*var_len = sizeof(StorageTmp->mtpOmSlCongestionRowStatus);
		rval = (u_char *) &StorageTmp->mtpOmSlCongestionRowStatus;
		break;
	default:
		ERROR_MSG("");
	}
	return (rval);
}

/**
 * @fn int write_mtpOmHandledOctetsOpcDpcSioInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpOmHandledOctetsOpcDpcSioInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmHandledOctetsOpcDpcSioInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpOmHandledOctetsOpcDpcSioTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmHandledOctetsOpcDpcSioInterval: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmHandledOctetsOpcDpcSioInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmHandledOctetsOpcDpcSioInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 180000 */
		/* Note: ranges 30000..30000 180000..180000 */
		if (set_value != 30000 && set_value != 180000) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmHandledOctetsOpcDpcSioInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old) == NULL)
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old = mtpOmHandledOctetsOpcDpcSioTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_rsvs++;
		StorageTmp->mtpOmHandledOctetsOpcDpcSioInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_tsts == 0)
				if ((ret = check_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpOmHandledOctetsOpcDpcSioInterval for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_sets == 0)
				if ((ret = update_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old) != NULL) {
			mtpOmHandledOctetsOpcDpcSioTable_destroy(&StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old);
			StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_rsvs = 0;
			StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_tsts = 0;
			StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_sets == 0)
			revert_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old) == NULL)
			break;
		StorageTmp->mtpOmHandledOctetsOpcDpcSioInterval = StorageOld->mtpOmHandledOctetsOpcDpcSioInterval;
		if (--StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_rsvs == 0)
			mtpOmHandledOctetsOpcDpcSioTable_destroy(&StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmReceivedOctetsOPCInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpOmReceivedOctetsOPCInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmReceivedOctetsOPCTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmReceivedOctetsOPCInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpOmReceivedOctetsOPCTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpOmReceivedOctetsOPCRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOPCInterval: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOPCInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOPCInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 90000..90000 180000..180000 */
		if (set_value != 90000 && set_value != 180000) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOPCInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old) == NULL)
			if (StorageTmp->mtpOmReceivedOctetsOPCTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old = mtpOmReceivedOctetsOPCTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpOmReceivedOctetsOPCTable_rsvs++;
		StorageTmp->mtpOmReceivedOctetsOPCInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpOmReceivedOctetsOPCTable_tsts == 0)
				if ((ret = check_mtpOmReceivedOctetsOPCTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmReceivedOctetsOPCTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpOmReceivedOctetsOPCInterval for you to use, and you have just been asked to do something with it.  Note that anything 
				   done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpOmReceivedOctetsOPCTable_sets == 0)
				if ((ret = update_mtpOmReceivedOctetsOPCTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmReceivedOctetsOPCTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old) != NULL) {
			mtpOmReceivedOctetsOPCTable_destroy(&StorageTmp->mtpOmReceivedOctetsOPCTable_old);
			StorageTmp->mtpOmReceivedOctetsOPCTable_rsvs = 0;
			StorageTmp->mtpOmReceivedOctetsOPCTable_tsts = 0;
			StorageTmp->mtpOmReceivedOctetsOPCTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpOmReceivedOctetsOPCTable_sets == 0)
			revert_mtpOmReceivedOctetsOPCTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old) == NULL)
			break;
		StorageTmp->mtpOmReceivedOctetsOPCInterval = StorageOld->mtpOmReceivedOctetsOPCInterval;
		if (--StorageTmp->mtpOmReceivedOctetsOPCTable_rsvs == 0)
			mtpOmReceivedOctetsOPCTable_destroy(&StorageTmp->mtpOmReceivedOctetsOPCTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmReceivedOctetsOpcSioInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpOmReceivedOctetsOpcSioInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmReceivedOctetsOpcSioInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpOmReceivedOctetsOpcSioTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOpcSioInterval: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOpcSioInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOpcSioInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 180000 */
		/* Note: ranges 90000..90000 180000..180000 */
		if (set_value != 90000 && set_value != 180000) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOpcSioInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old) == NULL)
			if (StorageTmp->mtpOmReceivedOctetsOpcSioTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old = mtpOmReceivedOctetsOpcSioTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpOmReceivedOctetsOpcSioTable_rsvs++;
		StorageTmp->mtpOmReceivedOctetsOpcSioInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpOmReceivedOctetsOpcSioTable_tsts == 0)
				if ((ret = check_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmReceivedOctetsOpcSioTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpOmReceivedOctetsOpcSioInterval for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpOmReceivedOctetsOpcSioTable_sets == 0)
				if ((ret = update_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmReceivedOctetsOpcSioTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old) != NULL) {
			mtpOmReceivedOctetsOpcSioTable_destroy(&StorageTmp->mtpOmReceivedOctetsOpcSioTable_old);
			StorageTmp->mtpOmReceivedOctetsOpcSioTable_rsvs = 0;
			StorageTmp->mtpOmReceivedOctetsOpcSioTable_tsts = 0;
			StorageTmp->mtpOmReceivedOctetsOpcSioTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpOmReceivedOctetsOpcSioTable_sets == 0)
			revert_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old) == NULL)
			break;
		StorageTmp->mtpOmReceivedOctetsOpcSioInterval = StorageOld->mtpOmReceivedOctetsOpcSioInterval;
		if (--StorageTmp->mtpOmReceivedOctetsOpcSioTable_rsvs == 0)
			mtpOmReceivedOctetsOpcSioTable_destroy(&StorageTmp->mtpOmReceivedOctetsOpcSioTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmAll5And30MinSlDurationInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpOmAll5And30MinSlDurationInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmAll5And30MinSlDurationInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpOmAll5And30MinSlDurationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpOmAll5And30MinSlDurationRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll5And30MinSlDurationInterval: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll5And30MinSlDurationInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll5And30MinSlDurationInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 30000..30000 180000..180000 */
		if (set_value != 30000 && set_value != 180000) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll5And30MinSlDurationInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old) == NULL)
			if (StorageTmp->mtpOmAll5And30MinSlDurationTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old = mtpOmAll5And30MinSlDurationTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpOmAll5And30MinSlDurationTable_rsvs++;
		StorageTmp->mtpOmAll5And30MinSlDurationInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpOmAll5And30MinSlDurationTable_tsts == 0)
				if ((ret = check_mtpOmAll5And30MinSlDurationTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmAll5And30MinSlDurationTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpOmAll5And30MinSlDurationInterval for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpOmAll5And30MinSlDurationTable_sets == 0)
				if ((ret = update_mtpOmAll5And30MinSlDurationTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmAll5And30MinSlDurationTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old) != NULL) {
			mtpOmAll5And30MinSlDurationTable_destroy(&StorageTmp->mtpOmAll5And30MinSlDurationTable_old);
			StorageTmp->mtpOmAll5And30MinSlDurationTable_rsvs = 0;
			StorageTmp->mtpOmAll5And30MinSlDurationTable_tsts = 0;
			StorageTmp->mtpOmAll5And30MinSlDurationTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpOmAll5And30MinSlDurationTable_sets == 0)
			revert_mtpOmAll5And30MinSlDurationTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old) == NULL)
			break;
		StorageTmp->mtpOmAll5And30MinSlDurationInterval = StorageOld->mtpOmAll5And30MinSlDurationInterval;
		if (--StorageTmp->mtpOmAll5And30MinSlDurationTable_rsvs == 0)
			mtpOmAll5And30MinSlDurationTable_destroy(&StorageTmp->mtpOmAll5And30MinSlDurationTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmAll30MinSlDurationInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpOmAll30MinSlDurationInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmAll30MinSlDurationTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmAll30MinSlDurationInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpOmAll30MinSlDurationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpOmAll30MinSlDurationRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll30MinSlDurationInterval: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll30MinSlDurationInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll30MinSlDurationInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 180000 */
		/* Note: ranges 30000..30000 180000..180000 */
		if (set_value != 30000 && set_value != 180000) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll30MinSlDurationInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old) == NULL)
			if (StorageTmp->mtpOmAll30MinSlDurationTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old = mtpOmAll30MinSlDurationTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpOmAll30MinSlDurationTable_rsvs++;
		StorageTmp->mtpOmAll30MinSlDurationInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpOmAll30MinSlDurationTable_tsts == 0)
				if ((ret = check_mtpOmAll30MinSlDurationTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmAll30MinSlDurationTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpOmAll30MinSlDurationInterval for you to use, and you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpOmAll30MinSlDurationTable_sets == 0)
				if ((ret = update_mtpOmAll30MinSlDurationTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmAll30MinSlDurationTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old) != NULL) {
			mtpOmAll30MinSlDurationTable_destroy(&StorageTmp->mtpOmAll30MinSlDurationTable_old);
			StorageTmp->mtpOmAll30MinSlDurationTable_rsvs = 0;
			StorageTmp->mtpOmAll30MinSlDurationTable_tsts = 0;
			StorageTmp->mtpOmAll30MinSlDurationTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpOmAll30MinSlDurationTable_sets == 0)
			revert_mtpOmAll30MinSlDurationTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old) == NULL)
			break;
		StorageTmp->mtpOmAll30MinSlDurationInterval = StorageOld->mtpOmAll30MinSlDurationInterval;
		if (--StorageTmp->mtpOmAll30MinSlDurationTable_rsvs == 0)
			mtpOmAll30MinSlDurationTable_destroy(&StorageTmp->mtpOmAll30MinSlDurationTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmSlCongestionFirst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpOmSlCongestionFirst(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmSlCongestionTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmSlCongestionFirst entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpOmSlCongestionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpOmSlCongestionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSlCongestionFirst: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSlCongestionFirst not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSlCongestionFirst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value false */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSlCongestionFirst: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) == NULL)
			if (StorageTmp->mtpOmSlCongestionTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old = mtpOmSlCongestionTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpOmSlCongestionTable_rsvs++;
		StorageTmp->mtpOmSlCongestionFirst = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpOmSlCongestionTable_tsts == 0)
				if ((ret = check_mtpOmSlCongestionTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmSlCongestionTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpOmSlCongestionFirst for you to use, and you have just been asked to do something with it.  Note that anything done
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpOmSlCongestionTable_sets == 0)
				if ((ret = update_mtpOmSlCongestionTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmSlCongestionTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) != NULL) {
			mtpOmSlCongestionTable_destroy(&StorageTmp->mtpOmSlCongestionTable_old);
			StorageTmp->mtpOmSlCongestionTable_rsvs = 0;
			StorageTmp->mtpOmSlCongestionTable_tsts = 0;
			StorageTmp->mtpOmSlCongestionTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpOmSlCongestionTable_sets == 0)
			revert_mtpOmSlCongestionTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) == NULL)
			break;
		StorageTmp->mtpOmSlCongestionFirst = StorageOld->mtpOmSlCongestionFirst;
		if (--StorageTmp->mtpOmSlCongestionTable_rsvs == 0)
			mtpOmSlCongestionTable_destroy(&StorageTmp->mtpOmSlCongestionTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmSlCongestionInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_mtpOmSlCongestionInterval(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmSlCongestionTable_data *StorageTmp = NULL, *StorageOld = NULL;
	size_t newlen = name_len - 15;
	long set_value = *((long *) var_val);
	int ret = SNMP_ERR_NOERROR;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmSlCongestionInterval entering action=%d...  \n", action));
	if (StorageTmp == NULL)
		return SNMP_ERR_NOSUCHNAME;
	StorageTmp = header_complex(mtpOmSlCongestionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	switch (action) {
	case RESERVE1:
		if (StorageTmp != NULL && statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->mtpOmSlCongestionRowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSlCongestionInterval: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSlCongestionInterval not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSlCongestionInterval: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 180000 */
		/* Note: ranges 30000..30000 180000..180000 */
		if (set_value != 30000 && set_value != 180000) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSlCongestionInterval: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* one allocation for the whole row */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) == NULL)
			if (StorageTmp->mtpOmSlCongestionTable_rsvs == 0)
				if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old = mtpOmSlCongestionTable_duplicate(StorageTmp)) == NULL)
					return SNMP_ERR_RESOURCEUNAVAILABLE;
		if (StorageOld != NULL)
			StorageTmp->mtpOmSlCongestionTable_rsvs++;
		StorageTmp->mtpOmSlCongestionInterval = set_value;
		/* XXX: insert code to consistency check this particular varbind, if necessary (so error codes are applied to varbinds) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) != NULL) {
			/* one consistency check for the whole row */
			if (StorageTmp->mtpOmSlCongestionTable_tsts == 0)
				if ((ret = check_mtpOmSlCongestionTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmSlCongestionTable_tsts++;
		}
		break;
	case ACTION:		/* The variable has been stored in StorageTmp->mtpOmSlCongestionInterval for you to use, and you have just been asked to do something with it.  Note that anything done 
				   here must be reversable in the UNDO case */
		if (StorageTmp == NULL)
			return SNMP_ERR_NOSUCHNAME;
		/* XXX: insert code to set this particular varbind, if necessary */
		/* one set action for the whole row */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) != NULL) {
			/* XXX: insert code to set this particular varbind, if necessary */
			if (StorageTmp->mtpOmSlCongestionTable_sets == 0)
				if ((ret = update_mtpOmSlCongestionTable_row(StorageTmp, StorageOld)) != SNMP_ERR_NOERROR)
					return (ret);
			StorageTmp->mtpOmSlCongestionTable_sets++;
		}
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		/* one commit for the whole mib */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) != NULL) {
			mtpOmSlCongestionTable_destroy(&StorageTmp->mtpOmSlCongestionTable_old);
			StorageTmp->mtpOmSlCongestionTable_rsvs = 0;
			StorageTmp->mtpOmSlCongestionTable_tsts = 0;
			StorageTmp->mtpOmSlCongestionTable_sets = 0;
		}
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) == NULL)
			break;
		/* XXX: insert code to undo any action performed on this particular varbind */
		if (--StorageTmp->mtpOmSlCongestionTable_sets == 0)
			revert_mtpOmSlCongestionTable_row(StorageTmp, StorageOld);
		/* fall through */
	case FREE:		/* Release any resources that have been allocated */
		if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) == NULL)
			break;
		StorageTmp->mtpOmSlCongestionInterval = StorageOld->mtpOmSlCongestionInterval;
		if (--StorageTmp->mtpOmSlCongestionTable_rsvs == 0)
			mtpOmSlCongestionTable_destroy(&StorageTmp->mtpOmSlCongestionTable_old);
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmHandledMSUsOpcDpcSioTable_row(struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmHandledOctetsOpcDpcSioTable_row(struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmAllSpUtilizationTable_row(struct mtpOmAllSpUtilizationTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmReceivedOctetsOPCTable_row(struct mtpOmReceivedOctetsOPCTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmReceivedOctetsOpcSioTable_row(struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmTransmittedOctetsDPCTable_row(struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmTransmittedOctetsDpcSioTable_row(struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmAll5And30MinSlDurationTable_row(struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmAll30MinSlDurationTable_row(struct mtpOmAll30MinSlDurationTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmAllSlUtilizationTable_row(struct mtpOmAllSlUtilizationTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_act_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an inactive table row can be activated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an inactive table
 * row can be activated.  Returns SNMP_ERR_NOERROR when activation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_act_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the new or inactive table row can be activated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int can_deact_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp)
 * @param StorageTmp the data (as updated)
 * @brief check whether an active table row can be deactivated
 *
 * This function is used by the ACTION phase of a RowStatus object to test whether an active table
 * row can be deactivated.  Returns SNMP_ERR_NOERROR when deactivation is permitted; an SNMP error
 * value, otherwise.  This function might use a 'test' operation against the driver to ensure that
 * the commit phase will succeed.
 */
int
can_deact_mtpOmSlCongestionTable_row(struct mtpOmSlCongestionTable_data *StorageTmp)
{
	/* XXX: provide code to check whether the active table row can be deactivated */
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmHandledMSUsOpcDpcSioRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmHandledMSUsOpcDpcSioRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmHandledMSUsOpcDpcSioTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmHandledMSUsOpcDpcSioRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmHandledMSUsOpcDpcSioTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmHandledMSUsOpcDpcSioRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmHandledMSUsOpcDpcSioRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmOpc */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmDpc */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmSio */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmOpc */
			/* Note: ranges 4..4 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 4)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmOpc: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmDpc */
			/* Note: ranges 4..4 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 4)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmDpc: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmSio */
			/* Note: ranges 1..1 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmSio: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmHandledMSUsOpcDpcSioTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmHandledMSUsOpcDpcSioTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmOpc, vp->val.string, vp->val_len);
			StorageNew->mtpOmOpcLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmDpc, vp->val.string, vp->val_len);
			StorageNew->mtpOmDpcLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmSio, vp->val.string, vp->val_len);
			StorageNew->mtpOmSioLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmHandledMSUsOpcDpcSioTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_old) == NULL)
				if (StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_old = mtpOmHandledMSUsOpcDpcSioTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmHandledMSUsOpcDpcSioTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmHandledMSUsOpcDpcSioTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmHandledMSUsOpcDpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmHandledMSUsOpcDpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmHandledMSUsOpcDpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
		   must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmHandledMSUsOpcDpcSioTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmHandledMSUsOpcDpcSioTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmHandledMSUsOpcDpcSioTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmHandledMSUsOpcDpcSioTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmHandledMSUsOpcDpcSioRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmHandledMSUsOpcDpcSioRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmHandledMSUsOpcDpcSioRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_old) != NULL) {
				mtpOmHandledMSUsOpcDpcSioTable_destroy(&StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_old);
				StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_rsvs = 0;
				StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_tsts = 0;
				StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmHandledMSUsOpcDpcSioTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmHandledMSUsOpcDpcSioTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmHandledMSUsOpcDpcSioTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmHandledMSUsOpcDpcSioRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmHandledMSUsOpcDpcSioTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmHandledMSUsOpcDpcSioTable_del(StorageNew);
				mtpOmHandledMSUsOpcDpcSioTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_rsvs == 0)
				mtpOmHandledMSUsOpcDpcSioTable_destroy(&StorageTmp->mtpOmHandledMSUsOpcDpcSioTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmHandledMSUsOpcDpcSioTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmHandledOctetsOpcDpcSioRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmHandledOctetsOpcDpcSioRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmHandledOctetsOpcDpcSioTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmHandledOctetsOpcDpcSioRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmHandledOctetsOpcDpcSioTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmHandledOctetsOpcDpcSioRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmHandledOctetsOpcDpcSioRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmOpc */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmDpc */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmSio */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmOpc */
			/* Note: ranges 4..4 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 4)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmOpc: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmDpc */
			/* Note: ranges 4..4 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 4)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmDpc: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmSio */
			/* Note: ranges 1..1 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmSio: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmHandledOctetsOpcDpcSioTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmHandledOctetsOpcDpcSioTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmOpc, vp->val.string, vp->val_len);
			StorageNew->mtpOmOpcLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmDpc, vp->val.string, vp->val_len);
			StorageNew->mtpOmDpcLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmSio, vp->val.string, vp->val_len);
			StorageNew->mtpOmSioLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmHandledOctetsOpcDpcSioTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old) == NULL)
				if (StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old = mtpOmHandledOctetsOpcDpcSioTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmHandledOctetsOpcDpcSioTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmHandledOctetsOpcDpcSioTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here 
		   must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmHandledOctetsOpcDpcSioTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmHandledOctetsOpcDpcSioTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmHandledOctetsOpcDpcSioRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmHandledOctetsOpcDpcSioRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmHandledOctetsOpcDpcSioRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old) != NULL) {
				mtpOmHandledOctetsOpcDpcSioTable_destroy(&StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old);
				StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_rsvs = 0;
				StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_tsts = 0;
				StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmHandledOctetsOpcDpcSioTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmHandledOctetsOpcDpcSioTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmHandledOctetsOpcDpcSioRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmHandledOctetsOpcDpcSioTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmHandledOctetsOpcDpcSioTable_del(StorageNew);
				mtpOmHandledOctetsOpcDpcSioTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_rsvs == 0)
				mtpOmHandledOctetsOpcDpcSioTable_destroy(&StorageTmp->mtpOmHandledOctetsOpcDpcSioTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmHandledOctetsOpcDpcSioTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmAllSpUtilizationRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmAllSpUtilizationRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmAllSpUtilizationTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmAllSpUtilizationTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmAllSpUtilizationRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmAllSpUtilizationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAllSpUtilizationRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAllSpUtilizationRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmAllSpUtilizationTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmAllSpUtilizationTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmAllSpUtilizationTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmAllSpUtilizationRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmAllSpUtilizationTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmAllSpUtilizationTable_old) == NULL)
				if (StorageTmp->mtpOmAllSpUtilizationTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmAllSpUtilizationTable_old = mtpOmAllSpUtilizationTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmAllSpUtilizationTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmAllSpUtilizationTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmAllSpUtilizationTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmAllSpUtilizationTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmAllSpUtilizationRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmAllSpUtilizationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmAllSpUtilizationRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmAllSpUtilizationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmAllSpUtilizationRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmAllSpUtilizationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmAllSpUtilizationRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must
		   be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmAllSpUtilizationTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmAllSpUtilizationRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmAllSpUtilizationTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmAllSpUtilizationRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmAllSpUtilizationTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmAllSpUtilizationTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmAllSpUtilizationRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmAllSpUtilizationRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmAllSpUtilizationRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmAllSpUtilizationTable_old) != NULL) {
				mtpOmAllSpUtilizationTable_destroy(&StorageTmp->mtpOmAllSpUtilizationTable_old);
				StorageTmp->mtpOmAllSpUtilizationTable_rsvs = 0;
				StorageTmp->mtpOmAllSpUtilizationTable_tsts = 0;
				StorageTmp->mtpOmAllSpUtilizationTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmAllSpUtilizationTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmAllSpUtilizationTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmAllSpUtilizationRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmAllSpUtilizationTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmAllSpUtilizationRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmAllSpUtilizationTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmAllSpUtilizationTable_del(StorageNew);
				mtpOmAllSpUtilizationTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmAllSpUtilizationTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmAllSpUtilizationTable_rsvs == 0)
				mtpOmAllSpUtilizationTable_destroy(&StorageTmp->mtpOmAllSpUtilizationTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmAllSpUtilizationTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmReceivedOctetsOPCRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmReceivedOctetsOPCRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmReceivedOctetsOPCTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmReceivedOctetsOPCTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmReceivedOctetsOPCRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmReceivedOctetsOPCTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOPCRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOPCRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmOpc */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmOpc */
			/* Note: ranges 4..4 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 4)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmOpc: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmReceivedOctetsOPCTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmReceivedOctetsOPCTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmOpc, vp->val.string, vp->val_len);
			StorageNew->mtpOmOpcLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmReceivedOctetsOPCTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmReceivedOctetsOPCRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmReceivedOctetsOPCTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old) == NULL)
				if (StorageTmp->mtpOmReceivedOctetsOPCTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old = mtpOmReceivedOctetsOPCTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmReceivedOctetsOPCTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmReceivedOctetsOPCTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmReceivedOctetsOPCTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmReceivedOctetsOPCTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmReceivedOctetsOPCRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmReceivedOctetsOPCTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmReceivedOctetsOPCRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmReceivedOctetsOPCTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmReceivedOctetsOPCRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmReceivedOctetsOPCTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmReceivedOctetsOPCRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must 
		   be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmReceivedOctetsOPCTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmReceivedOctetsOPCRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmReceivedOctetsOPCTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmReceivedOctetsOPCRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmReceivedOctetsOPCTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmReceivedOctetsOPCTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmReceivedOctetsOPCRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmReceivedOctetsOPCRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmReceivedOctetsOPCRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old) != NULL) {
				mtpOmReceivedOctetsOPCTable_destroy(&StorageTmp->mtpOmReceivedOctetsOPCTable_old);
				StorageTmp->mtpOmReceivedOctetsOPCTable_rsvs = 0;
				StorageTmp->mtpOmReceivedOctetsOPCTable_tsts = 0;
				StorageTmp->mtpOmReceivedOctetsOPCTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmReceivedOctetsOPCTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmReceivedOctetsOPCTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmReceivedOctetsOPCRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmReceivedOctetsOPCTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmReceivedOctetsOPCRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmReceivedOctetsOPCTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmReceivedOctetsOPCTable_del(StorageNew);
				mtpOmReceivedOctetsOPCTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOPCTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmReceivedOctetsOPCTable_rsvs == 0)
				mtpOmReceivedOctetsOPCTable_destroy(&StorageTmp->mtpOmReceivedOctetsOPCTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmReceivedOctetsOPCTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmReceivedOctetsOpcSioRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmReceivedOctetsOpcSioRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmReceivedOctetsOpcSioTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmReceivedOctetsOpcSioTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmReceivedOctetsOpcSioRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmReceivedOctetsOpcSioTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOpcSioRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmReceivedOctetsOpcSioRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmOpc */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmSio */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmOpc */
			/* Note: ranges 4..4 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 4)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmOpc: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmSio */
			/* Note: ranges 1..1 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmSio: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmReceivedOctetsOpcSioTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmReceivedOctetsOpcSioTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmOpc, vp->val.string, vp->val_len);
			StorageNew->mtpOmOpcLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmSio, vp->val.string, vp->val_len);
			StorageNew->mtpOmSioLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmReceivedOctetsOpcSioTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmReceivedOctetsOpcSioTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old) == NULL)
				if (StorageTmp->mtpOmReceivedOctetsOpcSioTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old = mtpOmReceivedOctetsOpcSioTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmReceivedOctetsOpcSioTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmReceivedOctetsOpcSioTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmReceivedOctetsOpcSioTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmReceivedOctetsOpcSioTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
		   must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmReceivedOctetsOpcSioTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmReceivedOctetsOpcSioTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmReceivedOctetsOpcSioRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmReceivedOctetsOpcSioRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmReceivedOctetsOpcSioRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old) != NULL) {
				mtpOmReceivedOctetsOpcSioTable_destroy(&StorageTmp->mtpOmReceivedOctetsOpcSioTable_old);
				StorageTmp->mtpOmReceivedOctetsOpcSioTable_rsvs = 0;
				StorageTmp->mtpOmReceivedOctetsOpcSioTable_tsts = 0;
				StorageTmp->mtpOmReceivedOctetsOpcSioTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmReceivedOctetsOpcSioTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmReceivedOctetsOpcSioTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmReceivedOctetsOpcSioRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmReceivedOctetsOpcSioTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmReceivedOctetsOpcSioTable_del(StorageNew);
				mtpOmReceivedOctetsOpcSioTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmReceivedOctetsOpcSioTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmReceivedOctetsOpcSioTable_rsvs == 0)
				mtpOmReceivedOctetsOpcSioTable_destroy(&StorageTmp->mtpOmReceivedOctetsOpcSioTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmReceivedOctetsOpcSioTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmTransmittedOctetsDPCRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmTransmittedOctetsDPCRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmTransmittedOctetsDPCTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmTransmittedOctetsDPCTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmTransmittedOctetsDPCRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmTransmittedOctetsDPCTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmTransmittedOctetsDPCRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmTransmittedOctetsDPCRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmDpc */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmDpc */
			/* Note: ranges 4..4 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 4)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmDpc: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmTransmittedOctetsDPCTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmTransmittedOctetsDPCTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmDpc, vp->val.string, vp->val_len);
			StorageNew->mtpOmDpcLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmTransmittedOctetsDPCTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmTransmittedOctetsDPCRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmTransmittedOctetsDPCTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmTransmittedOctetsDPCTable_old) == NULL)
				if (StorageTmp->mtpOmTransmittedOctetsDPCTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmTransmittedOctetsDPCTable_old = mtpOmTransmittedOctetsDPCTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmTransmittedOctetsDPCTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmTransmittedOctetsDPCTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmTransmittedOctetsDPCTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmTransmittedOctetsDPCTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmTransmittedOctetsDPCRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmTransmittedOctetsDPCTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmTransmittedOctetsDPCRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmTransmittedOctetsDPCTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmTransmittedOctetsDPCRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmTransmittedOctetsDPCTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmTransmittedOctetsDPCRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
		   must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmTransmittedOctetsDPCTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmTransmittedOctetsDPCRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmTransmittedOctetsDPCTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmTransmittedOctetsDPCRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmTransmittedOctetsDPCTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmTransmittedOctetsDPCTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmTransmittedOctetsDPCRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmTransmittedOctetsDPCRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmTransmittedOctetsDPCRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmTransmittedOctetsDPCTable_old) != NULL) {
				mtpOmTransmittedOctetsDPCTable_destroy(&StorageTmp->mtpOmTransmittedOctetsDPCTable_old);
				StorageTmp->mtpOmTransmittedOctetsDPCTable_rsvs = 0;
				StorageTmp->mtpOmTransmittedOctetsDPCTable_tsts = 0;
				StorageTmp->mtpOmTransmittedOctetsDPCTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmTransmittedOctetsDPCTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmTransmittedOctetsDPCTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmTransmittedOctetsDPCRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmTransmittedOctetsDPCTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmTransmittedOctetsDPCRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmTransmittedOctetsDPCTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmTransmittedOctetsDPCTable_del(StorageNew);
				mtpOmTransmittedOctetsDPCTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmTransmittedOctetsDPCTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmTransmittedOctetsDPCTable_rsvs == 0)
				mtpOmTransmittedOctetsDPCTable_destroy(&StorageTmp->mtpOmTransmittedOctetsDPCTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmTransmittedOctetsDPCTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmTransmittedOctetsDpcSioRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmTransmittedOctetsDpcSioRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmTransmittedOctetsDpcSioTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmTransmittedOctetsDpcSioTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmTransmittedOctetsDpcSioRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmTransmittedOctetsDpcSioTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmTransmittedOctetsDpcSioRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmTransmittedOctetsDpcSioRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSpId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmDpc */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmSio */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSpId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSpId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmDpc */
			/* Note: ranges 4..4 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 4)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmDpc: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmSio */
			/* Note: ranges 1..1 */
			if (vp->val_len > SPRINT_MAX_LEN || (vp->val_len != 1)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmSio: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmTransmittedOctetsDpcSioTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmTransmittedOctetsDpcSioTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSpId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmDpc, vp->val.string, vp->val_len);
			StorageNew->mtpOmDpcLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->mtpOmSio, vp->val.string, vp->val_len);
			StorageNew->mtpOmSioLen = vp->val_len;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmTransmittedOctetsDpcSioTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmTransmittedOctetsDpcSioTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmTransmittedOctetsDpcSioTable_old) == NULL)
				if (StorageTmp->mtpOmTransmittedOctetsDpcSioTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmTransmittedOctetsDpcSioTable_old = mtpOmTransmittedOctetsDpcSioTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmTransmittedOctetsDpcSioTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmTransmittedOctetsDpcSioTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmTransmittedOctetsDpcSioTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmTransmittedOctetsDpcSioTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmTransmittedOctetsDpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmTransmittedOctetsDpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmTransmittedOctetsDpcSioTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done
		   here must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmTransmittedOctetsDpcSioTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmTransmittedOctetsDpcSioTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmTransmittedOctetsDpcSioTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmTransmittedOctetsDpcSioTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmTransmittedOctetsDpcSioRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmTransmittedOctetsDpcSioRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmTransmittedOctetsDpcSioRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmTransmittedOctetsDpcSioTable_old) != NULL) {
				mtpOmTransmittedOctetsDpcSioTable_destroy(&StorageTmp->mtpOmTransmittedOctetsDpcSioTable_old);
				StorageTmp->mtpOmTransmittedOctetsDpcSioTable_rsvs = 0;
				StorageTmp->mtpOmTransmittedOctetsDpcSioTable_tsts = 0;
				StorageTmp->mtpOmTransmittedOctetsDpcSioTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmTransmittedOctetsDpcSioTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmTransmittedOctetsDpcSioTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmTransmittedOctetsDpcSioTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmTransmittedOctetsDpcSioRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmTransmittedOctetsDpcSioTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmTransmittedOctetsDpcSioTable_del(StorageNew);
				mtpOmTransmittedOctetsDpcSioTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmTransmittedOctetsDpcSioTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmTransmittedOctetsDpcSioTable_rsvs == 0)
				mtpOmTransmittedOctetsDpcSioTable_destroy(&StorageTmp->mtpOmTransmittedOctetsDpcSioTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmTransmittedOctetsDpcSioTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmAll5And30MinSlDurationRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmAll5And30MinSlDurationRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmAll5And30MinSlDurationTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmAll5And30MinSlDurationTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmAll5And30MinSlDurationRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmAll5And30MinSlDurationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll5And30MinSlDurationRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll5And30MinSlDurationRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSlId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..16 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 16)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmAll5And30MinSlDurationTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmAll5And30MinSlDurationTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSlId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmAll5And30MinSlDurationTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmAll5And30MinSlDurationRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmAll5And30MinSlDurationTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old) == NULL)
				if (StorageTmp->mtpOmAll5And30MinSlDurationTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old = mtpOmAll5And30MinSlDurationTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmAll5And30MinSlDurationTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmAll5And30MinSlDurationTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmAll5And30MinSlDurationTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmAll5And30MinSlDurationTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmAll5And30MinSlDurationRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmAll5And30MinSlDurationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmAll5And30MinSlDurationRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmAll5And30MinSlDurationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmAll5And30MinSlDurationRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmAll5And30MinSlDurationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmAll5And30MinSlDurationRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here 
		   must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmAll5And30MinSlDurationTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmAll5And30MinSlDurationRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmAll5And30MinSlDurationTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmAll5And30MinSlDurationRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmAll5And30MinSlDurationTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmAll5And30MinSlDurationTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmAll5And30MinSlDurationRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmAll5And30MinSlDurationRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmAll5And30MinSlDurationRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old) != NULL) {
				mtpOmAll5And30MinSlDurationTable_destroy(&StorageTmp->mtpOmAll5And30MinSlDurationTable_old);
				StorageTmp->mtpOmAll5And30MinSlDurationTable_rsvs = 0;
				StorageTmp->mtpOmAll5And30MinSlDurationTable_tsts = 0;
				StorageTmp->mtpOmAll5And30MinSlDurationTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmAll5And30MinSlDurationTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmAll5And30MinSlDurationTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmAll5And30MinSlDurationRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmAll5And30MinSlDurationTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmAll5And30MinSlDurationRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmAll5And30MinSlDurationTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmAll5And30MinSlDurationTable_del(StorageNew);
				mtpOmAll5And30MinSlDurationTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmAll5And30MinSlDurationTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmAll5And30MinSlDurationTable_rsvs == 0)
				mtpOmAll5And30MinSlDurationTable_destroy(&StorageTmp->mtpOmAll5And30MinSlDurationTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmAll5And30MinSlDurationTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmAll30MinSlDurationRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmAll30MinSlDurationRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmAll30MinSlDurationTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmAll30MinSlDurationTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmAll30MinSlDurationRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmAll30MinSlDurationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll30MinSlDurationRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAll30MinSlDurationRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSlId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..16 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 16)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmAll30MinSlDurationTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmAll30MinSlDurationTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSlId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmAll30MinSlDurationTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmAll30MinSlDurationRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmAll30MinSlDurationTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old) == NULL)
				if (StorageTmp->mtpOmAll30MinSlDurationTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old = mtpOmAll30MinSlDurationTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmAll30MinSlDurationTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmAll30MinSlDurationTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmAll30MinSlDurationTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmAll30MinSlDurationTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmAll30MinSlDurationRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmAll30MinSlDurationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmAll30MinSlDurationRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmAll30MinSlDurationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmAll30MinSlDurationRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmAll30MinSlDurationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmAll30MinSlDurationRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here
		   must be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmAll30MinSlDurationTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmAll30MinSlDurationRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmAll30MinSlDurationTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmAll30MinSlDurationRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmAll30MinSlDurationTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmAll30MinSlDurationTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmAll30MinSlDurationRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmAll30MinSlDurationRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmAll30MinSlDurationRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old) != NULL) {
				mtpOmAll30MinSlDurationTable_destroy(&StorageTmp->mtpOmAll30MinSlDurationTable_old);
				StorageTmp->mtpOmAll30MinSlDurationTable_rsvs = 0;
				StorageTmp->mtpOmAll30MinSlDurationTable_tsts = 0;
				StorageTmp->mtpOmAll30MinSlDurationTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmAll30MinSlDurationTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmAll30MinSlDurationTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmAll30MinSlDurationRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmAll30MinSlDurationTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmAll30MinSlDurationRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmAll30MinSlDurationTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmAll30MinSlDurationTable_del(StorageNew);
				mtpOmAll30MinSlDurationTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmAll30MinSlDurationTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmAll30MinSlDurationTable_rsvs == 0)
				mtpOmAll30MinSlDurationTable_destroy(&StorageTmp->mtpOmAll30MinSlDurationTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmAll30MinSlDurationTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmAllSlUtilizationRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmAllSlUtilizationRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmAllSlUtilizationTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmAllSlUtilizationTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmAllSlUtilizationRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmAllSlUtilizationTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAllSlUtilizationRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmAllSlUtilizationRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSlId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..16 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 16)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmAllSlUtilizationTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmAllSlUtilizationTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSlId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmAllSlUtilizationTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmAllSlUtilizationRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmAllSlUtilizationTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmAllSlUtilizationTable_old) == NULL)
				if (StorageTmp->mtpOmAllSlUtilizationTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmAllSlUtilizationTable_old = mtpOmAllSlUtilizationTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmAllSlUtilizationTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmAllSlUtilizationTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmAllSlUtilizationTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmAllSlUtilizationTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmAllSlUtilizationRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmAllSlUtilizationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmAllSlUtilizationRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmAllSlUtilizationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmAllSlUtilizationRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmAllSlUtilizationTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmAllSlUtilizationRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must
		   be reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmAllSlUtilizationTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmAllSlUtilizationRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmAllSlUtilizationTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmAllSlUtilizationRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmAllSlUtilizationTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmAllSlUtilizationTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmAllSlUtilizationRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmAllSlUtilizationRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmAllSlUtilizationRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmAllSlUtilizationTable_old) != NULL) {
				mtpOmAllSlUtilizationTable_destroy(&StorageTmp->mtpOmAllSlUtilizationTable_old);
				StorageTmp->mtpOmAllSlUtilizationTable_rsvs = 0;
				StorageTmp->mtpOmAllSlUtilizationTable_tsts = 0;
				StorageTmp->mtpOmAllSlUtilizationTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmAllSlUtilizationTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmAllSlUtilizationTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmAllSlUtilizationRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmAllSlUtilizationTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmAllSlUtilizationRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmAllSlUtilizationTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmAllSlUtilizationTable_del(StorageNew);
				mtpOmAllSlUtilizationTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmAllSlUtilizationTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmAllSlUtilizationTable_rsvs == 0)
				mtpOmAllSlUtilizationTable_destroy(&StorageTmp->mtpOmAllSlUtilizationTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmAllSlUtilizationTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_mtpOmSlCongestionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_mtpOmSlCongestionRowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct mtpOmSlCongestionTable_data *StorageTmp = NULL, *StorageOld = NULL;
	static struct mtpOmSlCongestionTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - 15;
	int set_value, ret;
	static struct variable_list *vars, *vp;

	DEBUGMSGTL(("mtpOmMIB", "write_mtpOmSlCongestionRowStatus entering action=%d...  \n", action));
	StorageTmp = header_complex(mtpOmSlCongestionTableStorage, NULL, &name[15], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSlCongestionRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to mtpOmSlCongestionRowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		StorageNew = StorageDel = NULL;
		vars = vp = NULL;
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* creation */
			vars = NULL;
			/* mtpSlId */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			/* mtpOmCongestionLevel */
			if ((vp = snmp_varlist_add_variable(&vars, NULL, 0, ASN_INTEGER, NULL, 0)) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			if (header_complex_parse_oid(&(name[15]), newlen, vars) != SNMPERR_SUCCESS) {
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			/* mtpSlId */
			if (vp->val_len > sizeof(uint32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			/* Note: ranges 1..16 */
			if ((1 > (ulong) *vp->val.integer || (ulong) *vp->val.integer > 16)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpSlId: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			/* mtpOmCongestionLevel */
			if (vp->val_len > sizeof(int32_t)) {
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmCongestionLevel: bad length\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			switch ((long) *vp->val.integer) {
			case MTPOMCONGESTIONLEVEL_NONE:
			case MTPOMCONGESTIONLEVEL_CONGESTIONLEVEL1:
			case MTPOMCONGESTIONLEVEL_CONGESTIONLEVEL2:
			case MTPOMCONGESTIONLEVEL_CONGESTIONLEVEL3:
				break;
			default:
				snmp_log(MY_FACILITY(LOG_NOTICE), "index mtpOmCongestionLevel: bad value\n");
				snmp_free_varbind(vars);
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vp->next_variable;
			if ((StorageNew = mtpOmSlCongestionTable_create()) == NULL) {
				snmp_free_varbind(vars);
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->mtpOmSlCongestionTable_rsvs = 1;
			vp = vars;
			StorageNew->mtpSlId = (ulong) *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->mtpOmCongestionLevel = (long) *vp->val.integer;
			vp = vp->next_variable;
			header_complex_add_data(&mtpOmSlCongestionTableStorage, vars, StorageNew);	/* frees vars */
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->mtpOmSlCongestionRowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->mtpOmSlCongestionTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* activate or deactivate */
			if (StorageTmp == NULL)
				return SNMP_ERR_NOSUCHNAME;
			/* one allocation for the whole row */
			if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) == NULL)
				if (StorageTmp->mtpOmSlCongestionTable_rsvs == 0)
					if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old = mtpOmSlCongestionTable_duplicate(StorageTmp)) == NULL)
						return SNMP_ERR_RESOURCEUNAVAILABLE;
			if (StorageOld != NULL)
				StorageTmp->mtpOmSlCongestionTable_rsvs++;
			break;
		case RS_DESTROY:
			if (StorageTmp == NULL)
				/* cannot destroy non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->mtpOmSlCongestionTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				mtpOmSlCongestionTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* check that activation is possible */
			if ((ret = can_act_mtpOmSlCongestionTable_row(StorageNew)) != SNMP_ERR_NOERROR)
				return (ret);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* check that activation is possible */
			if (StorageTmp->mtpOmSlCongestionRowStatus != RS_ACTIVE)
				if ((ret = can_act_mtpOmSlCongestionTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_NOTINSERVICE:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmSlCongestionRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmSlCongestionTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		case RS_DESTROY:
			/* check that deactivation is possible */
			if (StorageTmp->mtpOmSlCongestionRowStatus != RS_NOTINSERVICE)
				if ((ret = can_deact_mtpOmSlCongestionTable_row(StorageTmp)) != SNMP_ERR_NOERROR)
					return (ret);
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case ACTION:
		/* The variable has been stored in StorageTmp->mtpOmSlCongestionRowStatus for you to use, and you have just been asked to do something with it.  Note that anything done here must be
		   reversable in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* activate with underlying device */
			if (activate_mtpOmSlCongestionTable_row(StorageNew) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			/* state change already performed */
			if (StorageTmp->mtpOmSlCongestionRowStatus != RS_ACTIVE) {
				/* activate with underlying device */
				if (activate_mtpOmSlCongestionTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_NOTINSERVICE:
			/* state change already performed */
			if (StorageTmp->mtpOmSlCongestionRowStatus != RS_NOTINSERVICE) {
				/* deactivate with underlying device */
				if (deactivate_mtpOmSlCongestionTable_row(StorageTmp) != SNMP_ERR_NOERROR)
					return SNMP_ERR_COMMITFAILED;
			}
			break;
		case RS_DESTROY:
			/* commit destruction to underlying device */
			if (StorageDel == NULL)
				break;
			/* deactivate with underlying device */
			if (deactivate_mtpOmSlCongestionTable_row(StorageDel) != SNMP_ERR_NOERROR)
				return SNMP_ERR_COMMITFAILED;
			break;
		default:
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			StorageNew->mtpOmSlCongestionRowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			StorageNew->mtpOmSlCongestionRowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			StorageNew->mtpOmSlCongestionRowStatus = set_value;
			if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) != NULL) {
				mtpOmSlCongestionTable_destroy(&StorageTmp->mtpOmSlCongestionTable_old);
				StorageTmp->mtpOmSlCongestionTable_rsvs = 0;
				StorageTmp->mtpOmSlCongestionTable_tsts = 0;
				StorageTmp->mtpOmSlCongestionTable_sets = 0;
			}
			break;
		case RS_DESTROY:
			mtpOmSlCongestionTable_destroy(&StorageDel);
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* deactivate with underlying device */
			deactivate_mtpOmSlCongestionTable_row(StorageNew);
			break;
		case RS_CREATEANDWAIT:
			break;
		case RS_ACTIVE:
			if (StorageTmp->mtpOmSlCongestionRowStatus == RS_NOTINSERVICE)
				/* deactivate with underlying device */
				deactivate_mtpOmSlCongestionTable_row(StorageTmp);
			break;
		case RS_NOTINSERVICE:
			if (StorageTmp->mtpOmSlCongestionRowStatus == RS_ACTIVE)
				/* activate with underlying device */
				activate_mtpOmSlCongestionTable_row(StorageTmp);
			break;
		case RS_DESTROY:
			break;
		}
		/* fall through */
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			if (StorageNew) {
				mtpOmSlCongestionTable_del(StorageNew);
				mtpOmSlCongestionTable_destroy(&StorageNew);
			}
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if ((StorageOld = StorageTmp->mtpOmSlCongestionTable_old) == NULL)
				break;
			if (--StorageTmp->mtpOmSlCongestionTable_rsvs == 0)
				mtpOmSlCongestionTable_destroy(&StorageTmp->mtpOmSlCongestionTable_old);
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			if (StorageDel)
				mtpOmSlCongestionTable_add(StorageDel);
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn void mtpOmMIB_loop_handler(int dummy)
 * @param sig signal number
 * @brief handle event loop interation.
 *
 * This function is registered so that, when operating as a module, snmpd will call it one per event
 * loop interation.  This function is called before the next requst is processed and after the
 * previous request is processed.  Two things are done here:  1) The file descriptor that is used to
 * synchronize the agent with (pseudo-)device drivers is closed.  (Another approach, instead of
 * closing each time, would be to restart a timer each time that a request is made (loop is
 * performed) and if it expires, close the file descriptor).  2) The request number is incremented.
 * Although a request is not generated for each loop of the snmp event loop, it is true that a new
 * request cannot be generated without performing a loop.  Therefore, the sa_request is not the
 * request number but it is a temporally unique identifier for a request.
 */
void
mtpOmMIB_loop_handler(int sig)
{
	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_loop_handler: executing loop handler...  "));
	/* close files after each request */
	if (sa_fclose) {
		if (my_fd >= 0) {
			close(my_fd);
			my_fd = -1;
		}
	}
#if defined MASTER
	/* prepare for next request */
	sa_request++;
#endif				/* defined MASTER */
	if (external_signal_scheduled[sig] == 0)
		external_signal_scheduled[sig]--;
	if (mtpOmMIBold_signal_handler != NULL)
		(*mtpOmMIBold_signal_handler) (sig);
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
}

/**
 * @fn void mtpOmMIB_fd_handler(int fd, void *dummy)
 * @param fd file descriptor to read.
 * @param dummy client data passed to registration function (always NULL).
 * @brief handle read event on file descriptor.
 *
 * This read file descriptor handler is normally used for (pseudo-)device drivers that generate
 * statistical collection interval events, alarm events, or other operational measurement events, by
 * placing a message on the read queue of the "event handling" Stream.  Normally this routine
 * would adjust counts in some table or scalars, generate SNMP traps representing on-occurence
 * events, first and interval events, and alarm indications.
 */
void
mtpOmMIB_fd_handler(int fd, void *dummy)
{
	DEBUGMSGTL(("mtpOmMIB", "mtpOmMIB_fd_handler: executing fd handler...  "));
	/* XXX: place actions to handle my_fd here... */
	DEBUGMSGTL(("mtpOmMIB", "done.\n"));
	return;
}
