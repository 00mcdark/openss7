/*
 @(#) $RCSfile: ClientTransaction.java,v $ $Name:  $($Revision: 1.1.2.1 $) $Date: 2009-06-21 11:35:50 $ <p>
 
 Copyright &copy; 2008-2009  Monavacon Limited <a href="http://www.monavacon.com/">&lt;http://www.monavacon.com/&gt;</a>. <br>
 Copyright &copy; 2001-2008  OpenSS7 Corporation <a href="http://www.openss7.com/">&lt;http://www.openss7.com/&gt;</a>. <br>
 Copyright &copy; 1997-2001  Brian F. G. Bidulock <a href="mailto:bidulock@openss7.org">&lt;bidulock@openss7.org&gt;</a>. <p>
 
 All Rights Reserved. <p>
 
 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license. <p>
 
 This program is distributed in the hope that it will be useful, but <b>WITHOUT
 ANY WARRANTY</b>; without even the implied warranty of <b>MERCHANTABILITY</b>
 or <b>FITNESS FOR A PARTICULAR PURPOSE</b>.  See the GNU Affero General Public
 License for more details. <p>
 
 You should have received a copy of the GNU Affero General Public License along
 with this program.  If not, see
 <a href="http://www.gnu.org/licenses/">&lt;http://www.gnu.org/licenses/&gt</a>,
 or write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA. <p>
 
 <em>U.S. GOVERNMENT RESTRICTED RIGHTS</em>.  If you are licensing this
 Software on behalf of the U.S. Government ("Government"), the following
 provisions apply to you.  If the Software is supplied by the Department of
 Defense ("DoD"), it is classified as "Commercial Computer Software" under
 paragraph 252.227-7014 of the DoD Supplement to the Federal Acquisition
 Regulations ("DFARS") (or any successor regulations) and the Government is
 acquiring only the license rights granted herein (the license rights
 customarily provided to non-Government users).  If the Software is supplied to
 any unit or agency of the Government other than DoD, it is classified as
 "Restricted Computer Software" and the Government's rights in the Software are
 defined in paragraph 52.227-19 of the Federal Acquisition Regulations ("FAR")
 (or any successor regulations) or, in the cases of NASA, in paragraph
 18.52.227-86 of the NASA Supplement to the FAR (or any successor regulations). <p>
 
 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See
 <a href="http://www.openss7.com/">http://www.openss7.com/</a> <p>
 
 Last Modified $Date: 2009-06-21 11:35:50 $ by $Author: brian $
 */

package javax.sip;

import javax.sip.message.*;

/**
    A client transaction is used by a User Agent Client application to send Request messages to a
    User Agent Server application. The client transaction is also used to match Responses from the
    User Agent Server to fire Response events to the SipListener for a specific client transaction.
    This interfaces enables an application to send a Request's statefully. A new client transaction
    is generated by the application calling the SipProvider.getNewClientTransaction(Request) method.
    <p> A client transaction of the transaction layer is represented by a finite state machine that
    is constructed to process a particular request under the covers of a stateful SipProvider. The
    transaction layer handles application-layer retransmissions, matching of responses to requests,
    and application-layer timeouts. Any task that a User Agent Client accomplishes takes place using
    a series of transactions. <p> The client transaction must be unique within the underlying
    implementation. A common way to create this value is to compute a cryptographic hash of the To
    tag, From tag, Call-ID header field, the Request-URI of the request received (before
    translation), the topmost Via header, and the sequence number from the CSeq header field, in
    addition to any Proxy-Require and Proxy-Authorization header fields that may be present. The
    algorithm used to compute the hash is implementation-dependent. <p> For the detailed client
    transaction state machines refer to Chapter 17 of RFC 3261, the allowable transitions are
    summarized below: <dt>Invite Transaction: <br> <code>Calling --&gt; Proceeding --&gt; Completed
    --&gt; Terminated </code> <dt>Non-Invite Transaction: <br> <code>Trying --&gt; Proceeding --&gt;
    Completed --&gt; Terminated </code>
    @version 1.2.2
    @author Monavacon Limited
  */
public interface ClientTransaction extends Transaction {
    /**
        Sends the Request which created this ClientTransaction. When an application wishes to send a
        Request message, it creates a Request from the MessageFactory and then creates a new
        ClientTransaction from SipProvider.getNewClientTransaction(Request). Calling this method on
        the ClientTransaction sends the Request onto the network. The Request message gets sent via
        the ListeningPoint information of the SipProvider that is associated to this
        ClientTransaction. <p> This method assumes that the Request is sent out of Dialog. It uses
        the Router to determine the next hop. If the Router returns a empty iterator, and a Dialog
        is associated with the outgoing request of the Transaction then the Dialog route set is used
        to send the outgoing request. <p> This method implies that the application is functioning as
        either a UAC or a stateful proxy, hence the underlying implementation acts statefully.
        @exception SipException Thrown when the SipProvider cannot send the Request for any reason.
        @see Request
      */
    public void sendRequest() throws SipException;
    /**
        Creates a new Cancel message from the Request associated with this client transaction. The
        CANCEL request, is used to cancel the previous request sent by this client transaction.
        Specifically, it asks the UAS to cease processing the request and to generate an error
        response to that request. A CANCEL request constitutes its own transaction, but also
        references the transaction to be cancelled. CANCEL has no effect on a request to which a UAS
        has already given a final response. <p> Note that both the transaction corresponding to the
        original request and the CANCEL transaction will complete independently.  However, a UAC
        canceling a request cannot rely on receiving a 487 (Request Terminated) response for the
        original request, as an RFC 2543 compliant UAS will not generate such a response.  Therefore
        if there is no final response for the original request the application will receieve a
        TimeoutEvent with Timeout.TRANSACTION and the client should then consider the original
        transaction cancelled. <p> <li>UAC - A UAC should not send a CANCEL request to any request
        explicitly supported by this specification other than INVITE request. The reason being
        requests other than INVITE are responded to immediately and sending a CANCEL for a
        non-INVITE request would always create a race condition.  CANCELs are useful as a UAC can
        not send a BYE request on a dialog until receipt of 2xx final response to the INVITE
        request. The CANCEL attempts to force a non-2xx response to the INVITE, therefore if a UAC
        wishes to give up on its call attempt entirely it can send a CANCEL.  <li>Stateful proxies -
        A stateful proxy may generate CANCEL requests for: <ul> <li>INVITE Requests - A CANCEL can
        be sent on pending INVITE client transactions based on the period specified in the INVITE's
        Expires header field elapsing. However, this is generally unnecessary since the endpoints
        involved will take care of signaling the end of the transaction.  <li>Other Requests - An
        implementation of this specification does not need to support CANCELing non-INVITE
        transactions.  </ul>
        @return The new cancel Request specific to the Request of this client transaction.
        @exception SipException Thrown when this method is called to cancel a request that can't be
        cancelled i.e. ACK.
      */
    public Request createCancel() throws SipException;
    /**
        @deprecated Since v1.2. As a transaction that received a 2xx response terminates
        immediately, it cannot be used for creating the corresponding ACK. If this transaction
        created a dialog, the Dialog.createAck(long) method should be used.  Otherwise the stack
        will automatically create and send the ACK for non-2xx responses that need to be
        acknowledged. That is the application should never need to use this method. <p> Creates a
        new Ack message from the Request associated with this client transaction. This ACK can be
        used to acknowledge the 2xx response to the request sent by this transaction.
        @return The new ACK Request specific to the Request of this client transaction.
        @exception SipException Thrown when this method is called before a final response is
        received for the transaction.
      */
    public Request createAck() throws SipException;
}

// vim: sw=4 et tw=72 com=srO\:/**,mb\:*,ex\:*/,srO\:/*,mb\:*,ex\:*/,b\:TRANS,\://,b\:#,\:%,\:XCOMM,n\:>,fb\:-
