/*****************************************************************************

 @(#) $Id: ip_hooks.h.in,v 1.1.2.5 2011-03-26 04:28:46 brian Exp $

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2011  Monavacon Limited <http://www.monavacon.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation; version 3 of the License.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2011-03-26 04:28:46 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: ip_hooks.h.in,v $
 Revision 1.1.2.5  2011-03-26 04:28:46  brian
 - updates to build process

 Revision 1.1.2.4  2011-01-12 04:10:29  brian
 - code updates for 2.6.32 kernel and gcc 4.4

 Revision 1.1.2.3  2010-11-28 14:32:24  brian
 - updates to support debian squeeze 2.6.32 kernel

 Revision 1.1.2.2  2009-07-23 16:37:53  brian
 - updates for release

 Revision 1.1.2.1  2009-06-21 11:20:46  brian
 - added files to new distro

 Revision 0.9.2.7  2008-10-13 04:12:21  brian
 - handle exports rework strinet

 Revision 0.9.2.6  2008-09-10 03:50:07  brian
 - changes to accomodate FC9, SUSE 11.0 and Ubuntu 8.04

 Revision 0.9.2.5  2007/08/14 03:31:08  brian
 - GPLv3 header update

 Revision 0.9.2.4  2006/07/07 21:15:04  brian
 - correct compile back to RH 7.2

 Revision 0.9.2.3  2006/07/02 12:26:25  brian
 - make inet tests compatible

 Revision 0.9.2.2  2006/04/03 10:56:18  brian
 - xfrm_policy_delete now returns int instead of void

 Revision 0.9.2.1  2006/03/18 09:39:20  brian
 - added ip driver headers

 *****************************************************************************/

#ifndef __LOCAL_IP_HOOKS_H__
#define __LOCAL_IP_HOOKS_H__

/* This symbol should be defined by newer kernels, however, since the protocol
   value is always 132, we double check the definition for those kernels that
   haven't defined it yet.  */
#ifndef SOL_SCTP
#define SOL_SCTP 132
#endif

/* This symbol should be defined by newer kernels, however, since the protocol
   value is always 132, we double check the definition for those kernels that
   haven't defined it yet.  */
#ifndef IPPROTO_SCTP
#define IPPROTO_SCTP 132
#endif

#undef HAVE_KTYPE_STRUCT_SOCKADDR_STORAGE
#ifndef HAVE_KTYPE_STRUCT_SOCKADDR_STORAGE
#define _SS_MAXSIZE 128
#define _SS_ALIGNSIZE (__alignof__ (struct sockaddr *))
struct sockaddr_storage {
	sa_family_t ss_family;
	char __data[_SS_MAXSIZE - sizeof(sa_family_t)];
} __attribute__ ((aligned(_SS_ALIGNSIZE)));
#endif

extern struct icmp_err icmp_err_convert[];

extern struct icmp_mib icmp_statistic[];

#undef HAVE_IP_ROUTE_OUTPUT_FLOW_USABLE
#ifdef HAVE_IP_ROUTE_OUTPUT_FLOW_USABLE
#ifdef HAVE_IP_ROUTE_OUTPUT_FLOW_4_ARGS
extern int ip_route_output_flow(struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
#endif
#ifdef HAVE_IP_ROUTE_OUTPUT_FLOW_5_ARGS
extern int ip_route_output_flow(struct net *, struct rtable **rp, struct flowi *flp, struct sock *sk, int flags);
#endif
#endif

#undef HAVE_IP_RT_MIN_PMTU_USABLE
#ifdef HAVE_IP_RT_MIN_PMTU_USABLE
extern int ip_rt_min_pmtu;
#else
#define ip_rt_min_pmtu 552
#endif

#undef HAVE_IP_RT_MTU_EXPIRES_USABLE
#ifdef HAVE_IP_RT_MTU_EXPIRES_USABLE
extern int ip_rt_mtu_expires;
#endif

#undef HAVE_IP_RT_UPDATE_PMTU_USABLE
#ifdef HAVE_IP_RT_UPDATE_PMTU_USABLE
void ip_rt_update_pmtu(struct dst_entry *dst, unsigned mtu);
#endif

#undef HAVE_SYSCTL_IP_DYNADDR_USABLE
#ifndef sysctl_ip_dynaddr
#ifdef HAVE_SYSCTL_IP_DYNADDR_USABLE
extern int sysctl_ip_dynaddr;
#else
#define sysctl_ip_dynaddr 0
#endif
#endif

#undef HAVE_SYSCTL_IP_NONLOCAL_BIND_USABLE
#ifndef sysctl_ip_nonlocal_bind
#ifdef HAVE_SYSCTL_IP_NONLOCAL_BIND_USABLE
extern int sysctl_ip_nonlocal_bind;
#else
#define sysctl_ip_nonlocal_bind 0
#endif
#endif

#ifndef IPDEFTTL
#define IPDEFTTL 64
#endif

#undef HAVE_SYSCTL_IP_DEFAULT_TTL_USABLE
#ifndef sysctl_ip_default_ttl
#ifdef HAVE_SYSCTL_IP_DEFAULT_TTL_USABLE
extern int sysctl_ip_default_ttl;
#else
#define sysctl_ip_default_ttl IPDEFTTL
#endif
#endif

#ifdef HAVE_SYSCTL_LOCAL_PORT_RANGE_SYMBOL
extern int sysctl_local_port_range[2];
#endif				/* HAVE_SYSCTL_LOCAL_PORT_RANGE_SYMBOL */

#undef HAVE___IP_ROUTE_OUTPUT_KEY_USABLE
#ifdef HAVE___IP_ROUTE_OUTPUT_KEY_USABLE
#ifdef HAVE___IP_ROUTE_OUTPUT_KEY_2_ARGS
extern int __ip_route_output_key(struct rtable **rp, const struct flowi *flp);
#endif
#ifdef HAVE___IP_ROUTE_OUTPUT_KEY_3_ARGS
extern int __ip_route_output_key(struct net *, struct rtable **, const struct flowi *flp);
#endif
#endif

#undef HAVE_KMEMB_STRUCT_DST_ENTRY_PATH
#ifdef HAVE_KMEMB_STRUCT_DST_ENTRY_PATH
/* dst_pmtu should be already defined */
static __inline__ void
dst_update_pmtu(struct dst_entry *dst, uint32_t mtu)
{
	if (dst->ops->update_pmtu)
		dst->ops->update_pmtu(dst, mtu);
}
#elif !defined dst_pmtu
static __inline__ u32
dst_pmtu(struct dst_entry *dst)
{
	return (dst->pmtu);
}
#else
static __inline__ void
dst_update_pmtu(struct dst_entry *dst, uint32_t mtu)
{
	dst->pmtu = mtu;
}
#endif

#undef HAVE_KFUNC_DST_MTU
#ifdef HAVE_KFUNC_DST_MTU
/* Why do stupid people rename things like this? */
#	undef dst_pmtu
#	define dst_pmtu dst_mtu
#endif

#undef HAVE_KMEMB_STRUCT_NET_DEV_BASE_HEAD

#undef HAVE_IP_ROUTE_OUTPUT_EXPLICIT
#ifndef HAVE_IP_ROUTE_OUTPUT_EXPLICIT
static __inline__ int
ip_route_output(struct rtable **rp, u32 daddr, u32 saddr, u32 tos, int oif)
{
	struct flowi fl = {.oif = oif,
		.nl_u = {.ip4_u = {.daddr = daddr,
				   .saddr = saddr,
				   .tos = tos}},
		.proto = IPPROTO_SCTP,
		.uli_u = {.ports = {.sport = 0,.dport = 0}}
	};

#undef HAVE_KFUNC_IP_ROUTE_OUTPUT_KEY_3_ARGS
#ifdef HAVE_KFUNC_IP_ROUTE_OUTPUT_KEY_3_ARGS
	return ip_route_output_key(&init_net, rp, &fl);
#else
	return ip_route_output_key(rp, &fl);
#endif
}
#endif

#undef HAVE___XFRM_POLICY_CHECK_USABLE
#ifdef HAVE___XFRM_POLICY_CHECK_USABLE
int __xfrm_policy_check(struct sock *sk, int dir, struct sk_buff *skb, unsigned short family);
#endif

#undef HAVE_XFRM_POLICY_DELETE_USABLE
#ifdef HAVE_XFRM_POLICY_DELETE_USABLE
#ifdef HAVE_XFRM_POLICY_DELETE_RETURNS_INT
int xfrm_policy_delete(struct xfrm_policy *pol, int dir);
#else
void xfrm_policy_delete(struct xfrm_policy *pol, int dir);
#endif
#endif

#undef HAVE_SNMP_GET_INFO_USABLE
#ifdef HAVE_SNMP_GET_INFO_USABLE
int snmp_get_info(char *buffer, char **start, off_t offset, int length);
#endif

#undef HAVE_KFUNC_IP_FRAG_NQUEUES_1_ARG
#ifdef HAVE_KFUNC_IP_FRAG_NQUEUES_1_ARG
int ip_frag_nqueues(struct net *net);
#else
#undef HAVE_KFUNC_IP_FRAG_NQUEUES_0_ARGS
#ifdef HAVE_KFUNC_IP_FRAG_NQUEUES_0_ARGS
int ip_frag_nqueues(void);
#else
extern int ip_frag_nqueues;
#endif
#endif

#undef HAVE_KFUNC_IP_FRAG_MEM_1_ARG
#ifdef HAVE_KFUNC_IP_FRAG_MEM_1_ARG
int ip_frag_mem(struct net *net);
#else
#undef HAVE_KFUNC_IP_FRAG_MEM_0_ARGS
#ifdef HAVE_KFUNC_IP_FRAG_MEM_0_ARGS
int ip_frag_mem(void);
#else
extern atomic_t ip_frag_mem;
#endif
#endif

#ifndef SK_WMEM_MAX
#define SK_WMEM_MAX 65535
#endif
#ifndef SK_RMEM_MAX
#define SK_RMEM_MAX 65535
#endif

#undef HAVE_SYSCTL_RMEM_DEFAULT_SUPPORT
#ifndef sysctl_rmem_default
#ifdef HAVE_SYSCTL_RMEM_DEFAULT_SUPPORT
extern __u32 sysctl_rmem_default;
#elif defined HAVE_SYSCTL_RMEM_DEFAULT_USABLE && defined CONFIG_KERNEL_WEAK_SYMBOLS
extern __u32 sysctl_rmem_default __attribute__((weak));
__u32
sysctl_rmem_default_(void) {
	if (&sysctl_rmem_default != 0)
		return sysctl_rmem_default;
	return SK_RMEM_MAX;
}
#define sysctl_rmem_default sysctl_rmem_default_()
#else
#define sysctl_rmem_default SK_RMEM_MAX
#endif
#endif

#undef HAVE_SYSCTL_WMEM_DEFAULT_SUPPORT
#ifndef sysctl_wmem_default
#ifdef HAVE_SYSCTL_WMEM_DEFAULT_SUPPORT
extern __u32 sysctl_wmem_default;
#elif defined HAVE_SYSCTL_WMEM_DEFAULT_USABLE && defined CONFIG_KERNEL_WEAK_SYMBOLS
extern __u32 sysctl_wmem_default __attribute__((weak));
__u32
sysctl_wmem_default_(void) {
	if (&sysctl_wmem_default != 0)
		return sysctl_wmem_default;
	return SK_WMEM_MAX;
}
#define sysctl_wmem_default sysctl_wmem_default_()
#else
#define sysctl_wmem_default SK_WMEM_MAX
#endif
#endif

#undef HAVE_SYSCTL_RMEM_MAX_SUPPORT
#ifndef sysctl_rmem_max
#ifdef HAVE_SYSCTL_RMEM_MAX_SUPPORT
extern __u32 sysctl_rmem_max;
#elif defined HAVE_SYSCTL_RMEM_MAX_USABLE && defined CONFIG_KERNEL_WEAK_SYMBOLS
extern __u32 sysctl_rmem_max __attribute__((weak));
__u32
sysctl_rmem_max_(void) {
	if (&sysctl_rmem_max != 0)
		return sysctl_rmem_max;
	return SK_RMEM_MAX;
}
#define sysctl_rmem_max sysctl_rmem_max_()
#else
#define sysctl_rmem_max SK_RMEM_MAX
#endif
#endif

#undef HAVE_SYSCTL_WMEM_MAX_SUPPORT
#ifndef sysctl_wmem_max
#ifdef HAVE_SYSCTL_WMEM_MAX_SUPPORT
extern __u32 sysctl_wmem_max;
#elif defined HAVE_SYSCTL_WMEM_MAX_USABLE && defined CONFIG_KERNEL_WEAK_SYMBOLS
extern __u32 sysctl_wmem_max __attribute__((weak));
__u32
sysctl_wmem_max_(void) {
	if (&sysctl_wmem_max != 0)
		return sysctl_wmem_max;
	return SK_WMEM_MAX;
}
#define sysctl_wmem_max sysctl_wmem_max_()
#else
#define sysctl_wmem_max SK_WMEM_MAX
#endif
#endif

#ifndef socklen_t
typedef int socklen_t;

#define socklen_t socklen_t
#endif

#undef HAVE_KFUNC_SKB_DST
#ifndef HAVE_KFUNC_SKB_DST
static __inline__ struct dst_entry*
skb_dst(struct sk_buff *skb)
{
    return skb->dst;
}
#endif

#undef HAVE_KFUNC_SKB_DST_SET
#ifndef HAVE_KFUNC_SKB_DST_SET
static __inline__ void
skb_dst_set(struct sk_buff *skb, struct dst_entry *dst)
{
    skb->dst = dst;
}
#endif

#undef HAVE_KFUNC_SKB_RTABLE
#ifndef HAVE_KFUNC_SKB_RTABLE
static __inline__ struct rtable*
skb_rtable(struct sk_buff *skb)
{
    return (struct rtable *)skb->dst;
}
#endif

#undef HAVE___IP_SELECT_IDENT_SYMBOL
#undef HAVE_KFUNC___IP_SELECT_IDENT_2_ARGS
#undef HAVE_KFUNC___IP_SELECT_IDENT_3_ARGS
#undef HAVE___IP_SELECT_IDENT_SUPPORT
#undef HAVE___IP_SELECT_IDENT_USABLE

#if   defined HAVE___IP_SELECT_IDENT_SYMBOL
#   if !defined HAVE_KFUNC___IP_SELECT_IDENT_2_ARGS && !defined HAVE_KFUNC___IP_SELECT_IDENT_3_ARGS
#       error Need a way of selecting an ID for an IP packet.
#   endif
#   if   defined HAVE___IP_SELECT_IDENT_SUPPORT
#       if   defined HAVE_KFUNC___IP_SELECT_IDENT_2_ARGS
extern void __ip_select_ident(struct iphdr *iph, struct dst_entry *dst);	/* 2.4 */

#		define __ip_select_ident(a,b,c) __ip_select_ident(a,b)
#       elif defined HAVE_KFUNC___IP_SELECT_IDENT_3_ARGS
extern void __ip_select_ident(struct iphdr *iph, struct dst_entry *dst, int more);	/* 2.6 */

#		define __ip_select_ident(a,b,c) __ip_select_ident(a,b,c)
#       endif
#   elif defined HAVE___IP_SELECT_IDENT_USABLE && defined CONFIG_KERNEL_WEAK_SYMBOLS
/* This code is identical from 2.4.33 to 2.6.32, yet for some reason it is not
 * worth supporting in RedHat's kABI? */
#       if   defined HAVE_KFUNC___IP_SELECT_IDENT_2_ARGS
extern void __ip_select_ident(struct iphdr *iph, struct dst_entry *dst)
    __attribute__ ((weak));
#       elif defined HAVE_KFUNC___IP_SELECT_IDENT_3_ARGS
extern void __ip_select_ident(struct iphdr *iph, struct dst_entry *dst, int more)
    __attribute__ ((weak));
#	endif
STATIC streams_fastcall streams_inline void
__ip_select_ident_(struct iphdr *iph, struct dst_entry *dst, int more)
{
	struct rtable *rt;

	if (__ip_select_ident != 0)
#if   defined HAVE_KFUNC___IP_SELECT_IDENT_2_ARGS
		return __ip_select_ident(iph, dst);
#elif defined HAVE_KFUNC___IP_SELECT_IDENT_3_ARGS
		return __ip_select_ident(iph, dst, more);
#endif
	rt = (struct rtable *) dst;
	if (rt->peer) {
		iph->id = htons(inet_getid(rt->peer, more));	/* inline */
		return;
	}
	iph->id = (iph->daddr ^ jiffies);
	return;
}
#define __ip_select_ident(a,b,c) __ip_select_ident_(a,b,c)
#   else
#       error Need a way of selecting an ID for an IP packet.
#   endif
#endif

#endif				/* __LOCAL_IP_HOOKS_H__ */
