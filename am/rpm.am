## vim: ft=automake comments=b\:#,b\:##,b\:#\! formatoptions+=tcqlor
## =============================================================================
## 
# @(#) $RCSfile: rpm.am,v $ $Name:  $($Revision: 1.1.2.6 $) $Date: 2011-02-07 04:48:31 $
##
## -----------------------------------------------------------------------------
##
## Copyright (c) 2008-2009  Monavacon Limited <http://www.monavacon.com/>
## Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
## Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>
##
## All Rights Reserved.
##
## This program is free software; you can redistribute it and/or modify it under
## the terms of the GNU Affero General Public License as published by the Free
## Software Foundation; version 3 of the License.
##
## This program is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
## details.
##
## You should have received a copy of the GNU Affero General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>, or
## write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
## 02139, USA.
##
## -----------------------------------------------------------------------------
##
## U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
## behalf of the U.S. Government ("Government"), the following provisions apply
## to you.  If the Software is supplied by the Department of Defense ("DoD"), it
## is classified as "Commercial Computer Software" under paragraph 252.227-7014
## of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
## successor regulations) and the Government is acquiring only the license rights
## granted herein (the license rights customarily provided to non-Government
## users).  If the Software is supplied to any unit or agency of the Government
## other than DoD, it is classified as "Restricted Computer Software" and the
## Government's rights in the Software are defined in paragraph 52.227-19 of the
## Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
## the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
## (or any successor regulations).
##
## -----------------------------------------------------------------------------
##
## Commercial licensing and support of this software is available from OpenSS7
## Corporation at a fee.  See http://www.openss7.com/
##
## -----------------------------------------------------------------------------
##
## Last Modified $Date: 2011-02-07 04:48:31 $ by $Author: brian $
##
## =============================================================================

##
## These are some rules that I use for generating source and binary RPMs using automake.  I need to
## package releases using RPM.  The following rules accomplish that for most packages.
##

if MAINTAINER_MODE

##
## For better speed when building package binaries, we skip these rules to invoke package building.
## There is not (yet) a need to build packages when building packages...  We use maintainer mode to
## distinguish whether these rules are necessary or not.
##

##
# In the automake tradition, we print gobs of information.
##
RPMFLAGS		= -vv
SRPMFLAGS		= $(RPMFLAGS) --nodeps

##
# These are general rpm options that we always include in all rpm commands.  The top directory and
# subdirectories is applicable to all commands.
##
## NOTE: These options override anything in the ~/.rpmmacros file.  See notes in m4/rpm.m4.  We used
## to have source and binary payload defines in here before, but, now you can select your favorite
## (or use the site default) from the /usr/lib/rpm/macros or ~/.rpmmacros file.  We bzip source and
## payload to try to crunch 'em down more.
##
RPMOPTS			= $(PACKAGE_RPMOPTIONS) \
			  --define "_topdir $(topdir)" \
			  --define "_sourcedir $(sourcedir)" \
			  --define "_builddir $(rpmbuilddir)" \
			  --define "_rpmdir $(rpmdir)" \
			  --define "_srcrpmdir $(srcrpmdir)" \
			  --define "_specdir $(specdir)"

##
# Note that we created the usual rpm directories as well.  This is because rpm sometimes complains
# if directories do not exist directly under topdir.
##
rpm_directories		= $(topdir)/SOURCES $(sourcedir) \
			  $(topdir)/BUILD   $(rpmbuilddir) \
			  $(topdir)/RPMS    $(rpmdir) \
			  $(topdir)/SRPMS   $(srcrpmdir) \
			  $(topdir)/SPECS   $(specdir)

##
# Options for building source rpms.  We have separate fig and xpm macros from the binary rpms to
# avoid warnings about the files being multiply included.  Another approach would be to name the
# icons according to the individual package names and avoid specific macros for them.  We used to
# build one source rpm for all distros, but this is becoming unworkable.  Now each source rpm is
# distro specific.
##
RPMSOPTS		= $(RPMOPTS) \
			  --define "_gif_icon $(PACKAGE)-$(VERSION).gif" \
			  --define "_xpm_icon $(PACKAGE)-$(VERSION).xpm"

##
# Options for building binary rpms.  We have separate fig an xpm macros from the source rpms to
# avoid warnings about the fiest being multiply included.  Another approach would be to name the
# icons according to the individual package neames and avoid specific macros for them.
##
# For binary packages we define the extrarelease suffix on the rpm version and distribution name so
# that a distribution specific binary rpm is generated.  The distribution suffix and name are not
# included for the source rpm because the source rpm is applicable to all binary packages and
# distributions. (Wow! -- that took some effort!)
##
# _configdir must be overridden from /etc/sysconfig to /etc/default when building rpms on Debian
# (yes, I know: what's the point?).
##
RPMBOPTS		= $(RPMOPTS) \
			  --define "extrarelease $(PACKAGE_RPMEXTRA)" \
			  --define "extrarelease2 $(PACKAGE_RPMEXTRA2)" \
			  --define "distribution $(PACKAGE_RPMDIST) (contrib)" \
			  --define "_gif $(PACKAGE)-$(VERSION).gif" \
			  --define "_xpm $(PACKAGE)-$(VERSION).xpm" \
			  --define "_configdir $(configdir)"

##
# Options for signing packages.  These can be combined with the source or binary options above.
##
## We used to uses the autoconf variables to set the signature specific macros for rpm, but that
## turned out to be a bad idea.  What we used to do was as follows:
##
##RPMKOPTS		= $(RPMOPTS) \
##			--define "_signature gpg" \
##			--define "_gpg_path $(GNUPGHOME)" \
##			--define "_gpg_name $(GNUPGUSER)" \
##			--define "_gpgbin $(GPG)" \
##			--define "__gpg $(GPG)"
##
## As it turns out, it is a better idea not to manipulate these here at all, because they override
## more sane settings in /usr/lib/rpm/macros and ~/.rpmmacros.  Define the appropriate macros in your
## /usr/lib/rpm/macros file or ~/.rpmmacros instead.  Examples of my ~/.rpmmacros file are included
## in the documentation.
##
RPMKOPTS		= $(RPMOPTS)

rpmpkg			= $(PACKAGE)-$(VERSION)-$(PACKAGE_RPMRELEASE)
rpm_dir			= $(rpmbuilddir)/$(PACKAGE)-$(VERSION)
rpm_dir_stamp		= $(rpmbuilddir)/stamp-$(PACKAGE)-$(VERSION)
rpm_src_file		= $(srcrpmdir)/$(rpmpkg).src.rpm
rpm_sig_file		= $(srcrpmdir)/$(rpmpkg).src.rpm
rpm_tar_file		= $(sourcedir)/$(PACKAGE)-$(VERSION).tar.bz2
rpm_spec_file		= $(specdir)/$(PACKAGE)-$(VERSION).spec
rpm_img_files		= $(sourcedir)/$(PACKAGE)-$(VERSION).gif $(sourcedir)/$(PACKAGE)-$(VERSION).xpm
rpm_source_files	= $(rpm_spec_file) $(rpm_img_files) $(rpm_tar_file)
rpm_base_file		= $(PACKAGE)-$(VERSION)-$(PACKAGE_RPMRELEASE).*.rpm
rpm_binary_file		= $(PACKAGE)-*$(VERSION)-$(PACKAGE_RPMRELEASE)$(PACKAGE_RPMEXTRA).*.rpm
rpm_link_file		= $(topdir)/SRPMS/$(rpmpkg).src.rpm
##
# There are several forms (currently) for automatic loadable module files:
#
#  kernel-module-$$(foo)[-$$(flavor)]
#  kmod-$$(foo)[-$$(flavor)]
#  $$(foo)-kmod[-$$(flavor)]
#  $$(vendor)-$$(driver)-kmp[-$$(flavor)]
##
rpm_module0_file	= $(PACKAGE)-*-$(VERSION)-$(PACKAGE_RPMRELEASE)$(PACKAGE_RPMEXTRA).*.rpm
rpm_module1_file	= kernel-module-$(PACKAGE)-*$(VERSION)*$(PACKAGE_RPMRELEASE)$(PACKAGE_RPMEXTRA).*.rpm
rpm_module2_file	= kmod-$(PACKAGE)-*$(VERSION)*$(PACKAGE_RPMRELEASE)$(PACKAGE_RPMEXTRA).*.rpm
rpm_module3_file	= openss7-$(PACKAGE)*-kmp-*$(VERSION)*$(PACKAGE_RPMRELEASE)$(PACKAGE_RPMEXTRA).*.rpm
rpm_binary_files	= $(rpmdir)/*/$(rpm_base_file) \
			  $(rpmdir)/*/$(rpm_binary_file) \
			  $(rpmdir)/*/$(rpm_module0_file) \
			  $(rpmdir)/*/$(rpm_module1_file) \
			  $(rpmdir)/*/$(rpm_module2_file) \
			  $(rpmdir)/*/$(rpm_module3_file)
rpm_cache_files		= $(rpmbuilddir)/*config.cache \
			  $(rpmbuilddir)/*config.site \
			  $(rpmbuilddir)/*modpost.cache

RELEASE_DIRECTORIES	+= $(topdir)

##
# For the master build package it is sometime necessary to pass extra options down to configured
# subdirectories for a master build.  These options will contain the passed down options from the
# environment in that case.  See the recursive build targets below.
##
RPMXOPTS		=

RPMTARGET		= $(target)

#!
#! RPM Build Targets:
#! ------------------
#!
#! On rpm systems, or systems sporting rpm packaging tools, the following
#! targets are used to generate rpm release packages.  The epoch and release
#! number can be controlled by the contents of the .rpmepoch and .rpmrelease
#! files, or with the --with-rpm-epoch=EPOCH and --with-rpm-release=RELEASE
#! options to 'configure'.  See 'configure --help' for more information on
#! options.  We always use release number 1.  You can use release numbers
#! above 1.
#!
$(rpm_tar_file)::
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@f=`$(ECHO) "$@" | sed 's|^.*/||'`; \
	test ":$(FORCE)" != :force -a \( -f "$@" -o -f "$$f" \) || { \
		$(ECHO) "$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' -- $$f"; \
		$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' -- $$f; };  \
	d=; test -f $$f || d='$(srcdir)/'; \
	test ! \( "$@" -ef "$$d$$f" \) || exit 0; \
	test ":$(FORCE)" != :force -a -f "$@" || { \
		$(ECHO) "cp -f -- $$d$$f $@"; \
		cp -f -- $$d$$f $@; }

$(rpm_spec_file) $(rpm_img_files)::
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@f=`$(ECHO) "$@" | sed 's|^.*/||;s|$(PACKAGE)-$(VERSION)|$(PACKAGE_TARNAME)|'`; \
	test ":$(FORCE)" != :force -a \( -f "$@" -o -f "$$f" \) || { \
		$(ECHO) "$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' -- $$f"; \
		$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' -- $$f; };  \
	d=; test -f $$f || d='$(srcdir)/'; \
	test ! \( "$@" -ef "$$d$$f" \) || exit 0; \
	test ":$(FORCE)" != :force -a -f "$@" || { \
		$(ECHO) "cp -f -- $$d$$f $@"; \
		cp -f -- $$d$$f $@; }

##
# This builds an SRPM for the current target.
##
# Note: the icons need to be in the sourcedir, but the spec file needs to be in the current
# directory or the specdir or anywhere that we can find it.
##
# We use the -bs flag to rpmbuild instead of the -ts flag because our tarball could contain multiple
# spec files and rpmbuild otherwise uses the first one in the tar listing.  We should probably make
# sure that the tar has the required spec file listed first because then one can use the -ts command
# on the resulting spec file.  -bs also leaves the sources in place, which is what we want for
# distribution.
##

$(rpm_src_file):: $(rpm_source_files)
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@$(ECHO) "$(MAKE) $(AM_MAKEFLAGS) -- $(rpm_directories)" ; \
	$(MAKE) $(AM_MAKEFLAGS) -- $(rpm_directories) ; \
	test ":$(FORCE)" != :force -a -f "$@" || { \
		$(ECHO) "$(RPMBUILD) -bs $(SRPMFLAGS) $(RPMSOPTS) --target $(target) -- $<" ; \
		$(RPMBUILD) -bs $(SRPMFLAGS) $(RPMSOPTS) --target $(target) -- $< ; }

##
## This rule must come after the one above.
##
$(rpm_link_file)::
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@f=$(srcrpmdir)/`$(ECHO) "$@" | sed 's|^.*/||'`; \
	test ":$(FORCE)" != :force -a \( -f "$@" -o -f "$$f" \) || { \
		$(ECHO) "$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' -- $$f"; \
		$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' -- $$f; }; \
	test ! \( "$@" -ef "$$f" \) || exit 0; \
	d=; test -f $$f || d='$(srcdir)/'; \
	test ":$(FORCE)" != :force -a -f "$@" || { \
		$(ECHO) "cp -f --link -- $$d$$f $@"; \
		cp -f --link -- $$d$$f $@; }

#! srpm:
#!     This target generates the source rpm for the package (without signing the
#!     source rpm).  The source rpm will be named: @PACKAGE@-@VERSION@-@PACKAGE_RPMRELEASE@.srpm
#!
srpm: $(rpm_src_file) $(rpm_link_file)

##
# This is the type of thing that needs to be included in the master makefile to build rpms for the
# current target, we also build any defined AM_RPMTARGETS
##
each-rpm: $(rpm_spec_file) $(rpm_source_files)
	$(MAKE) $(AM_MAKEFLAGS) -- $(rpm_directories)
	$(RPMBUILD) -bb $(RPMFLAGS) $(RPMBOPTS) $(RPMXOPTS) $(AM_RPMXOPTS) $(AM_RPMBOPTS) $(AM_RPMFLAGS) --target $(RPMTARGET) -- $< || :

noa-rpm: AM_RPMBOPTS = --define "_without_arch --without-arch"
noa-rpm: RPMTARGET = "noarch"
noa-rpm: each-rpm

one-rpm: AM_RPMBOPTS = --define "_without_indep --without-indep"
one-rpm: each-rpm

one-t-rpm: AM_RPMXOPTS = --define "_without_modules --without-modules"
one-t-rpm: one-rpm

one-k-rpm: AM_RPMXOPTS = --define "_without_tools --without-tools"
one-k-rpm: one-rpm

#! rpms:
#!     This target is responsible for generating all of the package binary rpms
#!     for the architecture.  The binary rpms will be named:
#!
#!         @PACKAGE@-*@VERSION@-@PACKAGE_RPMRELEASE@.*.rpm
#!
#!     where the stars indicate the subpackage and the architecture.  Both the
#!     architecture specific subpackages (binary objects) and the architecture
#!     independent (.noarch) subpackages will be built unless the the former was
#!     disabled with the option `--disable-arch', or the later with the option
#!     `--disable-indep', passed to `configure'.
#!
rpms:
	@$(ECHO) "D: $@: rebuild noarch"; \
	$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' kversion='$(kversion)' RPMTARGET="noarch" noa-rpm || :
	@$(ECHO) "D: $@: rebuild $(kversion)"; \
	$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' kversion='$(kversion)' RPMTARGET='$(RPMTARGET)' one-k-rpm || :
	@$(ECHO) "D: $@: rebuild $(RPMTARGET)"; \
	$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' kversion='$(kversion)' RPMTARGET='$(RPMTARGET)' one-t-rpm || :

# Another sneaky trick
all-one-k-rpm: ALL_EXPORT_OPTS = RPMXOPTS='$(RPMXOPTS)'
all-one-t-rpm: ALL_EXPORT_OPTS = RPMXOPTS='$(RPMXOPTS)'
all-one-rpm:   ALL_EXPORT_OPTS = RPMXOPTS='$(RPMXOPTS)'
all-noa-rpm:   ALL_EXPORT_OPTS = RPMXOPTS='$(RPMXOPTS)'
all-rpms:      ALL_EXPORT_OPTS = RPMXOPTS='$(RPMXOPTS)'

#! sign srpm-sign:
#!     These two targets are the same.  When invoked, they will add a signature
#!     to the source rpm file, provided that the file does not already have a
#!     signature.  You will be prompted for a password if a signature is
#!     required.  Automated or unattended builds can be acheived by using
#!     the `emake' expect script, included in `@abs_srcdir@/scripts/emake'.
#!
sign srpm-sign: $(rpm_src_file) $(rpm_link_file)
	@if ! $(RPM) -K -- $< 2>&1 | grep -q ' gpg OK' >/dev/null 2>&1; then \
		user="$(GNUPGUSER)"; user="$${user:+ --define \"_gpg_name $$user\"}"; \
		home="$(GNUPGHOME)"; home="$${home:+ --define \"_gpg_path $$home\"}"; \
		pass="$(GNUPGPASS)"; pass="$${pass:+$(ECHO) \"$$pass\" |}"; \
		$(ECHO) "$(RPM) --addsign $(RPMFLAGS) `echo '$(RPMKOPTS)'` $$user$$home -- $<"; \
		eval "$$pass $(RPM) --addsign $(RPMFLAGS) `echo '$(RPMKOPTS)'` $$user$$home -- $<" || :; \
	fi

##
#   Note that older rpms (particularly those used by SuSE) are too stupid to handle the --with and
#   --without popt syntax, so we have to expand them to --defines.
##

#! rebuild:
#!     This target searches out a list of kernel names from the
#!     @DESTDIR@/lib/modules directory and builds rpms for those kernels and for
#!     each of a set of architectures given in the AM_RPMTARGETS variable to
#!     make.  This is a convenience target for building a group of rpms on a
#!     given build machine.  This target will only rebuild packages for
#!     architetures and kernels that do not already exist in the package
#!     distribution directory.
#!
rebuild: ALL_EXPORT_OPTS = RPMXOPTS='$(RPMXOPTS)'
rebuild:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@rpms=`find $(rpmdir)/noarch -name '$(rpm_base_file)' -o -name '$(rpm_binary_file)' 2>/dev/null`; \
	if test -z "$$rpms" -o -n '$(FORCE)'; then \
		$(ECHO) "D: $@: rebuild noarch"; \
		$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' RPMTARGET="noarch" noa-rpm || :; \
	else \
		$(ECHO) "D: $@: skipped noarch"; \
	fi; \
	targets="$(RPMTARGET) $(AM_RPMTARGETS)"; \
	for t in $$targets; do \
		a=`$(ECHO) "$$t" | sed 's,-.*$$,,'`; \
		test \( "$$a" != 'noarch' -a "$$a" != 'all' \) || continue; \
		kernels="`( find $(DESTDIR)$(rootdir)/lib/modules -type d -name '2\.[46]\.*' | sort -r ) 2>/dev/null`"; \
		for k in $$kernels; do \
			k=`basename $$k`; \
			test -e $(DESTDIR)$(rootdir)/lib/modules/$$k/build || continue; \
			if test -z '$(DESTDIR)'; then \
				if ! $(RPM) -q --whatprovides /lib/modules/$$k/build >/dev/null 2>&1; then \
					continue; \
				fi; \
			fi; \
			ks=`echo $$k | sed 's,-,.,g;s,_,.,g'`; \
			rpms="`find $(rpmdir)/$$a -name '*$(PACKAGE)-*$(VERSION)_'$$ks'-$(PACKAGE_RPMRELEASE)$(PACKAGE_RPMEXTRA).'$$a'.rpm' 2>/dev/null`"; \
			if test -z "$$rpms" -o -n '$(FORCE)'; then \
				$(ECHO) "D: $@: rebuild $$k"; \
				$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' kversion="$$k" RPMTARGET="$$t" one-k-rpm || :; \
			else \
				$(ECHO) "D: $@: skipped $$k"; \
			fi; \
		done; \
		rpms=`find $(rpmdir)/$$a -name '$(rpm_base_file)' -o -name '$(rpm_binary_file)' 2>/dev/null`; \
		if test -z "$$rpms" -o -n '$(FORCE)'; then \
			$(ECHO) "D: $@: rebuild $$a"; \
			$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' RPMTARGET="$$t" one-t-rpm || :; \
		else \
			$(ECHO) "D: $@: skipped $$a"; \
		fi; \
	done

#! resign:
#!     This target will search out and sign, with a GPG signature, the source
#!     rpm, and all of the binary rpms for this package that can be found in the
#!     package distribution directory.  This target will prompt for a GPG
#!     password.  Automated or unattended builds can be acheived with the
#!     `emake' expect script located here: `@abs_srcdir@/scripts/emake'.
#!
resign: ALL_EXPORT_OPTS = RPMXOPTS='$(RPMXOPTS)'
resign: sign
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@rpms=`find $(rpmdir) -name '$(rpm_base_file)' -o -name '$(rpm_binary_file)' -o -name '$(rpm_module0_file)' -o -name '$(rpm_module1_file)' -o -name '$(rpm_module2_file)' -o -name '$(rpm_module3_file)' 2>/dev/null`; \
	if test -z "$$rpms"; then \
		$(ECHO) "D: $@: rebuild rebuild"; \
		$(ECHO) "$(MAKE) $(AM_MAKEFLAGS) $(ALL_EXPORT_OPTS) rebuild"; \
		$(MAKE) $(AM_MAKEFLAGS) $(ALL_EXPORT_OPTS) rebuild; \
		rpms=`find $(rpmdir) -name '$(rpm_base_file)' -o -name '$(rpm_binary_file)' -o -name '$(rpm_module0_file)' -o -name '$(rpm_module1_file)' -o -name '$(rpm_module2_file)' -o -name '$(rpm_module3_file)' 2>/dev/null`; \
		if test -z "$$rpms"; then exit 1; fi; \
	fi; \
	rpms_to_sign=; \
	for f in $$rpms; do \
		if $(RPM) -K -- $$f 2>&1 | grep -q ' gpg OK' >/dev/null 2>&1; then \
			$(ECHO) "D: $@: sign ok $$f"; \
		else \
			$(ECHO) "D: $@: signing $$f"; \
			rpms_to_sign="$$rpms_to_sign $$f"; \
			rpms_to_sign="$${rpms_to_sign:+$$rpms_to_sign }$$f"; \
		fi; \
	done; \
	if test -n "$$rpms_to_sign"; then \
		$(ECHO) "D: $@: signing $$rpms_to_sign"; \
		user="$(GNUPGUSER)"; user="$${user:+ --define \"_gpg_name $$user\"}"; \
		home="$(GNUPGHOME)"; home="$${home:+ --define \"_gpg_path $$home\"}"; \
		pass="$(GNUPGPASS)"; pass="$${pass:+$(ECHO) \"$$pass\" |}"; \
		$(ECHO) "$(RPM) --addsign $(RPMFLAGS) `echo '$(RPMKOPTS)'` $$user$$home -- $$rpms_to_sign"; \
		eval "$$pass $(RPM) --addsign $(RPMFLAGS) `echo '$(RPMKOPTS)'` $$user$$home -- $$rpms_to_sign" || :; \
	else \
		$(ECHO) "D: $@: no sigs"; \
	fi

if BUILD_SRPMS
## BUILD_SRPMS

RELEASE			+= all-srpm
RELEASE_SIGN		+= all-sign all-resign
RELEASE_DIRECTORIES	+= $(rpm_directories)

if BUILD_RPMS
## BUILD_RPMS

RELEASE			+= all-noa-rpm all-one-k-rpm all-one-t-rpm

## BUILD_RPMS
endif

## BUILD_SRPMS
endif

##
# Because the build directory is in the autoconf top build directory on the local machine, it needs
# to be cleaned when a distclean is performed.  We use rpm to do this for us, and rpm will complain
# if the directory does not exist, so we ignore errors.  The rpm spec file must still exist for use
# to do this too.  The same is true for build files.
##
distclean-rpm:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@if test -f $(rpm_spec_file); then \
		echo '$(RPMBUILD) $(SRPMFLAGS) --clean $(RPMBOPTS) $(RPMXOPTS) $(AM_RPMBOPTS) $(AM_SRPMFLAGS) --target $(RPMTARGET) -- $(rpm_spec_file) || :'; \
		$(RPMBUILD) $(SRPMFLAGS) --clean $(RPMBOPTS) $(RPMXOPTS) $(AM_RPMBOPTS) $(AM_SRPMFLAGS) --target $(RPMTARGET) -- $(rpm_spec_file) || :; \
	fi

if BUILD_SRPMS
DISTCLEAN_LOCAL		+= distclean-rpm
endif

DISTCLEANFILES		+= $(rpm_cache_files) \
			   $(rpm_dir_stamp)

##
# Removing the sources and the spec file is removing from the distribution directory which, if
# different from the autoconf top build directory, is the main distribution directory.  We only want
# to remove these under exceptional circumstances (i.e. we are repeating a build during the release
# cycle).  Therefore we provide a special set of release targets for this purpose.
##
release-clean-rpm: distclean-rpm
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@if test -f $(rpm_spec_file); then \
		echo '$(RPMBUILD) $(SRPMFLAGS) --rmsource --rmspec $(RPMBOPTS) $(RPMXOPTS) $(AM_RPMBOPTS) $(AM_SRPMFLAGS) --target $(RPMTARGET) -- $(rpm_spec_file) || :'; \
		$(RPMBUILD) $(SRPMFLAGS) --rmsource --rmspec $(RPMBOPTS) $(RPMXOPTS) $(AM_RPMBOPTS) $(AM_SRPMFLAGS) --target $(RPMTARGET) -- $(rpm_spec_file) || :; \
	fi

if BUILD_SRPMS
RELEASE_CLEAN_LOCAL	+= release-clean-rpm
endif

RELEASECLEANFILES	+= $(rpm_dir_stamp) \
			   $(rpm_source_files) \
			   $(rpm_src_file) \
			   $(rpm_sig_file) \
			   $(rpm_binary_files) \
			   $(rpm_link_file)

MY_PHONY		+= srpm rpms \
			   each-rpm \
			   one-k-rpm \
			   one-t-rpm \
			   one-rpm \
			   noa-rpm \
			   sign \
			   srpm-sign \
			   rebuild \
			   resign
ALL_RECURSIVE_TARGETS	+= all-srpm \
			   all-rpms \
			   all-one-k-rpm \
			   all-one-t-rpm \
			   all-one-rpm \
			   all-noa-rpm \
			   all-sign \
			   all-rebuild \
			   all-resign

update-clean-rpm:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@$(ECHO) "rm -rf $(rpm_dir)"; \
	rm -rf $(rpm_dir) ; \
	list="$(rpm_tar_file) $(rpm_source_files) $(rpm_src_file) $(rpm_sig_file) $(rpm_binary_files)"; \
	for f in $$list; do \
		if test -e $$f -a \( ! -f '$(USTAMP)' -o $$f -nt '$(USTAMP)' \); then \
			$(ECHO) "D: $@: removed $$f"; \
			$(ECHO) "rm -f -- \"$$f\""; \
			rm -f -- "$$f"; \
		else \
			test ! -e "$$f" || $(ECHO) "D: $@: leaving $$f"; \
		fi; \
	done

if BUILD_SRPMS
UPDATE			+= all-update-srpm
if BUILD_RPMS
UPDATE			+= update-all-rpms
endif
UPDATE_SIGN		+= all-update-sign-srpm all-update-sign-rpms
UPDATE_DIRECTORIES	+=
UPDATE_CLEAN_LOCAL	+= update-clean-rpm
endif
UPDATECLEANFILES	+= $(rpm_dir_stamp)
##
## Provide updates to srpm packages.
##
## If the SRPM does not exist, create it.  If the SRPM exists, was created after
## the update stamp, and force is applied, remove and recreate the SRPM.
##
update-srpm:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@list="$(rpm_spec_file) $(rpm_img_files) $(rpm_src_file)"; for f in $$list; do \
		if test ! -e "$$f" -o \( -n '$(FORCE)' -a \( ! -e '$(USTAMP)' -o "$$f" -nt '$(USTAMP)' \) \); then \
			$(ECHO) "D: $@: rebuild $$f"; \
			$(ECHO) "rm -f -- \"$$f\""; rm -f -- "$$f"; \
			$(ECHO) "$(MAKE) $(AM_MAKEFLAGS) $(ALL_EXPORT_OPTS) -- \"$$f\""; \
			$(MAKE) $(AM_MAKEFLAGS) $(ALL_EXPORT_OPTS) -- "$$f"; \
		else \
			$(ECHO) "D: $@: skipped $$f"; \
		fi; \
	done

update-n-rpm:
	@$(ECHO_V) "D: Making $@ in `pwd`"; \
	rebuild=yes; \
	rpms=`find $(rpmdir)/noarch -name '$(rpm_base_file)' -o -name '$(rpm_binary_file)' 2>/dev/null`; \
	for f in $$rpms; do \
		if test -z '$(FORCE)' -o \( -e '$(USTAMP)' -a '$(USTAMP)' -nt "$$f" \); then \
			$(ECHO) "D: $@: leaving $$f"; \
			rebuild=no; \
		fi; \
	done; \
	if test ":$$rebuild" = :yes; then \
		$(ECHO) "D: $@: rebuild noarch"; \
		$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' RPMTARGET="noarch" noa-rpm || :; \
	else \
		$(ECHO) "D: $@: skipped noarch"; \
	fi

update-k-rpm:
	@$(ECHO_V) "D: Making $@ in `pwd`"; \
	a=`echo '$(RPMTARGET)' | sed 's,-.*$$,,'`; \
	test \( "$$a" != 'noarch' -a "$$a" != 'all' \) || exit 0; \
	test -e $(DESTDIR)$(rootdir)/lib/modules/$(kversion)/build || exit 0; \
	if test -z '$(DESTDIR)'; then \
		if ! $(RPM) -q --whatprovides /lib/modules/$(kversion)/build >/dev/null 2>&1; then \
			exit 0; \
		fi; \
	fi; \
	ks=`echo $(kversion) | sed 's,-,.,g;s,_,.,g'`; \
	rebuild=yes; \
	rpms="`find $(rpmdir)/$$a -name '*$(PACKAGE)-*$(VERSION)_'$$ks'-$(PACKAGE_RPMRELEASE)$(PACKAGE_RPMEXTRA).'$$a'.rpm' 2>/dev/null`"; \
	for f in $$rpms; do \
		if test -z '$(FORCE)' -o \( -e '$(USTAMP)' -a '$(USTAMP)' -nt "$$f" \); then \
			$(ECHO) "D: $@: leaving $$f"; \
			rebuild=no; \
		fi; \
	done; \
	if test ":$$rebuild" = :yes; then \
		$(ECHO) "D: $@: rebuild $(kversion)"; \
		$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' kversion="$(kversion)" RPMTARGET="$(RPMTARGET)" one-k-rpm || :; \
	else \
		$(ECHO) "D: $@: skipped $(kversion)"; \
	fi

update-t-rpm:
	@$(ECHO_V) "D: Making $@ in `pwd`"; \
	a=`echo '$(RPMTARGET)' | sed 's,-.*$$,,'`; \
	test \( "$$a" != 'noarch' -a "$$a" != 'all' \) || exit 0; \
	rebuild=yes; \
	rpms=`find $(rpmdir)/$$a -name '$(rpm_base_file)' -o -name '$(rpm_binary_file)' 2>/dev/null`; \
	for f in $$rpms; do \
		if test -z '$(FORCE)' -o \( -e '$(USTAMP)' -a '$(USTAMP)' -nt "$$f" \); then \
			$(ECHO) "D: $@: leaving $$f"; \
			rebuild=no; \
		fi; \
	done; \
	if test ":$$rebuild" = :yes; then \
		$(ECHO) "D: $@: rebuild $$a"; \
		$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' RPMTARGET='$(RPMTARGET)' one-t-rpm || :; \
	else \
		$(ECHO) "D: $@: skipped $$a"; \
	fi

update-all-rpms:
	@$(ECHO_V) "D: Making $@ in `pwd`"; \
	$(ECHO) "D: $@: rebuild noarch"; \
	$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' RPMTARGET="noarch" all-update-n-rpm || :; \
	targets="$(RPMTARGET) $(AM_RPMTARGETS)"; \
	for t in $$targets; do \
		a=`$(ECHO) "$$t" | sed 's,-.*$$,,'`; \
		test \( "$$a" != 'noarch' -a "$$a" != 'all' \) || continue; \
		kernels="`( find $(DESTDIR)$(rootdir)/lib/modules -type d -name '2\.[46]\.*' | sort -r ) 2>/dev/null`"; \
		for k in $$kernels; do \
			k=`basename $$k`; \
			test -e $(DESTDIR)$(rootdir)/lib/modules/$$k/build || continue; \
			if test -z '$(DESTDIR)'; then \
				if ! $(RPM) -q --whatprovides /lib/modules/$$k/build >/dev/null 2>&1; then \
					continue; \
				fi; \
			fi; \
			$(ECHO) "D: $@: rebuild $$k"; \
			$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' kversion="$$k" RPMTARGET="$$t" all-update-k-rpm || :; \
		done; \
		$(ECHO) "D: $@: rebuild $$a"; \
		$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' RPMTARGET="$$t" all-update-t-rpm || :; \
	done

MY_PHONY		+= update-n-rpm update-k-rpm update-t-rpm update-all-rpms
ALL_RECURSIVE_TARGETS	+= all-update-n-rpm all-update-k-rpm all-update-t-rpm

##
## Provide updates to rpm packages.
##
## If the RPMs in the set do not exist, create them.  If the RPMs in the set
## exist, were created after the update stamp, and force is applied, recreate
## the RPM set.
##
update-rpms: ALL_EXPORT_OPTS = RPMXOPTS='$(RPMXOPTS)'
update-rpms:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@rebuild=yes; \
	rpms=`find $(rpmdir)/noarch -name '$(rpm_base_file)' -o -name '$(rpm_binary_file)' 2>/dev/null`; \
	for f in $$rpms; do \
		if test -z '$(FORCE)' -o \( -e '$(USTAMP)' -a '$(USTAMP)' -nt "$$f" \); then \
			$(ECHO) "D: $@: leaving $$f"; \
			rebuild=no; \
		fi; \
	done; \
	if test ":$$rebuild" = :yes; then \
		$(ECHO) "D: $@: rebuild noarch"; \
		$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' RPMTARGET="noarch" noa-rpm || :; \
	else \
		$(ECHO) "D: $@: skipped noarch"; \
	fi; \
	targets="$(RPMTARGET) $(AM_RPMTARGETS)"; \
	for t in $$targets; do \
		a=`$(ECHO) "$$t" | sed 's,-.*$$,,'`; \
		test \( "$$a" != 'noarch' -a "$$a" != 'all' \) || continue; \
		kernels="`( find $(DESTDIR)$(rootdir)/lib/modules -type d -name '2\.[46]\.*' | sort -r ) 2>/dev/null`"; \
		for k in $$kernels; do \
			k=`basename $$k`; \
			test -e $(DESTDIR)$(rootdir)/lib/modules/$$k/build || continue; \
			if test -z '$(DESTDIR)'; then \
				if ! $(RPM) -q --whatprovides /lib/modules/$$k/build >/dev/null 2>&1; then \
					continue; \
				fi; \
			fi; \
			ks=`echo $$k | sed 's,-,.,g;s,_,.,g'`; \
			rebuild=yes; \
			rpms="`find $(rpmdir)/$$a -name '*$(PACKAGE)-*$(VERSION)_'$$ks'-$(PACKAGE_RPMRELEASE)$(PACKAGE_RPMEXTRA).'$$a'.rpm' 2>/dev/null`"; \
			for f in $$rpms; do \
				if test -z '$(FORCE)' -o \( -e '$(USTAMP)' -a '$(USTAMP)' -nt "$$f" \); then \
					$(ECHO) "D: $@: leaving $$f"; \
					rebuild=no; \
				fi; \
			done; \
			if test ":$$rebuild" = :yes; then \
				$(ECHO) "D: $@: rebuild $$k"; \
				$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' kversion="$$k" RPMTARGET="$$t" one-k-rpm || :; \
			else \
				$(ECHO) "D: $@: skipped $$k"; \
			fi; \
		done; \
		rebuild=yes; \
		rpms=`find $(rpmdir)/$$a -name '$(rpm_base_file)' -o -name '$(rpm_binary_file)' 2>/dev/null`; \
		for f in $$rpms; do \
			if test -z '$(FORCE)' -o \( -e '$(USTAMP)' -a '$(USTAMP)' -nt "$$f" \); then \
				$(ECHO) "D: $@: leaving $$f"; \
				rebuild=no; \
			fi; \
		done; \
		if test ":$$rebuild" = :yes; then \
			$(ECHO) "D: $@: rebuild $$a"; \
			$(MAKE) $(AM_MAKEFLAGS) RPMXOPTS='$(RPMXOPTS)' RPMTARGET="$$t" one-t-rpm || :; \
		else \
			$(ECHO) "D: $@: skipped $$a"; \
		fi; \
	done

##
## Provide updates to srpm signatures
##
## If the SRPM signature does not exist, create it.  If the SRPM signature
## exists, was created after the update stamp, and force is applied, resign the
## SRPM.  Care must be taken when signing SRPMs to restore the original
## file times.
##
update-sign-srpm:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@list="$(rpm_src_file) $(rpm_link_file)"; for f in $$list; do \
		if test ! -e "$$f"; then \
			$(ECHO) "D: $@: rebuild update-rpm"; \
			$(ECHO) "$(MAKE) $(AM_MAKEFLAGS) $(ALL_EXPORT_OPTS) update-srpm"; \
			$(MAKE) $(AM_MAKEFLAGS) $(ALL_EXPORT_OPTS) update-srpm; \
		fi; test -e "$$f" || continue; \
		resign=yes; \
		if $(RPM) -K -- "$$f" 2>&1 | grep -q ' gpg OK' >/dev/null 2>&1; then \
			$(ECHO) "D: $@: sign ok $$f"; \
			resign=no; \
		fi; \
		if test -z '$(FORCE)' -o \( -e '$(USTAMP)' -a '$(USTAMP)' -nt "$$f" \); then \
			$(ECHO) "D: $@: skipped $$f"; \
			resign=no; \
		fi; \
		if test ":$$resign" = :yes; then \
			$(ECHO) "D: $@: signing $$f"; \
			user="$(GNUPGUSER)"; user="$${user:+ --define \"_gpg_name $$user\"}"; \
			home="$(GNUPGHOME)"; home="$${home:+ --define \"_gpg_path $$home\"}"; \
			pass="$(GNUPGPASS)"; pass="$${pass:+$(ECHO) \"$$pass\" |}"; \
			$(ECHO) "$(RPM) --addsign $(RPMFLAGS) `echo '$(RPMKOPTS)'` $$user$$home -- $$f"; \
			eval "$$pass $(RPM) --addsign $(RPMFLAGS) `echo '$(RPMKOPTS)'` $$user$$home -- $$f" || :; \
		else \
			$(ECHO) "D: $@: skipped $$f"; \
		fi; \
	done

##
## Provide updates to rpm signatures
##
## If the RPM signatures do not exist, create them.  If the RPM signatures
## exist, were created after the update stamp, and force is applied, resign the
## RPMs.  Care must be taken when signing RPMs to restore the original file
## times.
##
update-sign-rpms:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@rpms=`find $(rpmdir) -name '$(rpm_base_file)' -o -name '$(rpm_binary_file)' -o -name '$(rpm_module0_file)' -o -name '$(rpm_module1_file)' -o -name '$(rpm_module2_file)' -o -name '$(rpm_module3_file)' 2>/dev/null`; \
	if test -z "$$rpms"; then \
		$(ECHO) "D: $@: rebuild update-rpm"; \
		$(ECHO) "$(MAKE) $(AM_MAKEFLAGS) $(ALL_EXPORT_OPTS) update-rpms"; \
		$(MAKE) $(AM_MAKEFLAGS) $(ALL_EXPORT_OPTS) update-rpms; \
		rpms=`find $(rpmdir) -name '$(rpm_base_file)' -o -name '$(rpm_binary_file)' -o -name '$(rpm_module0_file)' -o -name '$(rpm_module1_file)' -o -name '$(rpm_module2_file)' -o -name '$(rpm_module3_file)' 2>/dev/null`; \
	fi; if test -z "$$rpms"; then exit 0; fi; \
	rpms_to_sign=; \
	for f in $$rpms; do \
		resign=yes; \
		if $(RPM) -K -- "$$f" 2>&1 | grep -q ' gpg OK' >/dev/null 2>&1; then \
			$(ECHO) "D: $@: sign ok $$f"; \
			resign=no; \
		fi; \
		if test -z '$(FORCE)' -o \( -e '$(USTAMP)' -a '$(USTAMP)' -nt "$$f" \); then \
			$(ECHO) "D: $@: skipped $$f"; \
			resign=no; \
		fi; \
		if test ":$$resign" = :yes; then \
			$(ECHO) "D: $@: signing $$f"; \
			rpms_to_sign="$${rpms_to_sign:+$$rpms_to_sign }$$f"; \
		fi; \
	done; \
	if test -n "$$rpms_to_sign"; then \
		$(ECHO) "D: $@: signing $$rpms_to_sign"; \
		user="$(GNUPGUSER)"; user="$${user:+ --define \"_gpg_name $$user\"}"; \
		home="$(GNUPGHOME)"; home="$${home:+ --define \"_gpg_path $$home\"}"; \
		pass="$(GNUPGPASS)"; pass="$${pass:+$(ECHO) \"$$pass\" |}"; \
		$(ECHO) "$(RPM) --addsign $(RPMFLAGS) `echo '$(RPMKOPTS)'` $$user$$home -- $$rpms_to_sign"; \
		eval "$$pass $(RPM) --addsign $(RPMFLAGS) `echo '$(RPMKOPTS)'` $$user$$home -- $$rpms_to_sign" || :; \
	else \
		$(ECHO) "D: $@: no sigs"; \
	fi

MY_PHONY		+= update-srpm update-rpms update-sign-srpm update-sign-rpms
ALL_RECURSIVE_TARGETS	+= all-update-srpm all-update-rpms all-update-sign-srpm all-update-sign-rpms


if BUILD_RPMS

if BUILD_REPO_YUM

##
## The following builds repomd repositories.
##

RELEASE_DIRECTORIES	+= $(repodir)

repomd_files		= $(repodir)/repomd.xml \
			  $(repodir)/primary.xml.gz \
			  $(repodir)/filelists.xml.gz \
			  $(repodir)/other.xml.gz

repomd_signs		= $(repodir)/repomd.xml.asc

repomd_group		= $(repodir)/comps.xml

#!
#! YUM Build Targets:
#! ------------------
#!
#! On rpm systems, or systems supporting rpm packaging tools and repomd
#! repository metadata creation tools, the following targets are used to
#! manage repomd source repository meta data files.
#!
$(repomd_group)::
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@f=`$(ECHO) "$@" | sed 's|^.*/||'`; \
	d=; test -f $$f || d='$(srcdir)/'; \
	test -f "$$d$$f" || { \
		touch $$f; exit 0; }; \
	test ! \( "$@" -ef "$$d$$f" \) || exit 0; \
	test ":$(FORCE)" != :force -a -f "$@"  || { \
		$(ECHO) "cp -f -- $$d$$f $@"; \
		cp -f -- $$d$$f $@; }

$(repodir)/openss7.repo: $(repodir)
	( \
		echo '[openss7]'; \
		echo 'enabled = 1'; \
		echo 'name = OpenSS7 Repository'; \
		echo 'baseurl = http://www.openss7.org/repos/rpms/$(PACKAGE_RPMSUBDIR)'; \
		echo 'gpgkey = http://www.openss7.org/repos/tarballs/OPENSS7-GPG-KEY'; \
		echo 'repo_gpgcheck = 1'; \
		echo 'gpgcheck = 1'; \
		echo ''; \
		echo '[openss7-local]'; \
		echo 'enabled = 0'; \
		echo 'name = OpenSS7 Local Repository'; \
		echo 'baseurl = file://$(topdir)'; \
		echo 'gpgkey = file://$(tardir)/OPENSS7-GPG-KEY'; \
		echo 'repo_gpgcheck = 1'; \
		echo 'gpgcheck = 1'; \
	) > $@

$(repodir)/repomd.xml:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@if test ! -f $@; then \
		$(ECHO_V) "$(MAKE) $(AM_MAKEFLAGS) repo-yum"; \
		$(MAKE) $(AM_MAKEFLAGS) repo-yum; \
	fi

$(repodir)/repomd.xml.asc:: \
$(repodir)/repomd.xml
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@if test ! -f $@ || ! $(GPG) --verify -- $@ >/dev/null 2>&1; then \
		user="$(GNUPGUSER)"; user="$${user:+ -u }$$user"; \
		home="$(GNUPGHOME)"; home="$${home:+ --homedir }$$home"; \
		pass="$(GNUPGPASS)"; pass="$${pass:+ --batch }"; \
		pipe="$(GNUPGPASS)"; pipe="$${pipe:+$(ECHO) $$pipe |}"; \
		$(ECHO) "$(GPG) -ba --passphrase-fd 0$$user$$home$$pass -o- -- $< > $@ 2>/dev/null"; \
		eval "$$pipe $(GPG) -ba --passphrase-fd 0$$user$$home$$pass -o- -- $< > $@ 2>/dev/null"; \
	else touch "$@"; fi

#! repo-yum:
#!     Create (or recreate) the meta data files for a yum (repomd) repository in
#!     the package distribution directory, @repodir@/.
#!     When executed with root privilege, it will also place a local
#!     installation source (@PACKAGE_LCNAME@-media) in the /etc/yum.repo.d/
#!     directory on the target machine in the @PACKAGE_LCNAME@.repo file.
#!
repo-yum: $(repodir) $(repodir)/openss7.repo
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@f=`$(ECHO) $(repomd_group) | sed 's|^.*/||'`; \
	d=`pwd`/scripts/; test -f $$d$$f || d=`(cd $(srcdir); pwd)`/scripts/; \
	g=; test ! -f $$d$$f || g="-g $$d$$f"; \
	$(ECHO) "$(CREATEREPO) -p $(REPOFLAGS) $$g $(topdir)"; \
	$(CREATEREPO) -p $(REPOFLAGS) $$g $(topdir) || :

#! repo-sign-yum:
#! 	Sign the repomd.xml file and export the signing key.
repo-sign-yum: $(repomd_signs)

#! repo-clean-yum:
#!     Cleans the meta data files for a yum (repomd) repository from the package
#!     distribution directory, @repodir@/.
#!
repo-clean-yum:

REPO			+= repo-yum
REPO_SIGN		+= repo-sign-yum
REPO_CLEAN		+= repo-clean-yum
REPOCLEANFILES		+= $(repomd_files) $(repomd_signs) $(repomd_group) $(repodir)/openss7.repo

MY_PHONY		+= repo-yum repo-clean-yum

RELEASE			+= repo-yum
RELEASE_SIGN		+= repo-sign-yum
RELEASE_CLEAN_LOCAL	+= repo-clean-yum
RELEASECLEANFILES	+= $(repomd_files) $(repomd_signs) $(repomd_group) $(repodir)/openss7.repo

UPDATE			+= repo-yum
UPDATE_SIGN		+= repo-sign-yum
UPDATE_CLEAN_LOCAL	+= repo-yum repo-sign-yum
UPDATECLEANFILES	+=

endif
## BUILD_REPO_YUM

if BUILD_REPO_YAST

##
## The following builds yast repositories.
##

RELEASE_DIRECTORIES	+= $(yastdir) \
			   $(yastdir)/media.1 \
			   $(yastdir)/setup/descr

#!
#! YaST Build Targets:
#! -------------------
#!
#! On rpm systems, or systems supporting rpm packaging tools and YaST install
#! source repository creation tools, the following targets are used to manage
#! YaST install source repository meta data files.
#!
$(yastdir)/media.1/media:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@p=`$(RPM) --showrc | grep '\<packager\>' | sed 's,.*\<packager\>[[:space:]]*,,;s[[:space:]]*$$,,' 2>/dev/null`; \
	if test -z "$$p"; then p='Unknown'; fi; \
	$(ECHO) "( echo \"$$p\"; date +%Y%m%d%H%M%S; echo '1') >>$@"; \
	( $(ECHO) "$$p"; date +%Y%m%d%H%M%S; echo '1') >>$@

$(yastdir)/content:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@v=`$(RPM) --showrc | grep '\<vendor\>' | sed 's,.*\<vendor\>[[:space:]]*,,;s,[[:space:]]*$$,,' 2>/dev/null`; \
	if test -z "$$v"; then v='Unknown'; fi; \
	( \
		$(ECHO) "PRODUCT $(PACKAGE_TITLE)"; \
		$(ECHO) "VERSION $(PACAKGE_VERSION)-$(PACKAGE_RPMRELEASE)$(PACKAGE_RPMEXTRA)"; \
		$(ECHO) "VENDOR $$v"; \
		$(ECHO) "LABEL $(PACKAGE_RPMDIST) ($(PACKAGE_STITLE))"; \
		$(ECHO) "ARCH.i686 i686 i586 i486 i386 noarch"; \
		$(ECHO) "ARCH.i586 i586 i486 i386 noarch"; \
		$(ECHO) "ARCH.x86_64 x86_64 noarch"; \
		$(ECHO) "DEFAULTBASE i586"; \
		$(ECHO) "DESCRDIR setup/descr"; \
		$(ECHO) "DATADIR RPMS"; \
	) >>$@

$(yastdir)/content.asc:: \
$(yastdir)/content
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@if test ! -f $@ || ! $(GPG) --verify -- $@ >/dev/null 2>&1; then \
		user="$(GNUPGUSER)"; user="$${user:+ -u }$$user"; \
		home="$(GNUPGHOME)"; home="$${home:+ --homedir }$$home"; \
		pass="$(GNUPGPASS)"; pass="$${pass:+ --batch }"; \
		pipe="$(GNUPGPASS)"; pipe="$${pipe:+$(ECHO) $$pipe |}"; \
		$(ECHO) "$(GPG) -ba --passphrase-fd 0$$user$$home$$pass -o- -- $< > $@ 2>/dev/null"; \
		eval "$$pipe $(GPG) -ba --passphrase-fd 0$$user$$home$$pass -o- -- $< > $@ 2>/dev/null"; \
	else touch "$@"; fi

$(yastdir)/content.key:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@user="$(GNUPGUSER)"; user="$${user:+ -u }$$user"; \
	home="$(GNUPGHOME)"; home="$${home:+ --homedir }$$home"; \
	$(ECHO) "$(GPG) -a$$user$$home --export $(GNUPGUSER) >> $@"; \
	$(GPG) -a$$user$$home --export $(GNUPGUSER) >> $@

yast_meta_files		= $(yastdir)/media.1/media \
			  $(yastdir)/content

yast_sign_files		= $(yastdir)/content.asc \
			  $(yastdir)/content.key

yast_desc_files		= $(yastdir)/setup/descr/packages \
			  $(yastdir)/setup/descr/packages.*

##
# Each directory needs a directory.yast file so that YaST can determine the (visible) contents of
# the directory when using http or where the directory cannot be listed otherwise.
##

am__yast_skipfiles = (^|/)(\.[^/][^/]*|directory\.yast|INDEX\.gz|ARCHIVE\.gz|ls-lR\.gz|MD5SUMS(\.meta)?|SHA1SUMS(\.meta)?|md5sum\.txt)

repo-yast-listings:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@dir=`(cd $(yastdir); pwd)`; \
	find $$dir -follow -type d | while read d; do \
		p=`$(ECHO) "$$d" | sed 's,.*/,,'`; \
		case "$$p" in (RCS|CVS|.*) continue;; esac; \
		( $(ECHO_V) "cd -- \"$$d\""; \
		  cd -- "$$d"; \
			$(ECHO_V) "ls -AF1 | egrep -v '$(am__yast_skipfiles)$$' >directory.yast"; \
			ls -AF1 | egrep -v '$(am__yast_skipfiles)$$' >directory.yast; \
			$(ECHO_V) "ls -lR  | egrep -v '$(am__yast_skipfiles)$$' | gzip -c >ls-lR.gz"; \
			ls -lR  | egrep -v '$(am__yast_skipfiles)$$' | gzip -c >ls-lR.gz; \
			$(ECHO_V) "ls -A1  | egrep -v '$(am__yast_skipfiles)$$' | gzip -c >INDEX.gz"; \
			ls -A1  | egrep -v '$(am__yast_skipfiles)$$' | gzip -c >INDEX.gz; \
		); \
	done

repo-yast-listings-clean:
	@$(ECHO_V) "D: Making $@ in `pwd`"
	@test -n '$(yastdir)' || exit 1; \
	find $(yastdir) -follow \
		-name 'directory.yast' -o \
		-name 'ls-lR.gz' -o \
		-name 'INDEX.gz' | $(am__base_remove)

#! repo-yast:
#! 	Create (or recreate) the meta data files for a YaST2 repository in the
#! 	package distribution directory, @topdir@/.
#! 	When executed with root privilege, it will also place a local
#! 	installation source for use by YaST on the build system.
#!
repo-yast: $(yast_meta_files)
	@$(ECHO_V) "D: Making $@ in `pwd`"
	( cd $(yastdir); $(CREATE_PACKAGE_DESCR) -Z -V -C -K -F -B -d RPMS/ )
	$(MAKE) $(AM_MAKEFLAGS) repo-yast-listings

#! repo-sign-yast:
#! 	Sign the content file and export the signing key to content.key.
#! 	This target then performs all of the actions of the repo-yast
#! 	target to rebuild the directory listings.
#!
repo-sign-yast: $(yast_sign_files) repo-yast

#! repo-clean-yast:
#!     Cleans the meta data files for a YaST2 repository from the package
#!     distribution directory, @topdir@/.
#!
repo-clean-yast:

REPO			+= repo-yast
REPO_SIGN		+= repo-sign-yast
REPO_CLEAN		+= repo-clean-yast repo-yast-listings-clean
REPOCLEANFILES		+= $(yast_meta_files) $(yast_desc_files) $(yast_sign_files)

MY_PHONY		+= repo-yast repo-yast-listings repo-clean-yast

RELEASE			+= repo-yast
RELEASE_SIGN		+= repo-sign-yast
RELEASE_CLEAN_LOCAL	+= repo-clean-yast repo-yast-listings-clean
RELEASECLEANFILES	+= $(yast_meta_files) $(yast_desc_files) $(yast_sign_files)

UPDATE			+= repo-yast
UPDATE_SIGN		+= repo-sign-yast
UPDATE_CLEAN_LOCAL	+= repo-yast repo-sign-yast
UPDATECLEANFILES	+=

endif
## BUILD_REPO_YAST

endif
## BUILD_RPMS

endif
## MAINTAINER_MODE

EXTRA_DIST		+= $(PACKAGE_TARNAME).spec \
			   $(PACKAGE_TARNAME).gif \
			   $(PACKAGE_TARNAME).xpm \
			   .rpmrelease \
			   .rpmepoch

##
# We now have our own set of find-provides and find-requires scripts that
# are used for automatic dependency generation.  Put something like
#
# %_use_internal_dependency_generator 0
# %__find_provides %{_builddir}/scripts/rpm/find-provides
# %__find_requires %{_builddir}/scripts/rpm/find-requires
#
# In your ~/.rpmmacros to use them for now.
##
dist_noinst_SCRIPTS	+= scripts/rpm/check-files \
			   scripts/rpm/find-provides \
			   scripts/rpm/find-provides.d/firmware.prov \
			   scripts/rpm/find-provides.d/modalias.prov \
			   scripts/rpm/find-provides.java \
			   scripts/rpm/find-provides.kmod \
			   scripts/rpm/find-provides.ksyms \
			   scripts/rpm/find-provides.libtool \
			   scripts/rpm/find-provides.perl \
			   scripts/rpm/find-provides.pkgconfig \
			   scripts/rpm/find-provides.so \
			   scripts/rpm/find-prov.pl \
			   scripts/rpm/find-req.pl \
			   scripts/rpm/find-requires \
			   scripts/rpm/find-requires.exe \
			   scripts/rpm/find-requires.java \
			   scripts/rpm/find-requires.kmod \
			   scripts/rpm/find-requires.ksyms \
			   scripts/rpm/find-requires.libtool \
			   scripts/rpm/find-requires.perl \
			   scripts/rpm/find-requires.pkgconfig \
			   scripts/rpm/find-requires.so \
			   scripts/rpm/find-requires.tcl \
			   scripts/rpm/find-supplements \
			   scripts/rpm/find-supplements.ksyms \
			   scripts/rpm/get_magic.pl \
			   scripts/rpm/kmodtool \
			   scripts/rpm/magic.prov \
			   scripts/rpm/magic.req \
			   scripts/rpm/perldeps.pl \
			   scripts/rpm/perl.prov \
			   scripts/rpm/perl.req \
			   scripts/rpm/pythondeps.sh \
			   scripts/rpm/tcl.req


## =============================================================================
##
## $Log: rpm.am,v $
## Revision 1.1.2.6  2011-02-07 04:48:31  brian
## - updated configure and build scripts
##
## Revision 1.1.2.5  2009-07-24 13:49:44  brian
## - updates for release build
##
## Revision 1.1.2.4  2009-07-05 12:04:26  brian
## - updates for release builds
##
## Revision 1.1.2.3  2009-07-04 03:51:32  brian
## - updates for release
##
## Revision 1.1.2.2  2009-06-29 07:35:35  brian
## - improvements to build process
##
## Revision 1.1.2.1  2009-06-21 10:26:00  brian
## - added files to new distro
##
## =============================================================================
## vim: ft=automake comments=b\:#,b\:##,b\:#\! formatoptions+=tcqlor
