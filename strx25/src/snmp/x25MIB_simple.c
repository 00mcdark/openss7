/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "x25MIB_simple.h"

/* 
 * x25MIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid x25MIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3 };

/* 
 * variable7 x25MIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the x25MIB_simple mib section 
 */

struct variable7 x25MIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   X25PLEOPERATIONALSTATE  1
	{X25PLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 1, 1, 1, 2}},
#define   X25PLEADMINISTRATIVESTATE  2
	{X25PLEADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 3}},
#define   X25PLEPROTOCOLVERSIONSSUPPORTED  3
	{X25PLEPROTOCOLVERSIONSSUPPORTED, ASN_BIT_STR, RONLY, var_x25PLETable, 6, {1, 1, 1, 1, 1, 4}},
#define   X25PLELOCALDTEADDRESS  4
	{X25PLELOCALDTEADDRESS, ASN_OCTET_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 5}},
#define   X25PLEINTERFACEMODE   5
	{X25PLEINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 1, 1, 1, 6}},
#define   X25PLEFACILITYNONNEGOTIABLE  6
	{X25PLEFACILITYNONNEGOTIABLE, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 7}},
#define   X25PLEFACILITYAVAILABILITY  7
	{X25PLEFACILITYAVAILABILITY, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 8}},
#define   X25PLEFACILITYNEGOTIATION  8
	{X25PLEFACILITYNEGOTIATION, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 9}},
#define   X25PLEFACILITYWHILEIDLE  9
	{X25PLEFACILITYWHILEIDLE, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 10}},
#define   X25PLEPACKETSEQUENCENUMBERING  10
	{X25PLEPACKETSEQUENCENUMBERING, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 11}},
#define   X25PLEDEFAULTPACKETSIZEINCOMING  11
	{X25PLEDEFAULTPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 12}},
#define   X25PLEDEFAULTPACKETSIZEOUTGOING  12
	{X25PLEDEFAULTPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 13}},
#define   X25PLEDEFAULTWINDOWSIZEINCOMING  13
	{X25PLEDEFAULTWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 14}},
#define   X25PLEDEFAULTWINDOWSIZEOUTGOING  14
	{X25PLEDEFAULTWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 15}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSINCOMING  15
	{X25PLEDEFAULTTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 16}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING  16
	{X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 17}},
#define   X25PLESNSERVICEPROVIDER  17
	{X25PLESNSERVICEPROVIDER, ASN_OBJECT_ID, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 18}},
#define   X25PLESNSAP           18
	{X25PLESNSAP, ASN_OBJECT_ID, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 19}},
#define   X25PLELOGICALCHANNELASSIGNMENTHIC  19
	{X25PLELOGICALCHANNELASSIGNMENTHIC, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 20}},
#define   X25PLELOGICALCHANNELASSIGNMENTLIC  20
	{X25PLELOGICALCHANNELASSIGNMENTLIC, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 21}},
#define   X25PLELOGICALCHANNELASSIGNMENTHTC  21
	{X25PLELOGICALCHANNELASSIGNMENTHTC, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 22}},
#define   X25PLELOGICALCHANNELASSIGNMENTLTC  22
	{X25PLELOGICALCHANNELASSIGNMENTLTC, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 23}},
#define   X25PLELOGICALCHANNELASSIGNMENTHOC  23
	{X25PLELOGICALCHANNELASSIGNMENTHOC, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 24}},
#define   X25PLELOGICALCHANNELASSIGNMENTLOC  24
	{X25PLELOGICALCHANNELASSIGNMENTLOC, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 25}},
#define   X25PLEIVMOINTERFACEMODE  25
	{X25PLEIVMOINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 2}},
#define   X25PLEIVMODEFAULTPACKETSIZEINCOMING  26
	{X25PLEIVMODEFAULTPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 3}},
#define   X25PLEIVMODEFAULTPACKETSIZEOUTGOING  27
	{X25PLEIVMODEFAULTPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 4}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING  28
	{X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 5}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING  29
	{X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 6}},
#define   X25PLEIVMODEFAULTWINDOWSIZEINCOMING  30
	{X25PLEIVMODEFAULTWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 7}},
#define   X25PLEIVMODEFAULTWINDOWSIZEOUTGOING  31
	{X25PLEIVMODEFAULTWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 8}},
#define   X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION  32
	{X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 9}},
#define   X25PLEIVMOLOCALDTEADDRESS  33
	{X25PLEIVMOLOCALDTEADDRESS, ASN_OCTET_STR, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 10}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHPC  34
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHPC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 11}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLPC  35
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLPC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 12}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHIC  36
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHIC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 13}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLIC  37
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLIC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 14}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHTC  38
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHTC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 15}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLTC  39
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLTC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 16}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHOC  40
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHOC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 17}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLOC  41
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLOC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 18}},
#define   X25PLEIVMOSNSERVICEPROVIDER  42
	{X25PLEIVMOSNSERVICEPROVIDER, ASN_OBJECT_ID, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 19}},
#define   X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION  43
	{X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 20}},
#define   X25PLEDTEPACKETSEQUENCING  44
	{X25PLEDTEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 1}},
#define   X25PLEDTEMAXACTIVECIRCUITS  45
	{X25PLEDTEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 2}},
#define   X25PLEDTECALLDEFLECTIONSUBSCRIPTION  46
	{X25PLEDTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 3}},
#define   X25PLEDTERESTARTTIME  47
	{X25PLEDTERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 4}},
#define   X25PLEDTERESTARTCOUNT  48
	{X25PLEDTERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 5}},
#define   X25PLEDTEMINIMUMRECALLTIMER  49
	{X25PLEDTEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 6}},
#define   X25PLEDTEREGISTRATIONTIME  50
	{X25PLEDTEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 7}},
#define   X25PLEDTEREGISTRATIONCOUNT  51
	{X25PLEDTEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 8}},
#define   X25PLEDTEREGISTRATIONPERMITTED  52
	{X25PLEDTEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 9}},
#define   X25PLEDTEPROFILE      53
	{X25PLEDTEPROFILE, ASN_OBJECT_ID, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 10}},
#define   X25PLEDTEROWSTATUS    54
	{X25PLEDTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 11}},
#define   X25PLEDCEPACKETSEQUENCING  55
	{X25PLEDCEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 1}},
#define   X25PLEDCECALLDEFLECTIONSUBSCRIPTION  56
	{X25PLEDCECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 2}},
#define   X25PLEDCECUG          57
	{X25PLEDCECUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 3}},
#define   X25PLEDCEFASTSELECTACCEPTANCE  58
	{X25PLEDCEFASTSELECTACCEPTANCE, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 4}},
#define   X25PLEDCEINCOMINGCALLSBARRED  59
	{X25PLEDCEINCOMINGCALLSBARRED, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 5}},
#define   X25PLEDCEONEWAYLOGICALCHANNELOUTGOING  60
	{X25PLEDCEONEWAYLOGICALCHANNELOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 6}},
#define   X25PLEDCEOUTGOINGCALLSBARRED  61
	{X25PLEDCEOUTGOINGCALLSBARRED, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 7}},
#define   X25PLEDCEBILATERALCUG  62
	{X25PLEDCEBILATERALCUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 8}},
#define   X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS  63
	{X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 9}},
#define   X25PLEDCECALLREDIRECTION  64
	{X25PLEDCECALLREDIRECTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 10}},
#define   X25PLEDCECHARGINGINFORMATION  65
	{X25PLEDCECHARGINGINFORMATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 11}},
#define   X25PLEDCECUGWITHINCOMINGACCESS  66
	{X25PLEDCECUGWITHINCOMINGACCESS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 12}},
#define   X25PLEDCECUGWITHOUTGOINGACCESS  67
	{X25PLEDCECUGWITHOUTGOINGACCESS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 13}},
#define   X25PLEDCEDBITMODIFICATION  68
	{X25PLEDCEDBITMODIFICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 14}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSSUBSCRIPTION  69
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 15}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSSUPPORTED  70
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSSUPPORTED, ASN_BIT_STR, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 16}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING  71
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 17}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING  72
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 18}},
#define   X25PLEDCEHUNTGROUP    73
	{X25PLEDCEHUNTGROUP, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 19}},
#define   X25PLEDCEINCOMINGCALLBARREDWITHINCUG  74
	{X25PLEDCEINCOMINGCALLBARREDWITHINCUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 20}},
#define   X25PLEDCELOCALCHARGINGPREVENTION  75
	{X25PLEDCELOCALCHARGINGPREVENTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 21}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZESUBSCRIPTION  76
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZESUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 22}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM  77
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 23}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING  78
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 24}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING  79
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 25}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZESUBSCRIPTION  80
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZESUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 26}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEMAXIMUM  81
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEMAXIMUM, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 27}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEINCOMING  82
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 28}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEOUTGOING  83
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 29}},
#define   X25PLEDCENUIOVERRIDE  84
	{X25PLEDCENUIOVERRIDE, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 30}},
#define   X25PLEDCENUISUBSCRIPTION  85
	{X25PLEDCENUISUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 31}},
#define   X25PLEDCEONEWAYLOGICALCHANNELINCOMING  86
	{X25PLEDCEONEWAYLOGICALCHANNELINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 32}},
#define   X25PLEDCEONLINEFACILITYREGISTRATION  87
	{X25PLEDCEONLINEFACILITYREGISTRATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 33}},
#define   X25PLEDCEOUTGOINGCALLBARREDWITHINCUG  88
	{X25PLEDCEOUTGOINGCALLBARREDWITHINCUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 34}},
#define   X25PLEDCEPACKETRETRANSMISSION  89
	{X25PLEDCEPACKETRETRANSMISSION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 35}},
#define   X25PLEDCEREVERSECHARGINGACCEPTANCE  90
	{X25PLEDCEREVERSECHARGINGACCEPTANCE, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 36}},
#define   X25PLEDCEROASUBSCRIPTION  91
	{X25PLEDCEROASUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 37}},
#define   X25PLEDCERESTARTINDICATION  92
	{X25PLEDCERESTARTINDICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 38}},
#define   X25PLEDCERESTARTCOUNT  93
	{X25PLEDCERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 39}},
#define   X25PLEDCEINCOMINGCALL  94
	{X25PLEDCEINCOMINGCALL, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 40}},
#define   X25PLEDCECALLCOUNT    95
	{X25PLEDCECALLCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 41}},
#define   X25PLEDCERESETINDICATION  96
	{X25PLEDCERESETINDICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 42}},
#define   X25PLEDCERESETCOUNT   97
	{X25PLEDCERESETCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 43}},
#define   X25PLEDCECLEARINDICATION  98
	{X25PLEDCECLEARINDICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 44}},
#define   X25PLEDCECLEARCOUNT   99
	{X25PLEDCECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 45}},
#define   X25PLEDCEPROFILE      100
	{X25PLEDCEPROFILE, ASN_OBJECT_ID, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 46}},
#define   X25PLEDCEROWSTATUS    101
	{X25PLEDCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 47}},
#define   X25PLEDXEPACKETSEQUENCING  102
	{X25PLEDXEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 1}},
#define   X25PLEDXEMAXACTIVECIRCUITS  103
	{X25PLEDXEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 2}},
#define   X25PLEDXECALLDEFLECTIONSUBSCRIPTION  104
	{X25PLEDXECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 3}},
#define   X25PLEDXERESTARTTIME  105
	{X25PLEDXERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 4}},
#define   X25PLEDXERESTARTCOUNT  106
	{X25PLEDXERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 5}},
#define   X25PLEDXEMINIMUMRECALLTIMER  107
	{X25PLEDXEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 6}},
#define   X25PLEDXEREGISTRATIONTIME  108
	{X25PLEDXEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 7}},
#define   X25PLEDXEREGISTRATIONCOUNT  109
	{X25PLEDXEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 8}},
#define   X25PLEDXEREGISTRATIONPERMITTED  110
	{X25PLEDXEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 9}},
#define   X25PLEDXEPLECLIENTMONAME  111
	{X25PLEDXEPLECLIENTMONAME, ASN_OBJECT_ID, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 10}},
#define   X25PLEDXEPROFILE      112
	{X25PLEDXEPROFILE, ASN_OBJECT_ID, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 11}},
#define   X25PLEDXEROWSTATUS    113
	{X25PLEDXEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 12}},
#define   X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION  114
	{X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 1}},
#define   X25PLEIVMODTECALLTIME  115
	{X25PLEIVMODTECALLTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 2}},
#define   X25PLEIVMODTECLEARTIME  116
	{X25PLEIVMODTECLEARTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 3}},
#define   X25PLEIVMODTECLEARCOUNT  117
	{X25PLEIVMODTECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 4}},
#define   X25PLEIVMODTEPACKETSEQUENCING  118
	{X25PLEIVMODTEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 5}},
#define   X25PLEIVMODTEINTERRUPTTIME  119
	{X25PLEIVMODTEINTERRUPTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 6}},
#define   X25PLEIVMODTEMAXACTIVECIRCUITS  120
	{X25PLEIVMODTEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 7}},
#define   X25PLEIVMODTEMINIMUMRECALLTIMER  121
	{X25PLEIVMODTEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 8}},
#define   X25PLEIVMODTERESETTIME  122
	{X25PLEIVMODTERESETTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 9}},
#define   X25PLEIVMODTERESETCOUNT  123
	{X25PLEIVMODTERESETCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 10}},
#define   X25PLEIVMODTERESTARTTIME  124
	{X25PLEIVMODTERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 11}},
#define   X25PLEIVMODTERESTARTCOUNT  125
	{X25PLEIVMODTERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 12}},
#define   X25PLEIVMODTEWINDOWTIME  126
	{X25PLEIVMODTEWINDOWTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 13}},
#define   X25PLEIVMODTEDATATIME  127
	{X25PLEIVMODTEDATATIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 14}},
#define   X25PLEIVMODTEDATACOUNT  128
	{X25PLEIVMODTEDATACOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 15}},
#define   X25PLEIVMODTEREJECTTIME  129
	{X25PLEIVMODTEREJECTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 16}},
#define   X25PLEIVMODTEREJECTCOUNT  130
	{X25PLEIVMODTEREJECTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 17}},
#define   X25PLEIVMODTEREGISTRATIONTIME  131
	{X25PLEIVMODTEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 18}},
#define   X25PLEIVMODTEREGISTRATIONCOUNT  132
	{X25PLEIVMODTEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 19}},
#define   X25PLEIVMODTEREGISTRATIONPERMITTED  133
	{X25PLEIVMODTEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 20}},
#define   X25PLEIVMODTEROWSTATUS  134
	{X25PLEIVMODTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 21}},
#define   X25PLEIVMODCEROWSTATUS  135
	{X25PLEIVMODCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMODCETable, 6, {1, 1, 7, 1, 1, 1}},
#define   X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION  136
	{X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6, {1, 1, 8, 1, 1, 1}},
#define   X25PLEIVMODTEMAXACTIVECIRCUITS  137
	{X25PLEIVMODTEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6, {1, 1, 8, 1, 1, 2}},
#define   X25PLEIVMODTERESTARTTIME  138
	{X25PLEIVMODTERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6, {1, 1, 8, 1, 1, 3}},
#define   X25PLEIVMODTEMINIMUMRECALLTIMER  139
	{X25PLEIVMODTEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6, {1, 1, 8, 1, 1, 4}},
#define   X25PLEIVMODTERESTARTCOUNT  140
	{X25PLEIVMODTERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6, {1, 1, 8, 1, 1, 5}},
#define   X25PLEIVMODTEPACKETSEQUENCING  141
	{X25PLEIVMODTEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6, {1, 1, 8, 1, 1, 6}},
#define   X25PLEIVMODTEREGISTRATIONTIME  142
	{X25PLEIVMODTEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6, {1, 1, 8, 1, 1, 7}},
#define   X25PLEIVMODTEREGISTRATIONCOUNT  143
	{X25PLEIVMODTEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6, {1, 1, 8, 1, 1, 8}},
#define   X25PLEIVMODTEREGISTRATIONPERMITTED  144
	{X25PLEIVMODTEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6, {1, 1, 8, 1, 1, 9}},
#define   X25VCLOGICALCHANNEL   145
	{X25VCLOGICALCHANNEL, ASN_INTEGER, RONLY, var_x25VCTable, 6, {1, 1, 9, 1, 1, 2}},
#define   X25VCPACKETSEQUENCING  146
	{X25VCPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 3}},
#define   X25VCPACKETSIZEINCOMING  147
	{X25VCPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 4}},
#define   X25VCPACKETSIZEOUTGOING  148
	{X25VCPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 5}},
#define   X25VCWINDOWSIZEINCOMING  149
	{X25VCWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 6}},
#define   X25VCWINDOWSIZEOUTGOING  150
	{X25VCWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 7}},
#define   X25VCTHROUGHPUTCLASSINCOMING  151
	{X25VCTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 8}},
#define   X25VCTHROUGHPUTCLASSOUTGOING  152
	{X25VCTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 9}},
#define   X25VCDTEOCTETSRECEIVED  153
	{X25VCDTEOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 1}},
#define   X25VCDTEOCTETSSENT    154
	{X25VCDTEOCTETSSENT, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 2}},
#define   X25VCDTEDATAPACKETSRECEIVED  155
	{X25VCDTEDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 3}},
#define   X25VCDTEDATAPACKETSSENT  156
	{X25VCDTEDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 4}},
#define   X25VCDTEDATATIMEOUTS  157
	{X25VCDTEDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 5}},
#define   X25VCDTEINTERRUPTPACKETSRECEIVED  158
	{X25VCDTEINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 6}},
#define   X25VCDTEINTERRUPTPACKETSSENT  159
	{X25VCDTEINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 7}},
#define   X25VCDTEINTERRUPTTIMEOUTS  160
	{X25VCDTEINTERRUPTTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 8}},
#define   X25VCDTEPROVIDERRESETS  161
	{X25VCDTEPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 9}},
#define   X25VCDTEREMOTERESETS  162
	{X25VCDTEREMOTERESETS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 10}},
#define   X25VCDTERESETTIMEOUTS  163
	{X25VCDTERESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 11}},
#define   X25VCDCEOCTETSRECEIVED  164
	{X25VCDCEOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 1}},
#define   X25VCDCEOCTETSSENT    165
	{X25VCDCEOCTETSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 2}},
#define   X25VCDCEDATAPACKETSRECEIVED  166
	{X25VCDCEDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 3}},
#define   X25VCDCEDATAPACKETSSENT  167
	{X25VCDCEDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 4}},
#define   X25VCDCEINTERRUPTPACKETSRECEIVED  168
	{X25VCDCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 5}},
#define   X25VCDCEINTERRUPTPACKETSSENT  169
	{X25VCDCEINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 6}},
#define   X25VCDCEPROVIDERRESETS  170
	{X25VCDCEPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 7}},
#define   X25VCDCEREMOTERESETS  171
	{X25VCDCEREMOTERESETS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 8}},
#define   X25VCDCERESETTIMEOUTS  172
	{X25VCDCERESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 9}},
#define   X25VCDCEREMOTERESTARTS  173
	{X25VCDCEREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 10}},
#define   X25VCDCEPROVIDERDISCONNECTS  174
	{X25VCDCEPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 11}},
#define   X25VCDCEX25SEGMENTSRECEIVED  175
	{X25VCDCEX25SEGMENTSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 12}},
#define   X25VCDCEX25SEGMENTSSENT  176
	{X25VCDCEX25SEGMENTSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 13}},
#define   X25VCDXEOCTETSRECEIVED  177
	{X25VCDXEOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 1}},
#define   X25VCDXEOCTETSSENT    178
	{X25VCDXEOCTETSSENT, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 2}},
#define   X25VCDXEDATAPACKETSRECEIVED  179
	{X25VCDXEDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 3}},
#define   X25VCDXEDATAPACKETSSENT  180
	{X25VCDXEDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 4}},
#define   X25VCDXEDATATIMEOUTS  181
	{X25VCDXEDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 5}},
#define   X25VCDXEINTERRUPTPACKETSRECEIVED  182
	{X25VCDXEINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 6}},
#define   X25VCDXEINTERRUPTPACKETSSENT  183
	{X25VCDXEINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 7}},
#define   X25VCDXEINTERRUPTTIMEOUTS  184
	{X25VCDXEINTERRUPTTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 8}},
#define   X25VCDXEPROVIDERRESETS  185
	{X25VCDXEPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 9}},
#define   X25VCDXEREMOTERESETS  186
	{X25VCDXEREMOTERESETS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 10}},
#define   X25VCDXERESETTIMEOUTS  187
	{X25VCDXERESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 11}},
#define   X25PVCDTELOGICALCHANNEL  188
	{X25PVCDTELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDTETable, 6, {1, 1, 13, 1, 1, 1}},
#define   X25PVCDTEROWSTATUS    189
	{X25PVCDTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PVCDTETable, 6, {1, 1, 13, 1, 1, 2}},
#define   X25PVCDCELOGICALCHANNEL  190
	{X25PVCDCELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 1}},
#define   X25PVCDCECHARGINGDIRECTION  191
	{X25PVCDCECHARGINGDIRECTION, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 2}},
#define   X25PVCDCEOPERATIONALSTATE  192
	{X25PVCDCEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 3}},
#define   X25PVCDCEREMOTEDTEADDRESS  193
	{X25PVCDCEREMOTEDTEADDRESS, ASN_OCTET_STR, RWRITE, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 4}},
#define   X25PVCDCEREMOTELOGICALCHANNEL  194
	{X25PVCDCEREMOTELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 5}},
#define   X25PVCDCEROWSTATUS    195
	{X25PVCDCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 6}},
#define   X25PVCDXELOGICALCHANNEL  196
	{X25PVCDXELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDXETable, 6, {1, 1, 15, 1, 1, 1}},
#define   X25PVCDXEROWSTATUS    197
	{X25PVCDXEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PVCDXETable, 6, {1, 1, 15, 1, 1, 2}},
#define   X25SVCIVMOID          198
	{X25SVCIVMOID, ASN_OCTET_STR, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 1}},
#define   X25SVCIVMOFASTSELECT  199
	{X25SVCIVMOFASTSELECT, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 2}},
#define   X25SVCIVMOPACKETSIZEINCOMING  200
	{X25SVCIVMOPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 3}},
#define   X25SVCIVMOPACKETSIZEOUTGOING  201
	{X25SVCIVMOPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 4}},
#define   X25SVCIVMOREVERSECHARGING  202
	{X25SVCIVMOREVERSECHARGING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 5}},
#define   X25SVCIVMOTHROUGHPUTCLASSINCOMING  203
	{X25SVCIVMOTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 6}},
#define   X25SVCIVMOTHROUGHPUTCLASSOUTGOING  204
	{X25SVCIVMOTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 7}},
#define   X25SVCIVMOWINDOWSIZEINCOMING  205
	{X25SVCIVMOWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 8}},
#define   X25SVCIVMOWINDOWSIZEOUTGOING  206
	{X25SVCIVMOWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 9}},
#define   X25SVCIVMOROWSTATUS   207
	{X25SVCIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 10}},
#define   X25SVCIVMOID          208
	{X25SVCIVMOID, ASN_OCTET_STR, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 16, 1, 1, 1}},
#define   X25SVCIVMODTECALLTIME  209
	{X25SVCIVMODTECALLTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 1}},
#define   X25SVCIVMODTERESETTIME  210
	{X25SVCIVMODTERESETTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 2}},
#define   X25SVCIVMODTERESETCOUNT  211
	{X25SVCIVMODTERESETCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 3}},
#define   X25SVCIVMODTEINTERRUPTTIME  212
	{X25SVCIVMODTEINTERRUPTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 4}},
#define   X25SVCIVMODTECLEARTIME  213
	{X25SVCIVMODTECLEARTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 5}},
#define   X25SVCIVMODTECLEARCOUNT  214
	{X25SVCIVMODTECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 6}},
#define   X25SVCIVMODTEWINDOWTIME  215
	{X25SVCIVMODTEWINDOWTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 7}},
#define   X25SVCIVMODTEDATATIME  216
	{X25SVCIVMODTEDATATIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 8}},
#define   X25SVCIVMODTEDATACOUNT  217
	{X25SVCIVMODTEDATACOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 9}},
#define   X25SVCIVMODTEREJECTTIME  218
	{X25SVCIVMODTEREJECTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 10}},
#define   X25SVCIVMODTEREJECTCOUNT  219
	{X25SVCIVMODTEREJECTCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 11}},
#define   X25SVCIVMODTEROWSTATUS  220
	{X25SVCIVMODTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 17, 1, 1, 12}},
#define   X25SVCIVMOID          221
	{X25SVCIVMOID, ASN_OCTET_STR, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 16, 1, 1, 1}},
#define   X25SVCIVMODXECALLTIME  222
	{X25SVCIVMODXECALLTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 1}},
#define   X25SVCIVMODXERESETTIME  223
	{X25SVCIVMODXERESETTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 2}},
#define   X25SVCIVMODXECLEARTIME  224
	{X25SVCIVMODXECLEARTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 3}},
#define   X25SVCIVMODXEINTERRUPTTIME  225
	{X25SVCIVMODXEINTERRUPTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 4}},
#define   X25SVCIVMODXERESETCOUNT  226
	{X25SVCIVMODXERESETCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 5}},
#define   X25SVCIVMODXECLEARCOUNT  227
	{X25SVCIVMODXECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 6}},
#define   X25SVCIVMODXEROWSTATUS  228
	{X25SVCIVMODXEROWSTATUS, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 7}},
#define   X25SVCIVMODXEWINDOWTIME  229
	{X25SVCIVMODXEWINDOWTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 8}},
#define   X25SVCIVMODXEDATATIME  230
	{X25SVCIVMODXEDATATIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 9}},
#define   X25SVCIVMODXEDATACOUNT  231
	{X25SVCIVMODXEDATACOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 10}},
#define   X25SVCIVMODXEREJECTTIME  232
	{X25SVCIVMODXEREJECTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 12}},
#define   X25SVCIVMODXEREJECTCOUNT  233
	{X25SVCIVMODXEREJECTCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 18, 1, 1, 13}},
#define   X25SVCDTECALLINGADDRESSEXTENSION  234
	{X25SVCDTECALLINGADDRESSEXTENSION,, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 1}},
#define   X25SVCDTECALLEDADDRESSEXTENSION  235
	{X25SVCDTECALLEDADDRESSEXTENSION,, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 2}},
#define   X25SVCDTEDIRECTION    236
	{X25SVCDTEDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 3}},
#define   X25SVCDTEFASTSELECT   237
	{X25SVCDTEFASTSELECT, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 4}},
#define   X25SVCDTEORIGINALLYCALLEDADDRESS  238
	{X25SVCDTEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 5}},
#define   X25SVCDTEREDIRECTREASON  239
	{X25SVCDTEREDIRECTREASON, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 6}},
#define   X25SVCDTEREMOTEDTEADDRESS  240
	{X25SVCDTEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 7}},
#define   X25SVCDTEREVERSECHARGING  241
	{X25SVCDTEREVERSECHARGING, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 8}},
#define   X25SVCDCECHARGINGDIRECTION  242
	{X25SVCDCECHARGINGDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 1}},
#define   X25SVCDCECUGSELECTION  243
	{X25SVCDCECUGSELECTION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 2}},
#define   X25SVCDCEDIRECTION    244
	{X25SVCDCEDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 3}},
#define   X25SVCDCEFASTSELECT   245
	{X25SVCDCEFASTSELECT, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 4}},
#define   X25SVCDCEREMOTEDTEADDRESS  246
	{X25SVCDCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 5}},
#define   X25SVCDCETRANSITDELAYSELECTIONANDINDICATION  247
	{X25SVCDCETRANSITDELAYSELECTIONANDINDICATION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 6}},
#define   X25SVCDXEDIRECTION    248
	{X25SVCDXEDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 1}},
#define   X25SVCDXEREMOTEDTEADDRESS  249
	{X25SVCDXEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 2}},
#define   X25SVCDXEFASTSELECT   250
	{X25SVCDXEFASTSELECT, ASN_INTEGER, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 4}},
#define   X25SVCDXEREDIRECTREASON  251
	{X25SVCDXEREDIRECTREASON, ASN_INTEGER, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 5}},
#define   X25SVCDXEORIGINALLYCALLEDADDRESS  252
	{X25SVCDXEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 6}},
#define   X25SVCDXECALLINGADDRESSEXTENSION  253
	{X25SVCDXECALLINGADDRESSEXTENSION,, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 7}},
#define   X25SVCDXECALLEDADDRESSEXTENSION  254
	{X25SVCDXECALLEDADDRESSEXTENSION,, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 8}},
#define   X25DSCID              255
	{X25DSCID, ASN_OCTET_STR, RONLY, var_x25DSCTable, 6, {1, 1, 22, 1, 1, 1}},
#define   X25DSCRESETREQUESTINDICATIONPACKETS  256
	{X25DSCRESETREQUESTINDICATIONPACKETS, ASN_COUNTER64, RONLY, var_x25DSCTable, 6, {1, 1, 22, 1, 1, 2}},
#define   X25DSCSEGMENTSSENT    257
	{X25DSCSEGMENTSSENT, ASN_COUNTER64, RONLY, var_x25DSCTable, 6, {1, 1, 22, 1, 1, 3}},
#define   X25DSCSEGMENTSRECEIVED  258
	{X25DSCSEGMENTSRECEIVED, ASN_COUNTER64, RONLY, var_x25DSCTable, 6, {1, 1, 22, 1, 1, 4}},
#define   X25PLEDTESTATSCALLATTEMPTS  259
	{X25PLEDTESTATSCALLATTEMPTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 1}},
#define   X25PLEDTESTATSPROTOCOLERRORSDETECTEDLOCALLY  260
	{X25PLEDTESTATSPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 2}},
#define   X25PLEDTESTATSPROTOCOLERRORSACCUSEDOF  261
	{X25PLEDTESTATSPROTOCOLERRORSACCUSEDOF, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 3}},
#define   X25PLEDTESTATSCALLCOUNTSEXCEEDED  262
	{X25PLEDTESTATSCALLCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 4}},
#define   X25PLEDTESTATSOCTETSRECEIVED  263
	{X25PLEDTESTATSOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 5}},
#define   X25PLEDTESTATSOCTETSSENT  264
	{X25PLEDTESTATSOCTETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 6}},
#define   X25PLEDTESTATSCALLTIMEOUTS  265
	{X25PLEDTESTATSCALLTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 7}},
#define   X25PLEDTESTATSCALLSCONNECTED  266
	{X25PLEDTESTATSCALLSCONNECTED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 8}},
#define   X25PLEDTESTATSDATAPACKETSRECEIVED  267
	{X25PLEDTESTATSDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 9}},
#define   X25PLEDTESTATSDATAPACKETSSENT  268
	{X25PLEDTESTATSDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 10}},
#define   X25PLEDTESTATSDATATIMEOUTS  269
	{X25PLEDTESTATSDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 11}},
#define   X25PLEDTESTATSPROVIDERRESETS  270
	{X25PLEDTESTATSPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 12}},
#define   X25PLEDTESTATSPROVIDERDISCONNECTS  271
	{X25PLEDTESTATSPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 13}},
#define   X25PLEDTESTATSREMOTERESETS  272
	{X25PLEDTESTATSREMOTERESETS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 14}},
#define   X25PLEDTESTATSREMOTERESTARTS  273
	{X25PLEDTESTATSREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 15}},
#define   X25PLEDTESTATSRESETTIMEOUTS  274
	{X25PLEDTESTATSRESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 16}},
#define   X25PLEDTESTATSRESTARTCOUNTSEXCEEDED  275
	{X25PLEDTESTATSRESTARTCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 17}},
#define   X25PLEDTESTATSCLEARTIMEOUTS  276
	{X25PLEDTESTATSCLEARTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 18}},
#define   X25PLEDTESTATSCLEARCOUNTSEXCEEDED  277
	{X25PLEDTESTATSCLEARCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6, {1, 1, 23, 1, 1, 19}},
#define   X25PLEDCESTATSCALLATTEMPTS  278
	{X25PLEDCESTATSCALLATTEMPTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 1}},
#define   X25PLEDCESTATSCALLSCONNECTED  279
	{X25PLEDCESTATSCALLSCONNECTED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 2}},
#define   X25PLEDCESTATSOCTETSRECEIVED  280
	{X25PLEDCESTATSOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 3}},
#define   X25PLEDCESTATSOCTETSSENT  281
	{X25PLEDCESTATSOCTETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 4}},
#define   X25PLEDCESTATSDATAPACKETSRECEIVED  282
	{X25PLEDCESTATSDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 5}},
#define   X25PLEDCESTATSDATAPACKETSSENT  283
	{X25PLEDCESTATSDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 6}},
#define   X25PLEDCESTATSINTERRUPTPACKETSRECEIVED  284
	{X25PLEDCESTATSINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 7}},
#define   X25PLEDCESTATSINTERRUPTPACKETSSENT  285
	{X25PLEDCESTATSINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 8}},
#define   X25PLEDCESTATSPROVIDERRESETS  286
	{X25PLEDCESTATSPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 9}},
#define   X25PLEDCESTATSPROVIDERDISCONNECTS  287
	{X25PLEDCESTATSPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 10}},
#define   X25PLEDCESTATSREMOTERESETS  288
	{X25PLEDCESTATSREMOTERESETS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 11}},
#define   X25PLEDCESTATSREMOTERESTARTS  289
	{X25PLEDCESTATSREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 12}},
#define   X25PLEDCESTATSRESETTIMEOUTS  290
	{X25PLEDCESTATSRESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 13}},
#define   X25PLEDCESTATSX25SEGMENTSRECEIVED  291
	{X25PLEDCESTATSX25SEGMENTSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 14}},
#define   X25PLEDCESTATSX25SEGMENTSSENT  292
	{X25PLEDCESTATSX25SEGMENTSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6, {1, 1, 24, 1, 1, 15}},
#define   X25PLEDXESTATSCALLATTEMPTS  293
	{X25PLEDXESTATSCALLATTEMPTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 1}},
#define   X25PLEDXESTATSPROTOCOLERRORSDETECTEDLOCALLY  294
	{X25PLEDXESTATSPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 2}},
#define   X25PLEDXESTATSPROTOCOLERRORSACCUSEDOF  295
	{X25PLEDXESTATSPROTOCOLERRORSACCUSEDOF, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 3}},
#define   X25PLEDXESTATSCALLCOUNTSEXCEEDED  296
	{X25PLEDXESTATSCALLCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 4}},
#define   X25PLEDXESTATSOCTETSRECEIVED  297
	{X25PLEDXESTATSOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 5}},
#define   X25PLEDXESTATSOCTETSSENT  298
	{X25PLEDXESTATSOCTETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 6}},
#define   X25PLEDXESTATSCALLTIMEOUTS  299
	{X25PLEDXESTATSCALLTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 7}},
#define   X25PLEDXESTATSCALLSCONNECTED  300
	{X25PLEDXESTATSCALLSCONNECTED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 8}},
#define   X25PLEDXESTATSCLEARTIMEOUTS  301
	{X25PLEDXESTATSCLEARTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 9}},
#define   X25PLEDXESTATSDATAPACKETSRECEIVED  302
	{X25PLEDXESTATSDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 10}},
#define   X25PLEDXESTATSDATAPACKETSSENT  303
	{X25PLEDXESTATSDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 11}},
#define   X25PLEDXESTATSDATATIMEOUTS  304
	{X25PLEDXESTATSDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 12}},
#define   X25PLEDXESTATSPROVIDERRESETS  305
	{X25PLEDXESTATSPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 13}},
#define   X25PLEDXESTATSPROVIDERDISCONNECTS  306
	{X25PLEDXESTATSPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 14}},
#define   X25PLEDXESTATSREMOTERESETS  307
	{X25PLEDXESTATSREMOTERESETS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 15}},
#define   X25PLEDXESTATSREMOTERESTARTS  308
	{X25PLEDXESTATSREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 16}},
#define   X25PLEDXESTATSRESETTIMEOUTS  309
	{X25PLEDXESTATSRESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 17}},
#define   X25PLEDXESTATSRESTARTCOUNTSEXCEEDED  310
	{X25PLEDXESTATSRESTARTCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 18}},
#define   X25PLEDXESTATSCLEARCOUNTSEXCEEDED  311
	{X25PLEDXESTATSCLEARCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6, {1, 1, 25, 1, 1, 19}},
#define   NOTIFICATIONDATACHANNEL  311
	{NOTIFICATIONDATACHANNEL, ASN_INTEGER,, var_x25PLPMIB, 2, {2, 1}},
#define   NOTIFICATIONDATAPACKETHEADER  311
	{NOTIFICATIONDATAPACKETHEADER, ASN_OCTET_STR,, var_x25PLPMIB, 2, {2, 2}},
#define   NOTIFICATIONDATADIAGNOSTICCODE  311
	{NOTIFICATIONDATADIAGNOSTICCODE, ASN_OCTET_STR,, var_x25PLPMIB, 2, {2, 3}},
#define   NOTIFICATIONDATACAUSECODE  311
	{NOTIFICATIONDATACAUSECODE, ASN_OCTET_STR,, var_x25PLPMIB, 2, {2, 4}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_x25MIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_x25MIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("x25MIB_simple", x25MIB_simple_variables, variable7, x25MIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_x25MIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_x25MIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEADMINISTRATIVESTATE:
		*write_method = write_x25PLEAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEPROTOCOLVERSIONSSUPPORTED:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLELOCALDTEADDRESS:
		*write_method = write_x25PLELocalDTEAddress;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEINTERFACEMODE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEFACILITYNONNEGOTIABLE:
		*write_method = write_x25PLEFacilityNonNegotiable;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEFACILITYAVAILABILITY:
		*write_method = write_x25PLEFacilityAvailability;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEFACILITYNEGOTIATION:
		*write_method = write_x25PLEFacilityNegotiation;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEFACILITYWHILEIDLE:
		*write_method = write_x25PLEFacilityWhileIdle;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEPACKETSEQUENCENUMBERING:
		*write_method = write_x25PLEPacketSequenceNumbering;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDEFAULTPACKETSIZEINCOMING:
		*write_method = write_x25PLEDefaultPacketSizeIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDEFAULTPACKETSIZEOUTGOING:
		*write_method = write_x25PLEDefaultPacketSizeOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDEFAULTWINDOWSIZEINCOMING:
		*write_method = write_x25PLEDefaultWindowSizeIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDEFAULTWINDOWSIZEOUTGOING:
		*write_method = write_x25PLEDefaultWindowSizeOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25PLEDefaultThroughputClassIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25PLEDefaultThroughputClassOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLESNSERVICEPROVIDER:
		*write_method = write_x25PLESNServiceProvider;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case X25PLESNSAP:
		*write_method = write_x25PLESNSAP;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case X25PLELOGICALCHANNELASSIGNMENTHIC:
		*write_method = write_x25PLELogicalChannelAssignmentHIC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLELOGICALCHANNELASSIGNMENTLIC:
		*write_method = write_x25PLELogicalChannelAssignmentLIC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLELOGICALCHANNELASSIGNMENTHTC:
		*write_method = write_x25PLELogicalChannelAssignmentHTC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLELOGICALCHANNELASSIGNMENTLTC:
		*write_method = write_x25PLELogicalChannelAssignmentLTC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLELOGICALCHANNELASSIGNMENTHOC:
		*write_method = write_x25PLELogicalChannelAssignmentHOC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLELOGICALCHANNELASSIGNMENTLOC:
		*write_method = write_x25PLELogicalChannelAssignmentLOC;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLEIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEIVMOINTERFACEMODE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODEFAULTPACKETSIZEINCOMING:
		*write_method = write_x25PLEIVMODefaultPacketSizeIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODEFAULTPACKETSIZEOUTGOING:
		*write_method = write_x25PLEIVMODefaultPacketSizeOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25PLEIVMODefaultThroughputClassIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25PLEIVMODefaultThroughputClassOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODEFAULTWINDOWSIZEINCOMING:
		*write_method = write_x25PLEIVMODefaultWindowSizeIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODEFAULTWINDOWSIZEOUTGOING:
		*write_method = write_x25PLEIVMODefaultWindowSizeOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION:
		*write_method = write_x25PLEIVMOFlowControlParameterNegotiation;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOLOCALDTEADDRESS:
		*write_method = write_x25PLEIVMOLocalDTEAddress;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHPC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHPC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLPC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLPC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHIC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHIC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLIC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLIC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHTC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHTC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLTC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLTC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHOC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHOC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLOC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLOC;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMOSNSERVICEPROVIDER:
		*write_method = write_x25PLEIVMOSNServiceProvider;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION:
		*write_method = write_x25PLEIVMOThroughputClassNegotiation;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEDTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLEDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEDTEPACKETSEQUENCING:
		*write_method = write_x25PLEDTEPacketSequencing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDTEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEDTEMaxActiveCircuits;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEDTECallDeflectionSubscription;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDTERESTARTTIME:
		*write_method = write_x25PLEDTERestartTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDTERESTARTCOUNT:
		*write_method = write_x25PLEDTERestartCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDTEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEDTEMinimumRecallTimer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDTEREGISTRATIONTIME:
		*write_method = write_x25PLEDTERegistrationTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDTEREGISTRATIONCOUNT:
		*write_method = write_x25PLEDTERegistrationCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDTEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEDTERegistrationPermitted;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDTEPROFILE:
		*write_method = write_x25PLEDTEProfile;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case X25PLEDTEROWSTATUS:
		*write_method = write_x25PLEDTERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEDCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLEDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEDCEPACKETSEQUENCING:
		*write_method = write_x25PLEDCEPacketSequencing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEDCECallDeflectionSubscription;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCECUG:
		*write_method = write_x25PLEDCECUG;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEFASTSELECTACCEPTANCE:
		*write_method = write_x25PLEDCEFastSelectAcceptance;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEINCOMINGCALLSBARRED:
		*write_method = write_x25PLEDCEIncomingCallsBarred;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEONEWAYLOGICALCHANNELOUTGOING:
		*write_method = write_x25PLEDCEOneWayLogicalChannelOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEOUTGOINGCALLSBARRED:
		*write_method = write_x25PLEDCEOutgoingCallsBarred;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEBILATERALCUG:
		*write_method = write_x25PLEDCEBilateralCUG;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS:
		*write_method = write_x25PLEDCEBilateralCUGWithOutgoingAccess;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCECALLREDIRECTION:
		*write_method = write_x25PLEDCECallRedirection;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCECHARGINGINFORMATION:
		*write_method = write_x25PLEDCEChargingInformation;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCECUGWITHINCOMINGACCESS:
		*write_method = write_x25PLEDCECUGWithIncomingAccess;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCECUGWITHOUTGOINGACCESS:
		*write_method = write_x25PLEDCECUGWithOutgoingAccess;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEDBITMODIFICATION:
		*write_method = write_x25PLEDCEDBitModification;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSSUBSCRIPTION:
		*write_method = write_x25PLEDCEDefaultThroughputClassSubscription;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSSUPPORTED:
		*write_method = write_x25PLEDCEDefaultThroughputClassSupported;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25PLEDCEDefaultThroughputClassIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25PLEDCEDefaultThroughputClassOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEHUNTGROUP:
		*write_method = write_x25PLEDCEHuntGroup;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEINCOMINGCALLBARREDWITHINCUG:
		*write_method = write_x25PLEDCEIncomingCallBarredWithinCUG;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCELOCALCHARGINGPREVENTION:
		*write_method = write_x25PLEDCELocalChargingPrevention;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZESUBSCRIPTION:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeSubscription;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeMaximum;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZESUBSCRIPTION:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeSubscription;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEMAXIMUM:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeMaximum;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEINCOMING:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEOUTGOING:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCENUIOVERRIDE:
		*write_method = write_x25PLEDCENUIOverride;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCENUISUBSCRIPTION:
		*write_method = write_x25PLEDCENUISubscription;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEONEWAYLOGICALCHANNELINCOMING:
		*write_method = write_x25PLEDCEOneWayLogicalChannelIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEONLINEFACILITYREGISTRATION:
		*write_method = write_x25PLEDCEOnlineFacilityRegistration;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEOUTGOINGCALLBARREDWITHINCUG:
		*write_method = write_x25PLEDCEOutgoingCallBarredWithinCUG;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEPACKETRETRANSMISSION:
		*write_method = write_x25PLEDCEPacketRetransmission;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEREVERSECHARGINGACCEPTANCE:
		*write_method = write_x25PLEDCEReverseChargingAcceptance;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEROASUBSCRIPTION:
		*write_method = write_x25PLEDCEROASubscription;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCERESTARTINDICATION:
		*write_method = write_x25PLEDCERestartIndication;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCERESTARTCOUNT:
		*write_method = write_x25PLEDCERestartCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEINCOMINGCALL:
		*write_method = write_x25PLEDCEIncomingCall;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCECALLCOUNT:
		*write_method = write_x25PLEDCECallCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCERESETINDICATION:
		*write_method = write_x25PLEDCEResetIndication;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCERESETCOUNT:
		*write_method = write_x25PLEDCEResetCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCECLEARINDICATION:
		*write_method = write_x25PLEDCEClearIndication;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCECLEARCOUNT:
		*write_method = write_x25PLEDCEClearCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDCEPROFILE:
		*write_method = write_x25PLEDCEProfile;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case X25PLEDCEROWSTATUS:
		*write_method = write_x25PLEDCERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEDXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLEDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEDXEPACKETSEQUENCING:
		*write_method = write_x25PLEDXEPacketSequencing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDXEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEDXEMaxActiveCircuits;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDXECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEDXECallDeflectionSubscription;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDXERESTARTTIME:
		*write_method = write_x25PLEDXERestartTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDXERESTARTCOUNT:
		*write_method = write_x25PLEDXERestartCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDXEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEDXEMinimumRecallTimer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDXEREGISTRATIONTIME:
		*write_method = write_x25PLEDXERegistrationTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDXEREGISTRATIONCOUNT:
		*write_method = write_x25PLEDXERegistrationCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDXEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEDXERegistrationPermitted;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEDXEPLECLIENTMONAME:
		*write_method = write_x25PLEDXEPLEClientMOName;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case X25PLEDXEPROFILE:
		*write_method = write_x25PLEDXEProfile;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case X25PLEDXEROWSTATUS:
		*write_method = write_x25PLEDXERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEIVMODTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLEIVMODTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEIVMODTECallDeflectionSubscription;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTECALLTIME:
		*write_method = write_x25PLEIVMODTECallTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTECLEARTIME:
		*write_method = write_x25PLEIVMODTEClearTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTECLEARCOUNT:
		*write_method = write_x25PLEIVMODTEClearCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEPACKETSEQUENCING:
		*write_method = write_x25PLEIVMODTEPacketSequencing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEINTERRUPTTIME:
		*write_method = write_x25PLEIVMODTEInterruptTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEIVMODTEMaxActiveCircuits;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEIVMODTEMinimumRecallTimer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTERESETTIME:
		*write_method = write_x25PLEIVMODTEResetTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTERESETCOUNT:
		*write_method = write_x25PLEIVMODTEResetCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTERESTARTTIME:
		*write_method = write_x25PLEIVMODTERestartTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTERESTARTCOUNT:
		*write_method = write_x25PLEIVMODTERestartCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEWINDOWTIME:
		*write_method = write_x25PLEIVMODTEWindowTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEDATATIME:
		*write_method = write_x25PLEIVMODTEDataTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEDATACOUNT:
		*write_method = write_x25PLEIVMODTEDataCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEREJECTTIME:
		*write_method = write_x25PLEIVMODTERejectTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEREJECTCOUNT:
		*write_method = write_x25PLEIVMODTERejectCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEREGISTRATIONTIME:
		*write_method = write_x25PLEIVMODTERegistrationTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEREGISTRATIONCOUNT:
		*write_method = write_x25PLEIVMODTERegistrationCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEIVMODTERegistrationPermitted;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEROWSTATUS:
		*write_method = write_x25PLEIVMODTERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEIVMODCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLEIVMODCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEIVMODCEROWSTATUS:
		*write_method = write_x25PLEIVMODCERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEIVMODXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLEIVMODXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEIVMODTECallDeflectionSubscription;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEIVMODTEMaxActiveCircuits;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTERESTARTTIME:
		*write_method = write_x25PLEIVMODTERestartTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEIVMODTEMinimumRecallTimer;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTERESTARTCOUNT:
		*write_method = write_x25PLEIVMODTERestartCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEPACKETSEQUENCING:
		*write_method = write_x25PLEIVMODTEPacketSequencing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEREGISTRATIONTIME:
		*write_method = write_x25PLEIVMODTERegistrationTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEREGISTRATIONCOUNT:
		*write_method = write_x25PLEIVMODTERegistrationCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PLEIVMODTEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEIVMODTERegistrationPermitted;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25VCTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25VCTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25VCLOGICALCHANNEL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25VCPACKETSEQUENCING:
		*write_method = write_x25VCPacketSequencing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25VCPACKETSIZEINCOMING:
		*write_method = write_x25VCPacketSizeIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25VCPACKETSIZEOUTGOING:
		*write_method = write_x25VCPacketSizeOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25VCWINDOWSIZEINCOMING:
		*write_method = write_x25VCWindowSizeIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25VCWINDOWSIZEOUTGOING:
		*write_method = write_x25VCWindowSizeOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25VCTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25VCThroughputClassIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25VCTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25VCThroughputClassOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25VCDTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25VCDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25VCDTEOCTETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDTEOCTETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDTEDATAPACKETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDTEDATAPACKETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDTEDATATIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDTEINTERRUPTPACKETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDTEINTERRUPTPACKETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDTEINTERRUPTTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDTEPROVIDERRESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDTEREMOTERESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDTERESETTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25VCDCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25VCDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25VCDCEOCTETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEOCTETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEDATAPACKETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEDATAPACKETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEINTERRUPTPACKETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEINTERRUPTPACKETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEPROVIDERRESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEREMOTERESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCERESETTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEREMOTERESTARTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEPROVIDERDISCONNECTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEX25SEGMENTSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDCEX25SEGMENTSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25VCDXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25VCDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25VCDXEOCTETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDXEOCTETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDXEDATAPACKETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDXEDATAPACKETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDXEDATATIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDXEINTERRUPTPACKETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDXEINTERRUPTPACKETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDXEINTERRUPTTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDXEPROVIDERRESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDXEREMOTERESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25VCDXERESETTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PVCDTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PVCDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PVCDTELOGICALCHANNEL:
		*write_method = write_x25PVCDTELogicalChannel;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PVCDTEROWSTATUS:
		*write_method = write_x25PVCDTERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PVCDCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PVCDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PVCDCELOGICALCHANNEL:
		*write_method = write_x25PVCDCELogicalChannel;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PVCDCECHARGINGDIRECTION:
		*write_method = write_x25PVCDCEChargingDirection;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PVCDCEOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PVCDCEREMOTEDTEADDRESS:
		*write_method = write_x25PVCDCERemoteDTEAddress;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25PVCDCEREMOTELOGICALCHANNEL:
		*write_method = write_x25PVCDCERemoteLogicalChannel;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PVCDCEROWSTATUS:
		*write_method = write_x25PVCDCERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PVCDXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PVCDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PVCDXELOGICALCHANNEL:
		*write_method = write_x25PVCDXELogicalChannel;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25PVCDXEROWSTATUS:
		*write_method = write_x25PVCDXERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25SVCIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25SVCIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25SVCIVMOID:
		*write_method = write_x25SVCIVMOId;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25SVCIVMOFASTSELECT:
		*write_method = write_x25SVCIVMOFastSelect;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMOPACKETSIZEINCOMING:
		*write_method = write_x25SVCIVMOPacketSizeIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMOPACKETSIZEOUTGOING:
		*write_method = write_x25SVCIVMOPacketSizeOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMOREVERSECHARGING:
		*write_method = write_x25SVCIVMOReverseCharging;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMOTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25SVCIVMOThroughputClassIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMOTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25SVCIVMOThroughputClassOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMOWINDOWSIZEINCOMING:
		*write_method = write_x25SVCIVMOWindowSizeIncoming;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMOWINDOWSIZEOUTGOING:
		*write_method = write_x25SVCIVMOWindowSizeOutgoing;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMOROWSTATUS:
		*write_method = write_x25SVCIVMORowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25SVCIVMODTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25SVCIVMODTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25SVCIVMOID:
		*write_method = write_x25SVCIVMOId;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25SVCIVMODTECALLTIME:
		*write_method = write_x25SVCIVMODTECallTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTERESETTIME:
		*write_method = write_x25SVCIVMODTEResetTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTERESETCOUNT:
		*write_method = write_x25SVCIVMODTEResetCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTEINTERRUPTTIME:
		*write_method = write_x25SVCIVMODTEInterruptTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTECLEARTIME:
		*write_method = write_x25SVCIVMODTEClearTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTECLEARCOUNT:
		*write_method = write_x25SVCIVMODTEClearCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTEWINDOWTIME:
		*write_method = write_x25SVCIVMODTEWindowTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTEDATATIME:
		*write_method = write_x25SVCIVMODTEDataTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTEDATACOUNT:
		*write_method = write_x25SVCIVMODTEDataCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTEREJECTTIME:
		*write_method = write_x25SVCIVMODTERejectTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTEREJECTCOUNT:
		*write_method = write_x25SVCIVMODTERejectCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODTEROWSTATUS:
		*write_method = write_x25SVCIVMODTERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25SVCIVMODXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25SVCIVMODXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25SVCIVMOID:
		*write_method = write_x25SVCIVMOId;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25SVCIVMODXECALLTIME:
		*write_method = write_x25SVCIVMODXECallTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXERESETTIME:
		*write_method = write_x25SVCIVMODXEResetTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXECLEARTIME:
		*write_method = write_x25SVCIVMODXEClearTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXEINTERRUPTTIME:
		*write_method = write_x25SVCIVMODXEInterruptTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXERESETCOUNT:
		*write_method = write_x25SVCIVMODXEResetCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXECLEARCOUNT:
		*write_method = write_x25SVCIVMODXEClearCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXEROWSTATUS:
		*write_method = write_x25SVCIVMODXERowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXEWINDOWTIME:
		*write_method = write_x25SVCIVMODXEWindowTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXEDATATIME:
		*write_method = write_x25SVCIVMODXEDataTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXEDATACOUNT:
		*write_method = write_x25SVCIVMODXEDataCount;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXEREJECTTIME:
		*write_method = write_x25SVCIVMODXERejectTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCIVMODXEREJECTCOUNT:
		*write_method = write_x25SVCIVMODXERejectCount;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25SVCDTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25SVCDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25SVCDTECALLINGADDRESSEXTENSION:

	case X25SVCDTECALLEDADDRESSEXTENSION:

	case X25SVCDTEDIRECTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCDTEFASTSELECT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCDTEORIGINALLYCALLEDADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25SVCDTEREDIRECTREASON:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCDTEREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25SVCDTEREVERSECHARGING:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25SVCDCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25SVCDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25SVCDCECHARGINGDIRECTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCDCECUGSELECTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCDCEDIRECTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCDCEFASTSELECT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCDCEREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25SVCDCETRANSITDELAYSELECTIONANDINDICATION:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25SVCDXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25SVCDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25SVCDXEDIRECTION:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCDXEREMOTEDTEADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25SVCDXEFASTSELECT:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCDXEREDIRECTREASON:

		long_ret = 0;
		return (u_char *) &long_ret;
	case X25SVCDXEORIGINALLYCALLEDADDRESS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25SVCDXECALLINGADDRESSEXTENSION:

	case X25SVCDXECALLEDADDRESSEXTENSION:

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25DSCTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25DSCTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25DSCID:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case X25DSCRESETREQUESTINDICATIONPACKETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25DSCSEGMENTSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25DSCSEGMENTSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEDTEStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLEDTEStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEDTESTATSCALLATTEMPTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSPROTOCOLERRORSDETECTEDLOCALLY:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSPROTOCOLERRORSACCUSEDOF:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSCALLCOUNTSEXCEEDED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSOCTETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSOCTETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSCALLTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSCALLSCONNECTED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSDATAPACKETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSDATAPACKETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSDATATIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSPROVIDERRESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSPROVIDERDISCONNECTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSREMOTERESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSREMOTERESTARTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSRESETTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSRESTARTCOUNTSEXCEEDED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSCLEARTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDTESTATSCLEARCOUNTSEXCEEDED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEDCEStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLEDCEStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEDCESTATSCALLATTEMPTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSCALLSCONNECTED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSOCTETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSOCTETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSDATAPACKETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSDATAPACKETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSINTERRUPTPACKETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSINTERRUPTPACKETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSPROVIDERRESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSPROVIDERDISCONNECTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSREMOTERESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSREMOTERESTARTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSRESETTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSX25SEGMENTSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDCESTATSX25SEGMENTSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_x25PLEDXEStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25MIB_simple above.
 */
unsigned char *
var_x25PLEDXEStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case X25PLEDXESTATSCALLATTEMPTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSPROTOCOLERRORSDETECTEDLOCALLY:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSPROTOCOLERRORSACCUSEDOF:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSCALLCOUNTSEXCEEDED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSOCTETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSOCTETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSCALLTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSCALLSCONNECTED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSCLEARTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSDATAPACKETSRECEIVED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSDATAPACKETSSENT:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSDATATIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSPROVIDERRESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSPROVIDERDISCONNECTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSREMOTERESETS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSREMOTERESTARTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSRESETTIMEOUTS:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSRESTARTCOUNTSEXCEEDED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;
	case X25PLEDXESTATSCLEARCOUNTSEXCEEDED:

		c64.high = 0;
		c64.low = 0;
		*var_len = sizeof(c64);
		return (u_char *) &c64;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_x25PLEAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELocalDTEAddress(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to x25PLELocalDTEAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25PLELocalDTEAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEFacilityNonNegotiable(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to x25PLEFacilityNonNegotiable not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25PLEFacilityNonNegotiable: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEFacilityAvailability(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to x25PLEFacilityAvailability not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25PLEFacilityAvailability: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEFacilityNegotiation(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to x25PLEFacilityNegotiation not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25PLEFacilityNegotiation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEFacilityWhileIdle(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to x25PLEFacilityWhileIdle not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25PLEFacilityWhileIdle: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEPacketSequenceNumbering(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEPacketSequenceNumbering not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEPacketSequenceNumbering: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultPacketSizeIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDefaultPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDefaultPacketSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultPacketSizeOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDefaultPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDefaultPacketSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultWindowSizeIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDefaultWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDefaultWindowSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultWindowSizeOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDefaultWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDefaultWindowSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultThroughputClassIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDefaultThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDefaultThroughputClassIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultThroughputClassOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDefaultThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDefaultThroughputClassOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLESNServiceProvider(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to x25PLESNServiceProvider not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to x25PLESNServiceProvider: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLESNSAP(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to x25PLESNSAP not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to x25PLESNSAP: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentHIC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentHIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentHIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentLIC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentLIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentLIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentHTC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentHTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentHTC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentLTC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentLTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentLTC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentHOC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentHOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentHOC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentLOC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentLOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLELogicalChannelAssignmentLOC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultPacketSizeIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODefaultPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODefaultPacketSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultPacketSizeOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODefaultPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODefaultPacketSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultThroughputClassIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODefaultThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODefaultThroughputClassIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultThroughputClassOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODefaultThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODefaultThroughputClassOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultWindowSizeIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODefaultWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODefaultWindowSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultWindowSizeOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODefaultWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODefaultWindowSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOFlowControlParameterNegotiation(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMOFlowControlParameterNegotiation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMOFlowControlParameterNegotiation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLocalDTEAddress(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to x25PLEIVMOLocalDTEAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25PLEIVMOLocalDTEAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentHPC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentHPC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentHPC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentLPC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentLPC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentLPC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentHIC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentHIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentHIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentLIC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentLIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentLIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentHTC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentHTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentHTC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentLTC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentLTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentLTC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentHOC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentHOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentHOC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentLOC(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentLOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMOLogicalChannelAssignmentLOC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOSNServiceProvider(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to x25PLEIVMOSNServiceProvider not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to x25PLEIVMOSNServiceProvider: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOThroughputClassNegotiation(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMOThroughputClassNegotiation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMOThroughputClassNegotiation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTEPacketSequencing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDTEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDTEPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTEMaxActiveCircuits(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDTEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDTEMaxActiveCircuits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTECallDeflectionSubscription(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDTECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDTECallDeflectionSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERestartTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDTERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDTERestartTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERestartCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDTERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDTERestartCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTEMinimumRecallTimer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDTEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDTEMinimumRecallTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERegistrationTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDTERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDTERegistrationTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERegistrationCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDTERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDTERegistrationCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERegistrationPermitted(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDTERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDTERegistrationPermitted: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTEProfile(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to x25PLEDTEProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to x25PLEDTEProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDTERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDTERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEPacketSequencing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECallDeflectionSubscription(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCECallDeflectionSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECUG(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCECUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCECUG: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEFastSelectAcceptance(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEFastSelectAcceptance not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEFastSelectAcceptance: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEIncomingCallsBarred(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEIncomingCallsBarred not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEIncomingCallsBarred: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEOneWayLogicalChannelOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEOneWayLogicalChannelOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEOneWayLogicalChannelOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEOutgoingCallsBarred(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEOutgoingCallsBarred not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEOutgoingCallsBarred: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEBilateralCUG(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEBilateralCUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEBilateralCUG: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEBilateralCUGWithOutgoingAccess(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEBilateralCUGWithOutgoingAccess not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEBilateralCUGWithOutgoingAccess: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECallRedirection(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCECallRedirection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCECallRedirection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEChargingInformation(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEChargingInformation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEChargingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECUGWithIncomingAccess(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCECUGWithIncomingAccess not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCECUGWithIncomingAccess: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECUGWithOutgoingAccess(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCECUGWithOutgoingAccess not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCECUGWithOutgoingAccess: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEDBitModification(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEDBitModification not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEDBitModification: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEDefaultThroughputClassSubscription(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEDefaultThroughputClassSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEDefaultThroughputClassSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEDefaultThroughputClassSupported(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to x25PLEDCEDefaultThroughputClassSupported not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25PLEDCEDefaultThroughputClassSupported: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEDefaultThroughputClassIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEDefaultThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEDefaultThroughputClassIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEDefaultThroughputClassOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEDefaultThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEDefaultThroughputClassOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEHuntGroup(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEHuntGroup not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEHuntGroup: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEIncomingCallBarredWithinCUG(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEIncomingCallBarredWithinCUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEIncomingCallBarredWithinCUG: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCELocalChargingPrevention(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCELocalChargingPrevention not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCELocalChargingPrevention: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultPacketSizeSubscription(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultPacketSizeSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultPacketSizeSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultPacketSizeMaximum(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultPacketSizeMaximum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultPacketSizeMaximum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultPacketSizeIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultPacketSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultPacketSizeOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultPacketSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultWindowSizeSubscription(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultWindowSizeSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultWindowSizeSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultWindowSizeMaximum(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultWindowSizeMaximum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultWindowSizeMaximum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultWindowSizeIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultWindowSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultWindowSizeOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCENonStandardDefaultWindowSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENUIOverride(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCENUIOverride not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCENUIOverride: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENUISubscription(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCENUISubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCENUISubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEOneWayLogicalChannelIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEOneWayLogicalChannelIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEOneWayLogicalChannelIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEOnlineFacilityRegistration(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEOnlineFacilityRegistration not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEOnlineFacilityRegistration: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEOutgoingCallBarredWithinCUG(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEOutgoingCallBarredWithinCUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEOutgoingCallBarredWithinCUG: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEPacketRetransmission(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEPacketRetransmission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEPacketRetransmission: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEReverseChargingAcceptance(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEReverseChargingAcceptance not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEReverseChargingAcceptance: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEROASubscription(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEROASubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEROASubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCERestartIndication(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCERestartIndication not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCERestartIndication: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCERestartCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCERestartCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEIncomingCall(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEIncomingCall not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEIncomingCall: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECallCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCECallCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCECallCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEResetIndication(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEResetIndication not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEResetIndication: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEResetCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEResetCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEClearIndication(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEClearIndication not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEClearIndication: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEClearCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCEClearCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEProfile(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to x25PLEDCEProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to x25PLEDCEProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDCERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDCERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXEPacketSequencing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDXEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDXEPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXEMaxActiveCircuits(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDXEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDXEMaxActiveCircuits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXECallDeflectionSubscription(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDXECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDXECallDeflectionSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERestartTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDXERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDXERestartTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERestartCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDXERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDXERestartCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXEMinimumRecallTimer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDXEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDXEMinimumRecallTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERegistrationTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDXERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDXERegistrationTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERegistrationCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDXERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDXERegistrationCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERegistrationPermitted(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDXERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDXERegistrationPermitted: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXEPLEClientMOName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to x25PLEDXEPLEClientMOName not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to x25PLEDXEPLEClientMOName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXEProfile(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to x25PLEDXEProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to x25PLEDXEProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEDXERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEDXERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTECallDeflectionSubscription(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTECallDeflectionSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTECallTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTECallTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTECallTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEClearTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEClearTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEClearTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEClearCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEClearCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEPacketSequencing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEInterruptTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEInterruptTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEInterruptTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEMaxActiveCircuits(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEMaxActiveCircuits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEMinimumRecallTimer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEMinimumRecallTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEResetTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEResetTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEResetTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEResetCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEResetCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERestartTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERestartTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERestartCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERestartCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEWindowTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEWindowTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEDataTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEDataTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEDataTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEDataCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEDataCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEDataCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERejectTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERejectTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERejectTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERejectCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERejectCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERejectCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationPermitted(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationPermitted: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODCERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODCERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODCERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTECallDeflectionSubscription(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTECallDeflectionSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEMaxActiveCircuits(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEMaxActiveCircuits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERestartTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERestartTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEMinimumRecallTimer(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEMinimumRecallTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERestartCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERestartCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEPacketSequencing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTEPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationPermitted(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PLEIVMODTERegistrationPermitted: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCPacketSequencing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25VCPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25VCPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCPacketSizeIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25VCPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25VCPacketSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCPacketSizeOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25VCPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25VCPacketSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCWindowSizeIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25VCWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25VCWindowSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCWindowSizeOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25VCWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25VCWindowSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCThroughputClassIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25VCThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25VCThroughputClassIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCThroughputClassOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25VCThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25VCThroughputClassOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDTELogicalChannel(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PVCDTELogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PVCDTELogicalChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDTERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PVCDTERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PVCDTERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDCELogicalChannel(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PVCDCELogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PVCDCELogicalChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDCEChargingDirection(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PVCDCEChargingDirection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PVCDCEChargingDirection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDCERemoteDTEAddress(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to x25PVCDCERemoteDTEAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25PVCDCERemoteDTEAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDCERemoteLogicalChannel(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PVCDCERemoteLogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PVCDCERemoteLogicalChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDCERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PVCDCERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PVCDCERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDXELogicalChannel(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PVCDXELogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PVCDXELogicalChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDXERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25PVCDXERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25PVCDXERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOId(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to x25SVCIVMOId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25SVCIVMOId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOFastSelect(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMOFastSelect not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMOFastSelect: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOPacketSizeIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMOPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMOPacketSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOPacketSizeOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMOPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMOPacketSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOReverseCharging(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMOReverseCharging not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMOReverseCharging: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOThroughputClassIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMOThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMOThroughputClassIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOThroughputClassOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMOThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMOThroughputClassOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOWindowSizeIncoming(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMOWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMOWindowSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOWindowSizeOutgoing(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMOWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMOWindowSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMORowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMORowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMORowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOId(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to x25SVCIVMOId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25SVCIVMOId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTECallTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTECallTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTECallTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEResetTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTEResetTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTEResetTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEResetCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTEResetCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEInterruptTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTEInterruptTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTEInterruptTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEClearTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTEClearTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTEClearTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEClearCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTEClearCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEWindowTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTEWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTEWindowTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEDataTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTEDataTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTEDataTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEDataCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTEDataCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTEDataCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTERejectTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTERejectTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTERejectTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTERejectCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTERejectCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTERejectCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODTERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODTERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOId(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to x25SVCIVMOId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to x25SVCIVMOId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXECallTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXECallTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXECallTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEResetTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXEResetTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXEResetTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEClearTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXEClearTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXEClearTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEInterruptTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXEInterruptTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXEInterruptTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEResetCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXEResetCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEClearCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXEClearCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXERowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXERowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXERowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEWindowTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXEWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXEWindowTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEDataTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXEDataTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXEDataTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEDataCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXEDataCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXEDataCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXERejectTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXERejectTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXERejectTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXERejectCount(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to x25SVCIVMODXERejectCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to x25SVCIVMODXERejectCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
