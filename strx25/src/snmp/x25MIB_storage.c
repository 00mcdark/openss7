/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "x25MIB_storage.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int x25PLPMIB_refresh = 1;
volatile int x25PLETable_refresh = 1;
volatile int x25PLEIVMOTable_refresh = 1;
volatile int x25PLEDTETable_refresh = 1;
volatile int x25PLEDCETable_refresh = 1;
volatile int x25PLEDXETable_refresh = 1;
volatile int x25PLEIVMODTETable_refresh = 1;
volatile int x25PLEIVMODCETable_refresh = 1;
volatile int x25PLEIVMODXETable_refresh = 1;
volatile int x25VCTable_refresh = 1;
volatile int x25VCDTETable_refresh = 1;
volatile int x25VCDCETable_refresh = 1;
volatile int x25VCDXETable_refresh = 1;
volatile int x25PVCDTETable_refresh = 1;
volatile int x25PVCDCETable_refresh = 1;
volatile int x25PVCDXETable_refresh = 1;
volatile int x25SVCIVMOTable_refresh = 1;
volatile int x25SVCIVMODTETable_refresh = 1;
volatile int x25SVCIVMODXETable_refresh = 1;
volatile int x25SVCDTETable_refresh = 1;
volatile int x25SVCDCETable_refresh = 1;
volatile int x25SVCDXETable_refresh = 1;
volatile int x25DSCTable_refresh = 1;
volatile int x25PLEDTEStatsTable_refresh = 1;
volatile int x25PLEDCEStatsTable_refresh = 1;
volatile int x25PLEDXEStatsTable_refresh = 1;

/*
 * x25PLPMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid x25PLPMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3 };
oid x25PLEDTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 3, 1, 1 };
oid x25PLEDCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 4, 1, 1 };
oid x25PLEDXETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 5, 1, 1 };
oid x25PLEIVMODTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 6, 1, 1 };
oid x25PLEIVMODCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 7, 1, 1 };
oid x25PVCDTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 13, 1, 1 };
oid x25PVCDCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 14, 1, 1 };
oid x25PVCDXETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 15, 1, 1 };
oid x25SVCIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 16, 1, 1 };
oid x25SVCIVMODTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 17, 1, 1 };
oid x25SVCIVMODXETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 18, 1, 1 };

/*
 * variable7 x25PLPMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the x25PLPMIB mib section
 */
struct variable7 x25PLPMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   X25PLEOPERATIONALSTATE  (4 % 256)
	{X25PLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 1, 1, 1, 2}},
#define   X25PLEADMINISTRATIVESTATE  (5 % 256)
	{X25PLEADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 3}},
#define   X25PLEPROTOCOLVERSIONSSUPPORTED  (6 % 256)
	{X25PLEPROTOCOLVERSIONSSUPPORTED, ASN_BIT_STR, RONLY, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 4}},
#define   X25PLELOCALDTEADDRESS  (7 % 256)
	{X25PLELOCALDTEADDRESS, ASN_OCTET_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 5}},
#define   X25PLEINTERFACEMODE   (8 % 256)
	{X25PLEINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 1, 1, 1, 6}},
#define   X25PLEFACILITYNONNEGOTIABLE  (9 % 256)
	{X25PLEFACILITYNONNEGOTIABLE, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 7}},
#define   X25PLEFACILITYAVAILABILITY  (10 % 256)
	{X25PLEFACILITYAVAILABILITY, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 8}},
#define   X25PLEFACILITYNEGOTIATION  (11 % 256)
	{X25PLEFACILITYNEGOTIATION, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 9}},
#define   X25PLEFACILITYWHILEIDLE  (12 % 256)
	{X25PLEFACILITYWHILEIDLE, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 10}},
#define   X25PLEPACKETSEQUENCENUMBERING  (13 % 256)
	{X25PLEPACKETSEQUENCENUMBERING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 11}},
#define   X25PLEDEFAULTPACKETSIZEINCOMING  (14 % 256)
	{X25PLEDEFAULTPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 12}},
#define   X25PLEDEFAULTPACKETSIZEOUTGOING  (15 % 256)
	{X25PLEDEFAULTPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 13}},
#define   X25PLEDEFAULTWINDOWSIZEINCOMING  (16 % 256)
	{X25PLEDEFAULTWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 14}},
#define   X25PLEDEFAULTWINDOWSIZEOUTGOING  (17 % 256)
	{X25PLEDEFAULTWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 15}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSINCOMING  (18 % 256)
	{X25PLEDEFAULTTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 16}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING  (19 % 256)
	{X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 17}},
#define   X25PLESNSERVICEPROVIDER  (20 % 256)
	{X25PLESNSERVICEPROVIDER, ASN_OBJECT_ID, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 18}},
#define   X25PLESNSAP           (21 % 256)
	{X25PLESNSAP, ASN_OBJECT_ID, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 19}},
#define   X25PLELOGICALCHANNELASSIGNMENTHIC  (22 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTHIC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 20}},
#define   X25PLELOGICALCHANNELASSIGNMENTLIC  (23 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTLIC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 21}},
#define   X25PLELOGICALCHANNELASSIGNMENTHTC  (24 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTHTC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 22}},
#define   X25PLELOGICALCHANNELASSIGNMENTLTC  (25 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTLTC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 23}},
#define   X25PLELOGICALCHANNELASSIGNMENTHOC  (26 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTHOC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 24}},
#define   X25PLELOGICALCHANNELASSIGNMENTLOC  (27 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTLOC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 25}},
#define   X25PLEIVMOINTERFACEMODE  (32 % 256)
	{X25PLEIVMOINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 2}},
#define   X25PLEIVMODEFAULTPACKETSIZEINCOMING  (33 % 256)
	{X25PLEIVMODEFAULTPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 3}},
#define   X25PLEIVMODEFAULTPACKETSIZEOUTGOING  (34 % 256)
	{X25PLEIVMODEFAULTPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 4}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING  (35 % 256)
	{X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 5}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING  (36 % 256)
	{X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 6}},
#define   X25PLEIVMODEFAULTWINDOWSIZEINCOMING  (37 % 256)
	{X25PLEIVMODEFAULTWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 7}},
#define   X25PLEIVMODEFAULTWINDOWSIZEOUTGOING  (38 % 256)
	{X25PLEIVMODEFAULTWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 8}},
#define   X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION  (39 % 256)
	{X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 9}},
#define   X25PLEIVMOLOCALDTEADDRESS  (40 % 256)
	{X25PLEIVMOLOCALDTEADDRESS, ASN_OCTET_STR, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 10}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHPC  (41 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHPC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 11}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLPC  (42 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLPC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 12}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHIC  (43 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHIC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 13}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLIC  (44 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLIC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 14}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHTC  (45 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHTC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 15}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLTC  (46 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLTC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 16}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHOC  (47 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHOC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 17}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLOC  (48 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLOC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 18}},
#define   X25PLEIVMOSNSERVICEPROVIDER  (49 % 256)
	{X25PLEIVMOSNSERVICEPROVIDER, ASN_OBJECT_ID, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 19}},
#define   X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION  (50 % 256)
	{X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 20}},
#define   X25PLEDTEPACKETSEQUENCING  (54 % 256)
	{X25PLEDTEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 1}},
#define   X25PLEDTEMAXACTIVECIRCUITS  (55 % 256)
	{X25PLEDTEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6,
	 {1, 1, 3, 1, 1, 2}},
#define   X25PLEDTECALLDEFLECTIONSUBSCRIPTION  (56 % 256)
	{X25PLEDTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6,
	 {1, 1, 3, 1, 1, 3}},
#define   X25PLEDTERESTARTTIME  (57 % 256)
	{X25PLEDTERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 4}},
#define   X25PLEDTERESTARTCOUNT  (58 % 256)
	{X25PLEDTERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 5}},
#define   X25PLEDTEMINIMUMRECALLTIMER  (59 % 256)
	{X25PLEDTEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6,
	 {1, 1, 3, 1, 1, 6}},
#define   X25PLEDTEREGISTRATIONTIME  (60 % 256)
	{X25PLEDTEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 7}},
#define   X25PLEDTEREGISTRATIONCOUNT  (61 % 256)
	{X25PLEDTEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6,
	 {1, 1, 3, 1, 1, 8}},
#define   X25PLEDTEREGISTRATIONPERMITTED  (62 % 256)
	{X25PLEDTEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6,
	 {1, 1, 3, 1, 1, 9}},
#define   X25PLEDTEPROFILE      (63 % 256)
	{X25PLEDTEPROFILE, ASN_OBJECT_ID, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 10}},
#define   X25PLEDTEROWSTATUS    (64 % 256)
	{X25PLEDTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 11}},
#define   X25PLEDCEPACKETSEQUENCING  (68 % 256)
	{X25PLEDCEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 1}},
#define   X25PLEDCECALLDEFLECTIONSUBSCRIPTION  (69 % 256)
	{X25PLEDCECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 2}},
#define   X25PLEDCECUG          (70 % 256)
	{X25PLEDCECUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 3}},
#define   X25PLEDCEFASTSELECTACCEPTANCE  (71 % 256)
	{X25PLEDCEFASTSELECTACCEPTANCE, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 4}},
#define   X25PLEDCEINCOMINGCALLSBARRED  (72 % 256)
	{X25PLEDCEINCOMINGCALLSBARRED, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 5}},
#define   X25PLEDCEONEWAYLOGICALCHANNELOUTGOING  (73 % 256)
	{X25PLEDCEONEWAYLOGICALCHANNELOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 6}},
#define   X25PLEDCEOUTGOINGCALLSBARRED  (74 % 256)
	{X25PLEDCEOUTGOINGCALLSBARRED, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 7}},
#define   X25PLEDCEBILATERALCUG  (75 % 256)
	{X25PLEDCEBILATERALCUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 8}},
#define   X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS  (76 % 256)
	{X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 9}},
#define   X25PLEDCECALLREDIRECTION  (77 % 256)
	{X25PLEDCECALLREDIRECTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 10}},
#define   X25PLEDCECHARGINGINFORMATION  (78 % 256)
	{X25PLEDCECHARGINGINFORMATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 11}},
#define   X25PLEDCECUGWITHINCOMINGACCESS  (79 % 256)
	{X25PLEDCECUGWITHINCOMINGACCESS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 12}},
#define   X25PLEDCECUGWITHOUTGOINGACCESS  (80 % 256)
	{X25PLEDCECUGWITHOUTGOINGACCESS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 13}},
#define   X25PLEDCEDBITMODIFICATION  (81 % 256)
	{X25PLEDCEDBITMODIFICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 14}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSSUBSCRIPTION  (82 % 256)
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 15}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSSUPPORTED  (83 % 256)
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSSUPPORTED, ASN_BIT_STR, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 16}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING  (84 % 256)
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 17}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING  (85 % 256)
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 18}},
#define   X25PLEDCEHUNTGROUP    (86 % 256)
	{X25PLEDCEHUNTGROUP, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 19}},
#define   X25PLEDCEINCOMINGCALLBARREDWITHINCUG  (87 % 256)
	{X25PLEDCEINCOMINGCALLBARREDWITHINCUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 20}},
#define   X25PLEDCELOCALCHARGINGPREVENTION  (88 % 256)
	{X25PLEDCELOCALCHARGINGPREVENTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 21}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZESUBSCRIPTION  (89 % 256)
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZESUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable,
	 6, {1, 1, 4, 1, 1, 22}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM  (90 % 256)
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 23}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING  (91 % 256)
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 24}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING  (92 % 256)
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 25}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZESUBSCRIPTION  (93 % 256)
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZESUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable,
	 6, {1, 1, 4, 1, 1, 26}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEMAXIMUM  (94 % 256)
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEMAXIMUM, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 27}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEINCOMING  (95 % 256)
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 28}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEOUTGOING  (96 % 256)
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 29}},
#define   X25PLEDCENUIOVERRIDE  (97 % 256)
	{X25PLEDCENUIOVERRIDE, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 30}},
#define   X25PLEDCENUISUBSCRIPTION  (98 % 256)
	{X25PLEDCENUISUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 31}},
#define   X25PLEDCEONEWAYLOGICALCHANNELINCOMING  (99 % 256)
	{X25PLEDCEONEWAYLOGICALCHANNELINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 32}},
#define   X25PLEDCEONLINEFACILITYREGISTRATION  (100 % 256)
	{X25PLEDCEONLINEFACILITYREGISTRATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 33}},
#define   X25PLEDCEOUTGOINGCALLBARREDWITHINCUG  (101 % 256)
	{X25PLEDCEOUTGOINGCALLBARREDWITHINCUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 34}},
#define   X25PLEDCEPACKETRETRANSMISSION  (102 % 256)
	{X25PLEDCEPACKETRETRANSMISSION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 35}},
#define   X25PLEDCEREVERSECHARGINGACCEPTANCE  (103 % 256)
	{X25PLEDCEREVERSECHARGINGACCEPTANCE, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 36}},
#define   X25PLEDCEROASUBSCRIPTION  (104 % 256)
	{X25PLEDCEROASUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 37}},
#define   X25PLEDCERESTARTINDICATION  (105 % 256)
	{X25PLEDCERESTARTINDICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 38}},
#define   X25PLEDCERESTARTCOUNT  (106 % 256)
	{X25PLEDCERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 39}},
#define   X25PLEDCEINCOMINGCALL  (107 % 256)
	{X25PLEDCEINCOMINGCALL, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 40}},
#define   X25PLEDCECALLCOUNT    (108 % 256)
	{X25PLEDCECALLCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 41}},
#define   X25PLEDCERESETINDICATION  (109 % 256)
	{X25PLEDCERESETINDICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 42}},
#define   X25PLEDCERESETCOUNT   (110 % 256)
	{X25PLEDCERESETCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 43}},
#define   X25PLEDCECLEARINDICATION  (111 % 256)
	{X25PLEDCECLEARINDICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 44}},
#define   X25PLEDCECLEARCOUNT   (112 % 256)
	{X25PLEDCECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 45}},
#define   X25PLEDCEPROFILE      (113 % 256)
	{X25PLEDCEPROFILE, ASN_OBJECT_ID, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 46}},
#define   X25PLEDCEROWSTATUS    (114 % 256)
	{X25PLEDCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 47}},
#define   X25PLEDXEPACKETSEQUENCING  (118 % 256)
	{X25PLEDXEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 1}},
#define   X25PLEDXEMAXACTIVECIRCUITS  (119 % 256)
	{X25PLEDXEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 2}},
#define   X25PLEDXECALLDEFLECTIONSUBSCRIPTION  (120 % 256)
	{X25PLEDXECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 3}},
#define   X25PLEDXERESTARTTIME  (121 % 256)
	{X25PLEDXERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 4}},
#define   X25PLEDXERESTARTCOUNT  (122 % 256)
	{X25PLEDXERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 5}},
#define   X25PLEDXEMINIMUMRECALLTIMER  (123 % 256)
	{X25PLEDXEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 6}},
#define   X25PLEDXEREGISTRATIONTIME  (124 % 256)
	{X25PLEDXEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 7}},
#define   X25PLEDXEREGISTRATIONCOUNT  (125 % 256)
	{X25PLEDXEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 8}},
#define   X25PLEDXEREGISTRATIONPERMITTED  (126 % 256)
	{X25PLEDXEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 9}},
#define   X25PLEDXEPLECLIENTMONAME  (127 % 256)
	{X25PLEDXEPLECLIENTMONAME, ASN_OBJECT_ID, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 10}},
#define   X25PLEDXEPROFILE      (128 % 256)
	{X25PLEDXEPROFILE, ASN_OBJECT_ID, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 11}},
#define   X25PLEDXEROWSTATUS    (129 % 256)
	{X25PLEDXEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 12}},
#define   X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION  (134 % 256)
	{X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 1}},
#define   X25PLEIVMODTECALLTIME  (135 % 256)
	{X25PLEIVMODTECALLTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 2}},
#define   X25PLEIVMODTECLEARTIME  (136 % 256)
	{X25PLEIVMODTECLEARTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 3}},
#define   X25PLEIVMODTECLEARCOUNT  (137 % 256)
	{X25PLEIVMODTECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 4}},
#define   X25PLEIVMODTEPACKETSEQUENCING  (138 % 256)
	{X25PLEIVMODTEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 5}},
#define   X25PLEIVMODTEINTERRUPTTIME  (139 % 256)
	{X25PLEIVMODTEINTERRUPTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 6}},
#define   X25PLEIVMODTEMAXACTIVECIRCUITS  (140 % 256)
	{X25PLEIVMODTEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 7}},
#define   X25PLEIVMODTEMINIMUMRECALLTIMER  (141 % 256)
	{X25PLEIVMODTEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 8}},
#define   X25PLEIVMODTERESETTIME  (142 % 256)
	{X25PLEIVMODTERESETTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 9}},
#define   X25PLEIVMODTERESETCOUNT  (143 % 256)
	{X25PLEIVMODTERESETCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 10}},
#define   X25PLEIVMODTERESTARTTIME  (144 % 256)
	{X25PLEIVMODTERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 11}},
#define   X25PLEIVMODTERESTARTCOUNT  (145 % 256)
	{X25PLEIVMODTERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 12}},
#define   X25PLEIVMODTEWINDOWTIME  (146 % 256)
	{X25PLEIVMODTEWINDOWTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 13}},
#define   X25PLEIVMODTEDATATIME  (147 % 256)
	{X25PLEIVMODTEDATATIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 14}},
#define   X25PLEIVMODTEDATACOUNT  (148 % 256)
	{X25PLEIVMODTEDATACOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 15}},
#define   X25PLEIVMODTEREJECTTIME  (149 % 256)
	{X25PLEIVMODTEREJECTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 16}},
#define   X25PLEIVMODTEREJECTCOUNT  (150 % 256)
	{X25PLEIVMODTEREJECTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 17}},
#define   X25PLEIVMODTEREGISTRATIONTIME  (151 % 256)
	{X25PLEIVMODTEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 18}},
#define   X25PLEIVMODTEREGISTRATIONCOUNT  (152 % 256)
	{X25PLEIVMODTEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 19}},
#define   X25PLEIVMODTEREGISTRATIONPERMITTED  (153 % 256)
	{X25PLEIVMODTEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 20}},
#define   X25PLEIVMODTEROWSTATUS  (154 % 256)
	{X25PLEIVMODTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 21}},
#define   X25PLEIVMODCEROWSTATUS  (159 % 256)
	{X25PLEIVMODCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMODCETable, 6,
	 {1, 1, 7, 1, 1, 1}},
#define   X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION  (164 % 256)
	{X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 1}},
#define   X25PLEIVMODTEMAXACTIVECIRCUITS  (165 % 256)
	{X25PLEIVMODTEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 2}},
#define   X25PLEIVMODTERESTARTTIME  (166 % 256)
	{X25PLEIVMODTERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 3}},
#define   X25PLEIVMODTEMINIMUMRECALLTIMER  (167 % 256)
	{X25PLEIVMODTEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 4}},
#define   X25PLEIVMODTERESTARTCOUNT  (168 % 256)
	{X25PLEIVMODTERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 5}},
#define   X25PLEIVMODTEPACKETSEQUENCING  (169 % 256)
	{X25PLEIVMODTEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 6}},
#define   X25PLEIVMODTEREGISTRATIONTIME  (170 % 256)
	{X25PLEIVMODTEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 7}},
#define   X25PLEIVMODTEREGISTRATIONCOUNT  (171 % 256)
	{X25PLEIVMODTEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 8}},
#define   X25PLEIVMODTEREGISTRATIONPERMITTED  (172 % 256)
	{X25PLEIVMODTEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 9}},
#define   X25VCLOGICALCHANNEL   (177 % 256)
	{X25VCLOGICALCHANNEL, ASN_INTEGER, RONLY, var_x25VCTable, 6, {1, 1, 9, 1, 1, 2}},
#define   X25VCPACKETSEQUENCING  (178 % 256)
	{X25VCPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 3}},
#define   X25VCPACKETSIZEINCOMING  (179 % 256)
	{X25VCPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 4}},
#define   X25VCPACKETSIZEOUTGOING  (180 % 256)
	{X25VCPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 5}},
#define   X25VCWINDOWSIZEINCOMING  (181 % 256)
	{X25VCWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 6}},
#define   X25VCWINDOWSIZEOUTGOING  (182 % 256)
	{X25VCWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 7}},
#define   X25VCTHROUGHPUTCLASSINCOMING  (183 % 256)
	{X25VCTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 8}},
#define   X25VCTHROUGHPUTCLASSOUTGOING  (184 % 256)
	{X25VCTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 9}},
#define   X25VCDTEOCTETSRECEIVED  (189 % 256)
	{X25VCDTEOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 1}},
#define   X25VCDTEOCTETSSENT    (190 % 256)
	{X25VCDTEOCTETSSENT, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 2}},
#define   X25VCDTEDATAPACKETSRECEIVED  (191 % 256)
	{X25VCDTEDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6,
	 {1, 1, 10, 1, 1, 3}},
#define   X25VCDTEDATAPACKETSSENT  (192 % 256)
	{X25VCDTEDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 4}},
#define   X25VCDTEDATATIMEOUTS  (193 % 256)
	{X25VCDTEDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 5}},
#define   X25VCDTEINTERRUPTPACKETSRECEIVED  (194 % 256)
	{X25VCDTEINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6,
	 {1, 1, 10, 1, 1, 6}},
#define   X25VCDTEINTERRUPTPACKETSSENT  (195 % 256)
	{X25VCDTEINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6,
	 {1, 1, 10, 1, 1, 7}},
#define   X25VCDTEINTERRUPTTIMEOUTS  (196 % 256)
	{X25VCDTEINTERRUPTTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6,
	 {1, 1, 10, 1, 1, 8}},
#define   X25VCDTEPROVIDERRESETS  (197 % 256)
	{X25VCDTEPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 9}},
#define   X25VCDTEREMOTERESETS  (198 % 256)
	{X25VCDTEREMOTERESETS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 10}},
#define   X25VCDTERESETTIMEOUTS  (199 % 256)
	{X25VCDTERESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 11}},
#define   X25VCDCEOCTETSRECEIVED  (204 % 256)
	{X25VCDCEOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 1}},
#define   X25VCDCEOCTETSSENT    (205 % 256)
	{X25VCDCEOCTETSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 2}},
#define   X25VCDCEDATAPACKETSRECEIVED  (206 % 256)
	{X25VCDCEDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6,
	 {1, 1, 11, 1, 1, 3}},
#define   X25VCDCEDATAPACKETSSENT  (207 % 256)
	{X25VCDCEDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 4}},
#define   X25VCDCEINTERRUPTPACKETSRECEIVED  (208 % 256)
	{X25VCDCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6,
	 {1, 1, 11, 1, 1, 5}},
#define   X25VCDCEINTERRUPTPACKETSSENT  (209 % 256)
	{X25VCDCEINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6,
	 {1, 1, 11, 1, 1, 6}},
#define   X25VCDCEPROVIDERRESETS  (210 % 256)
	{X25VCDCEPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 7}},
#define   X25VCDCEREMOTERESETS  (211 % 256)
	{X25VCDCEREMOTERESETS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 8}},
#define   X25VCDCERESETTIMEOUTS  (212 % 256)
	{X25VCDCERESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 9}},
#define   X25VCDCEREMOTERESTARTS  (213 % 256)
	{X25VCDCEREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 10}},
#define   X25VCDCEPROVIDERDISCONNECTS  (214 % 256)
	{X25VCDCEPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6,
	 {1, 1, 11, 1, 1, 11}},
#define   X25VCDCEX25SEGMENTSRECEIVED  (215 % 256)
	{X25VCDCEX25SEGMENTSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6,
	 {1, 1, 11, 1, 1, 12}},
#define   X25VCDCEX25SEGMENTSSENT  (216 % 256)
	{X25VCDCEX25SEGMENTSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 13}},
#define   X25VCDXEOCTETSRECEIVED  (221 % 256)
	{X25VCDXEOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 1}},
#define   X25VCDXEOCTETSSENT    (222 % 256)
	{X25VCDXEOCTETSSENT, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 2}},
#define   X25VCDXEDATAPACKETSRECEIVED  (223 % 256)
	{X25VCDXEDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6,
	 {1, 1, 12, 1, 1, 3}},
#define   X25VCDXEDATAPACKETSSENT  (224 % 256)
	{X25VCDXEDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 4}},
#define   X25VCDXEDATATIMEOUTS  (225 % 256)
	{X25VCDXEDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 5}},
#define   X25VCDXEINTERRUPTPACKETSRECEIVED  (226 % 256)
	{X25VCDXEINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6,
	 {1, 1, 12, 1, 1, 6}},
#define   X25VCDXEINTERRUPTPACKETSSENT  (227 % 256)
	{X25VCDXEINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6,
	 {1, 1, 12, 1, 1, 7}},
#define   X25VCDXEINTERRUPTTIMEOUTS  (228 % 256)
	{X25VCDXEINTERRUPTTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6,
	 {1, 1, 12, 1, 1, 8}},
#define   X25VCDXEPROVIDERRESETS  (229 % 256)
	{X25VCDXEPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 9}},
#define   X25VCDXEREMOTERESETS  (230 % 256)
	{X25VCDXEREMOTERESETS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 10}},
#define   X25VCDXERESETTIMEOUTS  (231 % 256)
	{X25VCDXERESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 11}},
#define   X25PVCDTELOGICALCHANNEL  (236 % 256)
	{X25PVCDTELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDTETable, 6, {1, 1, 13, 1, 1, 1}},
#define   X25PVCDTEROWSTATUS    (237 % 256)
	{X25PVCDTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PVCDTETable, 6, {1, 1, 13, 1, 1, 2}},
#define   X25PVCDCELOGICALCHANNEL  (242 % 256)
	{X25PVCDCELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 1}},
#define   X25PVCDCECHARGINGDIRECTION  (243 % 256)
	{X25PVCDCECHARGINGDIRECTION, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6,
	 {1, 1, 14, 1, 1, 2}},
#define   X25PVCDCEOPERATIONALSTATE  (244 % 256)
	{X25PVCDCEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 3}},
#define   X25PVCDCEREMOTEDTEADDRESS  (245 % 256)
	{X25PVCDCEREMOTEDTEADDRESS, ASN_OCTET_STR, RWRITE, var_x25PVCDCETable, 6,
	 {1, 1, 14, 1, 1, 4}},
#define   X25PVCDCEREMOTELOGICALCHANNEL  (246 % 256)
	{X25PVCDCEREMOTELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6,
	 {1, 1, 14, 1, 1, 5}},
#define   X25PVCDCEROWSTATUS    (247 % 256)
	{X25PVCDCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 6}},
#define   X25PVCDXELOGICALCHANNEL  (252 % 256)
	{X25PVCDXELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDXETable, 6, {1, 1, 15, 1, 1, 1}},
#define   X25PVCDXEROWSTATUS    (253 % 256)
	{X25PVCDXEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PVCDXETable, 6, {1, 1, 15, 1, 1, 2}},
#define   X25SVCIVMOID          (257 % 256)
	{X25SVCIVMOID, ASN_OCTET_STR, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 1}},
#define   X25SVCIVMOFASTSELECT  (258 % 256)
	{X25SVCIVMOFASTSELECT, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 2}},
#define   X25SVCIVMOPACKETSIZEINCOMING  (259 % 256)
	{X25SVCIVMOPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 3}},
#define   X25SVCIVMOPACKETSIZEOUTGOING  (260 % 256)
	{X25SVCIVMOPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 4}},
#define   X25SVCIVMOREVERSECHARGING  (261 % 256)
	{X25SVCIVMOREVERSECHARGING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 5}},
#define   X25SVCIVMOTHROUGHPUTCLASSINCOMING  (262 % 256)
	{X25SVCIVMOTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 6}},
#define   X25SVCIVMOTHROUGHPUTCLASSOUTGOING  (263 % 256)
	{X25SVCIVMOTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 7}},
#define   X25SVCIVMOWINDOWSIZEINCOMING  (264 % 256)
	{X25SVCIVMOWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 8}},
#define   X25SVCIVMOWINDOWSIZEOUTGOING  (265 % 256)
	{X25SVCIVMOWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 9}},
#define   X25SVCIVMOROWSTATUS   (266 % 256)
	{X25SVCIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 10}},
#define   X25SVCIVMOID          (270 % 256)
	{X25SVCIVMOID, ASN_OCTET_STR, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 16, 1, 1, 1}},
#define   X25SVCIVMODTECALLTIME  (271 % 256)
	{X25SVCIVMODTECALLTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 1}},
#define   X25SVCIVMODTERESETTIME  (272 % 256)
	{X25SVCIVMODTERESETTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 2}},
#define   X25SVCIVMODTERESETCOUNT  (273 % 256)
	{X25SVCIVMODTERESETCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 3}},
#define   X25SVCIVMODTEINTERRUPTTIME  (274 % 256)
	{X25SVCIVMODTEINTERRUPTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 4}},
#define   X25SVCIVMODTECLEARTIME  (275 % 256)
	{X25SVCIVMODTECLEARTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 5}},
#define   X25SVCIVMODTECLEARCOUNT  (276 % 256)
	{X25SVCIVMODTECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 6}},
#define   X25SVCIVMODTEWINDOWTIME  (277 % 256)
	{X25SVCIVMODTEWINDOWTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 7}},
#define   X25SVCIVMODTEDATATIME  (278 % 256)
	{X25SVCIVMODTEDATATIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 8}},
#define   X25SVCIVMODTEDATACOUNT  (279 % 256)
	{X25SVCIVMODTEDATACOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 9}},
#define   X25SVCIVMODTEREJECTTIME  (280 % 256)
	{X25SVCIVMODTEREJECTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 10}},
#define   X25SVCIVMODTEREJECTCOUNT  (281 % 256)
	{X25SVCIVMODTEREJECTCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 11}},
#define   X25SVCIVMODTEROWSTATUS  (282 % 256)
	{X25SVCIVMODTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 12}},
#define   X25SVCIVMOID          (286 % 256)
	{X25SVCIVMOID, ASN_OCTET_STR, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 16, 1, 1, 1}},
#define   X25SVCIVMODXECALLTIME  (287 % 256)
	{X25SVCIVMODXECALLTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 1}},
#define   X25SVCIVMODXERESETTIME  (288 % 256)
	{X25SVCIVMODXERESETTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 2}},
#define   X25SVCIVMODXECLEARTIME  (289 % 256)
	{X25SVCIVMODXECLEARTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 3}},
#define   X25SVCIVMODXEINTERRUPTTIME  (290 % 256)
	{X25SVCIVMODXEINTERRUPTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 4}},
#define   X25SVCIVMODXERESETCOUNT  (291 % 256)
	{X25SVCIVMODXERESETCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 5}},
#define   X25SVCIVMODXECLEARCOUNT  (292 % 256)
	{X25SVCIVMODXECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 6}},
#define   X25SVCIVMODXEROWSTATUS  (293 % 256)
	{X25SVCIVMODXEROWSTATUS, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 7}},
#define   X25SVCIVMODXEWINDOWTIME  (294 % 256)
	{X25SVCIVMODXEWINDOWTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 8}},
#define   X25SVCIVMODXEDATATIME  (295 % 256)
	{X25SVCIVMODXEDATATIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 9}},
#define   X25SVCIVMODXEDATACOUNT  (296 % 256)
	{X25SVCIVMODXEDATACOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 10}},
#define   X25SVCIVMODXEREJECTTIME  (297 % 256)
	{X25SVCIVMODXEREJECTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 12}},
#define   X25SVCIVMODXEREJECTCOUNT  (298 % 256)
	{X25SVCIVMODXEREJECTCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 13}},
#define   X25SVCDTECALLINGADDRESSEXTENSION  (303 % 256)
	{X25SVCDTECALLINGADDRESSEXTENSION,, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 1}},
#define   X25SVCDTECALLEDADDRESSEXTENSION  (304 % 256)
	{X25SVCDTECALLEDADDRESSEXTENSION,, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 2}},
#define   X25SVCDTEDIRECTION    (305 % 256)
	{X25SVCDTEDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 3}},
#define   X25SVCDTEFASTSELECT   (306 % 256)
	{X25SVCDTEFASTSELECT, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 4}},
#define   X25SVCDTEORIGINALLYCALLEDADDRESS  (307 % 256)
	{X25SVCDTEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDTETable, 6,
	 {1, 1, 19, 1, 1, 5}},
#define   X25SVCDTEREDIRECTREASON  (308 % 256)
	{X25SVCDTEREDIRECTREASON, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 6}},
#define   X25SVCDTEREMOTEDTEADDRESS  (309 % 256)
	{X25SVCDTEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDTETable, 6,
	 {1, 1, 19, 1, 1, 7}},
#define   X25SVCDTEREVERSECHARGING  (310 % 256)
	{X25SVCDTEREVERSECHARGING, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 8}},
#define   X25SVCDCECHARGINGDIRECTION  (315 % 256)
	{X25SVCDCECHARGINGDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6,
	 {1, 1, 20, 1, 1, 1}},
#define   X25SVCDCECUGSELECTION  (316 % 256)
	{X25SVCDCECUGSELECTION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 2}},
#define   X25SVCDCEDIRECTION    (317 % 256)
	{X25SVCDCEDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 3}},
#define   X25SVCDCEFASTSELECT   (318 % 256)
	{X25SVCDCEFASTSELECT, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 4}},
#define   X25SVCDCEREMOTEDTEADDRESS  (319 % 256)
	{X25SVCDCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDCETable, 6,
	 {1, 1, 20, 1, 1, 5}},
#define   X25SVCDCETRANSITDELAYSELECTIONANDINDICATION  (320 % 256)
	{X25SVCDCETRANSITDELAYSELECTIONANDINDICATION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6,
	 {1, 1, 20, 1, 1, 6}},
#define   X25SVCDXEDIRECTION    (325 % 256)
	{X25SVCDXEDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 1}},
#define   X25SVCDXEREMOTEDTEADDRESS  (326 % 256)
	{X25SVCDXEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDXETable, 6,
	 {1, 1, 21, 1, 1, 2}},
#define   X25SVCDXEFASTSELECT   (327 % 256)
	{X25SVCDXEFASTSELECT, ASN_INTEGER, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 4}},
#define   X25SVCDXEREDIRECTREASON  (328 % 256)
	{X25SVCDXEREDIRECTREASON, ASN_INTEGER, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 5}},
#define   X25SVCDXEORIGINALLYCALLEDADDRESS  (329 % 256)
	{X25SVCDXEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDXETable, 6,
	 {1, 1, 21, 1, 1, 6}},
#define   X25SVCDXECALLINGADDRESSEXTENSION  (330 % 256)
	{X25SVCDXECALLINGADDRESSEXTENSION,, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 7}},
#define   X25SVCDXECALLEDADDRESSEXTENSION  (331 % 256)
	{X25SVCDXECALLEDADDRESSEXTENSION,, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 8}},
#define   X25DSCID              (336 % 256)
	{X25DSCID, ASN_OCTET_STR, RONLY, var_x25DSCTable, 6, {1, 1, 22, 1, 1, 1}},
#define   X25DSCRESETREQUESTINDICATIONPACKETS  (337 % 256)
	{X25DSCRESETREQUESTINDICATIONPACKETS, ASN_COUNTER64, RONLY, var_x25DSCTable, 6,
	 {1, 1, 22, 1, 1, 2}},
#define   X25DSCSEGMENTSSENT    (338 % 256)
	{X25DSCSEGMENTSSENT, ASN_COUNTER64, RONLY, var_x25DSCTable, 6, {1, 1, 22, 1, 1, 3}},
#define   X25DSCSEGMENTSRECEIVED  (339 % 256)
	{X25DSCSEGMENTSRECEIVED, ASN_COUNTER64, RONLY, var_x25DSCTable, 6, {1, 1, 22, 1, 1, 4}},
#define   X25PLEDTESTATSCALLATTEMPTS  (343 % 256)
	{X25PLEDTESTATSCALLATTEMPTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 1}},
#define   X25PLEDTESTATSPROTOCOLERRORSDETECTEDLOCALLY  (344 % 256)
	{X25PLEDTESTATSPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable,
	 6, {1, 1, 23, 1, 1, 2}},
#define   X25PLEDTESTATSPROTOCOLERRORSACCUSEDOF  (345 % 256)
	{X25PLEDTESTATSPROTOCOLERRORSACCUSEDOF, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 3}},
#define   X25PLEDTESTATSCALLCOUNTSEXCEEDED  (346 % 256)
	{X25PLEDTESTATSCALLCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 4}},
#define   X25PLEDTESTATSOCTETSRECEIVED  (347 % 256)
	{X25PLEDTESTATSOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 5}},
#define   X25PLEDTESTATSOCTETSSENT  (348 % 256)
	{X25PLEDTESTATSOCTETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 6}},
#define   X25PLEDTESTATSCALLTIMEOUTS  (349 % 256)
	{X25PLEDTESTATSCALLTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 7}},
#define   X25PLEDTESTATSCALLSCONNECTED  (350 % 256)
	{X25PLEDTESTATSCALLSCONNECTED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 8}},
#define   X25PLEDTESTATSDATAPACKETSRECEIVED  (351 % 256)
	{X25PLEDTESTATSDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 9}},
#define   X25PLEDTESTATSDATAPACKETSSENT  (352 % 256)
	{X25PLEDTESTATSDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 10}},
#define   X25PLEDTESTATSDATATIMEOUTS  (353 % 256)
	{X25PLEDTESTATSDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 11}},
#define   X25PLEDTESTATSPROVIDERRESETS  (354 % 256)
	{X25PLEDTESTATSPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 12}},
#define   X25PLEDTESTATSPROVIDERDISCONNECTS  (355 % 256)
	{X25PLEDTESTATSPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 13}},
#define   X25PLEDTESTATSREMOTERESETS  (356 % 256)
	{X25PLEDTESTATSREMOTERESETS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 14}},
#define   X25PLEDTESTATSREMOTERESTARTS  (357 % 256)
	{X25PLEDTESTATSREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 15}},
#define   X25PLEDTESTATSRESETTIMEOUTS  (358 % 256)
	{X25PLEDTESTATSRESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 16}},
#define   X25PLEDTESTATSRESTARTCOUNTSEXCEEDED  (359 % 256)
	{X25PLEDTESTATSRESTARTCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 17}},
#define   X25PLEDTESTATSCLEARTIMEOUTS  (360 % 256)
	{X25PLEDTESTATSCLEARTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 18}},
#define   X25PLEDTESTATSCLEARCOUNTSEXCEEDED  (361 % 256)
	{X25PLEDTESTATSCLEARCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 19}},
#define   X25PLEDCESTATSCALLATTEMPTS  (365 % 256)
	{X25PLEDCESTATSCALLATTEMPTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 1}},
#define   X25PLEDCESTATSCALLSCONNECTED  (366 % 256)
	{X25PLEDCESTATSCALLSCONNECTED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 2}},
#define   X25PLEDCESTATSOCTETSRECEIVED  (367 % 256)
	{X25PLEDCESTATSOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 3}},
#define   X25PLEDCESTATSOCTETSSENT  (368 % 256)
	{X25PLEDCESTATSOCTETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 4}},
#define   X25PLEDCESTATSDATAPACKETSRECEIVED  (369 % 256)
	{X25PLEDCESTATSDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 5}},
#define   X25PLEDCESTATSDATAPACKETSSENT  (370 % 256)
	{X25PLEDCESTATSDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 6}},
#define   X25PLEDCESTATSINTERRUPTPACKETSRECEIVED  (371 % 256)
	{X25PLEDCESTATSINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 7}},
#define   X25PLEDCESTATSINTERRUPTPACKETSSENT  (372 % 256)
	{X25PLEDCESTATSINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 8}},
#define   X25PLEDCESTATSPROVIDERRESETS  (373 % 256)
	{X25PLEDCESTATSPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 9}},
#define   X25PLEDCESTATSPROVIDERDISCONNECTS  (374 % 256)
	{X25PLEDCESTATSPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 10}},
#define   X25PLEDCESTATSREMOTERESETS  (375 % 256)
	{X25PLEDCESTATSREMOTERESETS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 11}},
#define   X25PLEDCESTATSREMOTERESTARTS  (376 % 256)
	{X25PLEDCESTATSREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 12}},
#define   X25PLEDCESTATSRESETTIMEOUTS  (377 % 256)
	{X25PLEDCESTATSRESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 13}},
#define   X25PLEDCESTATSX25SEGMENTSRECEIVED  (378 % 256)
	{X25PLEDCESTATSX25SEGMENTSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 14}},
#define   X25PLEDCESTATSX25SEGMENTSSENT  (379 % 256)
	{X25PLEDCESTATSX25SEGMENTSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 15}},
#define   X25PLEDXESTATSCALLATTEMPTS  (383 % 256)
	{X25PLEDXESTATSCALLATTEMPTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 1}},
#define   X25PLEDXESTATSPROTOCOLERRORSDETECTEDLOCALLY  (384 % 256)
	{X25PLEDXESTATSPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable,
	 6, {1, 1, 25, 1, 1, 2}},
#define   X25PLEDXESTATSPROTOCOLERRORSACCUSEDOF  (385 % 256)
	{X25PLEDXESTATSPROTOCOLERRORSACCUSEDOF, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 3}},
#define   X25PLEDXESTATSCALLCOUNTSEXCEEDED  (386 % 256)
	{X25PLEDXESTATSCALLCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 4}},
#define   X25PLEDXESTATSOCTETSRECEIVED  (387 % 256)
	{X25PLEDXESTATSOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 5}},
#define   X25PLEDXESTATSOCTETSSENT  (388 % 256)
	{X25PLEDXESTATSOCTETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 6}},
#define   X25PLEDXESTATSCALLTIMEOUTS  (389 % 256)
	{X25PLEDXESTATSCALLTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 7}},
#define   X25PLEDXESTATSCALLSCONNECTED  (390 % 256)
	{X25PLEDXESTATSCALLSCONNECTED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 8}},
#define   X25PLEDXESTATSCLEARTIMEOUTS  (391 % 256)
	{X25PLEDXESTATSCLEARTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 9}},
#define   X25PLEDXESTATSDATAPACKETSRECEIVED  (392 % 256)
	{X25PLEDXESTATSDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 10}},
#define   X25PLEDXESTATSDATAPACKETSSENT  (393 % 256)
	{X25PLEDXESTATSDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 11}},
#define   X25PLEDXESTATSDATATIMEOUTS  (394 % 256)
	{X25PLEDXESTATSDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 12}},
#define   X25PLEDXESTATSPROVIDERRESETS  (395 % 256)
	{X25PLEDXESTATSPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 13}},
#define   X25PLEDXESTATSPROVIDERDISCONNECTS  (396 % 256)
	{X25PLEDXESTATSPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 14}},
#define   X25PLEDXESTATSREMOTERESETS  (397 % 256)
	{X25PLEDXESTATSREMOTERESETS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 15}},
#define   X25PLEDXESTATSREMOTERESTARTS  (398 % 256)
	{X25PLEDXESTATSREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 16}},
#define   X25PLEDXESTATSRESETTIMEOUTS  (399 % 256)
	{X25PLEDXESTATSRESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 17}},
#define   X25PLEDXESTATSRESTARTCOUNTSEXCEEDED  (400 % 256)
	{X25PLEDXESTATSRESTARTCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 18}},
#define   X25PLEDXESTATSCLEARCOUNTSEXCEEDED  (401 % 256)
	{X25PLEDXESTATSCLEARCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 19}},

};

/*    (L = length of the oidsuffix) */
struct x25PLPMIB_data *x25PLPMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *x25PLETableStorage = NULL;
struct header_complex_index *x25PLEIVMOTableStorage = NULL;
struct header_complex_index *x25PLEDTETableStorage = NULL;
struct header_complex_index *x25PLEDCETableStorage = NULL;
struct header_complex_index *x25PLEDXETableStorage = NULL;
struct header_complex_index *x25PLEIVMODTETableStorage = NULL;
struct header_complex_index *x25PLEIVMODCETableStorage = NULL;
struct header_complex_index *x25PLEIVMODXETableStorage = NULL;
struct header_complex_index *x25VCTableStorage = NULL;
struct header_complex_index *x25VCDTETableStorage = NULL;
struct header_complex_index *x25VCDCETableStorage = NULL;
struct header_complex_index *x25VCDXETableStorage = NULL;
struct header_complex_index *x25PVCDTETableStorage = NULL;
struct header_complex_index *x25PVCDCETableStorage = NULL;
struct header_complex_index *x25PVCDXETableStorage = NULL;
struct header_complex_index *x25SVCIVMOTableStorage = NULL;
struct header_complex_index *x25SVCIVMODTETableStorage = NULL;
struct header_complex_index *x25SVCIVMODXETableStorage = NULL;
struct header_complex_index *x25SVCDTETableStorage = NULL;
struct header_complex_index *x25SVCDCETableStorage = NULL;
struct header_complex_index *x25SVCDXETableStorage = NULL;
struct header_complex_index *x25DSCTableStorage = NULL;
struct header_complex_index *x25PLEDTEStatsTableStorage = NULL;
struct header_complex_index *x25PLEDCEStatsTableStorage = NULL;
struct header_complex_index *x25PLEDXEStatsTableStorage = NULL;

/*
 * init_x25PLPMIB():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_x25PLPMIB(void)
{
	DEBUGMSGTL(("x25PLPMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("x25PLPMIB", x25PLPMIB_variables, variable7, x25PLPMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_x25PLPMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("x25PLPMIB", parse_x25PLPMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLETable", parse_x25PLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMOTable", parse_x25PLEIVMOTable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25PLEDTETable", parse_x25PLEDTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEDCETable", parse_x25PLEDCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEDXETable", parse_x25PLEDXETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMODTETable", parse_x25PLEIVMODTETable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMODCETable", parse_x25PLEIVMODCETable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMODXETable", parse_x25PLEIVMODXETable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25VCTable", parse_x25VCTable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25VCDTETable", parse_x25VCDTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25VCDCETable", parse_x25VCDCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25VCDXETable", parse_x25VCDXETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PVCDTETable", parse_x25PVCDTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PVCDCETable", parse_x25PVCDCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PVCDXETable", parse_x25PVCDXETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25SVCIVMOTable", parse_x25SVCIVMOTable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25SVCIVMODTETable", parse_x25SVCIVMODTETable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25SVCIVMODXETable", parse_x25SVCIVMODXETable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25SVCDTETable", parse_x25SVCDTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25SVCDCETable", parse_x25SVCDCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25SVCDXETable", parse_x25SVCDXETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25DSCTable", parse_x25DSCTable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEDTEStatsTable", parse_x25PLEDTEStatsTable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25PLEDCEStatsTable", parse_x25PLEDCEStatsTable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25PLEDXEStatsTable", parse_x25PLEDXEStatsTable, NULL,
				      "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLPMIB,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLETable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDXETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEIVMODTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEIVMODCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEIVMODXETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25VCTable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25VCDTETable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25VCDCETable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25VCDXETable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PVCDTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PVCDCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PVCDXETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCIVMODTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCIVMODXETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCDTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCDCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCDXETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25DSCTable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDTEStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDCEStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDXEStatsTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
}

/*
 * deinit_x25PLPMIB():
 *   Deinitialization routine.  This is called before the agent is unloaded.
 *   At a minimum, deregistration of your variables should take place here.
 */
void
deinit_x25PLPMIB(void)
{
	DEBUGMSGTL(("x25PLPMIB", "deinitializating...  "));
	unregister_mib(x25PLPMIB_variables_oid, sizeof(x25PLPMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("x25PLPMIB");
	snmpd_unregister_config_handler("x25PLETable");
	snmpd_unregister_config_handler("x25PLEIVMOTable");
	snmpd_unregister_config_handler("x25PLEDTETable");
	snmpd_unregister_config_handler("x25PLEDCETable");
	snmpd_unregister_config_handler("x25PLEDXETable");
	snmpd_unregister_config_handler("x25PLEIVMODTETable");
	snmpd_unregister_config_handler("x25PLEIVMODCETable");
	snmpd_unregister_config_handler("x25PLEIVMODXETable");
	snmpd_unregister_config_handler("x25VCTable");
	snmpd_unregister_config_handler("x25VCDTETable");
	snmpd_unregister_config_handler("x25VCDCETable");
	snmpd_unregister_config_handler("x25VCDXETable");
	snmpd_unregister_config_handler("x25PVCDTETable");
	snmpd_unregister_config_handler("x25PVCDCETable");
	snmpd_unregister_config_handler("x25PVCDXETable");
	snmpd_unregister_config_handler("x25SVCIVMOTable");
	snmpd_unregister_config_handler("x25SVCIVMODTETable");
	snmpd_unregister_config_handler("x25SVCIVMODXETable");
	snmpd_unregister_config_handler("x25SVCDTETable");
	snmpd_unregister_config_handler("x25SVCDCETable");
	snmpd_unregister_config_handler("x25SVCDXETable");
	snmpd_unregister_config_handler("x25DSCTable");
	snmpd_unregister_config_handler("x25PLEDTEStatsTable");
	snmpd_unregister_config_handler("x25PLEDCEStatsTable");
	snmpd_unregister_config_handler("x25PLEDXEStatsTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
}

int
term_x25PLPMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_x25PLPMIB();
	return 0;
}

/*
 * x25PLPMIB_add(): adds a structure node for scalars
 */
int
x25PLPMIB_add(struct x25PLPMIB_data *thedata)
{
	DEBUGMSGTL(("x25PLPMIB", "adding data...  "));
	x25PLPMIBStorage = thedata;
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLPMIB():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLPMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLPMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLPMIB_data);

	DEBUGMSGTL(("x25PLPMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}

	x25PLPMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
}

/*
 * store_x25PLPMIB():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLPMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLPMIB_data *StorageTmp;

	DEBUGMSGTL(("x25PLPMIB", "storing data...  "));
	refresh_x25PLPMIB();
	if ((StorageTmp = x25PLPMIBStorage) == NULL) {
		DEBUGMSGTL(("x25PLPMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->x25PLPMIBStorageType == ST_NONVOLATILE) { */
	memset(line, 0, sizeof(line));
	strcat(line, "x25PLPMIB ");
	cptr = line + strlen(line);

	snmpd_store_config(line);
	/* } */
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_x25PLPMIB: refresh x25PLPMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread scalars and tables from the STREAMS susbystem.  This function
 * is used when the agent starts for the first time, or after a SIGPOLL
 * has been received (and a scalar has been requested).
 */
void
refresh_x25PLPMIB(void)
{
	if (x25PLPMIBStorage == NULL) {
		struct x25PLPMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(x25PLPMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */

		x25PLPMIBStorage = StorageNew;
		x25PLPMIB_refresh = 1;
	}
	if (x25PLPMIB_refresh == 0)
		return;
	x25PLPMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_x25PLPMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
uint8_t *
var_x25PLPMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
	      WriteMethod ** write_method)
{
	struct x25PLPMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_x25PLPMIB();
	if ((StorageTmp = x25PLPMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * x25PLETable_add(): adds a structure node to our data set
 */
int
x25PLETable_add(struct x25PLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);

	header_complex_add_data(&x25PLETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLETable_data);

	DEBUGMSGTL(("x25PLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEOperationalState, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEAdministrativeState,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->x25PLEProtocolVersionsSupported,
				  &tmpsize);
	StorageTmp->x25PLEProtocolVersionsSupportedLen = tmpsize;
	if (StorageTmp->x25PLEProtocolVersionsSupported == NULL) {
		config_perror("invalid specification for x25PLEProtocolVersionsSupported");
		return;
	}

	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLELocalDTEAddress,
				  &tmpsize);
	StorageTmp->x25PLELocalDTEAddressLen = tmpsize;
	if (StorageTmp->x25PLELocalDTEAddress == NULL) {
		config_perror("invalid specification for x25PLELocalDTEAddress");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEInterfaceMode, &tmpsize);
	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->x25PLEFacilityNonNegotiable,
				  &tmpsize);
	StorageTmp->x25PLEFacilityNonNegotiableLen = tmpsize;
	if (StorageTmp->x25PLEFacilityNonNegotiable == NULL) {
		config_perror("invalid specification for x25PLEFacilityNonNegotiable");
		return;
	}

	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->x25PLEFacilityAvailability,
				  &tmpsize);
	StorageTmp->x25PLEFacilityAvailabilityLen = tmpsize;
	if (StorageTmp->x25PLEFacilityAvailability == NULL) {
		config_perror("invalid specification for x25PLEFacilityAvailability");
		return;
	}

	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->x25PLEFacilityNegotiation,
				  &tmpsize);
	StorageTmp->x25PLEFacilityNegotiationLen = tmpsize;
	if (StorageTmp->x25PLEFacilityNegotiation == NULL) {
		config_perror("invalid specification for x25PLEFacilityNegotiation");
		return;
	}

	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->x25PLEFacilityWhileIdle,
				  &tmpsize);
	StorageTmp->x25PLEFacilityWhileIdleLen = tmpsize;
	if (StorageTmp->x25PLEFacilityWhileIdle == NULL) {
		config_perror("invalid specification for x25PLEFacilityWhileIdle");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEPacketSequenceNumbering,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDefaultPacketSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDefaultPacketSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDefaultWindowSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDefaultWindowSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDefaultThroughputClassIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDefaultThroughputClassOutgoing, &tmpsize);
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLESNServiceProvider,
				  &tmpsize);
	StorageTmp->x25PLESNServiceProviderLen = tmpsize;
	if (StorageTmp->x25PLESNServiceProvider == NULL) {
		config_perror("invalid specification for x25PLESNServiceProvider");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLESNSAP, &tmpsize);
	StorageTmp->x25PLESNSAPLen = tmpsize;
	if (StorageTmp->x25PLESNSAP == NULL) {
		config_perror("invalid specification for x25PLESNSAP");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentHIC,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentLIC,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentHTC,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentLTC,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentHOC,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentLOC,
				  &tmpsize);

	x25PLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLETable", "done.\n"));
}

/*
 * store_x25PLETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLETable", "storing data...  "));
	refresh_x25PLETable();
	(void) tmpsize;
	for (hcindex = x25PLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEOperationalState,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEAdministrativeState, &tmpsize);
		tmpsize = StorageTmp->x25PLEProtocolVersionsSupportedLen;
		cptr =
		    read_config_store_data(ASN_BIT_STR, cptr,
					   &StorageTmp->x25PLEProtocolVersionsSupported, &tmpsize);
		tmpsize = StorageTmp->x25PLELocalDTEAddressLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLELocalDTEAddress,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEInterfaceMode,
					   &tmpsize);
		tmpsize = StorageTmp->x25PLEFacilityNonNegotiableLen;
		cptr =
		    read_config_store_data(ASN_BIT_STR, cptr,
					   &StorageTmp->x25PLEFacilityNonNegotiable, &tmpsize);
		tmpsize = StorageTmp->x25PLEFacilityAvailabilityLen;
		cptr =
		    read_config_store_data(ASN_BIT_STR, cptr,
					   &StorageTmp->x25PLEFacilityAvailability, &tmpsize);
		tmpsize = StorageTmp->x25PLEFacilityNegotiationLen;
		cptr =
		    read_config_store_data(ASN_BIT_STR, cptr,
					   &StorageTmp->x25PLEFacilityNegotiation, &tmpsize);
		tmpsize = StorageTmp->x25PLEFacilityWhileIdleLen;
		cptr =
		    read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->x25PLEFacilityWhileIdle,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEPacketSequenceNumbering, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDefaultPacketSizeIncoming, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDefaultPacketSizeOutgoing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDefaultWindowSizeIncoming, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDefaultWindowSizeOutgoing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDefaultThroughputClassIncoming,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDefaultThroughputClassOutgoing,
					   &tmpsize);
		tmpsize = StorageTmp->x25PLESNServiceProviderLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr,
					   &StorageTmp->x25PLESNServiceProvider, &tmpsize);
		tmpsize = StorageTmp->x25PLESNSAPLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->x25PLESNSAP, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLELogicalChannelAssignmentHIC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLELogicalChannelAssignmentLIC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLELogicalChannelAssignmentHTC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLELogicalChannelAssignmentLTC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLELogicalChannelAssignmentHOC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLELogicalChannelAssignmentLOC,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEIVMOTable_add(): adds a structure node to our data set
 */
int
x25PLEIVMOTable_add(struct x25PLEIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEIVMOId,
				  thedata->x25PLEIVMOIdLen);

	header_complex_add_data(&x25PLEIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEIVMOTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMOTable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEIVMOTable_data);

	DEBUGMSGTL(("x25PLEIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &tmpsize);
	StorageTmp->x25PLEIVMOIdLen = tmpsize;
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOInterfaceMode,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultPacketSizeIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultThroughputClassIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultWindowSizeIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOFlowControlParameterNegotiation, &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOLocalDTEAddress,
				  &tmpsize);
	StorageTmp->x25PLEIVMOLocalDTEAddressLen = tmpsize;
	if (StorageTmp->x25PLEIVMOLocalDTEAddress == NULL) {
		config_perror("invalid specification for x25PLEIVMOLocalDTEAddress");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC, &tmpsize);
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLEIVMOSNServiceProvider,
				  &tmpsize);
	StorageTmp->x25PLEIVMOSNServiceProviderLen = tmpsize;
	if (StorageTmp->x25PLEIVMOSNServiceProvider == NULL) {
		config_perror("invalid specification for x25PLEIVMOSNServiceProvider");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOThroughputClassNegotiation, &tmpsize);

	x25PLEIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
}

/*
 * store_x25PLEIVMOTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMOTable", "storing data...  "));
	refresh_x25PLEIVMOTable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMOTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLEIVMOTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLEIVMOTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25PLEIVMOIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMOInterfaceMode,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODefaultPacketSizeIncoming,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODefaultThroughputClassIncoming,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODefaultWindowSizeIncoming,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMOFlowControlParameterNegotiation,
					   &tmpsize);
		tmpsize = StorageTmp->x25PLEIVMOLocalDTEAddressLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->x25PLEIVMOLocalDTEAddress, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC,
					   &tmpsize);
		tmpsize = StorageTmp->x25PLEIVMOSNServiceProviderLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr,
					   &StorageTmp->x25PLEIVMOSNServiceProvider, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMOThroughputClassNegotiation,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEDTETable_add(): adds a structure node to our data set
 */
int
x25PLEDTETable_add(struct x25PLEDTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);

	header_complex_add_data(&x25PLEDTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEDTETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEDTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDTETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEDTETable_data);

	DEBUGMSGTL(("x25PLEDTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTEPacketSequencing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTEMaxActiveCircuits,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDTECallDeflectionSubscription, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERestartTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERestartCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTEMinimumRecallTimer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERegistrationTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERegistrationCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERegistrationPermitted,
				  &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLEDTEProfile, &tmpsize);
	StorageTmp->x25PLEDTEProfileLen = tmpsize;
	if (StorageTmp->x25PLEDTEProfile == NULL) {
		config_perror("invalid specification for x25PLEDTEProfile");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERowStatus, &tmpsize);

	x25PLEDTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDTETable", "done.\n"));
}

/*
 * store_x25PLEDTETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDTETable", "storing data...  "));
	refresh_x25PLEDTETable();
	(void) tmpsize;
	for (hcindex = x25PLEDTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDTETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLEDTETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLEDTETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDTEPacketSequencing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDTEMaxActiveCircuits, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDTECallDeflectionSubscription,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDTERestartTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDTERestartCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDTEMinimumRecallTimer, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDTERegistrationTime, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDTERegistrationCount, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDTERegistrationPermitted, &tmpsize);
		tmpsize = StorageTmp->x25PLEDTEProfileLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->x25PLEDTEProfile,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDTERowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLEDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEDCETable_add(): adds a structure node to our data set
 */
int
x25PLEDCETable_add(struct x25PLEDCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);

	header_complex_add_data(&x25PLEDCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEDCETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEDCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDCETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEDCETable_data);

	DEBUGMSGTL(("x25PLEDCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEPacketSequencing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCECallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCECUG, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEFastSelectAcceptance,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEIncomingCallsBarred,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEOutgoingCallsBarred,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEBilateralCUG, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCECallRedirection,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEChargingInformation,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCECUGWithIncomingAccess,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCECUGWithOutgoingAccess,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEDBitModification,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEDefaultThroughputClassSubscription,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_BIT_STR, line,
				  &StorageTmp->x25PLEDCEDefaultThroughputClassSupported, &tmpsize);
	StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen = tmpsize;
	if (StorageTmp->x25PLEDCEDefaultThroughputClassSupported == NULL) {
		config_perror("invalid specification for x25PLEDCEDefaultThroughputClassSupported");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEDefaultThroughputClassIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEHuntGroup, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCELocalChargingPrevention,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCENUIOverride, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCENUISubscription,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEOnlineFacilityRegistration, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEPacketRetransmission,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEReverseChargingAcceptance, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEROASubscription,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCERestartIndication,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCERestartCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEIncomingCall, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCECallCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEResetIndication,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEResetCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEClearIndication,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEClearCount, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLEDCEProfile, &tmpsize);
	StorageTmp->x25PLEDCEProfileLen = tmpsize;
	if (StorageTmp->x25PLEDCEProfile == NULL) {
		config_perror("invalid specification for x25PLEDCEProfile");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCERowStatus, &tmpsize);

	x25PLEDCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDCETable", "done.\n"));
}

/*
 * store_x25PLEDCETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDCETable", "storing data...  "));
	refresh_x25PLEDCETable();
	(void) tmpsize;
	for (hcindex = x25PLEDCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDCETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLEDCETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLEDCETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEPacketSequencing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCECallDeflectionSubscription,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCECUG, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEFastSelectAcceptance, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEIncomingCallsBarred, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEOutgoingCallsBarred, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCEBilateralCUG,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCECallRedirection,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEChargingInformation, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCECUGWithIncomingAccess, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCECUGWithOutgoingAccess, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEDBitModification, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEDefaultThroughputClassSubscription,
					   &tmpsize);
		tmpsize = StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen;
		cptr =
		    read_config_store_data(ASN_BIT_STR, cptr,
					   &StorageTmp->x25PLEDCEDefaultThroughputClassSupported,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEDefaultThroughputClassIncoming,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCEHuntGroup,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCELocalChargingPrevention, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->
					   x25PLEDCENonStandardDefaultPacketSizeSubscription,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->
					   x25PLEDCENonStandardDefaultPacketSizeMaximum, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->
					   x25PLEDCENonStandardDefaultPacketSizeIncoming, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->
					   x25PLEDCENonStandardDefaultPacketSizeOutgoing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->
					   x25PLEDCENonStandardDefaultWindowSizeSubscription,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->
					   x25PLEDCENonStandardDefaultWindowSizeMaximum, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->
					   x25PLEDCENonStandardDefaultWindowSizeIncoming, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->
					   x25PLEDCENonStandardDefaultWindowSizeOutgoing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCENUIOverride,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCENUISubscription,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEOnlineFacilityRegistration,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEPacketRetransmission, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCEReverseChargingAcceptance,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCEROASubscription,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDCERestartIndication, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCERestartCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCEIncomingCall,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCECallCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCEResetIndication,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCEResetCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCEClearIndication,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCEClearCount,
					   &tmpsize);
		tmpsize = StorageTmp->x25PLEDCEProfileLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->x25PLEDCEProfile,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCERowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLEDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEDXETable_add(): adds a structure node to our data set
 */
int
x25PLEDXETable_add(struct x25PLEDXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);

	header_complex_add_data(&x25PLEDXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEDXETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEDXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDXETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEDXETable_data);

	DEBUGMSGTL(("x25PLEDXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXEPacketSequencing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXEMaxActiveCircuits,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDXECallDeflectionSubscription, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERestartTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERestartCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXEMinimumRecallTimer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERegistrationTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERegistrationCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERegistrationPermitted,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLEDXEPLEClientMOName,
				  &tmpsize);
	StorageTmp->x25PLEDXEPLEClientMONameLen = tmpsize;
	if (StorageTmp->x25PLEDXEPLEClientMOName == NULL) {
		config_perror("invalid specification for x25PLEDXEPLEClientMOName");
		return;
	}

	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLEDXEProfile, &tmpsize);
	StorageTmp->x25PLEDXEProfileLen = tmpsize;
	if (StorageTmp->x25PLEDXEProfile == NULL) {
		config_perror("invalid specification for x25PLEDXEProfile");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERowStatus, &tmpsize);

	x25PLEDXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDXETable", "done.\n"));
}

/*
 * store_x25PLEDXETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDXETable", "storing data...  "));
	refresh_x25PLEDXETable();
	(void) tmpsize;
	for (hcindex = x25PLEDXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDXETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLEDXETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLEDXETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDXEPacketSequencing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDXEMaxActiveCircuits, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDXECallDeflectionSubscription,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDXERestartTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDXERestartCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDXEMinimumRecallTimer, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDXERegistrationTime, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDXERegistrationCount, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEDXERegistrationPermitted, &tmpsize);
		tmpsize = StorageTmp->x25PLEDXEPLEClientMONameLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr,
					   &StorageTmp->x25PLEDXEPLEClientMOName, &tmpsize);
		tmpsize = StorageTmp->x25PLEDXEProfileLen;
		cptr =
		    read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->x25PLEDXEProfile,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDXERowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLEDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEIVMODTETable_add(): adds a structure node to our data set
 */
int
x25PLEIVMODTETable_add(struct x25PLEIVMODTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMODTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEIVMOId,
				  thedata->x25PLEIVMOIdLen);

	header_complex_add_data(&x25PLEIVMODTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMODTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEIVMODTETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEIVMODTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMODTETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEIVMODTETable_data);

	DEBUGMSGTL(("x25PLEIVMODTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &tmpsize);
	StorageTmp->x25PLEIVMOIdLen = tmpsize;
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODTECallDeflectionSubscription, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTECallTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEClearTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEClearCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEPacketSequencing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEInterruptTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEMaxActiveCircuits,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEMinimumRecallTimer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEResetTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEResetCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERestartTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERestartCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEWindowTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEDataTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEDataCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERejectTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERejectCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERegistrationTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERegistrationCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODTERegistrationPermitted, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERowStatus, &tmpsize);

	x25PLEIVMODTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMODTETable", "done.\n"));
}

/*
 * store_x25PLEIVMODTETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMODTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMODTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMODTETable", "storing data...  "));
	refresh_x25PLEIVMODTETable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMODTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMODTETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLEIVMODTETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLEIVMODTETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25PLEIVMOIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTECallDeflectionSubscription,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTECallTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTEClearTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTEClearCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTEPacketSequencing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTEInterruptTime, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTEMaxActiveCircuits, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTEMinimumRecallTimer, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTEResetTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTEResetCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTERestartTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTERestartCount, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTEWindowTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTEDataTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTEDataCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTERejectTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTERejectCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTERegistrationTime, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTERegistrationCount, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTERegistrationPermitted,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTERowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLEIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEIVMODCETable_add(): adds a structure node to our data set
 */
int
x25PLEIVMODCETable_add(struct x25PLEIVMODCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMODCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEIVMOId,
				  thedata->x25PLEIVMOIdLen);

	header_complex_add_data(&x25PLEIVMODCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMODCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMODCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEIVMODCETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEIVMODCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMODCETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEIVMODCETable_data);

	DEBUGMSGTL(("x25PLEIVMODCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &tmpsize);
	StorageTmp->x25PLEIVMOIdLen = tmpsize;
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODCERowStatus, &tmpsize);

	x25PLEIVMODCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMODCETable", "done.\n"));
}

/*
 * store_x25PLEIVMODCETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMODCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMODCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMODCETable", "storing data...  "));
	refresh_x25PLEIVMODCETable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMODCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMODCETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLEIVMODCETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLEIVMODCETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25PLEIVMOIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODCERowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLEIVMODCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEIVMODXETable_add(): adds a structure node to our data set
 */
int
x25PLEIVMODXETable_add(struct x25PLEIVMODXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMODXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEIVMOId,
				  thedata->x25PLEIVMOIdLen);

	header_complex_add_data(&x25PLEIVMODXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMODXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEIVMODXETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEIVMODXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMODXETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEIVMODXETable_data);

	DEBUGMSGTL(("x25PLEIVMODXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId, &tmpsize);
	StorageTmp->x25PLEIVMOIdLen = tmpsize;
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODTECallDeflectionSubscription, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEMaxActiveCircuits,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERestartTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEMinimumRecallTimer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERestartCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEPacketSequencing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERegistrationTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERegistrationCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODTERegistrationPermitted, &tmpsize);

	x25PLEIVMODXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMODXETable", "done.\n"));
}

/*
 * store_x25PLEIVMODXETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMODXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMODXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMODXETable", "storing data...  "));
	refresh_x25PLEIVMODXETable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMODXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMODXETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLEIVMODXETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLEIVMODXETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25PLEIVMOIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTECallDeflectionSubscription,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTEMaxActiveCircuits, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEIVMODTERestartTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTEMinimumRecallTimer, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTERestartCount, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTEPacketSequencing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTERegistrationTime, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTERegistrationCount, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PLEIVMODTERegistrationPermitted,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLEIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25VCTable_add(): adds a structure node to our data set
 */
int
x25VCTable_add(struct x25VCTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25VCTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);

	header_complex_add_data(&x25VCTableStorage, vars, thedata);
	DEBUGMSGTL(("x25VCTable", "registered an entry\n"));
	DEBUGMSGTL(("x25VCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25VCTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25VCTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25VCTable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25VCTable_data);

	DEBUGMSGTL(("x25VCTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCLogicalChannel, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCPacketSequencing, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCPacketSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCPacketSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCWindowSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCWindowSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCThroughputClassIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCThroughputClassOutgoing,
				  &tmpsize);

	x25VCTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25VCTable", "done.\n"));
}

/*
 * store_x25VCTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25VCTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25VCTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25VCTable", "storing data...  "));
	refresh_x25VCTable();
	(void) tmpsize;
	for (hcindex = x25VCTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25VCTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25VCTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25VCTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25VCLogicalChannel,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25VCPacketSequencing,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25VCPacketSizeIncoming,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25VCPacketSizeOutgoing,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25VCWindowSizeIncoming,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25VCWindowSizeOutgoing,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25VCThroughputClassIncoming, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25VCThroughputClassOutgoing, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25VCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25VCDTETable_add(): adds a structure node to our data set
 */
int
x25VCDTETable_add(struct x25VCDTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25VCDTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);

	header_complex_add_data(&x25VCDTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25VCDTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25VCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25VCDTETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25VCDTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25VCDTETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25VCDTETable_data);

	DEBUGMSGTL(("x25VCDTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEOctetsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEDataPacketsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEDataTimeouts, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25VCDTEInterruptPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEInterruptPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEInterruptTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTERemoteResets, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEResetTimeouts,
				  &tmpsize);

	x25VCDTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25VCDTETable", "done.\n"));
}

/*
 * store_x25VCDTETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25VCDTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25VCDTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25VCDTETable", "storing data...  "));
	refresh_x25VCDTETable();
	(void) tmpsize;
	for (hcindex = x25VCDTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25VCDTETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25VCDTETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25VCDTETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDTEOctetsReceived,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDTEOctetsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDTEDataPacketsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDTEDataPacketsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDTEDataTimeouts,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDTEInterruptPacketsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDTEInterruptPacketsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDTEInterruptTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDTEProviderResets,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDTERemoteResets,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDTEResetTimeouts,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25VCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25VCDCETable_add(): adds a structure node to our data set
 */
int
x25VCDCETable_add(struct x25VCDCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25VCDCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);

	header_complex_add_data(&x25VCDCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25VCDCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25VCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25VCDCETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25VCDCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25VCDCETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25VCDCETable_data);

	DEBUGMSGTL(("x25VCDCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEOctetsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEDataPacketsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25VCDCEInterruptPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEInterruptPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCERemoteResets, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEResetTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCERemoteRestarts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEProviderDisconnects,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEX25SegmentsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEX25SegmentsSent,
				  &tmpsize);

	x25VCDCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25VCDCETable", "done.\n"));
}

/*
 * store_x25VCDCETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25VCDCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25VCDCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25VCDCETable", "storing data...  "));
	refresh_x25VCDCETable();
	(void) tmpsize;
	for (hcindex = x25VCDCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25VCDCETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25VCDCETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25VCDCETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDCEOctetsReceived,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDCEOctetsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDCEDataPacketsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDCEDataPacketsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDCEInterruptPacketsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDCEInterruptPacketsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDCEProviderResets,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDCERemoteResets,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDCEResetTimeouts,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDCERemoteRestarts,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDCEProviderDisconnects, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDCEX25SegmentsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDCEX25SegmentsSent, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25VCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25VCDXETable_add(): adds a structure node to our data set
 */
int
x25VCDXETable_add(struct x25VCDXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25VCDXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);

	header_complex_add_data(&x25VCDXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25VCDXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25VCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25VCDXETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25VCDXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25VCDXETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25VCDXETable_data);

	DEBUGMSGTL(("x25VCDXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEOctetsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEDataPacketsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEDataTimeouts, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25VCDXEInterruptPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEInterruptPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEInterruptTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXERemoteResets, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEResetTimeouts,
				  &tmpsize);

	x25VCDXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25VCDXETable", "done.\n"));
}

/*
 * store_x25VCDXETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25VCDXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25VCDXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25VCDXETable", "storing data...  "));
	refresh_x25VCDXETable();
	(void) tmpsize;
	for (hcindex = x25VCDXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25VCDXETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25VCDXETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25VCDXETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDXEOctetsReceived,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDXEOctetsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDXEDataPacketsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDXEDataPacketsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDXEDataTimeouts,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDXEInterruptPacketsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDXEInterruptPacketsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25VCDXEInterruptTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDXEProviderResets,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDXERemoteResets,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25VCDXEResetTimeouts,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25VCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PVCDTETable_add(): adds a structure node to our data set
 */
int
x25PVCDTETable_add(struct x25PVCDTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PVCDTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);

	header_complex_add_data(&x25PVCDTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PVCDTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PVCDTETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PVCDTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PVCDTETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PVCDTETable_data);

	DEBUGMSGTL(("x25PVCDTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDTELogicalChannel,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDTERowStatus, &tmpsize);

	x25PVCDTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PVCDTETable", "done.\n"));
}

/*
 * store_x25PVCDTETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PVCDTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PVCDTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PVCDTETable", "storing data...  "));
	refresh_x25PVCDTETable();
	(void) tmpsize;
	for (hcindex = x25PVCDTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PVCDTETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PVCDTETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PVCDTETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PVCDTELogicalChannel,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PVCDTERowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PVCDCETable_add(): adds a structure node to our data set
 */
int
x25PVCDCETable_add(struct x25PVCDCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PVCDCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);

	header_complex_add_data(&x25PVCDCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PVCDCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PVCDCETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PVCDCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PVCDCETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PVCDCETable_data);

	DEBUGMSGTL(("x25PVCDCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDCELogicalChannel,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDCEChargingDirection,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDCEOperationalState,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PVCDCERemoteDTEAddress,
				  &tmpsize);
	StorageTmp->x25PVCDCERemoteDTEAddressLen = tmpsize;
	if (StorageTmp->x25PVCDCERemoteDTEAddress == NULL) {
		config_perror("invalid specification for x25PVCDCERemoteDTEAddress");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDCERemoteLogicalChannel,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDCERowStatus, &tmpsize);

	x25PVCDCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PVCDCETable", "done.\n"));
}

/*
 * store_x25PVCDCETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PVCDCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PVCDCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PVCDCETable", "storing data...  "));
	refresh_x25PVCDCETable();
	(void) tmpsize;
	for (hcindex = x25PVCDCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PVCDCETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PVCDCETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PVCDCETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PVCDCELogicalChannel,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PVCDCEChargingDirection, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PVCDCEOperationalState, &tmpsize);
		tmpsize = StorageTmp->x25PVCDCERemoteDTEAddressLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->x25PVCDCERemoteDTEAddress, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25PVCDCERemoteLogicalChannel, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PVCDCERowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PVCDXETable_add(): adds a structure node to our data set
 */
int
x25PVCDXETable_add(struct x25PVCDXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PVCDXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);

	header_complex_add_data(&x25PVCDXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PVCDXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PVCDXETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PVCDXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PVCDXETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PVCDXETable_data);

	DEBUGMSGTL(("x25PVCDXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDXELogicalChannel,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDXERowStatus, &tmpsize);

	x25PVCDXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PVCDXETable", "done.\n"));
}

/*
 * store_x25PVCDXETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PVCDXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PVCDXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PVCDXETable", "storing data...  "));
	refresh_x25PVCDXETable();
	(void) tmpsize;
	for (hcindex = x25PVCDXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PVCDXETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PVCDXETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PVCDXETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PVCDXELogicalChannel,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PVCDXERowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25SVCIVMOTable_add(): adds a structure node to our data set
 */
int
x25SVCIVMOTable_add(struct x25SVCIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25SVCIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25SVCIVMOId,
				  thedata->x25SVCIVMOIdLen);

	header_complex_add_data(&x25SVCIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25SVCIVMOTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25SVCIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCIVMOTable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25SVCIVMOTable_data);

	DEBUGMSGTL(("x25SVCIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCIVMOId, &tmpsize);
	StorageTmp->x25SVCIVMOIdLen = tmpsize;
	if (StorageTmp->x25SVCIVMOId == NULL) {
		config_perror("invalid specification for x25SVCIVMOId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOFastSelect, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOPacketSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOPacketSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOReverseCharging,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOThroughputClassIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOThroughputClassOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOWindowSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOWindowSizeOutgoing,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMORowStatus, &tmpsize);

	x25SVCIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCIVMOTable", "done.\n"));
}

/*
 * store_x25SVCIVMOTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCIVMOTable", "storing data...  "));
	refresh_x25SVCIVMOTable();
	(void) tmpsize;
	for (hcindex = x25SVCIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCIVMOTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25SVCIVMOTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25SVCIVMOTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25SVCIVMOIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25SVCIVMOId,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMOFastSelect,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCIVMOPacketSizeIncoming, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCIVMOPacketSizeOutgoing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCIVMOReverseCharging, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCIVMOThroughputClassIncoming,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCIVMOThroughputClassOutgoing,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCIVMOWindowSizeIncoming, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCIVMOWindowSizeOutgoing, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMORowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25SVCIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25SVCIVMODTETable_add(): adds a structure node to our data set
 */
int
x25SVCIVMODTETable_add(struct x25SVCIVMODTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCIVMODTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25SVCIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25SVCIVMOId,
				  thedata->x25SVCIVMOIdLen);

	header_complex_add_data(&x25SVCIVMODTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCIVMODTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25SVCIVMODTETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25SVCIVMODTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCIVMODTETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25SVCIVMODTETable_data);

	DEBUGMSGTL(("x25SVCIVMODTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCIVMOId, &tmpsize);
	StorageTmp->x25SVCIVMOIdLen = tmpsize;
	if (StorageTmp->x25SVCIVMOId == NULL) {
		config_perror("invalid specification for x25SVCIVMOId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTECallTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEResetTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEResetCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEInterruptTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEClearTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEClearCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEWindowTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEDataTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEDataCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTERejectTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTERejectCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTERowStatus, &tmpsize);

	x25SVCIVMODTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCIVMODTETable", "done.\n"));
}

/*
 * store_x25SVCIVMODTETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCIVMODTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCIVMODTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCIVMODTETable", "storing data...  "));
	refresh_x25SVCIVMODTETable();
	(void) tmpsize;
	for (hcindex = x25SVCIVMODTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCIVMODTETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25SVCIVMODTETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25SVCIVMODTETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25SVCIVMOIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25SVCIVMOId,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTECallTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTEResetTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTEResetCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCIVMODTEInterruptTime, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTEClearTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTEClearCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTEWindowTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTEDataTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTEDataCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTERejectTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTERejectCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODTERowStatus,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25SVCIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25SVCIVMODXETable_add(): adds a structure node to our data set
 */
int
x25SVCIVMODXETable_add(struct x25SVCIVMODXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCIVMODXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25SVCIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25SVCIVMOId,
				  thedata->x25SVCIVMOIdLen);

	header_complex_add_data(&x25SVCIVMODXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCIVMODXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25SVCIVMODXETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25SVCIVMODXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCIVMODXETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25SVCIVMODXETable_data);

	DEBUGMSGTL(("x25SVCIVMODXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCIVMOId, &tmpsize);
	StorageTmp->x25SVCIVMOIdLen = tmpsize;
	if (StorageTmp->x25SVCIVMOId == NULL) {
		config_perror("invalid specification for x25SVCIVMOId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXECallTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEResetTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEClearTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEInterruptTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEResetCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEClearCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXERowStatus, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEWindowTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEDataTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEDataCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXERejectTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXERejectCount,
				  &tmpsize);

	x25SVCIVMODXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCIVMODXETable", "done.\n"));
}

/*
 * store_x25SVCIVMODXETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCIVMODXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCIVMODXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCIVMODXETable", "storing data...  "));
	refresh_x25SVCIVMODXETable();
	(void) tmpsize;
	for (hcindex = x25SVCIVMODXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCIVMODXETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25SVCIVMODXETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25SVCIVMODXETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25SVCIVMOIdLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25SVCIVMOId,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXECallTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXEResetTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXEClearTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCIVMODXEInterruptTime, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXEResetCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXEClearCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXERowStatus,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXEWindowTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXEDataTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXEDataCount,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXERejectTime,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCIVMODXERejectCount,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25SVCIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25SVCDTETable_add(): adds a structure node to our data set
 */
int
x25SVCDTETable_add(struct x25SVCDTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCDTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);

	header_complex_add_data(&x25SVCDTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCDTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25SVCDTETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25SVCDTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCDTETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25SVCDTETable_data);

	DEBUGMSGTL(("x25SVCDTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line =
	    read_config_read_data(, line, &StorageTmp->x25SVCDTECallingAddressExtension, &tmpsize);
	line =
	    read_config_read_data(, line, &StorageTmp->x25SVCDTECalledAddressExtension, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDTEDirection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDTEFastSelect, &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line,
				  &StorageTmp->x25SVCDTEOriginallyCalledAddress, &tmpsize);
	StorageTmp->x25SVCDTEOriginallyCalledAddressLen = tmpsize;
	if (StorageTmp->x25SVCDTEOriginallyCalledAddress == NULL) {
		config_perror("invalid specification for x25SVCDTEOriginallyCalledAddress");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDTERedirectReason,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCDTERemoteDTEAddress,
				  &tmpsize);
	StorageTmp->x25SVCDTERemoteDTEAddressLen = tmpsize;
	if (StorageTmp->x25SVCDTERemoteDTEAddress == NULL) {
		config_perror("invalid specification for x25SVCDTERemoteDTEAddress");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDTEReverseCharging,
				  &tmpsize);

	x25SVCDTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCDTETable", "done.\n"));
}

/*
 * store_x25SVCDTETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCDTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCDTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCDTETable", "storing data...  "));
	refresh_x25SVCDTETable();
	(void) tmpsize;
	for (hcindex = x25SVCDTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCDTETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25SVCDTETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25SVCDTETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		cptr =
		    read_config_store_data(, cptr, &StorageTmp->x25SVCDTECallingAddressExtension,
					   &tmpsize);
		cptr =
		    read_config_store_data(, cptr, &StorageTmp->x25SVCDTECalledAddressExtension,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCDTEDirection,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCDTEFastSelect,
					   &tmpsize);
		tmpsize = StorageTmp->x25SVCDTEOriginallyCalledAddressLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->x25SVCDTEOriginallyCalledAddress, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCDTERedirectReason,
					   &tmpsize);
		tmpsize = StorageTmp->x25SVCDTERemoteDTEAddressLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->x25SVCDTERemoteDTEAddress, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCDTEReverseCharging,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25SVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25SVCDCETable_add(): adds a structure node to our data set
 */
int
x25SVCDCETable_add(struct x25SVCDCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCDCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);

	header_complex_add_data(&x25SVCDCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCDCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25SVCDCETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25SVCDCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCDCETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25SVCDCETable_data);

	DEBUGMSGTL(("x25SVCDCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDCEChargingDirection,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDCECUGSelection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDCEDirection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDCEFastSelect, &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCDCERemoteDTEAddress,
				  &tmpsize);
	StorageTmp->x25SVCDCERemoteDTEAddressLen = tmpsize;
	if (StorageTmp->x25SVCDCERemoteDTEAddress == NULL) {
		config_perror("invalid specification for x25SVCDCERemoteDTEAddress");
		return;
	}

	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25SVCDCETransitDelaySelectionAndIndication,
				  &tmpsize);

	x25SVCDCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCDCETable", "done.\n"));
}

/*
 * store_x25SVCDCETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCDCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCDCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCDCETable", "storing data...  "));
	refresh_x25SVCDCETable();
	(void) tmpsize;
	for (hcindex = x25SVCDCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCDCETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25SVCDCETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25SVCDCETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCDCEChargingDirection, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCDCECUGSelection,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCDCEDirection,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCDCEFastSelect,
					   &tmpsize);
		tmpsize = StorageTmp->x25SVCDCERemoteDTEAddressLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->x25SVCDCERemoteDTEAddress, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr,
					   &StorageTmp->x25SVCDCETransitDelaySelectionAndIndication,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25SVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25SVCDXETable_add(): adds a structure node to our data set
 */
int
x25SVCDXETable_add(struct x25SVCDXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCDXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);

	header_complex_add_data(&x25SVCDXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCDXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25SVCDXETable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25SVCDXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCDXETable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25SVCDXETable_data);

	DEBUGMSGTL(("x25SVCDXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDXEDirection, &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCDXERemoteDTEAddress,
				  &tmpsize);
	StorageTmp->x25SVCDXERemoteDTEAddressLen = tmpsize;
	if (StorageTmp->x25SVCDXERemoteDTEAddress == NULL) {
		config_perror("invalid specification for x25SVCDXERemoteDTEAddress");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDXEFastSelect, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDXERedirectReason,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line,
				  &StorageTmp->x25SVCDXEOriginallyCalledAddress, &tmpsize);
	StorageTmp->x25SVCDXEOriginallyCalledAddressLen = tmpsize;
	if (StorageTmp->x25SVCDXEOriginallyCalledAddress == NULL) {
		config_perror("invalid specification for x25SVCDXEOriginallyCalledAddress");
		return;
	}

	line =
	    read_config_read_data(, line, &StorageTmp->x25SVCDXECallingAddressExtension, &tmpsize);
	line =
	    read_config_read_data(, line, &StorageTmp->x25SVCDXECalledAddressExtension, &tmpsize);

	x25SVCDXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCDXETable", "done.\n"));
}

/*
 * store_x25SVCDXETable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCDXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCDXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCDXETable", "storing data...  "));
	refresh_x25SVCDXETable();
	(void) tmpsize;
	for (hcindex = x25SVCDXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCDXETable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25SVCDXETableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25SVCDXETable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCDXEDirection,
					   &tmpsize);
		tmpsize = StorageTmp->x25SVCDXERemoteDTEAddressLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->x25SVCDXERemoteDTEAddress, &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCDXEFastSelect,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25SVCDXERedirectReason,
					   &tmpsize);
		tmpsize = StorageTmp->x25SVCDXEOriginallyCalledAddressLen;
		cptr =
		    read_config_store_data(ASN_OCTET_STR, cptr,
					   &StorageTmp->x25SVCDXEOriginallyCalledAddress, &tmpsize);
		cptr =
		    read_config_store_data(, cptr, &StorageTmp->x25SVCDXECallingAddressExtension,
					   &tmpsize);
		cptr =
		    read_config_store_data(, cptr, &StorageTmp->x25SVCDXECalledAddressExtension,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25SVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25DSCTable_add(): adds a structure node to our data set
 */
int
x25DSCTable_add(struct x25DSCTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25DSCTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	/* x25DSCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25DSCId,
				  thedata->x25DSCIdLen);

	header_complex_add_data(&x25DSCTableStorage, vars, thedata);
	DEBUGMSGTL(("x25DSCTable", "registered an entry\n"));
	DEBUGMSGTL(("x25DSCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25DSCTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25DSCTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25DSCTable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25DSCTable_data);

	DEBUGMSGTL(("x25DSCTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId, &tmpsize);
	StorageTmp->x25VCIdLen = tmpsize;
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25DSCId, &tmpsize);
	StorageTmp->x25DSCIdLen = tmpsize;
	if (StorageTmp->x25DSCId == NULL) {
		config_perror("invalid specification for x25DSCId");
		return;
	}

	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25DSCResetRequestIndicationPackets, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25DSCSegmentsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25DSCSegmentsReceived,
				  &tmpsize);

	x25DSCTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25DSCTable", "done.\n"));
}

/*
 * store_x25DSCTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25DSCTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25DSCTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25DSCTable", "storing data...  "));
	refresh_x25DSCTable();
	(void) tmpsize;
	for (hcindex = x25DSCTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25DSCTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25DSCTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25DSCTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		tmpsize = StorageTmp->x25VCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId, &tmpsize);
		tmpsize = StorageTmp->x25DSCIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25DSCId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25DSCResetRequestIndicationPackets,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25DSCSegmentsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr, &StorageTmp->x25DSCSegmentsReceived,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25DSCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEDTEStatsTable_add(): adds a structure node to our data set
 */
int
x25PLEDTEStatsTable_add(struct x25PLEDTEStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDTEStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);

	header_complex_add_data(&x25PLEDTEStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDTEStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDTEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEDTEStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEDTEStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDTEStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEDTEStatsTable_data);

	DEBUGMSGTL(("x25PLEDTEStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsCallAttempts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsProtocolErrorsDetectedLocally,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsProtocolErrorsAccusedOf, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsCallCountsExceeded, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsOctetsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsCallTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsCallsConnected,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsDataPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsDataTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsProviderDisconnects, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsRemoteResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsRemoteRestarts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsResetTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsRestartCountsExceeded, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsClearTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsClearCountsExceeded, &tmpsize);

	x25PLEDTEStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDTEStatsTable", "done.\n"));
}

/*
 * store_x25PLEDTEStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDTEStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDTEStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDTEStatsTable", "storing data...  "));
	refresh_x25PLEDTEStatsTable();
	(void) tmpsize;
	for (hcindex = x25PLEDTEStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDTEStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLEDTEStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLEDTEStatsTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsCallAttempts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsProtocolErrorsDetectedLocally,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsProtocolErrorsAccusedOf,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsCallCountsExceeded, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsOctetsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsOctetsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsCallTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsCallsConnected, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsDataPacketsReceived,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsDataPacketsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsDataTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsProviderResets, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsProviderDisconnects,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsRemoteResets, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsRemoteRestarts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsResetTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsRestartCountsExceeded,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsClearTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDTEStatsClearCountsExceeded,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLEDTEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEDCEStatsTable_add(): adds a structure node to our data set
 */
int
x25PLEDCEStatsTable_add(struct x25PLEDCEStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDCEStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);

	header_complex_add_data(&x25PLEDCEStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDCEStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDCEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEDCEStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEDCEStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDCEStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEDCEStatsTable_data);

	DEBUGMSGTL(("x25PLEDCEStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsCallAttempts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsCallsConnected,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsOctetsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDCEStatsDataPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDCEStatsInterruptPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDCEStatsInterruptPacketsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDCEStatsProviderDisconnects, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsRemoteResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsRemoteRestarts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsResetTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDCEStatsX25SegmentsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsX25SegmentsSent,
				  &tmpsize);

	x25PLEDCEStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDCEStatsTable", "done.\n"));
}

/*
 * store_x25PLEDCEStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDCEStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDCEStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDCEStatsTable", "storing data...  "));
	refresh_x25PLEDCEStatsTable();
	(void) tmpsize;
	for (hcindex = x25PLEDCEStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDCEStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLEDCEStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLEDCEStatsTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsCallAttempts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsCallsConnected, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsOctetsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsOctetsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsDataPacketsReceived,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsDataPacketsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsInterruptPacketsReceived,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsInterruptPacketsSent,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsProviderResets, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsProviderDisconnects,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsRemoteResets, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsRemoteRestarts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsResetTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsX25SegmentsReceived,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDCEStatsX25SegmentsSent, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLEDCEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * x25PLEDXEStatsTable_add(): adds a structure node to our data set
 */
int
x25PLEDXEStatsTable_add(struct x25PLEDXEStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDXEStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);

	header_complex_add_data(&x25PLEDXEStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDXEStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDXEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_x25PLEDXEStatsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_x25PLEDXEStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDXEStatsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(x25PLEDXEStatsTable_data);

	DEBUGMSGTL(("x25PLEDXEStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId, &tmpsize);
	StorageTmp->x25PLEIdLen = tmpsize;
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}

	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsCallAttempts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsProtocolErrorsDetectedLocally,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsProtocolErrorsAccusedOf, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsCallCountsExceeded, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsOctetsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsCallTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsCallsConnected,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsClearTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsDataPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsDataTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsProviderDisconnects, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsRemoteResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsRemoteRestarts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsResetTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsRestartCountsExceeded, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsClearCountsExceeded, &tmpsize);

	x25PLEDXEStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDXEStatsTable", "done.\n"));
}

/*
 * store_x25PLEDXEStatsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDXEStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDXEStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDXEStatsTable", "storing data...  "));
	refresh_x25PLEDXEStatsTable();
	(void) tmpsize;
	for (hcindex = x25PLEDXEStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDXEStatsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->x25PLEDXEStatsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLEDXEStatsTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->x25PLEIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsCallAttempts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsProtocolErrorsDetectedLocally,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsProtocolErrorsAccusedOf,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsCallCountsExceeded, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsOctetsReceived, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsOctetsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsCallTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsCallsConnected, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsClearTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsDataPacketsReceived,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsDataPacketsSent, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsDataTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsProviderResets, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsProviderDisconnects,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsRemoteResets, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsRemoteRestarts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsResetTimeouts, &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsRestartCountsExceeded,
					   &tmpsize);
		cptr =
		    read_config_store_data(ASN_COUNTER64, cptr,
					   &StorageTmp->x25PLEDXEStatsClearCountsExceeded,
					   &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("x25PLEDXEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_x25PLETable(): refresh x25PLETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLETable(void)
{
	if (x25PLETable_refresh == 0)
		return;
	x25PLETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLETable_row(): refresh x25PLETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLETable_row(struct x25PLETable_data *StorageTmp)
{
	if (StorageTmp->x25PLETable_request == sa_request)
		return;
	StorageTmp->x25PLETable_request = sa_request;
}

/*
 * var_x25PLETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		WriteMethod ** write_method)
{
	struct x25PLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEOperationalState);
		return (uint8_t *) &StorageTmp->x25PLEOperationalState;
	case X25PLEADMINISTRATIVESTATE:
		*write_method = write_x25PLEAdministrativeState;
		*var_len = sizeof(StorageTmp->x25PLEAdministrativeState);
		return (uint8_t *) &StorageTmp->x25PLEAdministrativeState;
	case X25PLEPROTOCOLVERSIONSSUPPORTED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEProtocolVersionsSupportedLen;
		return (uint8_t *) StorageTmp->x25PLEProtocolVersionsSupported;
	case X25PLELOCALDTEADDRESS:
		*write_method = write_x25PLELocalDTEAddress;
		*var_len = StorageTmp->x25PLELocalDTEAddressLen;
		return (uint8_t *) StorageTmp->x25PLELocalDTEAddress;
	case X25PLEINTERFACEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEInterfaceMode);
		return (uint8_t *) &StorageTmp->x25PLEInterfaceMode;
	case X25PLEFACILITYNONNEGOTIABLE:
		*write_method = write_x25PLEFacilityNonNegotiable;
		*var_len = StorageTmp->x25PLEFacilityNonNegotiableLen;
		return (uint8_t *) StorageTmp->x25PLEFacilityNonNegotiable;
	case X25PLEFACILITYAVAILABILITY:
		*write_method = write_x25PLEFacilityAvailability;
		*var_len = StorageTmp->x25PLEFacilityAvailabilityLen;
		return (uint8_t *) StorageTmp->x25PLEFacilityAvailability;
	case X25PLEFACILITYNEGOTIATION:
		*write_method = write_x25PLEFacilityNegotiation;
		*var_len = StorageTmp->x25PLEFacilityNegotiationLen;
		return (uint8_t *) StorageTmp->x25PLEFacilityNegotiation;
	case X25PLEFACILITYWHILEIDLE:
		*write_method = write_x25PLEFacilityWhileIdle;
		*var_len = StorageTmp->x25PLEFacilityWhileIdleLen;
		return (uint8_t *) StorageTmp->x25PLEFacilityWhileIdle;
	case X25PLEPACKETSEQUENCENUMBERING:
		*write_method = write_x25PLEPacketSequenceNumbering;
		*var_len = sizeof(StorageTmp->x25PLEPacketSequenceNumbering);
		return (uint8_t *) &StorageTmp->x25PLEPacketSequenceNumbering;
	case X25PLEDEFAULTPACKETSIZEINCOMING:
		*write_method = write_x25PLEDefaultPacketSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDefaultPacketSizeIncoming);
		return (uint8_t *) &StorageTmp->x25PLEDefaultPacketSizeIncoming;
	case X25PLEDEFAULTPACKETSIZEOUTGOING:
		*write_method = write_x25PLEDefaultPacketSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDefaultPacketSizeOutgoing);
		return (uint8_t *) &StorageTmp->x25PLEDefaultPacketSizeOutgoing;
	case X25PLEDEFAULTWINDOWSIZEINCOMING:
		*write_method = write_x25PLEDefaultWindowSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDefaultWindowSizeIncoming);
		return (uint8_t *) &StorageTmp->x25PLEDefaultWindowSizeIncoming;
	case X25PLEDEFAULTWINDOWSIZEOUTGOING:
		*write_method = write_x25PLEDefaultWindowSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDefaultWindowSizeOutgoing);
		return (uint8_t *) &StorageTmp->x25PLEDefaultWindowSizeOutgoing;
	case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25PLEDefaultThroughputClassIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDefaultThroughputClassIncoming);
		return (uint8_t *) &StorageTmp->x25PLEDefaultThroughputClassIncoming;
	case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25PLEDefaultThroughputClassOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDefaultThroughputClassOutgoing);
		return (uint8_t *) &StorageTmp->x25PLEDefaultThroughputClassOutgoing;
	case X25PLESNSERVICEPROVIDER:
		*write_method = write_x25PLESNServiceProvider;
		*var_len = StorageTmp->x25PLESNServiceProviderLen;
		return (uint8_t *) StorageTmp->x25PLESNServiceProvider;
	case X25PLESNSAP:
		*write_method = write_x25PLESNSAP;
		*var_len = StorageTmp->x25PLESNSAPLen;
		return (uint8_t *) StorageTmp->x25PLESNSAP;
	case X25PLELOGICALCHANNELASSIGNMENTHIC:
		*write_method = write_x25PLELogicalChannelAssignmentHIC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentHIC);
		return (uint8_t *) &StorageTmp->x25PLELogicalChannelAssignmentHIC;
	case X25PLELOGICALCHANNELASSIGNMENTLIC:
		*write_method = write_x25PLELogicalChannelAssignmentLIC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentLIC);
		return (uint8_t *) &StorageTmp->x25PLELogicalChannelAssignmentLIC;
	case X25PLELOGICALCHANNELASSIGNMENTHTC:
		*write_method = write_x25PLELogicalChannelAssignmentHTC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentHTC);
		return (uint8_t *) &StorageTmp->x25PLELogicalChannelAssignmentHTC;
	case X25PLELOGICALCHANNELASSIGNMENTLTC:
		*write_method = write_x25PLELogicalChannelAssignmentLTC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentLTC);
		return (uint8_t *) &StorageTmp->x25PLELogicalChannelAssignmentLTC;
	case X25PLELOGICALCHANNELASSIGNMENTHOC:
		*write_method = write_x25PLELogicalChannelAssignmentHOC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentHOC);
		return (uint8_t *) &StorageTmp->x25PLELogicalChannelAssignmentHOC;
	case X25PLELOGICALCHANNELASSIGNMENTLOC:
		*write_method = write_x25PLELogicalChannelAssignmentLOC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentLOC);
		return (uint8_t *) &StorageTmp->x25PLELogicalChannelAssignmentLOC;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEIVMOTable(): refresh x25PLEIVMOTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMOTable(void)
{
	if (x25PLEIVMOTable_refresh == 0)
		return;
	x25PLEIVMOTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEIVMOTable_row(): refresh x25PLEIVMOTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLEIVMOTable_row(struct x25PLEIVMOTable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMOTable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMOTable_request = sa_request;
}

/*
 * var_x25PLEIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLEIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		    WriteMethod ** write_method)
{
	struct x25PLEIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEIVMOINTERFACEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMOInterfaceMode);
		return (uint8_t *) &StorageTmp->x25PLEIVMOInterfaceMode;
	case X25PLEIVMODEFAULTPACKETSIZEINCOMING:
		*write_method = write_x25PLEIVMODefaultPacketSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultPacketSizeIncoming);
		return (uint8_t *) &StorageTmp->x25PLEIVMODefaultPacketSizeIncoming;
	case X25PLEIVMODEFAULTPACKETSIZEOUTGOING:
		*write_method = write_x25PLEIVMODefaultPacketSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing);
		return (uint8_t *) &StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25PLEIVMODefaultThroughputClassIncoming;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultThroughputClassIncoming);
		return (uint8_t *) &StorageTmp->x25PLEIVMODefaultThroughputClassIncoming;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25PLEIVMODefaultThroughputClassOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing);
		return (uint8_t *) &StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing;
	case X25PLEIVMODEFAULTWINDOWSIZEINCOMING:
		*write_method = write_x25PLEIVMODefaultWindowSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultWindowSizeIncoming);
		return (uint8_t *) &StorageTmp->x25PLEIVMODefaultWindowSizeIncoming;
	case X25PLEIVMODEFAULTWINDOWSIZEOUTGOING:
		*write_method = write_x25PLEIVMODefaultWindowSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing);
		return (uint8_t *) &StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing;
	case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION:
		*write_method = write_x25PLEIVMOFlowControlParameterNegotiation;
		*var_len = sizeof(StorageTmp->x25PLEIVMOFlowControlParameterNegotiation);
		return (uint8_t *) &StorageTmp->x25PLEIVMOFlowControlParameterNegotiation;
	case X25PLEIVMOLOCALDTEADDRESS:
		*write_method = write_x25PLEIVMOLocalDTEAddress;
		*var_len = StorageTmp->x25PLEIVMOLocalDTEAddressLen;
		return (uint8_t *) StorageTmp->x25PLEIVMOLocalDTEAddress;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHPC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHPC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC);
		return (uint8_t *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLPC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLPC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC);
		return (uint8_t *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHIC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHIC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC);
		return (uint8_t *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLIC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLIC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC);
		return (uint8_t *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHTC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHTC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC);
		return (uint8_t *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLTC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLTC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC);
		return (uint8_t *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHOC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHOC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC);
		return (uint8_t *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLOC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLOC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC);
		return (uint8_t *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC;
	case X25PLEIVMOSNSERVICEPROVIDER:
		*write_method = write_x25PLEIVMOSNServiceProvider;
		*var_len = StorageTmp->x25PLEIVMOSNServiceProviderLen;
		return (uint8_t *) StorageTmp->x25PLEIVMOSNServiceProvider;
	case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION:
		*write_method = write_x25PLEIVMOThroughputClassNegotiation;
		*var_len = sizeof(StorageTmp->x25PLEIVMOThroughputClassNegotiation);
		return (uint8_t *) &StorageTmp->x25PLEIVMOThroughputClassNegotiation;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEDTETable(): refresh x25PLEDTETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLEDTETable(void)
{
	if (x25PLEDTETable_refresh == 0)
		return;
	x25PLEDTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEDTETable_row(): refresh x25PLEDTETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLEDTETable_row(struct x25PLEDTETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDTETable_request == sa_request)
		return;
	StorageTmp->x25PLEDTETable_request = sa_request;
}

/*
 * var_x25PLEDTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLEDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PLEDTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEDTEPACKETSEQUENCING:
		*write_method = write_x25PLEDTEPacketSequencing;
		*var_len = sizeof(StorageTmp->x25PLEDTEPacketSequencing);
		return (uint8_t *) &StorageTmp->x25PLEDTEPacketSequencing;
	case X25PLEDTEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEDTEMaxActiveCircuits;
		*var_len = sizeof(StorageTmp->x25PLEDTEMaxActiveCircuits);
		return (uint8_t *) &StorageTmp->x25PLEDTEMaxActiveCircuits;
	case X25PLEDTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEDTECallDeflectionSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDTECallDeflectionSubscription);
		return (uint8_t *) &StorageTmp->x25PLEDTECallDeflectionSubscription;
	case X25PLEDTERESTARTTIME:
		*write_method = write_x25PLEDTERestartTime;
		*var_len = sizeof(StorageTmp->x25PLEDTERestartTime);
		return (uint8_t *) &StorageTmp->x25PLEDTERestartTime;
	case X25PLEDTERESTARTCOUNT:
		*write_method = write_x25PLEDTERestartCount;
		*var_len = sizeof(StorageTmp->x25PLEDTERestartCount);
		return (uint8_t *) &StorageTmp->x25PLEDTERestartCount;
	case X25PLEDTEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEDTEMinimumRecallTimer;
		*var_len = sizeof(StorageTmp->x25PLEDTEMinimumRecallTimer);
		return (uint8_t *) &StorageTmp->x25PLEDTEMinimumRecallTimer;
	case X25PLEDTEREGISTRATIONTIME:
		*write_method = write_x25PLEDTERegistrationTime;
		*var_len = sizeof(StorageTmp->x25PLEDTERegistrationTime);
		return (uint8_t *) &StorageTmp->x25PLEDTERegistrationTime;
	case X25PLEDTEREGISTRATIONCOUNT:
		*write_method = write_x25PLEDTERegistrationCount;
		*var_len = sizeof(StorageTmp->x25PLEDTERegistrationCount);
		return (uint8_t *) &StorageTmp->x25PLEDTERegistrationCount;
	case X25PLEDTEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEDTERegistrationPermitted;
		*var_len = sizeof(StorageTmp->x25PLEDTERegistrationPermitted);
		return (uint8_t *) &StorageTmp->x25PLEDTERegistrationPermitted;
	case X25PLEDTEPROFILE:
		*write_method = write_x25PLEDTEProfile;
		*var_len = StorageTmp->x25PLEDTEProfileLen;
		return (uint8_t *) StorageTmp->x25PLEDTEProfile;
	case X25PLEDTEROWSTATUS:
		*write_method = write_x25PLEDTERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEDTERowStatus);
		return (uint8_t *) &StorageTmp->x25PLEDTERowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEDCETable(): refresh x25PLEDCETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLEDCETable(void)
{
	if (x25PLEDCETable_refresh == 0)
		return;
	x25PLEDCETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEDCETable_row(): refresh x25PLEDCETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLEDCETable_row(struct x25PLEDCETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDCETable_request == sa_request)
		return;
	StorageTmp->x25PLEDCETable_request = sa_request;
}

/*
 * var_x25PLEDCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLEDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PLEDCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEDCEPACKETSEQUENCING:
		*write_method = write_x25PLEDCEPacketSequencing;
		*var_len = sizeof(StorageTmp->x25PLEDCEPacketSequencing);
		return (uint8_t *) &StorageTmp->x25PLEDCEPacketSequencing;
	case X25PLEDCECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEDCECallDeflectionSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCECallDeflectionSubscription);
		return (uint8_t *) &StorageTmp->x25PLEDCECallDeflectionSubscription;
	case X25PLEDCECUG:
		*write_method = write_x25PLEDCECUG;
		*var_len = sizeof(StorageTmp->x25PLEDCECUG);
		return (uint8_t *) &StorageTmp->x25PLEDCECUG;
	case X25PLEDCEFASTSELECTACCEPTANCE:
		*write_method = write_x25PLEDCEFastSelectAcceptance;
		*var_len = sizeof(StorageTmp->x25PLEDCEFastSelectAcceptance);
		return (uint8_t *) &StorageTmp->x25PLEDCEFastSelectAcceptance;
	case X25PLEDCEINCOMINGCALLSBARRED:
		*write_method = write_x25PLEDCEIncomingCallsBarred;
		*var_len = sizeof(StorageTmp->x25PLEDCEIncomingCallsBarred);
		return (uint8_t *) &StorageTmp->x25PLEDCEIncomingCallsBarred;
	case X25PLEDCEONEWAYLOGICALCHANNELOUTGOING:
		*write_method = write_x25PLEDCEOneWayLogicalChannelOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing);
		return (uint8_t *) &StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing;
	case X25PLEDCEOUTGOINGCALLSBARRED:
		*write_method = write_x25PLEDCEOutgoingCallsBarred;
		*var_len = sizeof(StorageTmp->x25PLEDCEOutgoingCallsBarred);
		return (uint8_t *) &StorageTmp->x25PLEDCEOutgoingCallsBarred;
	case X25PLEDCEBILATERALCUG:
		*write_method = write_x25PLEDCEBilateralCUG;
		*var_len = sizeof(StorageTmp->x25PLEDCEBilateralCUG);
		return (uint8_t *) &StorageTmp->x25PLEDCEBilateralCUG;
	case X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS:
		*write_method = write_x25PLEDCEBilateralCUGWithOutgoingAccess;
		*var_len = sizeof(StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess);
		return (uint8_t *) &StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess;
	case X25PLEDCECALLREDIRECTION:
		*write_method = write_x25PLEDCECallRedirection;
		*var_len = sizeof(StorageTmp->x25PLEDCECallRedirection);
		return (uint8_t *) &StorageTmp->x25PLEDCECallRedirection;
	case X25PLEDCECHARGINGINFORMATION:
		*write_method = write_x25PLEDCEChargingInformation;
		*var_len = sizeof(StorageTmp->x25PLEDCEChargingInformation);
		return (uint8_t *) &StorageTmp->x25PLEDCEChargingInformation;
	case X25PLEDCECUGWITHINCOMINGACCESS:
		*write_method = write_x25PLEDCECUGWithIncomingAccess;
		*var_len = sizeof(StorageTmp->x25PLEDCECUGWithIncomingAccess);
		return (uint8_t *) &StorageTmp->x25PLEDCECUGWithIncomingAccess;
	case X25PLEDCECUGWITHOUTGOINGACCESS:
		*write_method = write_x25PLEDCECUGWithOutgoingAccess;
		*var_len = sizeof(StorageTmp->x25PLEDCECUGWithOutgoingAccess);
		return (uint8_t *) &StorageTmp->x25PLEDCECUGWithOutgoingAccess;
	case X25PLEDCEDBITMODIFICATION:
		*write_method = write_x25PLEDCEDBitModification;
		*var_len = sizeof(StorageTmp->x25PLEDCEDBitModification);
		return (uint8_t *) &StorageTmp->x25PLEDCEDBitModification;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSSUBSCRIPTION:
		*write_method = write_x25PLEDCEDefaultThroughputClassSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCEDefaultThroughputClassSubscription);
		return (uint8_t *) &StorageTmp->x25PLEDCEDefaultThroughputClassSubscription;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSSUPPORTED:
		*write_method = write_x25PLEDCEDefaultThroughputClassSupported;
		*var_len = StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen;
		return (uint8_t *) StorageTmp->x25PLEDCEDefaultThroughputClassSupported;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25PLEDCEDefaultThroughputClassIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDCEDefaultThroughputClassIncoming);
		return (uint8_t *) &StorageTmp->x25PLEDCEDefaultThroughputClassIncoming;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25PLEDCEDefaultThroughputClassOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing);
		return (uint8_t *) &StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing;
	case X25PLEDCEHUNTGROUP:
		*write_method = write_x25PLEDCEHuntGroup;
		*var_len = sizeof(StorageTmp->x25PLEDCEHuntGroup);
		return (uint8_t *) &StorageTmp->x25PLEDCEHuntGroup;
	case X25PLEDCEINCOMINGCALLBARREDWITHINCUG:
		*write_method = write_x25PLEDCEIncomingCallBarredWithinCUG;
		*var_len = sizeof(StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG);
		return (uint8_t *) &StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG;
	case X25PLEDCELOCALCHARGINGPREVENTION:
		*write_method = write_x25PLEDCELocalChargingPrevention;
		*var_len = sizeof(StorageTmp->x25PLEDCELocalChargingPrevention);
		return (uint8_t *) &StorageTmp->x25PLEDCELocalChargingPrevention;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZESUBSCRIPTION:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription);
		return (uint8_t *) &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeMaximum;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum);
		return (uint8_t *) &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming);
		return (uint8_t *) &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing);
		return (uint8_t *) &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZESUBSCRIPTION:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription);
		return (uint8_t *) &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEMAXIMUM:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeMaximum;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum);
		return (uint8_t *) &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEINCOMING:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming);
		return (uint8_t *) &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEOUTGOING:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing);
		return (uint8_t *) &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing;
	case X25PLEDCENUIOVERRIDE:
		*write_method = write_x25PLEDCENUIOverride;
		*var_len = sizeof(StorageTmp->x25PLEDCENUIOverride);
		return (uint8_t *) &StorageTmp->x25PLEDCENUIOverride;
	case X25PLEDCENUISUBSCRIPTION:
		*write_method = write_x25PLEDCENUISubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCENUISubscription);
		return (uint8_t *) &StorageTmp->x25PLEDCENUISubscription;
	case X25PLEDCEONEWAYLOGICALCHANNELINCOMING:
		*write_method = write_x25PLEDCEOneWayLogicalChannelIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming);
		return (uint8_t *) &StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming;
	case X25PLEDCEONLINEFACILITYREGISTRATION:
		*write_method = write_x25PLEDCEOnlineFacilityRegistration;
		*var_len = sizeof(StorageTmp->x25PLEDCEOnlineFacilityRegistration);
		return (uint8_t *) &StorageTmp->x25PLEDCEOnlineFacilityRegistration;
	case X25PLEDCEOUTGOINGCALLBARREDWITHINCUG:
		*write_method = write_x25PLEDCEOutgoingCallBarredWithinCUG;
		*var_len = sizeof(StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG);
		return (uint8_t *) &StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG;
	case X25PLEDCEPACKETRETRANSMISSION:
		*write_method = write_x25PLEDCEPacketRetransmission;
		*var_len = sizeof(StorageTmp->x25PLEDCEPacketRetransmission);
		return (uint8_t *) &StorageTmp->x25PLEDCEPacketRetransmission;
	case X25PLEDCEREVERSECHARGINGACCEPTANCE:
		*write_method = write_x25PLEDCEReverseChargingAcceptance;
		*var_len = sizeof(StorageTmp->x25PLEDCEReverseChargingAcceptance);
		return (uint8_t *) &StorageTmp->x25PLEDCEReverseChargingAcceptance;
	case X25PLEDCEROASUBSCRIPTION:
		*write_method = write_x25PLEDCEROASubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCEROASubscription);
		return (uint8_t *) &StorageTmp->x25PLEDCEROASubscription;
	case X25PLEDCERESTARTINDICATION:
		*write_method = write_x25PLEDCERestartIndication;
		*var_len = sizeof(StorageTmp->x25PLEDCERestartIndication);
		return (uint8_t *) &StorageTmp->x25PLEDCERestartIndication;
	case X25PLEDCERESTARTCOUNT:
		*write_method = write_x25PLEDCERestartCount;
		*var_len = sizeof(StorageTmp->x25PLEDCERestartCount);
		return (uint8_t *) &StorageTmp->x25PLEDCERestartCount;
	case X25PLEDCEINCOMINGCALL:
		*write_method = write_x25PLEDCEIncomingCall;
		*var_len = sizeof(StorageTmp->x25PLEDCEIncomingCall);
		return (uint8_t *) &StorageTmp->x25PLEDCEIncomingCall;
	case X25PLEDCECALLCOUNT:
		*write_method = write_x25PLEDCECallCount;
		*var_len = sizeof(StorageTmp->x25PLEDCECallCount);
		return (uint8_t *) &StorageTmp->x25PLEDCECallCount;
	case X25PLEDCERESETINDICATION:
		*write_method = write_x25PLEDCEResetIndication;
		*var_len = sizeof(StorageTmp->x25PLEDCEResetIndication);
		return (uint8_t *) &StorageTmp->x25PLEDCEResetIndication;
	case X25PLEDCERESETCOUNT:
		*write_method = write_x25PLEDCEResetCount;
		*var_len = sizeof(StorageTmp->x25PLEDCEResetCount);
		return (uint8_t *) &StorageTmp->x25PLEDCEResetCount;
	case X25PLEDCECLEARINDICATION:
		*write_method = write_x25PLEDCEClearIndication;
		*var_len = sizeof(StorageTmp->x25PLEDCEClearIndication);
		return (uint8_t *) &StorageTmp->x25PLEDCEClearIndication;
	case X25PLEDCECLEARCOUNT:
		*write_method = write_x25PLEDCEClearCount;
		*var_len = sizeof(StorageTmp->x25PLEDCEClearCount);
		return (uint8_t *) &StorageTmp->x25PLEDCEClearCount;
	case X25PLEDCEPROFILE:
		*write_method = write_x25PLEDCEProfile;
		*var_len = StorageTmp->x25PLEDCEProfileLen;
		return (uint8_t *) StorageTmp->x25PLEDCEProfile;
	case X25PLEDCEROWSTATUS:
		*write_method = write_x25PLEDCERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEDCERowStatus);
		return (uint8_t *) &StorageTmp->x25PLEDCERowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEDXETable(): refresh x25PLEDXETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLEDXETable(void)
{
	if (x25PLEDXETable_refresh == 0)
		return;
	x25PLEDXETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEDXETable_row(): refresh x25PLEDXETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLEDXETable_row(struct x25PLEDXETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDXETable_request == sa_request)
		return;
	StorageTmp->x25PLEDXETable_request = sa_request;
}

/*
 * var_x25PLEDXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLEDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PLEDXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEDXEPACKETSEQUENCING:
		*write_method = write_x25PLEDXEPacketSequencing;
		*var_len = sizeof(StorageTmp->x25PLEDXEPacketSequencing);
		return (uint8_t *) &StorageTmp->x25PLEDXEPacketSequencing;
	case X25PLEDXEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEDXEMaxActiveCircuits;
		*var_len = sizeof(StorageTmp->x25PLEDXEMaxActiveCircuits);
		return (uint8_t *) &StorageTmp->x25PLEDXEMaxActiveCircuits;
	case X25PLEDXECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEDXECallDeflectionSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDXECallDeflectionSubscription);
		return (uint8_t *) &StorageTmp->x25PLEDXECallDeflectionSubscription;
	case X25PLEDXERESTARTTIME:
		*write_method = write_x25PLEDXERestartTime;
		*var_len = sizeof(StorageTmp->x25PLEDXERestartTime);
		return (uint8_t *) &StorageTmp->x25PLEDXERestartTime;
	case X25PLEDXERESTARTCOUNT:
		*write_method = write_x25PLEDXERestartCount;
		*var_len = sizeof(StorageTmp->x25PLEDXERestartCount);
		return (uint8_t *) &StorageTmp->x25PLEDXERestartCount;
	case X25PLEDXEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEDXEMinimumRecallTimer;
		*var_len = sizeof(StorageTmp->x25PLEDXEMinimumRecallTimer);
		return (uint8_t *) &StorageTmp->x25PLEDXEMinimumRecallTimer;
	case X25PLEDXEREGISTRATIONTIME:
		*write_method = write_x25PLEDXERegistrationTime;
		*var_len = sizeof(StorageTmp->x25PLEDXERegistrationTime);
		return (uint8_t *) &StorageTmp->x25PLEDXERegistrationTime;
	case X25PLEDXEREGISTRATIONCOUNT:
		*write_method = write_x25PLEDXERegistrationCount;
		*var_len = sizeof(StorageTmp->x25PLEDXERegistrationCount);
		return (uint8_t *) &StorageTmp->x25PLEDXERegistrationCount;
	case X25PLEDXEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEDXERegistrationPermitted;
		*var_len = sizeof(StorageTmp->x25PLEDXERegistrationPermitted);
		return (uint8_t *) &StorageTmp->x25PLEDXERegistrationPermitted;
	case X25PLEDXEPLECLIENTMONAME:
		*write_method = write_x25PLEDXEPLEClientMOName;
		*var_len = StorageTmp->x25PLEDXEPLEClientMONameLen;
		return (uint8_t *) StorageTmp->x25PLEDXEPLEClientMOName;
	case X25PLEDXEPROFILE:
		*write_method = write_x25PLEDXEProfile;
		*var_len = StorageTmp->x25PLEDXEProfileLen;
		return (uint8_t *) StorageTmp->x25PLEDXEProfile;
	case X25PLEDXEROWSTATUS:
		*write_method = write_x25PLEDXERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEDXERowStatus);
		return (uint8_t *) &StorageTmp->x25PLEDXERowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEIVMODTETable(): refresh x25PLEIVMODTETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMODTETable(void)
{
	if (x25PLEIVMODTETable_refresh == 0)
		return;
	x25PLEIVMODTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEIVMODTETable_row(): refresh x25PLEIVMODTETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLEIVMODTETable_row(struct x25PLEIVMODTETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMODTETable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMODTETable_request = sa_request;
}

/*
 * var_x25PLEIVMODTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLEIVMODTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEIVMODTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMODTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMODTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEIVMODTECallDeflectionSubscription;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTECallDeflectionSubscription);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTECallDeflectionSubscription;
	case X25PLEIVMODTECALLTIME:
		*write_method = write_x25PLEIVMODTECallTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTECallTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTECallTime;
	case X25PLEIVMODTECLEARTIME:
		*write_method = write_x25PLEIVMODTEClearTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEClearTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEClearTime;
	case X25PLEIVMODTECLEARCOUNT:
		*write_method = write_x25PLEIVMODTEClearCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEClearCount);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEClearCount;
	case X25PLEIVMODTEPACKETSEQUENCING:
		*write_method = write_x25PLEIVMODTEPacketSequencing;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEPacketSequencing);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEPacketSequencing;
	case X25PLEIVMODTEINTERRUPTTIME:
		*write_method = write_x25PLEIVMODTEInterruptTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEInterruptTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEInterruptTime;
	case X25PLEIVMODTEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEIVMODTEMaxActiveCircuits;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEMaxActiveCircuits);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEMaxActiveCircuits;
	case X25PLEIVMODTEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEIVMODTEMinimumRecallTimer;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEMinimumRecallTimer);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEMinimumRecallTimer;
	case X25PLEIVMODTERESETTIME:
		*write_method = write_x25PLEIVMODTEResetTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEResetTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEResetTime;
	case X25PLEIVMODTERESETCOUNT:
		*write_method = write_x25PLEIVMODTEResetCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEResetCount);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEResetCount;
	case X25PLEIVMODTERESTARTTIME:
		*write_method = write_x25PLEIVMODTERestartTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERestartTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERestartTime;
	case X25PLEIVMODTERESTARTCOUNT:
		*write_method = write_x25PLEIVMODTERestartCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERestartCount);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERestartCount;
	case X25PLEIVMODTEWINDOWTIME:
		*write_method = write_x25PLEIVMODTEWindowTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEWindowTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEWindowTime;
	case X25PLEIVMODTEDATATIME:
		*write_method = write_x25PLEIVMODTEDataTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEDataTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEDataTime;
	case X25PLEIVMODTEDATACOUNT:
		*write_method = write_x25PLEIVMODTEDataCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEDataCount);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEDataCount;
	case X25PLEIVMODTEREJECTTIME:
		*write_method = write_x25PLEIVMODTERejectTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERejectTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERejectTime;
	case X25PLEIVMODTEREJECTCOUNT:
		*write_method = write_x25PLEIVMODTERejectCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERejectCount);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERejectCount;
	case X25PLEIVMODTEREGISTRATIONTIME:
		*write_method = write_x25PLEIVMODTERegistrationTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERegistrationTime;
	case X25PLEIVMODTEREGISTRATIONCOUNT:
		*write_method = write_x25PLEIVMODTERegistrationCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationCount);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERegistrationCount;
	case X25PLEIVMODTEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEIVMODTERegistrationPermitted;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationPermitted);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERegistrationPermitted;
	case X25PLEIVMODTEROWSTATUS:
		*write_method = write_x25PLEIVMODTERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERowStatus);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEIVMODCETable(): refresh x25PLEIVMODCETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMODCETable(void)
{
	if (x25PLEIVMODCETable_refresh == 0)
		return;
	x25PLEIVMODCETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEIVMODCETable_row(): refresh x25PLEIVMODCETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLEIVMODCETable_row(struct x25PLEIVMODCETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMODCETable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMODCETable_request = sa_request;
}

/*
 * var_x25PLEIVMODCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLEIVMODCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct x25PLEIVMODCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEIVMODCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMODCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEIVMODCETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMODCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEIVMODCEROWSTATUS:
		*write_method = write_x25PLEIVMODCERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEIVMODCERowStatus);
		return (uint8_t *) &StorageTmp->x25PLEIVMODCERowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEIVMODXETable(): refresh x25PLEIVMODXETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMODXETable(void)
{
	if (x25PLEIVMODXETable_refresh == 0)
		return;
	x25PLEIVMODXETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEIVMODXETable_row(): refresh x25PLEIVMODXETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLEIVMODXETable_row(struct x25PLEIVMODXETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMODXETable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMODXETable_request = sa_request;
}

/*
 * var_x25PLEIVMODXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLEIVMODXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEIVMODXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMODXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMODXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEIVMODTECallDeflectionSubscription;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTECallDeflectionSubscription);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTECallDeflectionSubscription;
	case X25PLEIVMODTEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEIVMODTEMaxActiveCircuits;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEMaxActiveCircuits);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEMaxActiveCircuits;
	case X25PLEIVMODTERESTARTTIME:
		*write_method = write_x25PLEIVMODTERestartTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERestartTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERestartTime;
	case X25PLEIVMODTEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEIVMODTEMinimumRecallTimer;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEMinimumRecallTimer);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEMinimumRecallTimer;
	case X25PLEIVMODTERESTARTCOUNT:
		*write_method = write_x25PLEIVMODTERestartCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERestartCount);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERestartCount;
	case X25PLEIVMODTEPACKETSEQUENCING:
		*write_method = write_x25PLEIVMODTEPacketSequencing;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEPacketSequencing);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTEPacketSequencing;
	case X25PLEIVMODTEREGISTRATIONTIME:
		*write_method = write_x25PLEIVMODTERegistrationTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationTime);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERegistrationTime;
	case X25PLEIVMODTEREGISTRATIONCOUNT:
		*write_method = write_x25PLEIVMODTERegistrationCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationCount);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERegistrationCount;
	case X25PLEIVMODTEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEIVMODTERegistrationPermitted;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationPermitted);
		return (uint8_t *) &StorageTmp->x25PLEIVMODTERegistrationPermitted;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25VCTable(): refresh x25VCTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25VCTable(void)
{
	if (x25VCTable_refresh == 0)
		return;
	x25VCTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25VCTable_row(): refresh x25VCTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25VCTable_row(struct x25VCTable_data *StorageTmp)
{
	if (StorageTmp->x25VCTable_request == sa_request)
		return;
	StorageTmp->x25VCTable_request = sa_request;
}

/*
 * var_x25VCTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25VCTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
	       WriteMethod ** write_method)
{
	struct x25VCTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25VCTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25VCTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25VCTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25VCLOGICALCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCLogicalChannel);
		return (uint8_t *) &StorageTmp->x25VCLogicalChannel;
	case X25VCPACKETSEQUENCING:
		*write_method = write_x25VCPacketSequencing;
		*var_len = sizeof(StorageTmp->x25VCPacketSequencing);
		return (uint8_t *) &StorageTmp->x25VCPacketSequencing;
	case X25VCPACKETSIZEINCOMING:
		*write_method = write_x25VCPacketSizeIncoming;
		*var_len = sizeof(StorageTmp->x25VCPacketSizeIncoming);
		return (uint8_t *) &StorageTmp->x25VCPacketSizeIncoming;
	case X25VCPACKETSIZEOUTGOING:
		*write_method = write_x25VCPacketSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25VCPacketSizeOutgoing);
		return (uint8_t *) &StorageTmp->x25VCPacketSizeOutgoing;
	case X25VCWINDOWSIZEINCOMING:
		*write_method = write_x25VCWindowSizeIncoming;
		*var_len = sizeof(StorageTmp->x25VCWindowSizeIncoming);
		return (uint8_t *) &StorageTmp->x25VCWindowSizeIncoming;
	case X25VCWINDOWSIZEOUTGOING:
		*write_method = write_x25VCWindowSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25VCWindowSizeOutgoing);
		return (uint8_t *) &StorageTmp->x25VCWindowSizeOutgoing;
	case X25VCTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25VCThroughputClassIncoming;
		*var_len = sizeof(StorageTmp->x25VCThroughputClassIncoming);
		return (uint8_t *) &StorageTmp->x25VCThroughputClassIncoming;
	case X25VCTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25VCThroughputClassOutgoing;
		*var_len = sizeof(StorageTmp->x25VCThroughputClassOutgoing);
		return (uint8_t *) &StorageTmp->x25VCThroughputClassOutgoing;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25VCDTETable(): refresh x25VCDTETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25VCDTETable(void)
{
	if (x25VCDTETable_refresh == 0)
		return;
	x25VCDTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25VCDTETable_row(): refresh x25VCDTETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25VCDTETable_row(struct x25VCDTETable_data *StorageTmp)
{
	if (StorageTmp->x25VCDTETable_request == sa_request)
		return;
	StorageTmp->x25VCDTETable_request = sa_request;
}

/*
 * var_x25VCDTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25VCDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		  WriteMethod ** write_method)
{
	struct x25VCDTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25VCDTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25VCDTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25VCDTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25VCDTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25VCDTEOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEOctetsReceived);
		return (uint8_t *) &StorageTmp->x25VCDTEOctetsReceived;
	case X25VCDTEOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEOctetsSent);
		return (uint8_t *) &StorageTmp->x25VCDTEOctetsSent;
	case X25VCDTEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEDataPacketsReceived);
		return (uint8_t *) &StorageTmp->x25VCDTEDataPacketsReceived;
	case X25VCDTEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEDataPacketsSent);
		return (uint8_t *) &StorageTmp->x25VCDTEDataPacketsSent;
	case X25VCDTEDATATIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEDataTimeouts);
		return (uint8_t *) &StorageTmp->x25VCDTEDataTimeouts;
	case X25VCDTEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEInterruptPacketsReceived);
		return (uint8_t *) &StorageTmp->x25VCDTEInterruptPacketsReceived;
	case X25VCDTEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEInterruptPacketsSent);
		return (uint8_t *) &StorageTmp->x25VCDTEInterruptPacketsSent;
	case X25VCDTEINTERRUPTTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEInterruptTimeouts);
		return (uint8_t *) &StorageTmp->x25VCDTEInterruptTimeouts;
	case X25VCDTEPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEProviderResets);
		return (uint8_t *) &StorageTmp->x25VCDTEProviderResets;
	case X25VCDTEREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTERemoteResets);
		return (uint8_t *) &StorageTmp->x25VCDTERemoteResets;
	case X25VCDTERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEResetTimeouts);
		return (uint8_t *) &StorageTmp->x25VCDTEResetTimeouts;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25VCDCETable(): refresh x25VCDCETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25VCDCETable(void)
{
	if (x25VCDCETable_refresh == 0)
		return;
	x25VCDCETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25VCDCETable_row(): refresh x25VCDCETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25VCDCETable_row(struct x25VCDCETable_data *StorageTmp)
{
	if (StorageTmp->x25VCDCETable_request == sa_request)
		return;
	StorageTmp->x25VCDCETable_request = sa_request;
}

/*
 * var_x25VCDCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25VCDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		  WriteMethod ** write_method)
{
	struct x25VCDCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25VCDCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25VCDCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25VCDCETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25VCDCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25VCDCEOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEOctetsReceived);
		return (uint8_t *) &StorageTmp->x25VCDCEOctetsReceived;
	case X25VCDCEOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEOctetsSent);
		return (uint8_t *) &StorageTmp->x25VCDCEOctetsSent;
	case X25VCDCEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEDataPacketsReceived);
		return (uint8_t *) &StorageTmp->x25VCDCEDataPacketsReceived;
	case X25VCDCEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEDataPacketsSent);
		return (uint8_t *) &StorageTmp->x25VCDCEDataPacketsSent;
	case X25VCDCEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEInterruptPacketsReceived);
		return (uint8_t *) &StorageTmp->x25VCDCEInterruptPacketsReceived;
	case X25VCDCEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEInterruptPacketsSent);
		return (uint8_t *) &StorageTmp->x25VCDCEInterruptPacketsSent;
	case X25VCDCEPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEProviderResets);
		return (uint8_t *) &StorageTmp->x25VCDCEProviderResets;
	case X25VCDCEREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCERemoteResets);
		return (uint8_t *) &StorageTmp->x25VCDCERemoteResets;
	case X25VCDCERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEResetTimeouts);
		return (uint8_t *) &StorageTmp->x25VCDCEResetTimeouts;
	case X25VCDCEREMOTERESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCERemoteRestarts);
		return (uint8_t *) &StorageTmp->x25VCDCERemoteRestarts;
	case X25VCDCEPROVIDERDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEProviderDisconnects);
		return (uint8_t *) &StorageTmp->x25VCDCEProviderDisconnects;
	case X25VCDCEX25SEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEX25SegmentsReceived);
		return (uint8_t *) &StorageTmp->x25VCDCEX25SegmentsReceived;
	case X25VCDCEX25SEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEX25SegmentsSent);
		return (uint8_t *) &StorageTmp->x25VCDCEX25SegmentsSent;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25VCDXETable(): refresh x25VCDXETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25VCDXETable(void)
{
	if (x25VCDXETable_refresh == 0)
		return;
	x25VCDXETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25VCDXETable_row(): refresh x25VCDXETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25VCDXETable_row(struct x25VCDXETable_data *StorageTmp)
{
	if (StorageTmp->x25VCDXETable_request == sa_request)
		return;
	StorageTmp->x25VCDXETable_request = sa_request;
}

/*
 * var_x25VCDXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25VCDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		  WriteMethod ** write_method)
{
	struct x25VCDXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25VCDXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25VCDXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25VCDXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25VCDXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25VCDXEOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEOctetsReceived);
		return (uint8_t *) &StorageTmp->x25VCDXEOctetsReceived;
	case X25VCDXEOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEOctetsSent);
		return (uint8_t *) &StorageTmp->x25VCDXEOctetsSent;
	case X25VCDXEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEDataPacketsReceived);
		return (uint8_t *) &StorageTmp->x25VCDXEDataPacketsReceived;
	case X25VCDXEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEDataPacketsSent);
		return (uint8_t *) &StorageTmp->x25VCDXEDataPacketsSent;
	case X25VCDXEDATATIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEDataTimeouts);
		return (uint8_t *) &StorageTmp->x25VCDXEDataTimeouts;
	case X25VCDXEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEInterruptPacketsReceived);
		return (uint8_t *) &StorageTmp->x25VCDXEInterruptPacketsReceived;
	case X25VCDXEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEInterruptPacketsSent);
		return (uint8_t *) &StorageTmp->x25VCDXEInterruptPacketsSent;
	case X25VCDXEINTERRUPTTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEInterruptTimeouts);
		return (uint8_t *) &StorageTmp->x25VCDXEInterruptTimeouts;
	case X25VCDXEPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEProviderResets);
		return (uint8_t *) &StorageTmp->x25VCDXEProviderResets;
	case X25VCDXEREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXERemoteResets);
		return (uint8_t *) &StorageTmp->x25VCDXERemoteResets;
	case X25VCDXERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEResetTimeouts);
		return (uint8_t *) &StorageTmp->x25VCDXEResetTimeouts;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PVCDTETable(): refresh x25PVCDTETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PVCDTETable(void)
{
	if (x25PVCDTETable_refresh == 0)
		return;
	x25PVCDTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PVCDTETable_row(): refresh x25PVCDTETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PVCDTETable_row(struct x25PVCDTETable_data *StorageTmp)
{
	if (StorageTmp->x25PVCDTETable_request == sa_request)
		return;
	StorageTmp->x25PVCDTETable_request = sa_request;
}

/*
 * var_x25PVCDTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PVCDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PVCDTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PVCDTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PVCDTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PVCDTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PVCDTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PVCDTELOGICALCHANNEL:
		*write_method = write_x25PVCDTELogicalChannel;
		*var_len = sizeof(StorageTmp->x25PVCDTELogicalChannel);
		return (uint8_t *) &StorageTmp->x25PVCDTELogicalChannel;
	case X25PVCDTEROWSTATUS:
		*write_method = write_x25PVCDTERowStatus;
		*var_len = sizeof(StorageTmp->x25PVCDTERowStatus);
		return (uint8_t *) &StorageTmp->x25PVCDTERowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PVCDCETable(): refresh x25PVCDCETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PVCDCETable(void)
{
	if (x25PVCDCETable_refresh == 0)
		return;
	x25PVCDCETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PVCDCETable_row(): refresh x25PVCDCETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PVCDCETable_row(struct x25PVCDCETable_data *StorageTmp)
{
	if (StorageTmp->x25PVCDCETable_request == sa_request)
		return;
	StorageTmp->x25PVCDCETable_request = sa_request;
}

/*
 * var_x25PVCDCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PVCDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PVCDCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PVCDCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PVCDCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PVCDCETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PVCDCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PVCDCELOGICALCHANNEL:
		*write_method = write_x25PVCDCELogicalChannel;
		*var_len = sizeof(StorageTmp->x25PVCDCELogicalChannel);
		return (uint8_t *) &StorageTmp->x25PVCDCELogicalChannel;
	case X25PVCDCECHARGINGDIRECTION:
		*write_method = write_x25PVCDCEChargingDirection;
		*var_len = sizeof(StorageTmp->x25PVCDCEChargingDirection);
		return (uint8_t *) &StorageTmp->x25PVCDCEChargingDirection;
	case X25PVCDCEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PVCDCEOperationalState);
		return (uint8_t *) &StorageTmp->x25PVCDCEOperationalState;
	case X25PVCDCEREMOTEDTEADDRESS:
		*write_method = write_x25PVCDCERemoteDTEAddress;
		*var_len = StorageTmp->x25PVCDCERemoteDTEAddressLen;
		return (uint8_t *) StorageTmp->x25PVCDCERemoteDTEAddress;
	case X25PVCDCEREMOTELOGICALCHANNEL:
		*write_method = write_x25PVCDCERemoteLogicalChannel;
		*var_len = sizeof(StorageTmp->x25PVCDCERemoteLogicalChannel);
		return (uint8_t *) &StorageTmp->x25PVCDCERemoteLogicalChannel;
	case X25PVCDCEROWSTATUS:
		*write_method = write_x25PVCDCERowStatus;
		*var_len = sizeof(StorageTmp->x25PVCDCERowStatus);
		return (uint8_t *) &StorageTmp->x25PVCDCERowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PVCDXETable(): refresh x25PVCDXETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PVCDXETable(void)
{
	if (x25PVCDXETable_refresh == 0)
		return;
	x25PVCDXETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PVCDXETable_row(): refresh x25PVCDXETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PVCDXETable_row(struct x25PVCDXETable_data *StorageTmp)
{
	if (StorageTmp->x25PVCDXETable_request == sa_request)
		return;
	StorageTmp->x25PVCDXETable_request = sa_request;
}

/*
 * var_x25PVCDXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PVCDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PVCDXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PVCDXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PVCDXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PVCDXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PVCDXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PVCDXELOGICALCHANNEL:
		*write_method = write_x25PVCDXELogicalChannel;
		*var_len = sizeof(StorageTmp->x25PVCDXELogicalChannel);
		return (uint8_t *) &StorageTmp->x25PVCDXELogicalChannel;
	case X25PVCDXEROWSTATUS:
		*write_method = write_x25PVCDXERowStatus;
		*var_len = sizeof(StorageTmp->x25PVCDXERowStatus);
		return (uint8_t *) &StorageTmp->x25PVCDXERowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25SVCIVMOTable(): refresh x25SVCIVMOTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25SVCIVMOTable(void)
{
	if (x25SVCIVMOTable_refresh == 0)
		return;
	x25SVCIVMOTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25SVCIVMOTable_row(): refresh x25SVCIVMOTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25SVCIVMOTable_row(struct x25SVCIVMOTable_data *StorageTmp)
{
	if (StorageTmp->x25SVCIVMOTable_request == sa_request)
		return;
	StorageTmp->x25SVCIVMOTable_request = sa_request;
}

/*
 * var_x25SVCIVMOTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25SVCIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		    WriteMethod ** write_method)
{
	struct x25SVCIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25SVCIVMOID:
		*write_method = write_x25SVCIVMOId;
		*var_len = StorageTmp->x25SVCIVMOIdLen;
		return (uint8_t *) StorageTmp->x25SVCIVMOId;
	case X25SVCIVMOFASTSELECT:
		*write_method = write_x25SVCIVMOFastSelect;
		*var_len = sizeof(StorageTmp->x25SVCIVMOFastSelect);
		return (uint8_t *) &StorageTmp->x25SVCIVMOFastSelect;
	case X25SVCIVMOPACKETSIZEINCOMING:
		*write_method = write_x25SVCIVMOPacketSizeIncoming;
		*var_len = sizeof(StorageTmp->x25SVCIVMOPacketSizeIncoming);
		return (uint8_t *) &StorageTmp->x25SVCIVMOPacketSizeIncoming;
	case X25SVCIVMOPACKETSIZEOUTGOING:
		*write_method = write_x25SVCIVMOPacketSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25SVCIVMOPacketSizeOutgoing);
		return (uint8_t *) &StorageTmp->x25SVCIVMOPacketSizeOutgoing;
	case X25SVCIVMOREVERSECHARGING:
		*write_method = write_x25SVCIVMOReverseCharging;
		*var_len = sizeof(StorageTmp->x25SVCIVMOReverseCharging);
		return (uint8_t *) &StorageTmp->x25SVCIVMOReverseCharging;
	case X25SVCIVMOTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25SVCIVMOThroughputClassIncoming;
		*var_len = sizeof(StorageTmp->x25SVCIVMOThroughputClassIncoming);
		return (uint8_t *) &StorageTmp->x25SVCIVMOThroughputClassIncoming;
	case X25SVCIVMOTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25SVCIVMOThroughputClassOutgoing;
		*var_len = sizeof(StorageTmp->x25SVCIVMOThroughputClassOutgoing);
		return (uint8_t *) &StorageTmp->x25SVCIVMOThroughputClassOutgoing;
	case X25SVCIVMOWINDOWSIZEINCOMING:
		*write_method = write_x25SVCIVMOWindowSizeIncoming;
		*var_len = sizeof(StorageTmp->x25SVCIVMOWindowSizeIncoming);
		return (uint8_t *) &StorageTmp->x25SVCIVMOWindowSizeIncoming;
	case X25SVCIVMOWINDOWSIZEOUTGOING:
		*write_method = write_x25SVCIVMOWindowSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25SVCIVMOWindowSizeOutgoing);
		return (uint8_t *) &StorageTmp->x25SVCIVMOWindowSizeOutgoing;
	case X25SVCIVMOROWSTATUS:
		*write_method = write_x25SVCIVMORowStatus;
		*var_len = sizeof(StorageTmp->x25SVCIVMORowStatus);
		return (uint8_t *) &StorageTmp->x25SVCIVMORowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25SVCIVMODTETable(): refresh x25SVCIVMODTETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25SVCIVMODTETable(void)
{
	if (x25SVCIVMODTETable_refresh == 0)
		return;
	x25SVCIVMODTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25SVCIVMODTETable_row(): refresh x25SVCIVMODTETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25SVCIVMODTETable_row(struct x25SVCIVMODTETable_data *StorageTmp)
{
	if (StorageTmp->x25SVCIVMODTETable_request == sa_request)
		return;
	StorageTmp->x25SVCIVMODTETable_request = sa_request;
}

/*
 * var_x25SVCIVMODTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25SVCIVMODTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCIVMODTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCIVMODTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCIVMODTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25SVCIVMODTECALLTIME:
		*write_method = write_x25SVCIVMODTECallTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTECallTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTECallTime;
	case X25SVCIVMODTERESETTIME:
		*write_method = write_x25SVCIVMODTEResetTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEResetTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTEResetTime;
	case X25SVCIVMODTERESETCOUNT:
		*write_method = write_x25SVCIVMODTEResetCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEResetCount);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTEResetCount;
	case X25SVCIVMODTEINTERRUPTTIME:
		*write_method = write_x25SVCIVMODTEInterruptTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEInterruptTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTEInterruptTime;
	case X25SVCIVMODTECLEARTIME:
		*write_method = write_x25SVCIVMODTEClearTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEClearTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTEClearTime;
	case X25SVCIVMODTECLEARCOUNT:
		*write_method = write_x25SVCIVMODTEClearCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEClearCount);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTEClearCount;
	case X25SVCIVMODTEWINDOWTIME:
		*write_method = write_x25SVCIVMODTEWindowTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEWindowTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTEWindowTime;
	case X25SVCIVMODTEDATATIME:
		*write_method = write_x25SVCIVMODTEDataTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEDataTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTEDataTime;
	case X25SVCIVMODTEDATACOUNT:
		*write_method = write_x25SVCIVMODTEDataCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEDataCount);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTEDataCount;
	case X25SVCIVMODTEREJECTTIME:
		*write_method = write_x25SVCIVMODTERejectTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTERejectTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTERejectTime;
	case X25SVCIVMODTEREJECTCOUNT:
		*write_method = write_x25SVCIVMODTERejectCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTERejectCount);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTERejectCount;
	case X25SVCIVMODTEROWSTATUS:
		*write_method = write_x25SVCIVMODTERowStatus;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTERowStatus);
		return (uint8_t *) &StorageTmp->x25SVCIVMODTERowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25SVCIVMODXETable(): refresh x25SVCIVMODXETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25SVCIVMODXETable(void)
{
	if (x25SVCIVMODXETable_refresh == 0)
		return;
	x25SVCIVMODXETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25SVCIVMODXETable_row(): refresh x25SVCIVMODXETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25SVCIVMODXETable_row(struct x25SVCIVMODXETable_data *StorageTmp)
{
	if (StorageTmp->x25SVCIVMODXETable_request == sa_request)
		return;
	StorageTmp->x25SVCIVMODXETable_request = sa_request;
}

/*
 * var_x25SVCIVMODXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25SVCIVMODXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCIVMODXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCIVMODXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCIVMODXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25SVCIVMODXECALLTIME:
		*write_method = write_x25SVCIVMODXECallTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXECallTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXECallTime;
	case X25SVCIVMODXERESETTIME:
		*write_method = write_x25SVCIVMODXEResetTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEResetTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXEResetTime;
	case X25SVCIVMODXECLEARTIME:
		*write_method = write_x25SVCIVMODXEClearTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEClearTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXEClearTime;
	case X25SVCIVMODXEINTERRUPTTIME:
		*write_method = write_x25SVCIVMODXEInterruptTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEInterruptTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXEInterruptTime;
	case X25SVCIVMODXERESETCOUNT:
		*write_method = write_x25SVCIVMODXEResetCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEResetCount);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXEResetCount;
	case X25SVCIVMODXECLEARCOUNT:
		*write_method = write_x25SVCIVMODXEClearCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEClearCount);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXEClearCount;
	case X25SVCIVMODXEROWSTATUS:
		*write_method = write_x25SVCIVMODXERowStatus;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXERowStatus);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXERowStatus;
	case X25SVCIVMODXEWINDOWTIME:
		*write_method = write_x25SVCIVMODXEWindowTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEWindowTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXEWindowTime;
	case X25SVCIVMODXEDATATIME:
		*write_method = write_x25SVCIVMODXEDataTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEDataTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXEDataTime;
	case X25SVCIVMODXEDATACOUNT:
		*write_method = write_x25SVCIVMODXEDataCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEDataCount);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXEDataCount;
	case X25SVCIVMODXEREJECTTIME:
		*write_method = write_x25SVCIVMODXERejectTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXERejectTime);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXERejectTime;
	case X25SVCIVMODXEREJECTCOUNT:
		*write_method = write_x25SVCIVMODXERejectCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXERejectCount);
		return (uint8_t *) &StorageTmp->x25SVCIVMODXERejectCount;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25SVCDTETable(): refresh x25SVCDTETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25SVCDTETable(void)
{
	if (x25SVCDTETable_refresh == 0)
		return;
	x25SVCDTETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25SVCDTETable_row(): refresh x25SVCDTETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25SVCDTETable_row(struct x25SVCDTETable_data *StorageTmp)
{
	if (StorageTmp->x25SVCDTETable_request == sa_request)
		return;
	StorageTmp->x25SVCDTETable_request = sa_request;
}

/*
 * var_x25SVCDTETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25SVCDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25SVCDTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCDTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCDTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCDTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCDTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25SVCDTECALLINGADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDTECallingAddressExtension;
		return (uint8_t *) StorageTmp->x25SVCDTECallingAddressExtension;
	case X25SVCDTECALLEDADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDTECalledAddressExtension;
		return (uint8_t *) StorageTmp->x25SVCDTECalledAddressExtension;
	case X25SVCDTEDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDTEDirection);
		return (uint8_t *) &StorageTmp->x25SVCDTEDirection;
	case X25SVCDTEFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDTEFastSelect);
		return (uint8_t *) &StorageTmp->x25SVCDTEFastSelect;
	case X25SVCDTEORIGINALLYCALLEDADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDTEOriginallyCalledAddressLen;
		return (uint8_t *) StorageTmp->x25SVCDTEOriginallyCalledAddress;
	case X25SVCDTEREDIRECTREASON:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDTERedirectReason);
		return (uint8_t *) &StorageTmp->x25SVCDTERedirectReason;
	case X25SVCDTEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDTERemoteDTEAddressLen;
		return (uint8_t *) StorageTmp->x25SVCDTERemoteDTEAddress;
	case X25SVCDTEREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDTEReverseCharging);
		return (uint8_t *) &StorageTmp->x25SVCDTEReverseCharging;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25SVCDCETable(): refresh x25SVCDCETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25SVCDCETable(void)
{
	if (x25SVCDCETable_refresh == 0)
		return;
	x25SVCDCETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25SVCDCETable_row(): refresh x25SVCDCETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25SVCDCETable_row(struct x25SVCDCETable_data *StorageTmp)
{
	if (StorageTmp->x25SVCDCETable_request == sa_request)
		return;
	StorageTmp->x25SVCDCETable_request = sa_request;
}

/*
 * var_x25SVCDCETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25SVCDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25SVCDCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCDCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCDCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCDCETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCDCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25SVCDCECHARGINGDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDCEChargingDirection);
		return (uint8_t *) &StorageTmp->x25SVCDCEChargingDirection;
	case X25SVCDCECUGSELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDCECUGSelection);
		return (uint8_t *) &StorageTmp->x25SVCDCECUGSelection;
	case X25SVCDCEDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDCEDirection);
		return (uint8_t *) &StorageTmp->x25SVCDCEDirection;
	case X25SVCDCEFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDCEFastSelect);
		return (uint8_t *) &StorageTmp->x25SVCDCEFastSelect;
	case X25SVCDCEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDCERemoteDTEAddressLen;
		return (uint8_t *) StorageTmp->x25SVCDCERemoteDTEAddress;
	case X25SVCDCETRANSITDELAYSELECTIONANDINDICATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDCETransitDelaySelectionAndIndication);
		return (uint8_t *) &StorageTmp->x25SVCDCETransitDelaySelectionAndIndication;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25SVCDXETable(): refresh x25SVCDXETable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25SVCDXETable(void)
{
	if (x25SVCDXETable_refresh == 0)
		return;
	x25SVCDXETable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25SVCDXETable_row(): refresh x25SVCDXETable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25SVCDXETable_row(struct x25SVCDXETable_data *StorageTmp)
{
	if (StorageTmp->x25SVCDXETable_request == sa_request)
		return;
	StorageTmp->x25SVCDXETable_request = sa_request;
}

/*
 * var_x25SVCDXETable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25SVCDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25SVCDXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCDXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCDXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCDXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCDXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25SVCDXEDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDXEDirection);
		return (uint8_t *) &StorageTmp->x25SVCDXEDirection;
	case X25SVCDXEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDXERemoteDTEAddressLen;
		return (uint8_t *) StorageTmp->x25SVCDXERemoteDTEAddress;
	case X25SVCDXEFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDXEFastSelect);
		return (uint8_t *) &StorageTmp->x25SVCDXEFastSelect;
	case X25SVCDXEREDIRECTREASON:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDXERedirectReason);
		return (uint8_t *) &StorageTmp->x25SVCDXERedirectReason;
	case X25SVCDXEORIGINALLYCALLEDADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDXEOriginallyCalledAddressLen;
		return (uint8_t *) StorageTmp->x25SVCDXEOriginallyCalledAddress;
	case X25SVCDXECALLINGADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDXECallingAddressExtension;
		return (uint8_t *) StorageTmp->x25SVCDXECallingAddressExtension;
	case X25SVCDXECALLEDADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDXECalledAddressExtension;
		return (uint8_t *) StorageTmp->x25SVCDXECalledAddressExtension;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25DSCTable(): refresh x25DSCTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25DSCTable(void)
{
	if (x25DSCTable_refresh == 0)
		return;
	x25DSCTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25DSCTable_row(): refresh x25DSCTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25DSCTable_row(struct x25DSCTable_data *StorageTmp)
{
	if (StorageTmp->x25DSCTable_request == sa_request)
		return;
	StorageTmp->x25DSCTable_request = sa_request;
}

/*
 * var_x25DSCTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25DSCTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		WriteMethod ** write_method)
{
	struct x25DSCTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25DSCTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25DSCTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25DSCTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25DSCTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25DSCID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25DSCIdLen;
		return (uint8_t *) StorageTmp->x25DSCId;
	case X25DSCRESETREQUESTINDICATIONPACKETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25DSCResetRequestIndicationPackets);
		return (uint8_t *) &StorageTmp->x25DSCResetRequestIndicationPackets;
	case X25DSCSEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25DSCSegmentsSent);
		return (uint8_t *) &StorageTmp->x25DSCSegmentsSent;
	case X25DSCSEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25DSCSegmentsReceived);
		return (uint8_t *) &StorageTmp->x25DSCSegmentsReceived;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEDTEStatsTable(): refresh x25PLEDTEStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLEDTEStatsTable(void)
{
	if (x25PLEDTEStatsTable_refresh == 0)
		return;
	x25PLEDTEStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEDTEStatsTable_row(): refresh x25PLEDTEStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLEDTEStatsTable_row(struct x25PLEDTEStatsTable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDTEStatsTable_request == sa_request)
		return;
	StorageTmp->x25PLEDTEStatsTable_request = sa_request;
}

/*
 * var_x25PLEDTEStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLEDTEStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
			WriteMethod ** write_method)
{
	struct x25PLEDTEStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDTEStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDTEStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDTEStatsTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDTEStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEDTESTATSCALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsCallAttempts);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsCallAttempts;
	case X25PLEDTESTATSPROTOCOLERRORSDETECTEDLOCALLY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsProtocolErrorsDetectedLocally);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsProtocolErrorsDetectedLocally;
	case X25PLEDTESTATSPROTOCOLERRORSACCUSEDOF:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsProtocolErrorsAccusedOf);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsProtocolErrorsAccusedOf;
	case X25PLEDTESTATSCALLCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsCallCountsExceeded);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsCallCountsExceeded;
	case X25PLEDTESTATSOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsOctetsReceived);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsOctetsReceived;
	case X25PLEDTESTATSOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsOctetsSent);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsOctetsSent;
	case X25PLEDTESTATSCALLTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsCallTimeouts);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsCallTimeouts;
	case X25PLEDTESTATSCALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsCallsConnected);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsCallsConnected;
	case X25PLEDTESTATSDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsDataPacketsReceived);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsDataPacketsReceived;
	case X25PLEDTESTATSDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsDataPacketsSent);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsDataPacketsSent;
	case X25PLEDTESTATSDATATIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsDataTimeouts);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsDataTimeouts;
	case X25PLEDTESTATSPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsProviderResets);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsProviderResets;
	case X25PLEDTESTATSPROVIDERDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsProviderDisconnects);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsProviderDisconnects;
	case X25PLEDTESTATSREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsRemoteResets);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsRemoteResets;
	case X25PLEDTESTATSREMOTERESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsRemoteRestarts);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsRemoteRestarts;
	case X25PLEDTESTATSRESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsResetTimeouts);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsResetTimeouts;
	case X25PLEDTESTATSRESTARTCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsRestartCountsExceeded);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsRestartCountsExceeded;
	case X25PLEDTESTATSCLEARTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsClearTimeouts);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsClearTimeouts;
	case X25PLEDTESTATSCLEARCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsClearCountsExceeded);
		return (uint8_t *) &StorageTmp->x25PLEDTEStatsClearCountsExceeded;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEDCEStatsTable(): refresh x25PLEDCEStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLEDCEStatsTable(void)
{
	if (x25PLEDCEStatsTable_refresh == 0)
		return;
	x25PLEDCEStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEDCEStatsTable_row(): refresh x25PLEDCEStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLEDCEStatsTable_row(struct x25PLEDCEStatsTable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDCEStatsTable_request == sa_request)
		return;
	StorageTmp->x25PLEDCEStatsTable_request = sa_request;
}

/*
 * var_x25PLEDCEStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLEDCEStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
			WriteMethod ** write_method)
{
	struct x25PLEDCEStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDCEStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDCEStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDCEStatsTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDCEStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEDCESTATSCALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsCallAttempts);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsCallAttempts;
	case X25PLEDCESTATSCALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsCallsConnected);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsCallsConnected;
	case X25PLEDCESTATSOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsOctetsReceived);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsOctetsReceived;
	case X25PLEDCESTATSOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsOctetsSent);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsOctetsSent;
	case X25PLEDCESTATSDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsDataPacketsReceived);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsDataPacketsReceived;
	case X25PLEDCESTATSDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsDataPacketsSent);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsDataPacketsSent;
	case X25PLEDCESTATSINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsInterruptPacketsReceived);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsInterruptPacketsReceived;
	case X25PLEDCESTATSINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsInterruptPacketsSent);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsInterruptPacketsSent;
	case X25PLEDCESTATSPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsProviderResets);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsProviderResets;
	case X25PLEDCESTATSPROVIDERDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsProviderDisconnects);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsProviderDisconnects;
	case X25PLEDCESTATSREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsRemoteResets);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsRemoteResets;
	case X25PLEDCESTATSREMOTERESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsRemoteRestarts);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsRemoteRestarts;
	case X25PLEDCESTATSRESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsResetTimeouts);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsResetTimeouts;
	case X25PLEDCESTATSX25SEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsX25SegmentsReceived);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsX25SegmentsReceived;
	case X25PLEDCESTATSX25SEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsX25SegmentsSent);
		return (uint8_t *) &StorageTmp->x25PLEDCEStatsX25SegmentsSent;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_x25PLEDXEStatsTable(): refresh x25PLEDXEStatsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_x25PLEDXEStatsTable(void)
{
	if (x25PLEDXEStatsTable_refresh == 0)
		return;
	x25PLEDXEStatsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_x25PLEDXEStatsTable_row(): refresh x25PLEDXEStatsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_x25PLEDXEStatsTable_row(struct x25PLEDXEStatsTable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDXEStatsTable_request == sa_request)
		return;
	StorageTmp->x25PLEDXEStatsTable_request = sa_request;
}

/*
 * var_x25PLEDXEStatsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_x25PLPMIB above.
 */
uint8_t *
var_x25PLEDXEStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
			WriteMethod ** write_method)
{
	struct x25PLEDXEStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDXEStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDXEStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDXEStatsTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDXEStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case X25PLEDXESTATSCALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsCallAttempts);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsCallAttempts;
	case X25PLEDXESTATSPROTOCOLERRORSDETECTEDLOCALLY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsProtocolErrorsDetectedLocally);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsProtocolErrorsDetectedLocally;
	case X25PLEDXESTATSPROTOCOLERRORSACCUSEDOF:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsProtocolErrorsAccusedOf);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsProtocolErrorsAccusedOf;
	case X25PLEDXESTATSCALLCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsCallCountsExceeded);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsCallCountsExceeded;
	case X25PLEDXESTATSOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsOctetsReceived);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsOctetsReceived;
	case X25PLEDXESTATSOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsOctetsSent);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsOctetsSent;
	case X25PLEDXESTATSCALLTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsCallTimeouts);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsCallTimeouts;
	case X25PLEDXESTATSCALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsCallsConnected);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsCallsConnected;
	case X25PLEDXESTATSCLEARTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsClearTimeouts);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsClearTimeouts;
	case X25PLEDXESTATSDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsDataPacketsReceived);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsDataPacketsReceived;
	case X25PLEDXESTATSDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsDataPacketsSent);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsDataPacketsSent;
	case X25PLEDXESTATSDATATIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsDataTimeouts);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsDataTimeouts;
	case X25PLEDXESTATSPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsProviderResets);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsProviderResets;
	case X25PLEDXESTATSPROVIDERDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsProviderDisconnects);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsProviderDisconnects;
	case X25PLEDXESTATSREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsRemoteResets);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsRemoteResets;
	case X25PLEDXESTATSREMOTERESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsRemoteRestarts);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsRemoteRestarts;
	case X25PLEDXESTATSRESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsResetTimeouts);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsResetTimeouts;
	case X25PLEDXESTATSRESTARTCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsRestartCountsExceeded);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsRestartCountsExceeded;
	case X25PLEDXESTATSCLEARCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsClearCountsExceeded);
		return (uint8_t *) &StorageTmp->x25PLEDXEStatsClearCountsExceeded;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_x25PLEAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEAdministrativeState entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEAdministrativeState;
		StorageTmp->x25PLEAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELocalDTEAddress(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLELocalDTEAddress entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELocalDTEAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLELocalDTEAddress;
		tmplen = StorageTmp->x25PLELocalDTEAddressLen;
		memdup((void *) &StorageTmp->x25PLELocalDTEAddress, var_val, var_val_len);
		StorageTmp->x25PLELocalDTEAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLELocalDTEAddress);
		StorageTmp->x25PLELocalDTEAddress = tmpvar;
		StorageTmp->x25PLELocalDTEAddressLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEFacilityNonNegotiable(int action, uint8_t *var_val, uint8_t var_val_type,
				  size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEFacilityNonNegotiable entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityNonNegotiable not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEFacilityNonNegotiable;
		tmplen = StorageTmp->x25PLEFacilityNonNegotiableLen;
		memdup((void *) &StorageTmp->x25PLEFacilityNonNegotiable, var_val, var_val_len);
		StorageTmp->x25PLEFacilityNonNegotiableLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEFacilityNonNegotiable);
		StorageTmp->x25PLEFacilityNonNegotiable = tmpvar;
		StorageTmp->x25PLEFacilityNonNegotiableLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEFacilityAvailability(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEFacilityAvailability entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityAvailability not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEFacilityAvailability;
		tmplen = StorageTmp->x25PLEFacilityAvailabilityLen;
		memdup((void *) &StorageTmp->x25PLEFacilityAvailability, var_val, var_val_len);
		StorageTmp->x25PLEFacilityAvailabilityLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEFacilityAvailability);
		StorageTmp->x25PLEFacilityAvailability = tmpvar;
		StorageTmp->x25PLEFacilityAvailabilityLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEFacilityNegotiation(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEFacilityNegotiation entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityNegotiation not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEFacilityNegotiation;
		tmplen = StorageTmp->x25PLEFacilityNegotiationLen;
		memdup((void *) &StorageTmp->x25PLEFacilityNegotiation, var_val, var_val_len);
		StorageTmp->x25PLEFacilityNegotiationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEFacilityNegotiation);
		StorageTmp->x25PLEFacilityNegotiation = tmpvar;
		StorageTmp->x25PLEFacilityNegotiationLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEFacilityWhileIdle(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEFacilityWhileIdle entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityWhileIdle not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEFacilityWhileIdle;
		tmplen = StorageTmp->x25PLEFacilityWhileIdleLen;
		memdup((void *) &StorageTmp->x25PLEFacilityWhileIdle, var_val, var_val_len);
		StorageTmp->x25PLEFacilityWhileIdleLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEFacilityWhileIdle);
		StorageTmp->x25PLEFacilityWhileIdle = tmpvar;
		StorageTmp->x25PLEFacilityWhileIdleLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEPacketSequenceNumbering(int action, uint8_t *var_val, uint8_t var_val_type,
				    size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEPacketSequenceNumbering entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEPacketSequenceNumbering not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEPacketSequenceNumbering;
		StorageTmp->x25PLEPacketSequenceNumbering = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEPacketSequenceNumbering = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultPacketSizeIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
				      size_t var_val_len, uint8_t *statP, oid * name,
				      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDefaultPacketSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDefaultPacketSizeIncoming;
		StorageTmp->x25PLEDefaultPacketSizeIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultPacketSizeIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultPacketSizeOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
				      size_t var_val_len, uint8_t *statP, oid * name,
				      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDefaultPacketSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDefaultPacketSizeOutgoing;
		StorageTmp->x25PLEDefaultPacketSizeOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultPacketSizeOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultWindowSizeIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
				      size_t var_val_len, uint8_t *statP, oid * name,
				      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDefaultWindowSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDefaultWindowSizeIncoming;
		StorageTmp->x25PLEDefaultWindowSizeIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultWindowSizeIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultWindowSizeOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
				      size_t var_val_len, uint8_t *statP, oid * name,
				      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDefaultWindowSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDefaultWindowSizeOutgoing;
		StorageTmp->x25PLEDefaultWindowSizeOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultWindowSizeOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultThroughputClassIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
					   size_t var_val_len, uint8_t *statP, oid * name,
					   size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDefaultThroughputClassIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDefaultThroughputClassIncoming;
		StorageTmp->x25PLEDefaultThroughputClassIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultThroughputClassIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDefaultThroughputClassOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
					   size_t var_val_len, uint8_t *statP, oid * name,
					   size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDefaultThroughputClassOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDefaultThroughputClassOutgoing;
		StorageTmp->x25PLEDefaultThroughputClassOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultThroughputClassOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLESNServiceProvider(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLESNServiceProvider entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLESNServiceProvider not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLESNServiceProvider;
		tmplen = StorageTmp->x25PLESNServiceProviderLen;
		memdup((void *) &StorageTmp->x25PLESNServiceProvider, var_val, var_val_len);
		StorageTmp->x25PLESNServiceProviderLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLESNServiceProvider);
		StorageTmp->x25PLESNServiceProvider = tmpvar;
		StorageTmp->x25PLESNServiceProviderLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLESNSAP(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		  uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLESNSAP entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLESNSAP not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLESNSAP;
		tmplen = StorageTmp->x25PLESNSAPLen;
		memdup((void *) &StorageTmp->x25PLESNSAP, var_val, var_val_len);
		StorageTmp->x25PLESNSAPLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLESNSAP);
		StorageTmp->x25PLESNSAP = tmpvar;
		StorageTmp->x25PLESNSAPLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentHIC(int action, uint8_t *var_val, uint8_t var_val_type,
					size_t var_val_len, uint8_t *statP, oid * name,
					size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentHIC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLELogicalChannelAssignmentHIC;
		StorageTmp->x25PLELogicalChannelAssignmentHIC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentHIC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentLIC(int action, uint8_t *var_val, uint8_t var_val_type,
					size_t var_val_len, uint8_t *statP, oid * name,
					size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentLIC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLELogicalChannelAssignmentLIC;
		StorageTmp->x25PLELogicalChannelAssignmentLIC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentLIC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentHTC(int action, uint8_t *var_val, uint8_t var_val_type,
					size_t var_val_len, uint8_t *statP, oid * name,
					size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentHTC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLELogicalChannelAssignmentHTC;
		StorageTmp->x25PLELogicalChannelAssignmentHTC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentHTC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentLTC(int action, uint8_t *var_val, uint8_t var_val_type,
					size_t var_val_len, uint8_t *statP, oid * name,
					size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentLTC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLELogicalChannelAssignmentLTC;
		StorageTmp->x25PLELogicalChannelAssignmentLTC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentLTC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentHOC(int action, uint8_t *var_val, uint8_t var_val_type,
					size_t var_val_len, uint8_t *statP, oid * name,
					size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentHOC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLELogicalChannelAssignmentHOC;
		StorageTmp->x25PLELogicalChannelAssignmentHOC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentHOC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLELogicalChannelAssignmentLOC(int action, uint8_t *var_val, uint8_t var_val_type,
					size_t var_val_len, uint8_t *statP, oid * name,
					size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentLOC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLELogicalChannelAssignmentLOC;
		StorageTmp->x25PLELogicalChannelAssignmentLOC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentLOC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultPacketSizeIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
					  size_t var_val_len, uint8_t *statP, oid * name,
					  size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultPacketSizeIncoming entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODefaultPacketSizeIncoming;
		StorageTmp->x25PLEIVMODefaultPacketSizeIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultPacketSizeIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultPacketSizeOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
					  size_t var_val_len, uint8_t *statP, oid * name,
					  size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultPacketSizeOutgoing entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing;
		StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultThroughputClassIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
					       size_t var_val_len, uint8_t *statP, oid * name,
					       size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultThroughputClassIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODefaultThroughputClassIncoming;
		StorageTmp->x25PLEIVMODefaultThroughputClassIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultThroughputClassIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultThroughputClassOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
					       size_t var_val_len, uint8_t *statP, oid * name,
					       size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultThroughputClassOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing;
		StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultWindowSizeIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
					  size_t var_val_len, uint8_t *statP, oid * name,
					  size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultWindowSizeIncoming entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODefaultWindowSizeIncoming;
		StorageTmp->x25PLEIVMODefaultWindowSizeIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultWindowSizeIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODefaultWindowSizeOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
					  size_t var_val_len, uint8_t *statP, oid * name,
					  size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultWindowSizeOutgoing entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing;
		StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOFlowControlParameterNegotiation(int action, uint8_t *var_val, uint8_t var_val_type,
						size_t var_val_len, uint8_t *statP, oid * name,
						size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOFlowControlParameterNegotiation entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOFlowControlParameterNegotiation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOFlowControlParameterNegotiation;
		StorageTmp->x25PLEIVMOFlowControlParameterNegotiation = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOFlowControlParameterNegotiation = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLocalDTEAddress(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMOLocalDTEAddress entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLocalDTEAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOLocalDTEAddress;
		tmplen = StorageTmp->x25PLEIVMOLocalDTEAddressLen;
		memdup((void *) &StorageTmp->x25PLEIVMOLocalDTEAddress, var_val, var_val_len);
		StorageTmp->x25PLEIVMOLocalDTEAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEIVMOLocalDTEAddress);
		StorageTmp->x25PLEIVMOLocalDTEAddress = tmpvar;
		StorageTmp->x25PLEIVMOLocalDTEAddressLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentHPC(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentHPC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHPC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentLPC(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentLPC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLPC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentHIC(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentHIC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentLIC(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentLIC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentHTC(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentHTC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentLTC(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentLTC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentHOC(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentHOC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOLogicalChannelAssignmentLOC(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentLOC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOSNServiceProvider(int action, uint8_t *var_val, uint8_t var_val_type,
				  size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMOSNServiceProvider entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOSNServiceProvider not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOSNServiceProvider;
		tmplen = StorageTmp->x25PLEIVMOSNServiceProviderLen;
		memdup((void *) &StorageTmp->x25PLEIVMOSNServiceProvider, var_val, var_val_len);
		StorageTmp->x25PLEIVMOSNServiceProviderLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEIVMOSNServiceProvider);
		StorageTmp->x25PLEIVMOSNServiceProvider = tmpvar;
		StorageTmp->x25PLEIVMOSNServiceProviderLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMOThroughputClassNegotiation(int action, uint8_t *var_val, uint8_t var_val_type,
					   size_t var_val_len, uint8_t *statP, oid * name,
					   size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOThroughputClassNegotiation entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOThroughputClassNegotiation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMOThroughputClassNegotiation;
		StorageTmp->x25PLEIVMOThroughputClassNegotiation = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOThroughputClassNegotiation = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTEPacketSequencing(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTEPacketSequencing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDTEPacketSequencing;
		StorageTmp->x25PLEDTEPacketSequencing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTEPacketSequencing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTEMaxActiveCircuits(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTEMaxActiveCircuits entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDTEMaxActiveCircuits;
		StorageTmp->x25PLEDTEMaxActiveCircuits = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTEMaxActiveCircuits = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTECallDeflectionSubscription(int action, uint8_t *var_val, uint8_t var_val_type,
					  size_t var_val_len, uint8_t *statP, oid * name,
					  size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDTECallDeflectionSubscription entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDTECallDeflectionSubscription;
		StorageTmp->x25PLEDTECallDeflectionSubscription = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTECallDeflectionSubscription = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERestartTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTERestartTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDTERestartTime;
		StorageTmp->x25PLEDTERestartTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTERestartTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERestartCount(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTERestartCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDTERestartCount;
		StorageTmp->x25PLEDTERestartCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTERestartCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTEMinimumRecallTimer(int action, uint8_t *var_val, uint8_t var_val_type,
				  size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTEMinimumRecallTimer entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDTEMinimumRecallTimer;
		StorageTmp->x25PLEDTEMinimumRecallTimer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTEMinimumRecallTimer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERegistrationTime(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTERegistrationTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDTERegistrationTime;
		StorageTmp->x25PLEDTERegistrationTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTERegistrationTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERegistrationCount(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTERegistrationCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDTERegistrationCount;
		StorageTmp->x25PLEDTERegistrationCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTERegistrationCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERegistrationPermitted(int action, uint8_t *var_val, uint8_t var_val_type,
				     size_t var_val_len, uint8_t *statP, oid * name,
				     size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTERegistrationPermitted entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDTERegistrationPermitted;
		StorageTmp->x25PLEDTERegistrationPermitted = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTERegistrationPermitted = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTEProfile(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		       uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTEProfile entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDTEProfile;
		tmplen = StorageTmp->x25PLEDTEProfileLen;
		memdup((void *) &StorageTmp->x25PLEDTEProfile, var_val, var_val_len);
		StorageTmp->x25PLEDTEProfileLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEDTEProfile);
		StorageTmp->x25PLEDTEProfile = tmpvar;
		StorageTmp->x25PLEDTEProfileLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEPacketSequencing(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEPacketSequencing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEPacketSequencing;
		StorageTmp->x25PLEDCEPacketSequencing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEPacketSequencing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECallDeflectionSubscription(int action, uint8_t *var_val, uint8_t var_val_type,
					  size_t var_val_len, uint8_t *statP, oid * name,
					  size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCECallDeflectionSubscription entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCECallDeflectionSubscription;
		StorageTmp->x25PLEDCECallDeflectionSubscription = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECallDeflectionSubscription = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECUG(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCECUG entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCECUG;
		StorageTmp->x25PLEDCECUG = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECUG = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEFastSelectAcceptance(int action, uint8_t *var_val, uint8_t var_val_type,
				    size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEFastSelectAcceptance entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEFastSelectAcceptance not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEFastSelectAcceptance;
		StorageTmp->x25PLEDCEFastSelectAcceptance = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEFastSelectAcceptance = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEIncomingCallsBarred(int action, uint8_t *var_val, uint8_t var_val_type,
				   size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEIncomingCallsBarred entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCallsBarred not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEIncomingCallsBarred;
		StorageTmp->x25PLEDCEIncomingCallsBarred = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEIncomingCallsBarred = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEOneWayLogicalChannelOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEOneWayLogicalChannelOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOneWayLogicalChannelOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing;
		StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEOutgoingCallsBarred(int action, uint8_t *var_val, uint8_t var_val_type,
				   size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEOutgoingCallsBarred entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOutgoingCallsBarred not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEOutgoingCallsBarred;
		StorageTmp->x25PLEDCEOutgoingCallsBarred = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEOutgoingCallsBarred = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEBilateralCUG(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEBilateralCUG entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEBilateralCUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEBilateralCUG;
		StorageTmp->x25PLEDCEBilateralCUG = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEBilateralCUG = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEBilateralCUGWithOutgoingAccess(int action, uint8_t *var_val, uint8_t var_val_type,
					      size_t var_val_len, uint8_t *statP, oid * name,
					      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEBilateralCUGWithOutgoingAccess entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEBilateralCUGWithOutgoingAccess not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess;
		StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECallRedirection(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCECallRedirection entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallRedirection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCECallRedirection;
		StorageTmp->x25PLEDCECallRedirection = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECallRedirection = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEChargingInformation(int action, uint8_t *var_val, uint8_t var_val_type,
				   size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEChargingInformation entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEChargingInformation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEChargingInformation;
		StorageTmp->x25PLEDCEChargingInformation = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEChargingInformation = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECUGWithIncomingAccess(int action, uint8_t *var_val, uint8_t var_val_type,
				     size_t var_val_len, uint8_t *statP, oid * name,
				     size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCECUGWithIncomingAccess entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECUGWithIncomingAccess not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCECUGWithIncomingAccess;
		StorageTmp->x25PLEDCECUGWithIncomingAccess = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECUGWithIncomingAccess = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECUGWithOutgoingAccess(int action, uint8_t *var_val, uint8_t var_val_type,
				     size_t var_val_len, uint8_t *statP, oid * name,
				     size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCECUGWithOutgoingAccess entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECUGWithOutgoingAccess not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCECUGWithOutgoingAccess;
		StorageTmp->x25PLEDCECUGWithOutgoingAccess = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECUGWithOutgoingAccess = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEDBitModification(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEDBitModification entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDBitModification not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEDBitModification;
		StorageTmp->x25PLEDCEDBitModification = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEDBitModification = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEDefaultThroughputClassSubscription(int action, uint8_t *var_val,
						  uint8_t var_val_type, size_t var_val_len,
						  uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEDefaultThroughputClassSubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEDefaultThroughputClassSubscription;
		StorageTmp->x25PLEDCEDefaultThroughputClassSubscription = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEDefaultThroughputClassSubscription = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEDefaultThroughputClassSupported(int action, uint8_t *var_val, uint8_t var_val_type,
					       size_t var_val_len, uint8_t *statP, oid * name,
					       size_t name_len)
{
	static char *tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEDefaultThroughputClassSupported entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassSupported not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEDefaultThroughputClassSupported;
		tmplen = StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen;
		memdup((void *) &StorageTmp->x25PLEDCEDefaultThroughputClassSupported, var_val,
		       var_val_len);
		StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEDCEDefaultThroughputClassSupported);
		StorageTmp->x25PLEDCEDefaultThroughputClassSupported = tmpvar;
		StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEDefaultThroughputClassIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
					      size_t var_val_len, uint8_t *statP, oid * name,
					      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEDefaultThroughputClassIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEDefaultThroughputClassIncoming;
		StorageTmp->x25PLEDCEDefaultThroughputClassIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEDefaultThroughputClassIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEDefaultThroughputClassOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
					      size_t var_val_len, uint8_t *statP, oid * name,
					      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEDefaultThroughputClassOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing;
		StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEHuntGroup(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			 uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEHuntGroup entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEHuntGroup not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEHuntGroup;
		StorageTmp->x25PLEDCEHuntGroup = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEHuntGroup = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEIncomingCallBarredWithinCUG(int action, uint8_t *var_val, uint8_t var_val_type,
					   size_t var_val_len, uint8_t *statP, oid * name,
					   size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEIncomingCallBarredWithinCUG entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCallBarredWithinCUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG;
		StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCELocalChargingPrevention(int action, uint8_t *var_val, uint8_t var_val_type,
				       size_t var_val_len, uint8_t *statP, oid * name,
				       size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCELocalChargingPrevention entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCELocalChargingPrevention not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCELocalChargingPrevention;
		StorageTmp->x25PLEDCELocalChargingPrevention = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCELocalChargingPrevention = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultPacketSizeSubscription(int action, uint8_t *var_val,
							uint8_t var_val_type, size_t var_val_len,
							uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultPacketSizeSubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription;
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultPacketSizeMaximum(int action, uint8_t *var_val,
						   uint8_t var_val_type, size_t var_val_len,
						   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultPacketSizeMaximum entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeMaximum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum;
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultPacketSizeIncoming(int action, uint8_t *var_val,
						    uint8_t var_val_type, size_t var_val_len,
						    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultPacketSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming;
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultPacketSizeOutgoing(int action, uint8_t *var_val,
						    uint8_t var_val_type, size_t var_val_len,
						    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultPacketSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing;
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultWindowSizeSubscription(int action, uint8_t *var_val,
							uint8_t var_val_type, size_t var_val_len,
							uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultWindowSizeSubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription;
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultWindowSizeMaximum(int action, uint8_t *var_val,
						   uint8_t var_val_type, size_t var_val_len,
						   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultWindowSizeMaximum entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeMaximum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum;
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultWindowSizeIncoming(int action, uint8_t *var_val,
						    uint8_t var_val_type, size_t var_val_len,
						    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultWindowSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming;
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENonStandardDefaultWindowSizeOutgoing(int action, uint8_t *var_val,
						    uint8_t var_val_type, size_t var_val_len,
						    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultWindowSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing;
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENUIOverride(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCENUIOverride entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENUIOverride not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCENUIOverride;
		StorageTmp->x25PLEDCENUIOverride = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENUIOverride = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCENUISubscription(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCENUISubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENUISubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCENUISubscription;
		StorageTmp->x25PLEDCENUISubscription = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENUISubscription = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEOneWayLogicalChannelIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
					    size_t var_val_len, uint8_t *statP, oid * name,
					    size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEOneWayLogicalChannelIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOneWayLogicalChannelIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming;
		StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEOnlineFacilityRegistration(int action, uint8_t *var_val, uint8_t var_val_type,
					  size_t var_val_len, uint8_t *statP, oid * name,
					  size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEOnlineFacilityRegistration entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOnlineFacilityRegistration not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEOnlineFacilityRegistration;
		StorageTmp->x25PLEDCEOnlineFacilityRegistration = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEOnlineFacilityRegistration = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEOutgoingCallBarredWithinCUG(int action, uint8_t *var_val, uint8_t var_val_type,
					   size_t var_val_len, uint8_t *statP, oid * name,
					   size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEOutgoingCallBarredWithinCUG entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOutgoingCallBarredWithinCUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG;
		StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEPacketRetransmission(int action, uint8_t *var_val, uint8_t var_val_type,
				    size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEPacketRetransmission entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEPacketRetransmission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEPacketRetransmission;
		StorageTmp->x25PLEDCEPacketRetransmission = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEPacketRetransmission = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEReverseChargingAcceptance(int action, uint8_t *var_val, uint8_t var_val_type,
					 size_t var_val_len, uint8_t *statP, oid * name,
					 size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEReverseChargingAcceptance entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEReverseChargingAcceptance not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEReverseChargingAcceptance;
		StorageTmp->x25PLEDCEReverseChargingAcceptance = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEReverseChargingAcceptance = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEROASubscription(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEROASubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEROASubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEROASubscription;
		StorageTmp->x25PLEDCEROASubscription = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEROASubscription = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCERestartIndication(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCERestartIndication entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCERestartIndication not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCERestartIndication;
		StorageTmp->x25PLEDCERestartIndication = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCERestartIndication = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCERestartCount(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCERestartCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCERestartCount;
		StorageTmp->x25PLEDCERestartCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCERestartCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEIncomingCall(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEIncomingCall entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCall not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEIncomingCall;
		StorageTmp->x25PLEDCEIncomingCall = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEIncomingCall = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCECallCount(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			 uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCECallCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCECallCount;
		StorageTmp->x25PLEDCECallCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECallCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEResetIndication(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEResetIndication entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEResetIndication not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEResetIndication;
		StorageTmp->x25PLEDCEResetIndication = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEResetIndication = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEResetCount(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			  uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEResetCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEResetCount;
		StorageTmp->x25PLEDCEResetCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEResetCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEClearIndication(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEClearIndication entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEClearIndication not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEClearIndication;
		StorageTmp->x25PLEDCEClearIndication = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEClearIndication = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEClearCount(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			  uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEClearCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEClearCount;
		StorageTmp->x25PLEDCEClearCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEClearCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCEProfile(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		       uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEProfile entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDCEProfile;
		tmplen = StorageTmp->x25PLEDCEProfileLen;
		memdup((void *) &StorageTmp->x25PLEDCEProfile, var_val, var_val_len);
		StorageTmp->x25PLEDCEProfileLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEDCEProfile);
		StorageTmp->x25PLEDCEProfile = tmpvar;
		StorageTmp->x25PLEDCEProfileLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXEPacketSequencing(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXEPacketSequencing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXEPacketSequencing;
		StorageTmp->x25PLEDXEPacketSequencing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXEPacketSequencing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXEMaxActiveCircuits(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXEMaxActiveCircuits entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXEMaxActiveCircuits;
		StorageTmp->x25PLEDXEMaxActiveCircuits = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXEMaxActiveCircuits = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXECallDeflectionSubscription(int action, uint8_t *var_val, uint8_t var_val_type,
					  size_t var_val_len, uint8_t *statP, oid * name,
					  size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDXECallDeflectionSubscription entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXECallDeflectionSubscription;
		StorageTmp->x25PLEDXECallDeflectionSubscription = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXECallDeflectionSubscription = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERestartTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXERestartTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXERestartTime;
		StorageTmp->x25PLEDXERestartTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXERestartTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERestartCount(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXERestartCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXERestartCount;
		StorageTmp->x25PLEDXERestartCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXERestartCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXEMinimumRecallTimer(int action, uint8_t *var_val, uint8_t var_val_type,
				  size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXEMinimumRecallTimer entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXEMinimumRecallTimer;
		StorageTmp->x25PLEDXEMinimumRecallTimer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXEMinimumRecallTimer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERegistrationTime(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXERegistrationTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXERegistrationTime;
		StorageTmp->x25PLEDXERegistrationTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXERegistrationTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERegistrationCount(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXERegistrationCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXERegistrationCount;
		StorageTmp->x25PLEDXERegistrationCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXERegistrationCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERegistrationPermitted(int action, uint8_t *var_val, uint8_t var_val_type,
				     size_t var_val_len, uint8_t *statP, oid * name,
				     size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXERegistrationPermitted entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXERegistrationPermitted;
		StorageTmp->x25PLEDXERegistrationPermitted = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXERegistrationPermitted = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXEPLEClientMOName(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXEPLEClientMOName entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEPLEClientMOName not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXEPLEClientMOName;
		tmplen = StorageTmp->x25PLEDXEPLEClientMONameLen;
		memdup((void *) &StorageTmp->x25PLEDXEPLEClientMOName, var_val, var_val_len);
		StorageTmp->x25PLEDXEPLEClientMONameLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEDXEPLEClientMOName);
		StorageTmp->x25PLEDXEPLEClientMOName = tmpvar;
		StorageTmp->x25PLEDXEPLEClientMONameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXEProfile(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		       uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXEProfile entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEDXEProfile;
		tmplen = StorageTmp->x25PLEDXEProfileLen;
		memdup((void *) &StorageTmp->x25PLEDXEProfile, var_val, var_val_len);
		StorageTmp->x25PLEDXEProfileLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PLEDXEProfile);
		StorageTmp->x25PLEDXEProfile = tmpvar;
		StorageTmp->x25PLEDXEProfileLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTECallDeflectionSubscription(int action, uint8_t *var_val, uint8_t var_val_type,
					      size_t var_val_len, uint8_t *statP, oid * name,
					      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODTECallDeflectionSubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTECallDeflectionSubscription;
		StorageTmp->x25PLEIVMODTECallDeflectionSubscription = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTECallDeflectionSubscription = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTECallTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTECallTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTECallTime;
		StorageTmp->x25PLEIVMODTECallTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTECallTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEClearTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEClearTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEClearTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEClearTime;
		StorageTmp->x25PLEIVMODTEClearTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEClearTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEClearCount(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEClearCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEClearCount;
		StorageTmp->x25PLEIVMODTEClearCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEClearCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEPacketSequencing(int action, uint8_t *var_val, uint8_t var_val_type,
				    size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEPacketSequencing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEPacketSequencing;
		StorageTmp->x25PLEIVMODTEPacketSequencing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEPacketSequencing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEInterruptTime(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEInterruptTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEInterruptTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEInterruptTime;
		StorageTmp->x25PLEIVMODTEInterruptTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEInterruptTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEMaxActiveCircuits(int action, uint8_t *var_val, uint8_t var_val_type,
				     size_t var_val_len, uint8_t *statP, oid * name,
				     size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEMaxActiveCircuits entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEMaxActiveCircuits;
		StorageTmp->x25PLEIVMODTEMaxActiveCircuits = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEMaxActiveCircuits = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEMinimumRecallTimer(int action, uint8_t *var_val, uint8_t var_val_type,
				      size_t var_val_len, uint8_t *statP, oid * name,
				      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEMinimumRecallTimer entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEMinimumRecallTimer;
		StorageTmp->x25PLEIVMODTEMinimumRecallTimer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEMinimumRecallTimer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEResetTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEResetTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEResetTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEResetTime;
		StorageTmp->x25PLEIVMODTEResetTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEResetTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEResetCount(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEResetCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEResetCount;
		StorageTmp->x25PLEIVMODTEResetCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEResetCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERestartTime(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERestartTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERestartTime;
		StorageTmp->x25PLEIVMODTERestartTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERestartTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERestartCount(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERestartCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERestartCount;
		StorageTmp->x25PLEIVMODTERestartCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERestartCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEWindowTime(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEWindowTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEWindowTime;
		StorageTmp->x25PLEIVMODTEWindowTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEWindowTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEDataTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEDataTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEDataTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEDataTime;
		StorageTmp->x25PLEIVMODTEDataTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEDataTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEDataCount(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEDataCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEDataCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEDataCount;
		StorageTmp->x25PLEIVMODTEDataCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEDataCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERejectTime(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERejectTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERejectTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERejectTime;
		StorageTmp->x25PLEIVMODTERejectTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERejectTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERejectCount(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERejectCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERejectCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERejectCount;
		StorageTmp->x25PLEIVMODTERejectCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERejectCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationTime(int action, uint8_t *var_val, uint8_t var_val_type,
				    size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERegistrationTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERegistrationTime;
		StorageTmp->x25PLEIVMODTERegistrationTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationCount(int action, uint8_t *var_val, uint8_t var_val_type,
				     size_t var_val_len, uint8_t *statP, oid * name,
				     size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERegistrationCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERegistrationCount;
		StorageTmp->x25PLEIVMODTERegistrationCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationPermitted(int action, uint8_t *var_val, uint8_t var_val_type,
					 size_t var_val_len, uint8_t *statP, oid * name,
					 size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODTERegistrationPermitted entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERegistrationPermitted;
		StorageTmp->x25PLEIVMODTERegistrationPermitted = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationPermitted = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTECallDeflectionSubscription(int action, uint8_t *var_val, uint8_t var_val_type,
					      size_t var_val_len, uint8_t *statP, oid * name,
					      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODTECallDeflectionSubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTECallDeflectionSubscription;
		StorageTmp->x25PLEIVMODTECallDeflectionSubscription = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTECallDeflectionSubscription = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEMaxActiveCircuits(int action, uint8_t *var_val, uint8_t var_val_type,
				     size_t var_val_len, uint8_t *statP, oid * name,
				     size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEMaxActiveCircuits entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEMaxActiveCircuits;
		StorageTmp->x25PLEIVMODTEMaxActiveCircuits = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEMaxActiveCircuits = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERestartTime(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERestartTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERestartTime;
		StorageTmp->x25PLEIVMODTERestartTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERestartTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEMinimumRecallTimer(int action, uint8_t *var_val, uint8_t var_val_type,
				      size_t var_val_len, uint8_t *statP, oid * name,
				      size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEMinimumRecallTimer entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEMinimumRecallTimer;
		StorageTmp->x25PLEIVMODTEMinimumRecallTimer = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEMinimumRecallTimer = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERestartCount(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERestartCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERestartCount;
		StorageTmp->x25PLEIVMODTERestartCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERestartCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTEPacketSequencing(int action, uint8_t *var_val, uint8_t var_val_type,
				    size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEPacketSequencing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTEPacketSequencing;
		StorageTmp->x25PLEIVMODTEPacketSequencing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEPacketSequencing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationTime(int action, uint8_t *var_val, uint8_t var_val_type,
				    size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERegistrationTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERegistrationTime;
		StorageTmp->x25PLEIVMODTERegistrationTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationCount(int action, uint8_t *var_val, uint8_t var_val_type,
				     size_t var_val_len, uint8_t *statP, oid * name,
				     size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERegistrationCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERegistrationCount;
		StorageTmp->x25PLEIVMODTERegistrationCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERegistrationPermitted(int action, uint8_t *var_val, uint8_t var_val_type,
					 size_t var_val_len, uint8_t *statP, oid * name,
					 size_t name_len)
{
	static int32_t tmpvar;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODTERegistrationPermitted entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PLEIVMODTERegistrationPermitted;
		StorageTmp->x25PLEIVMODTERegistrationPermitted = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationPermitted = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCPacketSequencing(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25VCTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25VCPacketSequencing entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25VCPacketSequencing;
		StorageTmp->x25VCPacketSequencing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCPacketSequencing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCPacketSizeIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25VCTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25VCPacketSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25VCPacketSizeIncoming;
		StorageTmp->x25VCPacketSizeIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCPacketSizeIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCPacketSizeOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25VCTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25VCPacketSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25VCPacketSizeOutgoing;
		StorageTmp->x25VCPacketSizeOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCPacketSizeOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCWindowSizeIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25VCTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25VCWindowSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25VCWindowSizeIncoming;
		StorageTmp->x25VCWindowSizeIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCWindowSizeIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCWindowSizeOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25VCTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25VCWindowSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25VCWindowSizeOutgoing;
		StorageTmp->x25VCWindowSizeOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCWindowSizeOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCThroughputClassIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
				   size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25VCTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25VCThroughputClassIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25VCThroughputClassIncoming;
		StorageTmp->x25VCThroughputClassIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCThroughputClassIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25VCThroughputClassOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
				   size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25VCTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25VCThroughputClassOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25VCThroughputClassOutgoing;
		StorageTmp->x25VCThroughputClassOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCThroughputClassOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDTELogicalChannel(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PVCDTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDTELogicalChannel entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDTELogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PVCDTELogicalChannel;
		StorageTmp->x25PVCDTELogicalChannel = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDTELogicalChannel = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDCELogicalChannel(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PVCDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDCELogicalChannel entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCELogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PVCDCELogicalChannel;
		StorageTmp->x25PVCDCELogicalChannel = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDCELogicalChannel = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDCEChargingDirection(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PVCDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDCEChargingDirection entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCEChargingDirection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PVCDCEChargingDirection;
		StorageTmp->x25PVCDCEChargingDirection = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDCEChargingDirection = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDCERemoteDTEAddress(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct x25PVCDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDCERemoteDTEAddress entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCERemoteDTEAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PVCDCERemoteDTEAddress;
		tmplen = StorageTmp->x25PVCDCERemoteDTEAddressLen;
		memdup((void *) &StorageTmp->x25PVCDCERemoteDTEAddress, var_val, var_val_len);
		StorageTmp->x25PVCDCERemoteDTEAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25PVCDCERemoteDTEAddress);
		StorageTmp->x25PVCDCERemoteDTEAddress = tmpvar;
		StorageTmp->x25PVCDCERemoteDTEAddressLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDCERemoteLogicalChannel(int action, uint8_t *var_val, uint8_t var_val_type,
				    size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PVCDCETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDCERemoteLogicalChannel entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCERemoteLogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PVCDCERemoteLogicalChannel;
		StorageTmp->x25PVCDCERemoteLogicalChannel = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDCERemoteLogicalChannel = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDXELogicalChannel(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25PVCDXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDXELogicalChannel entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDXELogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25PVCDXELogicalChannel;
		StorageTmp->x25PVCDXELogicalChannel = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDXELogicalChannel = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOId(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		   uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOId entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOId;
		tmplen = StorageTmp->x25SVCIVMOIdLen;
		memdup((void *) &StorageTmp->x25SVCIVMOId, var_val, var_val_len);
		StorageTmp->x25SVCIVMOIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25SVCIVMOId);
		StorageTmp->x25SVCIVMOId = tmpvar;
		StorageTmp->x25SVCIVMOIdLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOFastSelect(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			   uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOFastSelect entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOFastSelect not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOFastSelect;
		StorageTmp->x25SVCIVMOFastSelect = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOFastSelect = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOPacketSizeIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
				   size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOPacketSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOPacketSizeIncoming;
		StorageTmp->x25SVCIVMOPacketSizeIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOPacketSizeIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOPacketSizeOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
				   size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOPacketSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOPacketSizeOutgoing;
		StorageTmp->x25SVCIVMOPacketSizeOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOPacketSizeOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOReverseCharging(int action, uint8_t *var_val, uint8_t var_val_type,
				size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOReverseCharging entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOReverseCharging not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOReverseCharging;
		StorageTmp->x25SVCIVMOReverseCharging = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOReverseCharging = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOThroughputClassIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
					size_t var_val_len, uint8_t *statP, oid * name,
					size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25SVCIVMOThroughputClassIncoming entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOThroughputClassIncoming;
		StorageTmp->x25SVCIVMOThroughputClassIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOThroughputClassIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOThroughputClassOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
					size_t var_val_len, uint8_t *statP, oid * name,
					size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25SVCIVMOThroughputClassOutgoing entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOThroughputClassOutgoing;
		StorageTmp->x25SVCIVMOThroughputClassOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOThroughputClassOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOWindowSizeIncoming(int action, uint8_t *var_val, uint8_t var_val_type,
				   size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOWindowSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOWindowSizeIncoming;
		StorageTmp->x25SVCIVMOWindowSizeIncoming = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOWindowSizeIncoming = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOWindowSizeOutgoing(int action, uint8_t *var_val, uint8_t var_val_type,
				   size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOWindowSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOWindowSizeOutgoing;
		StorageTmp->x25SVCIVMOWindowSizeOutgoing = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOWindowSizeOutgoing = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOId(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		   uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOId entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOId;
		tmplen = StorageTmp->x25SVCIVMOIdLen;
		memdup((void *) &StorageTmp->x25SVCIVMOId, var_val, var_val_len);
		StorageTmp->x25SVCIVMOIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25SVCIVMOId);
		StorageTmp->x25SVCIVMOId = tmpvar;
		StorageTmp->x25SVCIVMOIdLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTECallTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTECallTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTECallTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTECallTime;
		StorageTmp->x25SVCIVMODTECallTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTECallTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEResetTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEResetTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEResetTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTEResetTime;
		StorageTmp->x25SVCIVMODTEResetTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEResetTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEResetCount(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEResetCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTEResetCount;
		StorageTmp->x25SVCIVMODTEResetCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEResetCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEInterruptTime(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEInterruptTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEInterruptTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTEInterruptTime;
		StorageTmp->x25SVCIVMODTEInterruptTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEInterruptTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEClearTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEClearTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEClearTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTEClearTime;
		StorageTmp->x25SVCIVMODTEClearTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEClearTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEClearCount(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEClearCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTEClearCount;
		StorageTmp->x25SVCIVMODTEClearCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEClearCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEWindowTime(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEWindowTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTEWindowTime;
		StorageTmp->x25SVCIVMODTEWindowTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEWindowTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEDataTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEDataTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEDataTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTEDataTime;
		StorageTmp->x25SVCIVMODTEDataTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEDataTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTEDataCount(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEDataCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEDataCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTEDataCount;
		StorageTmp->x25SVCIVMODTEDataCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEDataCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTERejectTime(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTERejectTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTERejectTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTERejectTime;
		StorageTmp->x25SVCIVMODTERejectTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTERejectTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTERejectCount(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTERejectCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTERejectCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODTERejectCount;
		StorageTmp->x25SVCIVMODTERejectCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTERejectCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMOId(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
		   uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOId entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMOId;
		tmplen = StorageTmp->x25SVCIVMOIdLen;
		memdup((void *) &StorageTmp->x25SVCIVMOId, var_val, var_val_len);
		StorageTmp->x25SVCIVMOIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->x25SVCIVMOId);
		StorageTmp->x25SVCIVMOId = tmpvar;
		StorageTmp->x25SVCIVMOIdLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXECallTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXECallTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXECallTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXECallTime;
		StorageTmp->x25SVCIVMODXECallTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXECallTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEResetTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEResetTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEResetTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXEResetTime;
		StorageTmp->x25SVCIVMODXEResetTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEResetTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEClearTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEClearTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEClearTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXEClearTime;
		StorageTmp->x25SVCIVMODXEClearTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEClearTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEInterruptTime(int action, uint8_t *var_val, uint8_t var_val_type,
				 size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEInterruptTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEInterruptTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXEInterruptTime;
		StorageTmp->x25SVCIVMODXEInterruptTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEInterruptTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEResetCount(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEResetCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXEResetCount;
		StorageTmp->x25SVCIVMODXEResetCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEResetCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEClearCount(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEClearCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXEClearCount;
		StorageTmp->x25SVCIVMODXEClearCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEClearCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEWindowTime(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEWindowTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXEWindowTime;
		StorageTmp->x25SVCIVMODXEWindowTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEWindowTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEDataTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			    uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEDataTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEDataTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXEDataTime;
		StorageTmp->x25SVCIVMODXEDataTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEDataTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXEDataCount(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEDataCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEDataCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXEDataCount;
		StorageTmp->x25SVCIVMODXEDataCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEDataCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXERejectTime(int action, uint8_t *var_val, uint8_t var_val_type,
			      size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXERejectTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXERejectTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXERejectTime;
		StorageTmp->x25SVCIVMODXERejectTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXERejectTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXERejectCount(int action, uint8_t *var_val, uint8_t var_val_type,
			       size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXERejectCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXERejectCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->x25SVCIVMODXERejectCount;
		StorageTmp->x25SVCIVMODXERejectCount = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXERejectCount = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDTERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			 uint8_t *statP, oid * name, size_t name_len)
{
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static struct x25PLEDTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEDTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25PLEDTETableStorage, NULL,
			   &name[sizeof(x25PLEDTETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25PLEDTETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25PLEDTETable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->x25PLEDTEPacketSequencing = 1;
			StorageNew->x25PLEDTERestartTime = 18000;
			StorageNew->x25PLEDTERestartCount = 1;
			StorageNew->x25PLEDTERegistrationTime = 30000;
			StorageNew->x25PLEDTERegistrationCount = 1;
			StorageNew->x25PLEDTERegistrationPermitted = 2;

			StorageNew->x25PLEDTERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25PLEDTETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25PLEDTERowStatus;
			StorageTmp->x25PLEDTERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25PLEDTETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PLEDTETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PLEDTETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PLEDTETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25PLEDTETable_add(StorageDel);
		} else {
			StorageTmp->x25PLEDTERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25PLEDTERowStatus == RS_CREATEANDGO) {
				StorageTmp->x25PLEDTERowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->x25PLEDTERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25PLEDTERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDCERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			 uint8_t *statP, oid * name, size_t name_len)
{
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static struct x25PLEDCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEDCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25PLEDCETableStorage, NULL,
			   &name[sizeof(x25PLEDCETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25PLEDCETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25PLEDCETable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->x25PLEDCERestartIndication = 6000;
			StorageNew->x25PLEDCERestartCount = 1;
			StorageNew->x25PLEDCEIncomingCall = 18000;
			StorageNew->x25PLEDCEResetCount = 1;
			StorageNew->x25PLEDCEClearIndication = 6000;
			StorageNew->x25PLEDCEClearCount = 1;

			StorageNew->x25PLEDCERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25PLEDCETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25PLEDCERowStatus;
			StorageTmp->x25PLEDCERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25PLEDCETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PLEDCETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PLEDCETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PLEDCETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25PLEDCETable_add(StorageDel);
		} else {
			StorageTmp->x25PLEDCERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25PLEDCERowStatus == RS_CREATEANDGO) {
				StorageTmp->x25PLEDCERowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->x25PLEDCERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25PLEDCERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEDXERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			 uint8_t *statP, oid * name, size_t name_len)
{
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static struct x25PLEDXETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEDXETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25PLEDXETableStorage, NULL,
			   &name[sizeof(x25PLEDXETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDXERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25PLEDXETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25PLEDXETable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->x25PLEDXERestartTime = 18000;
			StorageNew->x25PLEDXERegistrationTime = 30000;
			StorageNew->x25PLEDXERegistrationCount = 1;
			StorageNew->x25PLEDXERegistrationPermitted = 2;

			StorageNew->x25PLEDXERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25PLEDXETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25PLEDXERowStatus;
			StorageTmp->x25PLEDXERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25PLEDXETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PLEDXETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PLEDXETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PLEDXETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25PLEDXETable_add(StorageDel);
		} else {
			StorageTmp->x25PLEDXERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25PLEDXERowStatus == RS_CREATEANDGO) {
				StorageTmp->x25PLEDXERowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->x25PLEDXERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25PLEDXERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODTERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static struct x25PLEIVMODTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEIVMODTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25PLEIVMODTETableStorage, NULL,
			   &name[sizeof(x25PLEIVMODTETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE),
			 "write to x25PLEIVMODTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEIVMOId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25PLEIVMODTETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMODTETable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->x25PLEIVMODTERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25PLEIVMODTETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMODTERowStatus;
			StorageTmp->x25PLEIVMODTERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25PLEIVMODTETableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&x25PLEIVMODTETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PLEIVMODTETableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&x25PLEIVMODTETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25PLEIVMODTETable_add(StorageDel);
		} else {
			StorageTmp->x25PLEIVMODTERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25PLEIVMODTERowStatus == RS_CREATEANDGO) {
				StorageTmp->x25PLEIVMODTERowStatus = RS_ACTIVE;
			} else if (StorageTmp
				   && StorageTmp->x25PLEIVMODTERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25PLEIVMODTERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PLEIVMODCERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMODCETable_data *StorageTmp = NULL;
	static struct x25PLEIVMODCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEIVMODCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25PLEIVMODCETableStorage, NULL,
			   &name[sizeof(x25PLEIVMODCETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE),
			 "write to x25PLEIVMODCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEIVMOId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25PLEIVMODCETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMODCETable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->x25PLEIVMODCERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25PLEIVMODCETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMODCERowStatus;
			StorageTmp->x25PLEIVMODCERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25PLEIVMODCETableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&x25PLEIVMODCETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PLEIVMODCETableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&x25PLEIVMODCETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25PLEIVMODCETable_add(StorageDel);
		} else {
			StorageTmp->x25PLEIVMODCERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25PLEIVMODCERowStatus == RS_CREATEANDGO) {
				StorageTmp->x25PLEIVMODCERowStatus = RS_ACTIVE;
			} else if (StorageTmp
				   && StorageTmp->x25PLEIVMODCERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25PLEIVMODCERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDTERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			 uint8_t *statP, oid * name, size_t name_len)
{
	struct x25PVCDTETable_data *StorageTmp = NULL;
	static struct x25PVCDTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PVCDTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25PVCDTETableStorage, NULL,
			   &name[sizeof(x25PVCDTETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PVCDTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25VCId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25PVCDTETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25PVCDTETable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25VCId, vp->val.string, vp->val_len);
			StorageNew->x25VCIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->x25PVCDTERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25PVCDTETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25PVCDTERowStatus;
			StorageTmp->x25PVCDTERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25PVCDTETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PVCDTETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PVCDTETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PVCDTETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25PVCDTETable_add(StorageDel);
		} else {
			StorageTmp->x25PVCDTERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25PVCDTERowStatus == RS_CREATEANDGO) {
				StorageTmp->x25PVCDTERowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->x25PVCDTERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25PVCDTERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDCERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			 uint8_t *statP, oid * name, size_t name_len)
{
	struct x25PVCDCETable_data *StorageTmp = NULL;
	static struct x25PVCDCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PVCDCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25PVCDCETableStorage, NULL,
			   &name[sizeof(x25PVCDCETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PVCDCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25VCId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25PVCDCETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25PVCDCETable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25VCId, vp->val.string, vp->val_len);
			StorageNew->x25VCIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->x25PVCDCERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25PVCDCETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25PVCDCERowStatus;
			StorageTmp->x25PVCDCERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25PVCDCETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PVCDCETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PVCDCETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PVCDCETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25PVCDCETable_add(StorageDel);
		} else {
			StorageTmp->x25PVCDCERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25PVCDCERowStatus == RS_CREATEANDGO) {
				StorageTmp->x25PVCDCERowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->x25PVCDCERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25PVCDCERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25PVCDXERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			 uint8_t *statP, oid * name, size_t name_len)
{
	struct x25PVCDXETable_data *StorageTmp = NULL;
	static struct x25PVCDXETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PVCDXETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25PVCDXETableStorage, NULL,
			   &name[sizeof(x25PVCDXETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PVCDXERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25VCId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25PVCDXETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25PVCDXETable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25VCId, vp->val.string, vp->val_len);
			StorageNew->x25VCIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->x25PVCDXERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25PVCDXETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25PVCDXERowStatus;
			StorageTmp->x25PVCDXERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25PVCDXETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PVCDXETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25PVCDXETableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25PVCDXETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25PVCDXETable_add(StorageDel);
		} else {
			StorageTmp->x25PVCDXERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25PVCDXERowStatus == RS_CREATEANDGO) {
				StorageTmp->x25PVCDXERowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->x25PVCDXERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25PVCDXERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMORowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			  uint8_t *statP, oid * name, size_t name_len)
{
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static struct x25SVCIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25SVCIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25SVCIVMOTableStorage, NULL,
			   &name[sizeof(x25SVCIVMOTable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25SVCIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25SVCIVMOId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25SVCIVMOTable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25SVCIVMOTable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25SVCIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25SVCIVMOIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->x25SVCIVMORowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25SVCIVMOTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25SVCIVMORowStatus;
			StorageTmp->x25SVCIVMORowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25SVCIVMOTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25SVCIVMOTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25SVCIVMOTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&x25SVCIVMOTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25SVCIVMOTable_add(StorageDel);
		} else {
			StorageTmp->x25SVCIVMORowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25SVCIVMORowStatus == RS_CREATEANDGO) {
				StorageTmp->x25SVCIVMORowStatus = RS_ACTIVE;
			} else if (StorageTmp
				   && StorageTmp->x25SVCIVMORowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25SVCIVMORowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODTERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static struct x25SVCIVMODTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25SVCIVMODTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25SVCIVMODTETableStorage, NULL,
			   &name[sizeof(x25SVCIVMODTETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE),
			 "write to x25SVCIVMODTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25SVCIVMOId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25SVCIVMODTETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25SVCIVMODTETable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25SVCIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25SVCIVMOIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->x25SVCIVMODTECallTime = 20000;
			StorageNew->x25SVCIVMODTEResetTime = 18000;
			StorageNew->x25SVCIVMODTEResetCount = 1;
			StorageNew->x25SVCIVMODTEInterruptTime = 18000;
			StorageNew->x25SVCIVMODTEClearTime = 18000;

			StorageNew->x25SVCIVMODTERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25SVCIVMODTETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25SVCIVMODTERowStatus;
			StorageTmp->x25SVCIVMODTERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25SVCIVMODTETableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&x25SVCIVMODTETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25SVCIVMODTETableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&x25SVCIVMODTETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25SVCIVMODTETable_add(StorageDel);
		} else {
			StorageTmp->x25SVCIVMODTERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25SVCIVMODTERowStatus == RS_CREATEANDGO) {
				StorageTmp->x25SVCIVMODTERowStatus = RS_ACTIVE;
			} else if (StorageTmp
				   && StorageTmp->x25SVCIVMODTERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25SVCIVMODTERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_x25SVCIVMODXERowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len,
			     uint8_t *statP, oid * name, size_t name_len)
{
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static struct x25SVCIVMODXETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25SVCIVMODXETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp =
	    header_complex(x25SVCIVMODXETableStorage, NULL,
			   &name[sizeof(x25SVCIVMODXETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE),
			 "write to x25SVCIVMODXERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25PLEId 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* x25SVCIVMOId 
												 */

			if (header_complex_parse_oid
			    (&(name[sizeof(x25SVCIVMODXETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(x25SVCIVMODXETable_data);
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25SVCIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25SVCIVMOIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->x25SVCIVMODXERowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				x25SVCIVMODXETable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->x25SVCIVMODXERowStatus;
			StorageTmp->x25SVCIVMODXERowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(x25SVCIVMODXETableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&x25SVCIVMODXETableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(x25SVCIVMODXETableStorage, StorageTmp);
			StorageDel =
			    header_complex_extract_entry(&x25SVCIVMODXETableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			x25SVCIVMODXETable_add(StorageDel);
		} else {
			StorageTmp->x25SVCIVMODXERowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->x25SVCIVMODXERowStatus == RS_CREATEANDGO) {
				StorageTmp->x25SVCIVMODXERowStatus = RS_ACTIVE;
			} else if (StorageTmp
				   && StorageTmp->x25SVCIVMODXERowStatus == RS_CREATEANDWAIT) {
				StorageTmp->x25SVCIVMODXERowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
