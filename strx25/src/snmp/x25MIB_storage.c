/*****************************************************************************

 @(#) $RCSfile$ $Name$($Revision$) $Date$

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2009  Monavacom Limited <http://www.monavacom.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date$ by $Author$

 -----------------------------------------------------------------------------

 $Log$
 *****************************************************************************/

#ident "@(#) $RCSfile$ $Name$($Revision$) $Date$"

static char const ident[] = "$RCSfile$ $Name$($Revision$) $Date$";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "x25MIB_storage.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int x25PLPMIB_refresh = 1;
volatile int x25PLETable_refresh = 1;
volatile int x25PLEIVMOTable_refresh = 1;
volatile int x25PLEDTETable_refresh = 1;
volatile int x25PLEDCETable_refresh = 1;
volatile int x25PLEDXETable_refresh = 1;
volatile int x25PLEIVMODTETable_refresh = 1;
volatile int x25PLEIVMODCETable_refresh = 1;
volatile int x25PLEIVMODXETable_refresh = 1;
volatile int x25VCTable_refresh = 1;
volatile int x25VCDTETable_refresh = 1;
volatile int x25VCDCETable_refresh = 1;
volatile int x25VCDXETable_refresh = 1;
volatile int x25PVCDTETable_refresh = 1;
volatile int x25PVCDCETable_refresh = 1;
volatile int x25PVCDXETable_refresh = 1;
volatile int x25SVCIVMOTable_refresh = 1;
volatile int x25SVCIVMODTETable_refresh = 1;
volatile int x25SVCIVMODXETable_refresh = 1;
volatile int x25SVCDTETable_refresh = 1;
volatile int x25SVCDCETable_refresh = 1;
volatile int x25SVCDXETable_refresh = 1;
volatile int x25DSCTable_refresh = 1;
volatile int x25PLEDTEStatsTable_refresh = 1;
volatile int x25PLEDCEStatsTable_refresh = 1;
volatile int x25PLEDXEStatsTable_refresh = 1;

/*
 * x25PLPMIB_variables_oid: object identifier for x25PLPMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid x25PLPMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3 };
oid x25PLEDTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 3, 1, 1 };
oid x25PLEDCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 4, 1, 1 };
oid x25PLEDXETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 5, 1, 1 };
oid x25PLEIVMODTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 6, 1, 1 };
oid x25PLEIVMODCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 7, 1, 1 };
oid x25PVCDTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 13, 1, 1 };
oid x25PVCDCETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 14, 1, 1 };
oid x25PVCDXETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 15, 1, 1 };
oid x25SVCIVMOTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 16, 1, 1 };
oid x25SVCIVMODTETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 17, 1, 1 };
oid x25SVCIVMODXETable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 1, 1, 18, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */

/*
 * Oids accessible only for notify defined in this MIB.
 */
oid notificationDataChannel_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 2 };
oid notificationDataPacketHeader_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 2 };
oid notificationDataDiagnosticCode_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 2 };
oid notificationDataCauseCode_oid[10] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 2 };

/*
 * Other oids defined in this MIB.
 */
oid providerInitiatedDisconnect_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 3, 1 };
oid remotelyInitiatedReset_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 3, 1 };
oid providerInitiatedReset_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 3, 1 };
oid remotelyInitiatedRestart_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 3, 1 };
oid restartCountExceeded_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 3, 1 };
oid protocolErrorDetectedLocally_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 3, 1 };
oid accusedOfProtocolError_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 3, 1 };
oid callEstablishmentRetryCountExceeded_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 3, 1 };
oid clearCountExceeded_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 3, 1 };
oid successfulConnectionEstablishment_oid[11] = { 1, 3, 6, 1, 4, 1, 29591, 1, 3, 3, 2 };

/*
 * variable7 x25PLPMIB_variables: tree for x25PLPMIB
 * This variable defines function callbacks and type return information for the x25PLPMIB mib section
 */
struct variable7 x25PLPMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   X25PLEOPERATIONALSTATE  (4 % 256)
	{X25PLEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 1, 1, 1, 2}},
#define   X25PLEADMINISTRATIVESTATE  (5 % 256)
	{X25PLEADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 3}},
#define   X25PLEPROTOCOLVERSIONSSUPPORTED  (6 % 256)
	{X25PLEPROTOCOLVERSIONSSUPPORTED, ASN_BIT_STR, RONLY, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 4}},
#define   X25PLELOCALDTEADDRESS  (7 % 256)
	{X25PLELOCALDTEADDRESS, ASN_OCTET_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 5}},
#define   X25PLEINTERFACEMODE   (8 % 256)
	{X25PLEINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLETable, 6, {1, 1, 1, 1, 1, 6}},
#define   X25PLEFACILITYNONNEGOTIABLE  (9 % 256)
	{X25PLEFACILITYNONNEGOTIABLE, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 7}},
#define   X25PLEFACILITYAVAILABILITY  (10 % 256)
	{X25PLEFACILITYAVAILABILITY, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 8}},
#define   X25PLEFACILITYNEGOTIATION  (11 % 256)
	{X25PLEFACILITYNEGOTIATION, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 9}},
#define   X25PLEFACILITYWHILEIDLE  (12 % 256)
	{X25PLEFACILITYWHILEIDLE, ASN_BIT_STR, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 10}},
#define   X25PLEPACKETSEQUENCENUMBERING  (13 % 256)
	{X25PLEPACKETSEQUENCENUMBERING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 11}},
#define   X25PLEDEFAULTPACKETSIZEINCOMING  (14 % 256)
	{X25PLEDEFAULTPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 12}},
#define   X25PLEDEFAULTPACKETSIZEOUTGOING  (15 % 256)
	{X25PLEDEFAULTPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 13}},
#define   X25PLEDEFAULTWINDOWSIZEINCOMING  (16 % 256)
	{X25PLEDEFAULTWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 14}},
#define   X25PLEDEFAULTWINDOWSIZEOUTGOING  (17 % 256)
	{X25PLEDEFAULTWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 15}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSINCOMING  (18 % 256)
	{X25PLEDEFAULTTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 16}},
#define   X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING  (19 % 256)
	{X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 17}},
#define   X25PLESNSERVICEPROVIDER  (20 % 256)
	{X25PLESNSERVICEPROVIDER, ASN_OBJECT_ID, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 18}},
#define   X25PLESNSAP           (21 % 256)
	{X25PLESNSAP, ASN_OBJECT_ID, RWRITE, var_x25PLETable, 6, {1, 1, 1, 1, 1, 19}},
#define   X25PLELOGICALCHANNELASSIGNMENTHIC  (22 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTHIC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 20}},
#define   X25PLELOGICALCHANNELASSIGNMENTLIC  (23 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTLIC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 21}},
#define   X25PLELOGICALCHANNELASSIGNMENTHTC  (24 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTHTC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 22}},
#define   X25PLELOGICALCHANNELASSIGNMENTLTC  (25 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTLTC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 23}},
#define   X25PLELOGICALCHANNELASSIGNMENTHOC  (26 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTHOC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 24}},
#define   X25PLELOGICALCHANNELASSIGNMENTLOC  (27 % 256)
	{X25PLELOGICALCHANNELASSIGNMENTLOC, ASN_INTEGER, RWRITE, var_x25PLETable, 6,
	 {1, 1, 1, 1, 1, 25}},
#define   X25PLEIVMOINTERFACEMODE  (32 % 256)
	{X25PLEIVMOINTERFACEMODE, ASN_INTEGER, RONLY, var_x25PLEIVMOTable, 6, {1, 1, 2, 1, 1, 2}},
#define   X25PLEIVMODEFAULTPACKETSIZEINCOMING  (33 % 256)
	{X25PLEIVMODEFAULTPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 3}},
#define   X25PLEIVMODEFAULTPACKETSIZEOUTGOING  (34 % 256)
	{X25PLEIVMODEFAULTPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 4}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING  (35 % 256)
	{X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 5}},
#define   X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING  (36 % 256)
	{X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 6}},
#define   X25PLEIVMODEFAULTWINDOWSIZEINCOMING  (37 % 256)
	{X25PLEIVMODEFAULTWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 7}},
#define   X25PLEIVMODEFAULTWINDOWSIZEOUTGOING  (38 % 256)
	{X25PLEIVMODEFAULTWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 8}},
#define   X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION  (39 % 256)
	{X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 9}},
#define   X25PLEIVMOLOCALDTEADDRESS  (40 % 256)
	{X25PLEIVMOLOCALDTEADDRESS, ASN_OCTET_STR, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 10}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHPC  (41 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHPC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 11}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLPC  (42 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLPC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 12}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHIC  (43 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHIC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 13}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLIC  (44 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLIC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 14}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHTC  (45 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHTC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 15}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLTC  (46 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLTC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 16}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTHOC  (47 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTHOC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 17}},
#define   X25PLEIVMOLOGICALCHANNELASSIGNMENTLOC  (48 % 256)
	{X25PLEIVMOLOGICALCHANNELASSIGNMENTLOC, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 18}},
#define   X25PLEIVMOSNSERVICEPROVIDER  (49 % 256)
	{X25PLEIVMOSNSERVICEPROVIDER, ASN_OBJECT_ID, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 19}},
#define   X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION  (50 % 256)
	{X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION, ASN_INTEGER, RWRITE, var_x25PLEIVMOTable, 6,
	 {1, 1, 2, 1, 1, 20}},
#define   X25PLEDTEPACKETSEQUENCING  (54 % 256)
	{X25PLEDTEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 1}},
#define   X25PLEDTEMAXACTIVECIRCUITS  (55 % 256)
	{X25PLEDTEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6,
	 {1, 1, 3, 1, 1, 2}},
#define   X25PLEDTECALLDEFLECTIONSUBSCRIPTION  (56 % 256)
	{X25PLEDTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6,
	 {1, 1, 3, 1, 1, 3}},
#define   X25PLEDTERESTARTTIME  (57 % 256)
	{X25PLEDTERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 4}},
#define   X25PLEDTERESTARTCOUNT  (58 % 256)
	{X25PLEDTERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 5}},
#define   X25PLEDTEMINIMUMRECALLTIMER  (59 % 256)
	{X25PLEDTEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6,
	 {1, 1, 3, 1, 1, 6}},
#define   X25PLEDTEREGISTRATIONTIME  (60 % 256)
	{X25PLEDTEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 7}},
#define   X25PLEDTEREGISTRATIONCOUNT  (61 % 256)
	{X25PLEDTEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6,
	 {1, 1, 3, 1, 1, 8}},
#define   X25PLEDTEREGISTRATIONPERMITTED  (62 % 256)
	{X25PLEDTEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6,
	 {1, 1, 3, 1, 1, 9}},
#define   X25PLEDTEPROFILE      (63 % 256)
	{X25PLEDTEPROFILE, ASN_OBJECT_ID, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 10}},
#define   X25PLEDTEROWSTATUS    (64 % 256)
	{X25PLEDTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEDTETable, 6, {1, 1, 3, 1, 1, 11}},
#define   X25PLEDCEPACKETSEQUENCING  (68 % 256)
	{X25PLEDCEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 1}},
#define   X25PLEDCECALLDEFLECTIONSUBSCRIPTION  (69 % 256)
	{X25PLEDCECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 2}},
#define   X25PLEDCECUG          (70 % 256)
	{X25PLEDCECUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 3}},
#define   X25PLEDCEFASTSELECTACCEPTANCE  (71 % 256)
	{X25PLEDCEFASTSELECTACCEPTANCE, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 4}},
#define   X25PLEDCEINCOMINGCALLSBARRED  (72 % 256)
	{X25PLEDCEINCOMINGCALLSBARRED, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 5}},
#define   X25PLEDCEONEWAYLOGICALCHANNELOUTGOING  (73 % 256)
	{X25PLEDCEONEWAYLOGICALCHANNELOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 6}},
#define   X25PLEDCEOUTGOINGCALLSBARRED  (74 % 256)
	{X25PLEDCEOUTGOINGCALLSBARRED, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 7}},
#define   X25PLEDCEBILATERALCUG  (75 % 256)
	{X25PLEDCEBILATERALCUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 8}},
#define   X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS  (76 % 256)
	{X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 9}},
#define   X25PLEDCECALLREDIRECTION  (77 % 256)
	{X25PLEDCECALLREDIRECTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 10}},
#define   X25PLEDCECHARGINGINFORMATION  (78 % 256)
	{X25PLEDCECHARGINGINFORMATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 11}},
#define   X25PLEDCECUGWITHINCOMINGACCESS  (79 % 256)
	{X25PLEDCECUGWITHINCOMINGACCESS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 12}},
#define   X25PLEDCECUGWITHOUTGOINGACCESS  (80 % 256)
	{X25PLEDCECUGWITHOUTGOINGACCESS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 13}},
#define   X25PLEDCEDBITMODIFICATION  (81 % 256)
	{X25PLEDCEDBITMODIFICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 14}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSSUBSCRIPTION  (82 % 256)
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 15}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSSUPPORTED  (83 % 256)
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSSUPPORTED, ASN_BIT_STR, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 16}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING  (84 % 256)
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 17}},
#define   X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING  (85 % 256)
	{X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 18}},
#define   X25PLEDCEHUNTGROUP    (86 % 256)
	{X25PLEDCEHUNTGROUP, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 19}},
#define   X25PLEDCEINCOMINGCALLBARREDWITHINCUG  (87 % 256)
	{X25PLEDCEINCOMINGCALLBARREDWITHINCUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 20}},
#define   X25PLEDCELOCALCHARGINGPREVENTION  (88 % 256)
	{X25PLEDCELOCALCHARGINGPREVENTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 21}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZESUBSCRIPTION  (89 % 256)
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZESUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable,
	 6, {1, 1, 4, 1, 1, 22}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM  (90 % 256)
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 23}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING  (91 % 256)
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 24}},
#define   X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING  (92 % 256)
	{X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 25}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZESUBSCRIPTION  (93 % 256)
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZESUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable,
	 6, {1, 1, 4, 1, 1, 26}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEMAXIMUM  (94 % 256)
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEMAXIMUM, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 27}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEINCOMING  (95 % 256)
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 28}},
#define   X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEOUTGOING  (96 % 256)
	{X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 29}},
#define   X25PLEDCENUIOVERRIDE  (97 % 256)
	{X25PLEDCENUIOVERRIDE, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 30}},
#define   X25PLEDCENUISUBSCRIPTION  (98 % 256)
	{X25PLEDCENUISUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 31}},
#define   X25PLEDCEONEWAYLOGICALCHANNELINCOMING  (99 % 256)
	{X25PLEDCEONEWAYLOGICALCHANNELINCOMING, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 32}},
#define   X25PLEDCEONLINEFACILITYREGISTRATION  (100 % 256)
	{X25PLEDCEONLINEFACILITYREGISTRATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 33}},
#define   X25PLEDCEOUTGOINGCALLBARREDWITHINCUG  (101 % 256)
	{X25PLEDCEOUTGOINGCALLBARREDWITHINCUG, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 34}},
#define   X25PLEDCEPACKETRETRANSMISSION  (102 % 256)
	{X25PLEDCEPACKETRETRANSMISSION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 35}},
#define   X25PLEDCEREVERSECHARGINGACCEPTANCE  (103 % 256)
	{X25PLEDCEREVERSECHARGINGACCEPTANCE, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 36}},
#define   X25PLEDCEROASUBSCRIPTION  (104 % 256)
	{X25PLEDCEROASUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 37}},
#define   X25PLEDCERESTARTINDICATION  (105 % 256)
	{X25PLEDCERESTARTINDICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6,
	 {1, 1, 4, 1, 1, 38}},
#define   X25PLEDCERESTARTCOUNT  (106 % 256)
	{X25PLEDCERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 39}},
#define   X25PLEDCEINCOMINGCALL  (107 % 256)
	{X25PLEDCEINCOMINGCALL, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 40}},
#define   X25PLEDCECALLCOUNT    (108 % 256)
	{X25PLEDCECALLCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 41}},
#define   X25PLEDCERESETINDICATION  (109 % 256)
	{X25PLEDCERESETINDICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 42}},
#define   X25PLEDCERESETCOUNT   (110 % 256)
	{X25PLEDCERESETCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 43}},
#define   X25PLEDCECLEARINDICATION  (111 % 256)
	{X25PLEDCECLEARINDICATION, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 44}},
#define   X25PLEDCECLEARCOUNT   (112 % 256)
	{X25PLEDCECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 45}},
#define   X25PLEDCEPROFILE      (113 % 256)
	{X25PLEDCEPROFILE, ASN_OBJECT_ID, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 46}},
#define   X25PLEDCEROWSTATUS    (114 % 256)
	{X25PLEDCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEDCETable, 6, {1, 1, 4, 1, 1, 47}},
#define   X25PLEDXEPACKETSEQUENCING  (118 % 256)
	{X25PLEDXEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 1}},
#define   X25PLEDXEMAXACTIVECIRCUITS  (119 % 256)
	{X25PLEDXEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 2}},
#define   X25PLEDXECALLDEFLECTIONSUBSCRIPTION  (120 % 256)
	{X25PLEDXECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 3}},
#define   X25PLEDXERESTARTTIME  (121 % 256)
	{X25PLEDXERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 4}},
#define   X25PLEDXERESTARTCOUNT  (122 % 256)
	{X25PLEDXERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 5}},
#define   X25PLEDXEMINIMUMRECALLTIMER  (123 % 256)
	{X25PLEDXEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 6}},
#define   X25PLEDXEREGISTRATIONTIME  (124 % 256)
	{X25PLEDXEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 7}},
#define   X25PLEDXEREGISTRATIONCOUNT  (125 % 256)
	{X25PLEDXEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 8}},
#define   X25PLEDXEREGISTRATIONPERMITTED  (126 % 256)
	{X25PLEDXEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 9}},
#define   X25PLEDXEPLECLIENTMONAME  (127 % 256)
	{X25PLEDXEPLECLIENTMONAME, ASN_OBJECT_ID, RWRITE, var_x25PLEDXETable, 6,
	 {1, 1, 5, 1, 1, 10}},
#define   X25PLEDXEPROFILE      (128 % 256)
	{X25PLEDXEPROFILE, ASN_OBJECT_ID, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 11}},
#define   X25PLEDXEROWSTATUS    (129 % 256)
	{X25PLEDXEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEDXETable, 6, {1, 1, 5, 1, 1, 12}},
#define   X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION  (134 % 256)
	{X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 1}},
#define   X25PLEIVMODTECALLTIME  (135 % 256)
	{X25PLEIVMODTECALLTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6, {1, 1, 6, 1, 1, 2}},
#define   X25PLEIVMODTECLEARTIME  (136 % 256)
	{X25PLEIVMODTECLEARTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 3}},
#define   X25PLEIVMODTECLEARCOUNT  (137 % 256)
	{X25PLEIVMODTECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 4}},
#define   X25PLEIVMODTEPACKETSEQUENCING  (138 % 256)
	{X25PLEIVMODTEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 5}},
#define   X25PLEIVMODTEINTERRUPTTIME  (139 % 256)
	{X25PLEIVMODTEINTERRUPTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 6}},
#define   X25PLEIVMODTEMAXACTIVECIRCUITS  (140 % 256)
	{X25PLEIVMODTEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 7}},
#define   X25PLEIVMODTEMINIMUMRECALLTIMER  (141 % 256)
	{X25PLEIVMODTEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 8}},
#define   X25PLEIVMODTERESETTIME  (142 % 256)
	{X25PLEIVMODTERESETTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 9}},
#define   X25PLEIVMODTERESETCOUNT  (143 % 256)
	{X25PLEIVMODTERESETCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 10}},
#define   X25PLEIVMODTERESTARTTIME  (144 % 256)
	{X25PLEIVMODTERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 11}},
#define   X25PLEIVMODTERESTARTCOUNT  (145 % 256)
	{X25PLEIVMODTERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 12}},
#define   X25PLEIVMODTEWINDOWTIME  (146 % 256)
	{X25PLEIVMODTEWINDOWTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 13}},
#define   X25PLEIVMODTEDATATIME  (147 % 256)
	{X25PLEIVMODTEDATATIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 14}},
#define   X25PLEIVMODTEDATACOUNT  (148 % 256)
	{X25PLEIVMODTEDATACOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 15}},
#define   X25PLEIVMODTEREJECTTIME  (149 % 256)
	{X25PLEIVMODTEREJECTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 16}},
#define   X25PLEIVMODTEREJECTCOUNT  (150 % 256)
	{X25PLEIVMODTEREJECTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 17}},
#define   X25PLEIVMODTEREGISTRATIONTIME  (151 % 256)
	{X25PLEIVMODTEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 18}},
#define   X25PLEIVMODTEREGISTRATIONCOUNT  (152 % 256)
	{X25PLEIVMODTEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 19}},
#define   X25PLEIVMODTEREGISTRATIONPERMITTED  (153 % 256)
	{X25PLEIVMODTEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 20}},
#define   X25PLEIVMODTEROWSTATUS  (154 % 256)
	{X25PLEIVMODTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMODTETable, 6,
	 {1, 1, 6, 1, 1, 21}},
#define   X25PLEIVMODCEROWSTATUS  (159 % 256)
	{X25PLEIVMODCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PLEIVMODCETable, 6,
	 {1, 1, 7, 1, 1, 1}},
#define   X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION  (164 % 256)
	{X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 1}},
#define   X25PLEIVMODTEMAXACTIVECIRCUITS  (165 % 256)
	{X25PLEIVMODTEMAXACTIVECIRCUITS, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 2}},
#define   X25PLEIVMODTERESTARTTIME  (166 % 256)
	{X25PLEIVMODTERESTARTTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 3}},
#define   X25PLEIVMODTEMINIMUMRECALLTIMER  (167 % 256)
	{X25PLEIVMODTEMINIMUMRECALLTIMER, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 4}},
#define   X25PLEIVMODTERESTARTCOUNT  (168 % 256)
	{X25PLEIVMODTERESTARTCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 5}},
#define   X25PLEIVMODTEPACKETSEQUENCING  (169 % 256)
	{X25PLEIVMODTEPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 6}},
#define   X25PLEIVMODTEREGISTRATIONTIME  (170 % 256)
	{X25PLEIVMODTEREGISTRATIONTIME, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 7}},
#define   X25PLEIVMODTEREGISTRATIONCOUNT  (171 % 256)
	{X25PLEIVMODTEREGISTRATIONCOUNT, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 8}},
#define   X25PLEIVMODTEREGISTRATIONPERMITTED  (172 % 256)
	{X25PLEIVMODTEREGISTRATIONPERMITTED, ASN_INTEGER, RWRITE, var_x25PLEIVMODXETable, 6,
	 {1, 1, 8, 1, 1, 9}},
#define   X25VCLOGICALCHANNEL   (177 % 256)
	{X25VCLOGICALCHANNEL, ASN_INTEGER, RONLY, var_x25VCTable, 6, {1, 1, 9, 1, 1, 2}},
#define   X25VCPACKETSEQUENCING  (178 % 256)
	{X25VCPACKETSEQUENCING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 3}},
#define   X25VCPACKETSIZEINCOMING  (179 % 256)
	{X25VCPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 4}},
#define   X25VCPACKETSIZEOUTGOING  (180 % 256)
	{X25VCPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 5}},
#define   X25VCWINDOWSIZEINCOMING  (181 % 256)
	{X25VCWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 6}},
#define   X25VCWINDOWSIZEOUTGOING  (182 % 256)
	{X25VCWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 7}},
#define   X25VCTHROUGHPUTCLASSINCOMING  (183 % 256)
	{X25VCTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 8}},
#define   X25VCTHROUGHPUTCLASSOUTGOING  (184 % 256)
	{X25VCTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25VCTable, 6, {1, 1, 9, 1, 1, 9}},
#define   X25VCDTEOCTETSRECEIVED  (189 % 256)
	{X25VCDTEOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 1}},
#define   X25VCDTEOCTETSSENT    (190 % 256)
	{X25VCDTEOCTETSSENT, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 2}},
#define   X25VCDTEDATAPACKETSRECEIVED  (191 % 256)
	{X25VCDTEDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6,
	 {1, 1, 10, 1, 1, 3}},
#define   X25VCDTEDATAPACKETSSENT  (192 % 256)
	{X25VCDTEDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 4}},
#define   X25VCDTEDATATIMEOUTS  (193 % 256)
	{X25VCDTEDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 5}},
#define   X25VCDTEINTERRUPTPACKETSRECEIVED  (194 % 256)
	{X25VCDTEINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6,
	 {1, 1, 10, 1, 1, 6}},
#define   X25VCDTEINTERRUPTPACKETSSENT  (195 % 256)
	{X25VCDTEINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6,
	 {1, 1, 10, 1, 1, 7}},
#define   X25VCDTEINTERRUPTTIMEOUTS  (196 % 256)
	{X25VCDTEINTERRUPTTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6,
	 {1, 1, 10, 1, 1, 8}},
#define   X25VCDTEPROVIDERRESETS  (197 % 256)
	{X25VCDTEPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 9}},
#define   X25VCDTEREMOTERESETS  (198 % 256)
	{X25VCDTEREMOTERESETS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 10}},
#define   X25VCDTERESETTIMEOUTS  (199 % 256)
	{X25VCDTERESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDTETable, 6, {1, 1, 10, 1, 1, 11}},
#define   X25VCDCEOCTETSRECEIVED  (204 % 256)
	{X25VCDCEOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 1}},
#define   X25VCDCEOCTETSSENT    (205 % 256)
	{X25VCDCEOCTETSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 2}},
#define   X25VCDCEDATAPACKETSRECEIVED  (206 % 256)
	{X25VCDCEDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6,
	 {1, 1, 11, 1, 1, 3}},
#define   X25VCDCEDATAPACKETSSENT  (207 % 256)
	{X25VCDCEDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 4}},
#define   X25VCDCEINTERRUPTPACKETSRECEIVED  (208 % 256)
	{X25VCDCEINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6,
	 {1, 1, 11, 1, 1, 5}},
#define   X25VCDCEINTERRUPTPACKETSSENT  (209 % 256)
	{X25VCDCEINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6,
	 {1, 1, 11, 1, 1, 6}},
#define   X25VCDCEPROVIDERRESETS  (210 % 256)
	{X25VCDCEPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 7}},
#define   X25VCDCEREMOTERESETS  (211 % 256)
	{X25VCDCEREMOTERESETS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 8}},
#define   X25VCDCERESETTIMEOUTS  (212 % 256)
	{X25VCDCERESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 9}},
#define   X25VCDCEREMOTERESTARTS  (213 % 256)
	{X25VCDCEREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 10}},
#define   X25VCDCEPROVIDERDISCONNECTS  (214 % 256)
	{X25VCDCEPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6,
	 {1, 1, 11, 1, 1, 11}},
#define   X25VCDCEX25SEGMENTSRECEIVED  (215 % 256)
	{X25VCDCEX25SEGMENTSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6,
	 {1, 1, 11, 1, 1, 12}},
#define   X25VCDCEX25SEGMENTSSENT  (216 % 256)
	{X25VCDCEX25SEGMENTSSENT, ASN_COUNTER64, RONLY, var_x25VCDCETable, 6, {1, 1, 11, 1, 1, 13}},
#define   X25VCDXEOCTETSRECEIVED  (221 % 256)
	{X25VCDXEOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 1}},
#define   X25VCDXEOCTETSSENT    (222 % 256)
	{X25VCDXEOCTETSSENT, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 2}},
#define   X25VCDXEDATAPACKETSRECEIVED  (223 % 256)
	{X25VCDXEDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6,
	 {1, 1, 12, 1, 1, 3}},
#define   X25VCDXEDATAPACKETSSENT  (224 % 256)
	{X25VCDXEDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 4}},
#define   X25VCDXEDATATIMEOUTS  (225 % 256)
	{X25VCDXEDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 5}},
#define   X25VCDXEINTERRUPTPACKETSRECEIVED  (226 % 256)
	{X25VCDXEINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6,
	 {1, 1, 12, 1, 1, 6}},
#define   X25VCDXEINTERRUPTPACKETSSENT  (227 % 256)
	{X25VCDXEINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6,
	 {1, 1, 12, 1, 1, 7}},
#define   X25VCDXEINTERRUPTTIMEOUTS  (228 % 256)
	{X25VCDXEINTERRUPTTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6,
	 {1, 1, 12, 1, 1, 8}},
#define   X25VCDXEPROVIDERRESETS  (229 % 256)
	{X25VCDXEPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 9}},
#define   X25VCDXEREMOTERESETS  (230 % 256)
	{X25VCDXEREMOTERESETS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 10}},
#define   X25VCDXERESETTIMEOUTS  (231 % 256)
	{X25VCDXERESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25VCDXETable, 6, {1, 1, 12, 1, 1, 11}},
#define   X25PVCDTELOGICALCHANNEL  (236 % 256)
	{X25PVCDTELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDTETable, 6, {1, 1, 13, 1, 1, 1}},
#define   X25PVCDTEROWSTATUS    (237 % 256)
	{X25PVCDTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PVCDTETable, 6, {1, 1, 13, 1, 1, 2}},
#define   X25PVCDCELOGICALCHANNEL  (242 % 256)
	{X25PVCDCELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 1}},
#define   X25PVCDCECHARGINGDIRECTION  (243 % 256)
	{X25PVCDCECHARGINGDIRECTION, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6,
	 {1, 1, 14, 1, 1, 2}},
#define   X25PVCDCEOPERATIONALSTATE  (244 % 256)
	{X25PVCDCEOPERATIONALSTATE, ASN_INTEGER, RONLY, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 3}},
#define   X25PVCDCEREMOTEDTEADDRESS  (245 % 256)
	{X25PVCDCEREMOTEDTEADDRESS, ASN_OCTET_STR, RWRITE, var_x25PVCDCETable, 6,
	 {1, 1, 14, 1, 1, 4}},
#define   X25PVCDCEREMOTELOGICALCHANNEL  (246 % 256)
	{X25PVCDCEREMOTELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6,
	 {1, 1, 14, 1, 1, 5}},
#define   X25PVCDCEROWSTATUS    (247 % 256)
	{X25PVCDCEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PVCDCETable, 6, {1, 1, 14, 1, 1, 6}},
#define   X25PVCDXELOGICALCHANNEL  (252 % 256)
	{X25PVCDXELOGICALCHANNEL, ASN_INTEGER, RWRITE, var_x25PVCDXETable, 6, {1, 1, 15, 1, 1, 1}},
#define   X25PVCDXEROWSTATUS    (253 % 256)
	{X25PVCDXEROWSTATUS, ASN_INTEGER, RWRITE, var_x25PVCDXETable, 6, {1, 1, 15, 1, 1, 2}},
#define   X25SVCIVMOID          (257 % 256)
	{X25SVCIVMOID, ASN_OCTET_STR, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 1}},
#define   X25SVCIVMOFASTSELECT  (258 % 256)
	{X25SVCIVMOFASTSELECT, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 2}},
#define   X25SVCIVMOPACKETSIZEINCOMING  (259 % 256)
	{X25SVCIVMOPACKETSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 3}},
#define   X25SVCIVMOPACKETSIZEOUTGOING  (260 % 256)
	{X25SVCIVMOPACKETSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 4}},
#define   X25SVCIVMOREVERSECHARGING  (261 % 256)
	{X25SVCIVMOREVERSECHARGING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 5}},
#define   X25SVCIVMOTHROUGHPUTCLASSINCOMING  (262 % 256)
	{X25SVCIVMOTHROUGHPUTCLASSINCOMING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 6}},
#define   X25SVCIVMOTHROUGHPUTCLASSOUTGOING  (263 % 256)
	{X25SVCIVMOTHROUGHPUTCLASSOUTGOING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 7}},
#define   X25SVCIVMOWINDOWSIZEINCOMING  (264 % 256)
	{X25SVCIVMOWINDOWSIZEINCOMING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 8}},
#define   X25SVCIVMOWINDOWSIZEOUTGOING  (265 % 256)
	{X25SVCIVMOWINDOWSIZEOUTGOING, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6,
	 {1, 1, 16, 1, 1, 9}},
#define   X25SVCIVMOROWSTATUS   (266 % 256)
	{X25SVCIVMOROWSTATUS, ASN_INTEGER, RWRITE, var_x25SVCIVMOTable, 6, {1, 1, 16, 1, 1, 10}},
#define   X25SVCIVMOID          (270 % 256)
	{X25SVCIVMOID, ASN_OCTET_STR, RWRITE, var_x25SVCIVMODTETable, 6, {1, 1, 16, 1, 1, 1}},
#define   X25SVCIVMODTECALLTIME  (271 % 256)
	{X25SVCIVMODTECALLTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 1}},
#define   X25SVCIVMODTERESETTIME  (272 % 256)
	{X25SVCIVMODTERESETTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 2}},
#define   X25SVCIVMODTERESETCOUNT  (273 % 256)
	{X25SVCIVMODTERESETCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 3}},
#define   X25SVCIVMODTEINTERRUPTTIME  (274 % 256)
	{X25SVCIVMODTEINTERRUPTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 4}},
#define   X25SVCIVMODTECLEARTIME  (275 % 256)
	{X25SVCIVMODTECLEARTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 5}},
#define   X25SVCIVMODTECLEARCOUNT  (276 % 256)
	{X25SVCIVMODTECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 6}},
#define   X25SVCIVMODTEWINDOWTIME  (277 % 256)
	{X25SVCIVMODTEWINDOWTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 7}},
#define   X25SVCIVMODTEDATATIME  (278 % 256)
	{X25SVCIVMODTEDATATIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 8}},
#define   X25SVCIVMODTEDATACOUNT  (279 % 256)
	{X25SVCIVMODTEDATACOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 9}},
#define   X25SVCIVMODTEREJECTTIME  (280 % 256)
	{X25SVCIVMODTEREJECTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 10}},
#define   X25SVCIVMODTEREJECTCOUNT  (281 % 256)
	{X25SVCIVMODTEREJECTCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 11}},
#define   X25SVCIVMODTEROWSTATUS  (282 % 256)
	{X25SVCIVMODTEROWSTATUS, ASN_INTEGER, RWRITE, var_x25SVCIVMODTETable, 6,
	 {1, 1, 17, 1, 1, 12}},
#define   X25SVCIVMOID          (286 % 256)
	{X25SVCIVMOID, ASN_OCTET_STR, RWRITE, var_x25SVCIVMODXETable, 6, {1, 1, 16, 1, 1, 1}},
#define   X25SVCIVMODXECALLTIME  (287 % 256)
	{X25SVCIVMODXECALLTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 1}},
#define   X25SVCIVMODXERESETTIME  (288 % 256)
	{X25SVCIVMODXERESETTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 2}},
#define   X25SVCIVMODXECLEARTIME  (289 % 256)
	{X25SVCIVMODXECLEARTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 3}},
#define   X25SVCIVMODXEINTERRUPTTIME  (290 % 256)
	{X25SVCIVMODXEINTERRUPTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 4}},
#define   X25SVCIVMODXERESETCOUNT  (291 % 256)
	{X25SVCIVMODXERESETCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 5}},
#define   X25SVCIVMODXECLEARCOUNT  (292 % 256)
	{X25SVCIVMODXECLEARCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 6}},
#define   X25SVCIVMODXEROWSTATUS  (293 % 256)
	{X25SVCIVMODXEROWSTATUS, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 7}},
#define   X25SVCIVMODXEWINDOWTIME  (294 % 256)
	{X25SVCIVMODXEWINDOWTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 8}},
#define   X25SVCIVMODXEDATATIME  (295 % 256)
	{X25SVCIVMODXEDATATIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 9}},
#define   X25SVCIVMODXEDATACOUNT  (296 % 256)
	{X25SVCIVMODXEDATACOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 10}},
#define   X25SVCIVMODXEREJECTTIME  (297 % 256)
	{X25SVCIVMODXEREJECTTIME, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 12}},
#define   X25SVCIVMODXEREJECTCOUNT  (298 % 256)
	{X25SVCIVMODXEREJECTCOUNT, ASN_INTEGER, RWRITE, var_x25SVCIVMODXETable, 6,
	 {1, 1, 18, 1, 1, 13}},
#define   X25SVCDTECALLINGADDRESSEXTENSION  (303 % 256)
	{X25SVCDTECALLINGADDRESSEXTENSION,, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 1}},
#define   X25SVCDTECALLEDADDRESSEXTENSION  (304 % 256)
	{X25SVCDTECALLEDADDRESSEXTENSION,, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 2}},
#define   X25SVCDTEDIRECTION    (305 % 256)
	{X25SVCDTEDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 3}},
#define   X25SVCDTEFASTSELECT   (306 % 256)
	{X25SVCDTEFASTSELECT, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 4}},
#define   X25SVCDTEORIGINALLYCALLEDADDRESS  (307 % 256)
	{X25SVCDTEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDTETable, 6,
	 {1, 1, 19, 1, 1, 5}},
#define   X25SVCDTEREDIRECTREASON  (308 % 256)
	{X25SVCDTEREDIRECTREASON, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 6}},
#define   X25SVCDTEREMOTEDTEADDRESS  (309 % 256)
	{X25SVCDTEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDTETable, 6,
	 {1, 1, 19, 1, 1, 7}},
#define   X25SVCDTEREVERSECHARGING  (310 % 256)
	{X25SVCDTEREVERSECHARGING, ASN_INTEGER, RONLY, var_x25SVCDTETable, 6, {1, 1, 19, 1, 1, 8}},
#define   X25SVCDCECHARGINGDIRECTION  (315 % 256)
	{X25SVCDCECHARGINGDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6,
	 {1, 1, 20, 1, 1, 1}},
#define   X25SVCDCECUGSELECTION  (316 % 256)
	{X25SVCDCECUGSELECTION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 2}},
#define   X25SVCDCEDIRECTION    (317 % 256)
	{X25SVCDCEDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 3}},
#define   X25SVCDCEFASTSELECT   (318 % 256)
	{X25SVCDCEFASTSELECT, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6, {1, 1, 20, 1, 1, 4}},
#define   X25SVCDCEREMOTEDTEADDRESS  (319 % 256)
	{X25SVCDCEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDCETable, 6,
	 {1, 1, 20, 1, 1, 5}},
#define   X25SVCDCETRANSITDELAYSELECTIONANDINDICATION  (320 % 256)
	{X25SVCDCETRANSITDELAYSELECTIONANDINDICATION, ASN_INTEGER, RONLY, var_x25SVCDCETable, 6,
	 {1, 1, 20, 1, 1, 6}},
#define   X25SVCDXEDIRECTION    (325 % 256)
	{X25SVCDXEDIRECTION, ASN_INTEGER, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 1}},
#define   X25SVCDXEREMOTEDTEADDRESS  (326 % 256)
	{X25SVCDXEREMOTEDTEADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDXETable, 6,
	 {1, 1, 21, 1, 1, 2}},
#define   X25SVCDXEFASTSELECT   (327 % 256)
	{X25SVCDXEFASTSELECT, ASN_INTEGER, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 4}},
#define   X25SVCDXEREDIRECTREASON  (328 % 256)
	{X25SVCDXEREDIRECTREASON, ASN_INTEGER, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 5}},
#define   X25SVCDXEORIGINALLYCALLEDADDRESS  (329 % 256)
	{X25SVCDXEORIGINALLYCALLEDADDRESS, ASN_OCTET_STR, RONLY, var_x25SVCDXETable, 6,
	 {1, 1, 21, 1, 1, 6}},
#define   X25SVCDXECALLINGADDRESSEXTENSION  (330 % 256)
	{X25SVCDXECALLINGADDRESSEXTENSION,, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 7}},
#define   X25SVCDXECALLEDADDRESSEXTENSION  (331 % 256)
	{X25SVCDXECALLEDADDRESSEXTENSION,, RONLY, var_x25SVCDXETable, 6, {1, 1, 21, 1, 1, 8}},
#define   X25DSCID              (336 % 256)
	{X25DSCID, ASN_OCTET_STR, RONLY, var_x25DSCTable, 6, {1, 1, 22, 1, 1, 1}},
#define   X25DSCRESETREQUESTINDICATIONPACKETS  (337 % 256)
	{X25DSCRESETREQUESTINDICATIONPACKETS, ASN_COUNTER64, RONLY, var_x25DSCTable, 6,
	 {1, 1, 22, 1, 1, 2}},
#define   X25DSCSEGMENTSSENT    (338 % 256)
	{X25DSCSEGMENTSSENT, ASN_COUNTER64, RONLY, var_x25DSCTable, 6, {1, 1, 22, 1, 1, 3}},
#define   X25DSCSEGMENTSRECEIVED  (339 % 256)
	{X25DSCSEGMENTSRECEIVED, ASN_COUNTER64, RONLY, var_x25DSCTable, 6, {1, 1, 22, 1, 1, 4}},
#define   X25PLEDTESTATSCALLATTEMPTS  (343 % 256)
	{X25PLEDTESTATSCALLATTEMPTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 1}},
#define   X25PLEDTESTATSPROTOCOLERRORSDETECTEDLOCALLY  (344 % 256)
	{X25PLEDTESTATSPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable,
	 6, {1, 1, 23, 1, 1, 2}},
#define   X25PLEDTESTATSPROTOCOLERRORSACCUSEDOF  (345 % 256)
	{X25PLEDTESTATSPROTOCOLERRORSACCUSEDOF, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 3}},
#define   X25PLEDTESTATSCALLCOUNTSEXCEEDED  (346 % 256)
	{X25PLEDTESTATSCALLCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 4}},
#define   X25PLEDTESTATSOCTETSRECEIVED  (347 % 256)
	{X25PLEDTESTATSOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 5}},
#define   X25PLEDTESTATSOCTETSSENT  (348 % 256)
	{X25PLEDTESTATSOCTETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 6}},
#define   X25PLEDTESTATSCALLTIMEOUTS  (349 % 256)
	{X25PLEDTESTATSCALLTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 7}},
#define   X25PLEDTESTATSCALLSCONNECTED  (350 % 256)
	{X25PLEDTESTATSCALLSCONNECTED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 8}},
#define   X25PLEDTESTATSDATAPACKETSRECEIVED  (351 % 256)
	{X25PLEDTESTATSDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 9}},
#define   X25PLEDTESTATSDATAPACKETSSENT  (352 % 256)
	{X25PLEDTESTATSDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 10}},
#define   X25PLEDTESTATSDATATIMEOUTS  (353 % 256)
	{X25PLEDTESTATSDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 11}},
#define   X25PLEDTESTATSPROVIDERRESETS  (354 % 256)
	{X25PLEDTESTATSPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 12}},
#define   X25PLEDTESTATSPROVIDERDISCONNECTS  (355 % 256)
	{X25PLEDTESTATSPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 13}},
#define   X25PLEDTESTATSREMOTERESETS  (356 % 256)
	{X25PLEDTESTATSREMOTERESETS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 14}},
#define   X25PLEDTESTATSREMOTERESTARTS  (357 % 256)
	{X25PLEDTESTATSREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 15}},
#define   X25PLEDTESTATSRESETTIMEOUTS  (358 % 256)
	{X25PLEDTESTATSRESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 16}},
#define   X25PLEDTESTATSRESTARTCOUNTSEXCEEDED  (359 % 256)
	{X25PLEDTESTATSRESTARTCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 17}},
#define   X25PLEDTESTATSCLEARTIMEOUTS  (360 % 256)
	{X25PLEDTESTATSCLEARTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 18}},
#define   X25PLEDTESTATSCLEARCOUNTSEXCEEDED  (361 % 256)
	{X25PLEDTESTATSCLEARCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDTEStatsTable, 6,
	 {1, 1, 23, 1, 1, 19}},
#define   X25PLEDCESTATSCALLATTEMPTS  (365 % 256)
	{X25PLEDCESTATSCALLATTEMPTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 1}},
#define   X25PLEDCESTATSCALLSCONNECTED  (366 % 256)
	{X25PLEDCESTATSCALLSCONNECTED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 2}},
#define   X25PLEDCESTATSOCTETSRECEIVED  (367 % 256)
	{X25PLEDCESTATSOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 3}},
#define   X25PLEDCESTATSOCTETSSENT  (368 % 256)
	{X25PLEDCESTATSOCTETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 4}},
#define   X25PLEDCESTATSDATAPACKETSRECEIVED  (369 % 256)
	{X25PLEDCESTATSDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 5}},
#define   X25PLEDCESTATSDATAPACKETSSENT  (370 % 256)
	{X25PLEDCESTATSDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 6}},
#define   X25PLEDCESTATSINTERRUPTPACKETSRECEIVED  (371 % 256)
	{X25PLEDCESTATSINTERRUPTPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 7}},
#define   X25PLEDCESTATSINTERRUPTPACKETSSENT  (372 % 256)
	{X25PLEDCESTATSINTERRUPTPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 8}},
#define   X25PLEDCESTATSPROVIDERRESETS  (373 % 256)
	{X25PLEDCESTATSPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 9}},
#define   X25PLEDCESTATSPROVIDERDISCONNECTS  (374 % 256)
	{X25PLEDCESTATSPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 10}},
#define   X25PLEDCESTATSREMOTERESETS  (375 % 256)
	{X25PLEDCESTATSREMOTERESETS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 11}},
#define   X25PLEDCESTATSREMOTERESTARTS  (376 % 256)
	{X25PLEDCESTATSREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 12}},
#define   X25PLEDCESTATSRESETTIMEOUTS  (377 % 256)
	{X25PLEDCESTATSRESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 13}},
#define   X25PLEDCESTATSX25SEGMENTSRECEIVED  (378 % 256)
	{X25PLEDCESTATSX25SEGMENTSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 14}},
#define   X25PLEDCESTATSX25SEGMENTSSENT  (379 % 256)
	{X25PLEDCESTATSX25SEGMENTSSENT, ASN_COUNTER64, RONLY, var_x25PLEDCEStatsTable, 6,
	 {1, 1, 24, 1, 1, 15}},
#define   X25PLEDXESTATSCALLATTEMPTS  (383 % 256)
	{X25PLEDXESTATSCALLATTEMPTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 1}},
#define   X25PLEDXESTATSPROTOCOLERRORSDETECTEDLOCALLY  (384 % 256)
	{X25PLEDXESTATSPROTOCOLERRORSDETECTEDLOCALLY, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable,
	 6, {1, 1, 25, 1, 1, 2}},
#define   X25PLEDXESTATSPROTOCOLERRORSACCUSEDOF  (385 % 256)
	{X25PLEDXESTATSPROTOCOLERRORSACCUSEDOF, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 3}},
#define   X25PLEDXESTATSCALLCOUNTSEXCEEDED  (386 % 256)
	{X25PLEDXESTATSCALLCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 4}},
#define   X25PLEDXESTATSOCTETSRECEIVED  (387 % 256)
	{X25PLEDXESTATSOCTETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 5}},
#define   X25PLEDXESTATSOCTETSSENT  (388 % 256)
	{X25PLEDXESTATSOCTETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 6}},
#define   X25PLEDXESTATSCALLTIMEOUTS  (389 % 256)
	{X25PLEDXESTATSCALLTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 7}},
#define   X25PLEDXESTATSCALLSCONNECTED  (390 % 256)
	{X25PLEDXESTATSCALLSCONNECTED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 8}},
#define   X25PLEDXESTATSCLEARTIMEOUTS  (391 % 256)
	{X25PLEDXESTATSCLEARTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 9}},
#define   X25PLEDXESTATSDATAPACKETSRECEIVED  (392 % 256)
	{X25PLEDXESTATSDATAPACKETSRECEIVED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 10}},
#define   X25PLEDXESTATSDATAPACKETSSENT  (393 % 256)
	{X25PLEDXESTATSDATAPACKETSSENT, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 11}},
#define   X25PLEDXESTATSDATATIMEOUTS  (394 % 256)
	{X25PLEDXESTATSDATATIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 12}},
#define   X25PLEDXESTATSPROVIDERRESETS  (395 % 256)
	{X25PLEDXESTATSPROVIDERRESETS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 13}},
#define   X25PLEDXESTATSPROVIDERDISCONNECTS  (396 % 256)
	{X25PLEDXESTATSPROVIDERDISCONNECTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 14}},
#define   X25PLEDXESTATSREMOTERESETS  (397 % 256)
	{X25PLEDXESTATSREMOTERESETS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 15}},
#define   X25PLEDXESTATSREMOTERESTARTS  (398 % 256)
	{X25PLEDXESTATSREMOTERESTARTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 16}},
#define   X25PLEDXESTATSRESETTIMEOUTS  (399 % 256)
	{X25PLEDXESTATSRESETTIMEOUTS, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 17}},
#define   X25PLEDXESTATSRESTARTCOUNTSEXCEEDED  (400 % 256)
	{X25PLEDXESTATSRESTARTCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 18}},
#define   X25PLEDXESTATSCLEARCOUNTSEXCEEDED  (401 % 256)
	{X25PLEDXESTATSCLEARCOUNTSEXCEEDED, ASN_COUNTER64, RONLY, var_x25PLEDXEStatsTable, 6,
	 {1, 1, 25, 1, 1, 19}},
};

/* (L = length of the oidsuffix) */
struct x25PLPMIB_data *x25PLPMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *x25PLETableStorage = NULL;
struct header_complex_index *x25PLEIVMOTableStorage = NULL;
struct header_complex_index *x25PLEDTETableStorage = NULL;
struct header_complex_index *x25PLEDCETableStorage = NULL;
struct header_complex_index *x25PLEDXETableStorage = NULL;
struct header_complex_index *x25PLEIVMODTETableStorage = NULL;
struct header_complex_index *x25PLEIVMODCETableStorage = NULL;
struct header_complex_index *x25PLEIVMODXETableStorage = NULL;
struct header_complex_index *x25VCTableStorage = NULL;
struct header_complex_index *x25VCDTETableStorage = NULL;
struct header_complex_index *x25VCDCETableStorage = NULL;
struct header_complex_index *x25VCDXETableStorage = NULL;
struct header_complex_index *x25PVCDTETableStorage = NULL;
struct header_complex_index *x25PVCDCETableStorage = NULL;
struct header_complex_index *x25PVCDXETableStorage = NULL;
struct header_complex_index *x25SVCIVMOTableStorage = NULL;
struct header_complex_index *x25SVCIVMODTETableStorage = NULL;
struct header_complex_index *x25SVCIVMODXETableStorage = NULL;
struct header_complex_index *x25SVCDTETableStorage = NULL;
struct header_complex_index *x25SVCDCETableStorage = NULL;
struct header_complex_index *x25SVCDXETableStorage = NULL;
struct header_complex_index *x25DSCTableStorage = NULL;
struct header_complex_index *x25PLEDTEStatsTableStorage = NULL;
struct header_complex_index *x25PLEDCEStatsTableStorage = NULL;
struct header_complex_index *x25PLEDXEStatsTableStorage = NULL;

/*
 * init_x25PLPMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_x25PLPMIB(void)
{
	DEBUGMSGTL(("x25PLPMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("x25PLPMIB", x25PLPMIB_variables, variable7, x25PLPMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_x25PLPMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("x25PLPMIB", parse_x25PLPMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLETable", parse_x25PLETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMOTable", parse_x25PLEIVMOTable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25PLEDTETable", parse_x25PLEDTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEDCETable", parse_x25PLEDCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEDXETable", parse_x25PLEDXETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMODTETable", parse_x25PLEIVMODTETable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMODCETable", parse_x25PLEIVMODCETable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25PLEIVMODXETable", parse_x25PLEIVMODXETable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25VCTable", parse_x25VCTable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25VCDTETable", parse_x25VCDTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25VCDCETable", parse_x25VCDCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25VCDXETable", parse_x25VCDXETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PVCDTETable", parse_x25PVCDTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PVCDCETable", parse_x25PVCDCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PVCDXETable", parse_x25PVCDXETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25SVCIVMOTable", parse_x25SVCIVMOTable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25SVCIVMODTETable", parse_x25SVCIVMODTETable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25SVCIVMODXETable", parse_x25SVCIVMODXETable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25SVCDTETable", parse_x25SVCDTETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25SVCDCETable", parse_x25SVCDCETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25SVCDXETable", parse_x25SVCDXETable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25DSCTable", parse_x25DSCTable, NULL, "HELP STRING");
	snmpd_register_config_handler("x25PLEDTEStatsTable", parse_x25PLEDTEStatsTable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25PLEDCEStatsTable", parse_x25PLEDCEStatsTable, NULL,
				      "HELP STRING");
	snmpd_register_config_handler("x25PLEDXEStatsTable", parse_x25PLEDXEStatsTable, NULL,
				      "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLPMIB,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25PLETable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDXETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEIVMODTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEIVMODCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEIVMODXETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25VCTable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25VCDTETable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25VCDCETable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25VCDXETable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PVCDTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PVCDCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PVCDXETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCIVMOTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCIVMODTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCIVMODXETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCDTETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCDCETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25SVCDXETable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_x25DSCTable,
			       NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDTEStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDCEStatsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
			       store_x25PLEDXEStatsTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
}

/*
 * deinit_x25PLPMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_x25PLPMIB(void)
{
	DEBUGMSGTL(("x25PLPMIB", "deinitializating...  "));
	unregister_mib(x25PLPMIB_variables_oid, sizeof(x25PLPMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("x25PLPMIB");
	snmpd_unregister_config_handler("x25PLETable");
	snmpd_unregister_config_handler("x25PLEIVMOTable");
	snmpd_unregister_config_handler("x25PLEDTETable");
	snmpd_unregister_config_handler("x25PLEDCETable");
	snmpd_unregister_config_handler("x25PLEDXETable");
	snmpd_unregister_config_handler("x25PLEIVMODTETable");
	snmpd_unregister_config_handler("x25PLEIVMODCETable");
	snmpd_unregister_config_handler("x25PLEIVMODXETable");
	snmpd_unregister_config_handler("x25VCTable");
	snmpd_unregister_config_handler("x25VCDTETable");
	snmpd_unregister_config_handler("x25VCDCETable");
	snmpd_unregister_config_handler("x25VCDXETable");
	snmpd_unregister_config_handler("x25PVCDTETable");
	snmpd_unregister_config_handler("x25PVCDCETable");
	snmpd_unregister_config_handler("x25PVCDXETable");
	snmpd_unregister_config_handler("x25SVCIVMOTable");
	snmpd_unregister_config_handler("x25SVCIVMODTETable");
	snmpd_unregister_config_handler("x25SVCIVMODXETable");
	snmpd_unregister_config_handler("x25SVCDTETable");
	snmpd_unregister_config_handler("x25SVCDCETable");
	snmpd_unregister_config_handler("x25SVCDXETable");
	snmpd_unregister_config_handler("x25DSCTable");
	snmpd_unregister_config_handler("x25PLEDTEStatsTable");
	snmpd_unregister_config_handler("x25PLEDCEStatsTable");
	snmpd_unregister_config_handler("x25PLEDXEStatsTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
}

int
term_x25PLPMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_x25PLPMIB();
	return 0;
}

/**
 * @fn struct x25PLPMIB_data *x25PLPMIB_create(void)
 * @brief create a fresh data structure representing scalars in x25PLPMIB.
 * Creates a new x25PLPMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in x25PLPMIB.
 */
struct x25PLPMIB_data *
x25PLPMIB_create(void)
{
	struct x25PLPMIB_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLPMIB_data);

	DEBUGMSGTL(("x25PLPMIB", "creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */

	}
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLPMIB_destroy(struct x25PLPMIB_data **thedata)
 * @brief delete a scalars structure from x25PLPMIB.
 * @param thedata pointer to the data structure in x25PLPMIB.
 * Frees scalars that were previously removed from x25PLPMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLPMIB_destroy(struct x25PLPMIB_data **thedata)
{
	struct x25PLPMIB_data *StorageDel;

	DEBUGMSGTL(("x25PLPMIB", "deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLPMIB_add(struct x25PLPMIB_data *thedata)
 * @param thedata the structure representing x25PLPMIB scalars.
 * @brief adds node to the x25PLPMIB scalar data set.
 * Adds a scalar structure to the x25PLPMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
x25PLPMIB_add(struct x25PLPMIB_data *thedata)
{
	DEBUGMSGTL(("x25PLPMIB", "adding data...  "));
	x25PLPMIBStorage = thedata;
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLPMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLPMIB entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLPMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_x25PLPMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLPMIB_data *StorageTmp = x25PLPMIB_create();

	DEBUGMSGTL(("x25PLPMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	x25PLPMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
}

/*
 * store_x25PLPMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_x25PLPMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLPMIB_data *StorageTmp;

	DEBUGMSGTL(("x25PLPMIB", "storing data...  "));
	refresh_x25PLPMIB();
	if ((StorageTmp = x25PLPMIBStorage) == NULL) {
		DEBUGMSGTL(("x25PLPMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "x25PLPMIB ");
		cptr = line + strlen(line);
		/* XXX: remove individual scalars that are not persistent */
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("x25PLPMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_x25PLPMIB(void)
 * @brief refresh the scalar values of x25PLPMIB.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_x25PLPMIB(void)
{
	if (x25PLPMIBStorage == NULL) {
		struct x25PLPMIB_data *StorageNew;

		if ((StorageNew = x25PLPMIB_create()) == NULL)
			return;
		x25PLPMIBStorage = StorageNew;
		x25PLPMIB_refresh = 1;
	}
	if (x25PLPMIB_refresh == 0)
		return;
	x25PLPMIB_refresh = 0;
	/* XXX: Update scalars as required here... */
}

/**
* @fn u_char * var_x25PLPMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
* @param vp a pointer to the entry in the variables table for the requested variable.
* @param name the object identifier for which to find.
* @param length the length of the object identifier.
* @param exact whether the name is exact.
* @param var_len a pointer to the length of the representation of the object.
* @param write_method a pointer to a write method for the object.
* @brief locate variables in x25PLPMIB.
* This function returns a pointer to a memory area that is static across the request that contains
* the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
* GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
* telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
* overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
* writing.  Write-only objects can be effected in this way.
*/
u_char *
var_x25PLPMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
	      WriteMethod ** write_method)
{
	struct x25PLPMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_x25PLPMIB();
	if ((StorageTmp = x25PLPMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn struct x25PLETable_data *x25PLETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLETable table.
 * Creates a new x25PLETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLETable_data *
x25PLETable_create(void)
{
	struct x25PLETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLETable_data);

	DEBUGMSGTL(("x25PLETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLETable_destroy(struct x25PLETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLETable_destroy(struct x25PLETable_data **thedata)
{
	struct x25PLETable_data *StorageDel;

	DEBUGMSGTL(("x25PLETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEProtocolVersionsSupported);
		StorageDel->x25PLEProtocolVersionsSupportedLen = 0;
		SNMP_FREE(StorageDel->x25PLELocalDTEAddress);
		StorageDel->x25PLELocalDTEAddressLen = 0;
		SNMP_FREE(StorageDel->x25PLEFacilityNonNegotiable);
		StorageDel->x25PLEFacilityNonNegotiableLen = 0;
		SNMP_FREE(StorageDel->x25PLEFacilityAvailability);
		StorageDel->x25PLEFacilityAvailabilityLen = 0;
		SNMP_FREE(StorageDel->x25PLEFacilityNegotiation);
		StorageDel->x25PLEFacilityNegotiationLen = 0;
		SNMP_FREE(StorageDel->x25PLEFacilityWhileIdle);
		StorageDel->x25PLEFacilityWhileIdleLen = 0;
		SNMP_FREE(StorageDel->x25PLESNServiceProvider);
		StorageDel->x25PLESNServiceProviderLen = 0;
		SNMP_FREE(StorageDel->x25PLESNSAP);
		StorageDel->x25PLESNSAPLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLETable_add(struct x25PLETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLETable table data set.
 * Adds a table row structure to the x25PLETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLETable_add(struct x25PLETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLETable_del(struct x25PLETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLETable_del(struct x25PLETable_data *thedata)
{
	struct x25PLETable_data *StorageDel;

	DEBUGMSGTL(("x25PLETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLETable_data *StorageTmp = x25PLETable_create();

	DEBUGMSGTL(("x25PLETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEOperationalState, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEAdministrativeState,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->x25PLEProtocolVersionsSupported,
				  &StorageTmp->x25PLEProtocolVersionsSupportedLen);
	if (StorageTmp->x25PLEProtocolVersionsSupported == NULL) {
		config_perror("invalid specification for x25PLEProtocolVersionsSupported");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLELocalDTEAddress,
				  &StorageTmp->x25PLELocalDTEAddressLen);
	if (StorageTmp->x25PLELocalDTEAddress == NULL) {
		config_perror("invalid specification for x25PLELocalDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEInterfaceMode, &tmpsize);
	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->x25PLEFacilityNonNegotiable,
				  &StorageTmp->x25PLEFacilityNonNegotiableLen);
	if (StorageTmp->x25PLEFacilityNonNegotiable == NULL) {
		config_perror("invalid specification for x25PLEFacilityNonNegotiable");
		return;
	}
	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->x25PLEFacilityAvailability,
				  &StorageTmp->x25PLEFacilityAvailabilityLen);
	if (StorageTmp->x25PLEFacilityAvailability == NULL) {
		config_perror("invalid specification for x25PLEFacilityAvailability");
		return;
	}
	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->x25PLEFacilityNegotiation,
				  &StorageTmp->x25PLEFacilityNegotiationLen);
	if (StorageTmp->x25PLEFacilityNegotiation == NULL) {
		config_perror("invalid specification for x25PLEFacilityNegotiation");
		return;
	}
	line =
	    read_config_read_data(ASN_BIT_STR, line, &StorageTmp->x25PLEFacilityWhileIdle,
				  &StorageTmp->x25PLEFacilityWhileIdleLen);
	if (StorageTmp->x25PLEFacilityWhileIdle == NULL) {
		config_perror("invalid specification for x25PLEFacilityWhileIdle");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEPacketSequenceNumbering,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDefaultPacketSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDefaultPacketSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDefaultWindowSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDefaultWindowSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDefaultThroughputClassIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDefaultThroughputClassOutgoing, &tmpsize);
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLESNServiceProvider,
				  &StorageTmp->x25PLESNServiceProviderLen);
	if (StorageTmp->x25PLESNServiceProvider == NULL) {
		config_perror("invalid specification for x25PLESNServiceProvider");
		return;
	}
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLESNSAP,
				  &StorageTmp->x25PLESNSAPLen);
	if (StorageTmp->x25PLESNSAP == NULL) {
		config_perror("invalid specification for x25PLESNSAP");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentHIC,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentLIC,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentHTC,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentLTC,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentHOC,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLELogicalChannelAssignmentLOC,
				  &tmpsize);
	x25PLETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLETable", "done.\n"));
}

/*
 * store_x25PLETable(): store configuraiton file for x25PLETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLETable", "storing data...  "));
	refresh_x25PLETable();
	(void) tmpsize;
	for (hcindex = x25PLETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEOperationalState, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEAdministrativeState,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_BIT_STR, cptr,
						   &StorageTmp->x25PLEProtocolVersionsSupported,
						   &StorageTmp->x25PLEProtocolVersionsSupportedLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr,
						   &StorageTmp->x25PLELocalDTEAddress,
						   &StorageTmp->x25PLELocalDTEAddressLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEInterfaceMode, &tmpsize);
			cptr =
			    read_config_store_data(ASN_BIT_STR, cptr,
						   &StorageTmp->x25PLEFacilityNonNegotiable,
						   &StorageTmp->x25PLEFacilityNonNegotiableLen);
			cptr =
			    read_config_store_data(ASN_BIT_STR, cptr,
						   &StorageTmp->x25PLEFacilityAvailability,
						   &StorageTmp->x25PLEFacilityAvailabilityLen);
			cptr =
			    read_config_store_data(ASN_BIT_STR, cptr,
						   &StorageTmp->x25PLEFacilityNegotiation,
						   &StorageTmp->x25PLEFacilityNegotiationLen);
			cptr =
			    read_config_store_data(ASN_BIT_STR, cptr,
						   &StorageTmp->x25PLEFacilityWhileIdle,
						   &StorageTmp->x25PLEFacilityWhileIdleLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEPacketSequenceNumbering,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDefaultPacketSizeIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDefaultPacketSizeOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDefaultWindowSizeIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDefaultWindowSizeOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDefaultThroughputClassIncoming, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDefaultThroughputClassOutgoing, &tmpsize);
			cptr =
			    read_config_store_data(ASN_OBJECT_ID, cptr,
						   &StorageTmp->x25PLESNServiceProvider,
						   &StorageTmp->x25PLESNServiceProviderLen);
			cptr =
			    read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->x25PLESNSAP,
						   &StorageTmp->x25PLESNSAPLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLELogicalChannelAssignmentHIC,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLELogicalChannelAssignmentLIC,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLELogicalChannelAssignmentHTC,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLELogicalChannelAssignmentLTC,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLELogicalChannelAssignmentHOC,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLELogicalChannelAssignmentLOC,
						   &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEIVMOTable_data *x25PLEIVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEIVMOTable table.
 * Creates a new x25PLEIVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEIVMOTable_data *
x25PLEIVMOTable_create(void)
{
	struct x25PLEIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMOTable_data);

	DEBUGMSGTL(("x25PLEIVMOTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLEIVMODefaultThroughputClassIncoming = none(0);
		StorageNew->x25PLEIVMODefaultThroughputClassOutgoing = none(0);
		StorageNew->x25PLEIVMOThroughputClassNegotiation = notsubscribed(2);

	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEIVMOTable_destroy(struct x25PLEIVMOTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEIVMOTable_destroy(struct x25PLEIVMOTable_data **thedata)
{
	struct x25PLEIVMOTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMOTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOLocalDTEAddress);
		StorageDel->x25PLEIVMOLocalDTEAddressLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOSNServiceProvider);
		StorageDel->x25PLEIVMOSNServiceProviderLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMOTable_add(struct x25PLEIVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEIVMOTable table data set.
 * Adds a table row structure to the x25PLEIVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEIVMOTable_add(struct x25PLEIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId,
				  thedata->x25PLEIVMOIdLen);
	header_complex_add_data(&x25PLEIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMOTable_del(struct x25PLEIVMOTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEIVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEIVMOTable_del(struct x25PLEIVMOTable_data *thedata)
{
	struct x25PLEIVMOTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMOTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr =
		     header_complex_find_entry(x25PLEIVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEIVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEIVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEIVMOTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEIVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMOTable_data *StorageTmp = x25PLEIVMOTable_create();

	DEBUGMSGTL(("x25PLEIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId,
				  &StorageTmp->x25PLEIVMOIdLen);
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMOInterfaceMode,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultPacketSizeIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultThroughputClassIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultWindowSizeIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOFlowControlParameterNegotiation, &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOLocalDTEAddress,
				  &StorageTmp->x25PLEIVMOLocalDTEAddressLen);
	if (StorageTmp->x25PLEIVMOLocalDTEAddress == NULL) {
		config_perror("invalid specification for x25PLEIVMOLocalDTEAddress");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC, &tmpsize);
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLEIVMOSNServiceProvider,
				  &StorageTmp->x25PLEIVMOSNServiceProviderLen);
	if (StorageTmp->x25PLEIVMOSNServiceProvider == NULL) {
		config_perror("invalid specification for x25PLEIVMOSNServiceProvider");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMOThroughputClassNegotiation, &tmpsize);
	x25PLEIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
}

/*
 * store_x25PLEIVMOTable(): store configuraiton file for x25PLEIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMOTable", "storing data...  "));
	refresh_x25PLEIVMOTable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMOTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId,
						   &StorageTmp->x25PLEIVMOIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMOInterfaceMode, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODefaultPacketSizeIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMODefaultThroughputClassIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMODefaultThroughputClassOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODefaultWindowSizeIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMOFlowControlParameterNegotiation,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr,
						   &StorageTmp->x25PLEIVMOLocalDTEAddress,
						   &StorageTmp->x25PLEIVMOLocalDTEAddressLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMOLogicalChannelAssignmentHPC, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMOLogicalChannelAssignmentLPC, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMOLogicalChannelAssignmentHIC, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMOLogicalChannelAssignmentLIC, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMOLogicalChannelAssignmentHTC, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMOLogicalChannelAssignmentLTC, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMOLogicalChannelAssignmentHOC, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMOLogicalChannelAssignmentLOC, &tmpsize);
			cptr =
			    read_config_store_data(ASN_OBJECT_ID, cptr,
						   &StorageTmp->x25PLEIVMOSNServiceProvider,
						   &StorageTmp->x25PLEIVMOSNServiceProviderLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMOThroughputClassNegotiation, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEDTETable_data *x25PLEDTETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEDTETable table.
 * Creates a new x25PLEDTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEDTETable_data *
x25PLEDTETable_create(void)
{
	struct x25PLEDTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEDTETable_data);

	DEBUGMSGTL(("x25PLEDTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLEDTEPacketSequencing = 1;
		StorageNew->x25PLEDTERestartTime = 18000;
		StorageNew->x25PLEDTERestartCount = 1;
		StorageNew->x25PLEDTERegistrationTime = 30000;
		StorageNew->x25PLEDTERegistrationCount = 1;
		StorageNew->x25PLEDTERegistrationPermitted = 2;
		StorageNew->x25PLEDTERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PLEDTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEDTETable_destroy(struct x25PLEDTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEDTETable_destroy(struct x25PLEDTETable_data **thedata)
{
	struct x25PLEDTETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEDTEProfile);
		StorageDel->x25PLEDTEProfileLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDTETable_add(struct x25PLEDTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEDTETable table data set.
 * Adds a table row structure to the x25PLEDTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEDTETable_add(struct x25PLEDTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLEDTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDTETable_del(struct x25PLEDTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEDTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEDTETable_del(struct x25PLEDTETable_data *thedata)
{
	struct x25PLEDTETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLEDTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEDTETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEDTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEDTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEDTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEDTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDTETable_data *StorageTmp = x25PLEDTETable_create();

	DEBUGMSGTL(("x25PLEDTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTEPacketSequencing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTEMaxActiveCircuits,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDTECallDeflectionSubscription, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERestartTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERestartCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTEMinimumRecallTimer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERegistrationTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERegistrationCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERegistrationPermitted,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLEDTEProfile,
				  &StorageTmp->x25PLEDTEProfileLen);
	if (StorageTmp->x25PLEDTEProfile == NULL) {
		config_perror("invalid specification for x25PLEDTEProfile");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDTERowStatus, &tmpsize);
	x25PLEDTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDTETable", "done.\n"));
}

/*
 * store_x25PLEDTETable(): store configuraiton file for x25PLEDTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDTETable", "storing data...  "));
	refresh_x25PLEDTETable();
	(void) tmpsize;
	for (hcindex = x25PLEDTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEDTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDTEPacketSequencing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDTEMaxActiveCircuits,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDTECallDeflectionSubscription,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDTERestartTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDTERestartCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDTEMinimumRecallTimer,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDTERegistrationTime,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDTERegistrationCount,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDTERegistrationPermitted,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_OBJECT_ID, cptr,
						   &StorageTmp->x25PLEDTEProfile,
						   &StorageTmp->x25PLEDTEProfileLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEDCETable_data *x25PLEDCETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEDCETable table.
 * Creates a new x25PLEDCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEDCETable_data *
x25PLEDCETable_create(void)
{
	struct x25PLEDCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEDCETable_data);

	DEBUGMSGTL(("x25PLEDCETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLEDCERestartIndication = 6000;
		StorageNew->x25PLEDCERestartCount = 1;
		StorageNew->x25PLEDCEIncomingCall = 18000;
		StorageNew->x25PLEDCEResetCount = 1;
		StorageNew->x25PLEDCEClearIndication = 6000;
		StorageNew->x25PLEDCEClearCount = 1;
		StorageNew->x25PLEDCERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PLEDCETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEDCETable_destroy(struct x25PLEDCETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEDCETable_destroy(struct x25PLEDCETable_data **thedata)
{
	struct x25PLEDCETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDCETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEDCEDefaultThroughputClassSupported);
		StorageDel->x25PLEDCEDefaultThroughputClassSupportedLen = 0;
		SNMP_FREE(StorageDel->x25PLEDCEProfile);
		StorageDel->x25PLEDCEProfileLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDCETable_add(struct x25PLEDCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEDCETable table data set.
 * Adds a table row structure to the x25PLEDCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEDCETable_add(struct x25PLEDCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLEDCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDCETable_del(struct x25PLEDCETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEDCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEDCETable_del(struct x25PLEDCETable_data *thedata)
{
	struct x25PLEDCETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDCETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLEDCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEDCETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEDCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEDCETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEDCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEDCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDCETable_data *StorageTmp = x25PLEDCETable_create();

	DEBUGMSGTL(("x25PLEDCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEPacketSequencing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCECallDeflectionSubscription, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCECUG, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEFastSelectAcceptance,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEIncomingCallsBarred,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEOutgoingCallsBarred,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEBilateralCUG, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCECallRedirection,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEChargingInformation,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCECUGWithIncomingAccess,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCECUGWithOutgoingAccess,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEDBitModification,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEDefaultThroughputClassSubscription,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_BIT_STR, line,
				  &StorageTmp->x25PLEDCEDefaultThroughputClassSupported,
				  &StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen);
	if (StorageTmp->x25PLEDCEDefaultThroughputClassSupported == NULL) {
		config_perror("invalid specification for x25PLEDCEDefaultThroughputClassSupported");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEDefaultThroughputClassIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEHuntGroup, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCELocalChargingPrevention,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCENUIOverride, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCENUISubscription,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEOnlineFacilityRegistration, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEPacketRetransmission,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDCEReverseChargingAcceptance, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEROASubscription,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCERestartIndication,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCERestartCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEIncomingCall, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCECallCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEResetIndication,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEResetCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEClearIndication,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCEClearCount, &tmpsize);
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLEDCEProfile,
				  &StorageTmp->x25PLEDCEProfileLen);
	if (StorageTmp->x25PLEDCEProfile == NULL) {
		config_perror("invalid specification for x25PLEDCEProfile");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDCERowStatus, &tmpsize);
	x25PLEDCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDCETable", "done.\n"));
}

/*
 * store_x25PLEDCETable(): store configuraiton file for x25PLEDCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDCETable", "storing data...  "));
	refresh_x25PLEDCETable();
	(void) tmpsize;
	for (hcindex = x25PLEDCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEDCETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEPacketSequencing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCECallDeflectionSubscription,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->x25PLEDCECUG,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEFastSelectAcceptance,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEIncomingCallsBarred,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCEOneWayLogicalChannelOutgoing, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEOutgoingCallsBarred,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEBilateralCUG, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCEBilateralCUGWithOutgoingAccess,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCECallRedirection, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEChargingInformation,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCECUGWithIncomingAccess,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCECUGWithOutgoingAccess,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEDBitModification,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCEDefaultThroughputClassSubscription,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_BIT_STR, cptr,
						   &StorageTmp->
						   x25PLEDCEDefaultThroughputClassSupported,
						   &StorageTmp->
						   x25PLEDCEDefaultThroughputClassSupportedLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCEDefaultThroughputClassIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCEDefaultThroughputClassOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEHuntGroup, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCEIncomingCallBarredWithinCUG, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCELocalChargingPrevention,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCENonStandardDefaultPacketSizeSubscription,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCENonStandardDefaultPacketSizeMaximum,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCENonStandardDefaultPacketSizeIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCENonStandardDefaultPacketSizeOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCENonStandardDefaultWindowSizeSubscription,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCENonStandardDefaultWindowSizeMaximum,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCENonStandardDefaultWindowSizeIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCENonStandardDefaultWindowSizeOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCENUIOverride, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCENUISubscription, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCEOneWayLogicalChannelIncoming, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEOnlineFacilityRegistration,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEDCEOutgoingCallBarredWithinCUG, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEPacketRetransmission,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEReverseChargingAcceptance,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEROASubscription, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCERestartIndication,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCERestartCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEIncomingCall, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCECallCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEResetIndication, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEResetCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEClearIndication, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCEClearCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_OBJECT_ID, cptr,
						   &StorageTmp->x25PLEDCEProfile,
						   &StorageTmp->x25PLEDCEProfileLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEDXETable_data *x25PLEDXETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEDXETable table.
 * Creates a new x25PLEDXETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEDXETable_data *
x25PLEDXETable_create(void)
{
	struct x25PLEDXETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEDXETable_data);

	DEBUGMSGTL(("x25PLEDXETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLEDXERestartTime = 18000;
		StorageNew->x25PLEDXERegistrationTime = 30000;
		StorageNew->x25PLEDXERegistrationCount = 1;
		StorageNew->x25PLEDXERegistrationPermitted = 2;
		StorageNew->x25PLEDXERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PLEDXETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEDXETable_destroy(struct x25PLEDXETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEDXETable_destroy(struct x25PLEDXETable_data **thedata)
{
	struct x25PLEDXETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDXETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEDXEPLEClientMOName);
		StorageDel->x25PLEDXEPLEClientMONameLen = 0;
		SNMP_FREE(StorageDel->x25PLEDXEProfile);
		StorageDel->x25PLEDXEProfileLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDXETable_add(struct x25PLEDXETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEDXETable table data set.
 * Adds a table row structure to the x25PLEDXETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEDXETable_add(struct x25PLEDXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLEDXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDXETable_del(struct x25PLEDXETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEDXETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEDXETable_del(struct x25PLEDXETable_data *thedata)
{
	struct x25PLEDXETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDXETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PLEDXETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEDXETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEDXETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEDXETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEDXETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEDXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDXETable_data *StorageTmp = x25PLEDXETable_create();

	DEBUGMSGTL(("x25PLEDXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXEPacketSequencing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXEMaxActiveCircuits,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEDXECallDeflectionSubscription, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERestartTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERestartCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXEMinimumRecallTimer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERegistrationTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERegistrationCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERegistrationPermitted,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLEDXEPLEClientMOName,
				  &StorageTmp->x25PLEDXEPLEClientMONameLen);
	if (StorageTmp->x25PLEDXEPLEClientMOName == NULL) {
		config_perror("invalid specification for x25PLEDXEPLEClientMOName");
		return;
	}
	line =
	    read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->x25PLEDXEProfile,
				  &StorageTmp->x25PLEDXEProfileLen);
	if (StorageTmp->x25PLEDXEProfile == NULL) {
		config_perror("invalid specification for x25PLEDXEProfile");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEDXERowStatus, &tmpsize);
	x25PLEDXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDXETable", "done.\n"));
}

/*
 * store_x25PLEDXETable(): store configuraiton file for x25PLEDXETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDXETable", "storing data...  "));
	refresh_x25PLEDXETable();
	(void) tmpsize;
	for (hcindex = x25PLEDXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDXETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEDXETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDXEPacketSequencing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDXEMaxActiveCircuits,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDXECallDeflectionSubscription,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDXERestartTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDXERestartCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDXEMinimumRecallTimer,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDXERegistrationTime,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDXERegistrationCount,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDXERegistrationPermitted,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_OBJECT_ID, cptr,
						   &StorageTmp->x25PLEDXEPLEClientMOName,
						   &StorageTmp->x25PLEDXEPLEClientMONameLen);
			cptr =
			    read_config_store_data(ASN_OBJECT_ID, cptr,
						   &StorageTmp->x25PLEDXEProfile,
						   &StorageTmp->x25PLEDXEProfileLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEDXERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEIVMODTETable_data *x25PLEIVMODTETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEIVMODTETable table.
 * Creates a new x25PLEIVMODTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEIVMODTETable_data *
x25PLEIVMODTETable_create(void)
{
	struct x25PLEIVMODTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMODTETable_data);

	DEBUGMSGTL(("x25PLEIVMODTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLEIVMODTERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PLEIVMODTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEIVMODTETable_destroy(struct x25PLEIVMODTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEIVMODTETable_destroy(struct x25PLEIVMODTETable_data **thedata)
{
	struct x25PLEIVMODTETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMODTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMODTETable_add(struct x25PLEIVMODTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEIVMODTETable table data set.
 * Adds a table row structure to the x25PLEIVMODTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEIVMODTETable_add(struct x25PLEIVMODTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMODTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId,
				  thedata->x25PLEIVMOIdLen);
	header_complex_add_data(&x25PLEIVMODTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMODTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMODTETable_del(struct x25PLEIVMODTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEIVMODTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEIVMODTETable_del(struct x25PLEIVMODTETable_data *thedata)
{
	struct x25PLEIVMODTETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMODTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr =
		     header_complex_find_entry(x25PLEIVMODTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEIVMODTETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEIVMODTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEIVMODTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEIVMODTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEIVMODTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMODTETable_data *StorageTmp = x25PLEIVMODTETable_create();

	DEBUGMSGTL(("x25PLEIVMODTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId,
				  &StorageTmp->x25PLEIVMOIdLen);
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODTECallDeflectionSubscription, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTECallTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEClearTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEClearCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEPacketSequencing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEInterruptTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEMaxActiveCircuits,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEMinimumRecallTimer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEResetTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEResetCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERestartTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERestartCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEWindowTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEDataTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEDataCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERejectTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERejectCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERegistrationTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERegistrationCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODTERegistrationPermitted, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERowStatus, &tmpsize);
	x25PLEIVMODTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMODTETable", "done.\n"));
}

/*
 * store_x25PLEIVMODTETable(): store configuraiton file for x25PLEIVMODTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMODTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMODTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMODTETable", "storing data...  "));
	refresh_x25PLEIVMODTETable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMODTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMODTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMODTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId,
						   &StorageTmp->x25PLEIVMOIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMODTECallDeflectionSubscription,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTECallTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEClearTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEClearCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEPacketSequencing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEInterruptTime,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEMaxActiveCircuits,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEMinimumRecallTimer,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEResetTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEResetCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERestartTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERestartCount,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEWindowTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEDataTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEDataCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERejectTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERejectCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERegistrationTime,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERegistrationCount,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERegistrationPermitted,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEIVMODCETable_data *x25PLEIVMODCETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEIVMODCETable table.
 * Creates a new x25PLEIVMODCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEIVMODCETable_data *
x25PLEIVMODCETable_create(void)
{
	struct x25PLEIVMODCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMODCETable_data);

	DEBUGMSGTL(("x25PLEIVMODCETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PLEIVMODCERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PLEIVMODCETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEIVMODCETable_destroy(struct x25PLEIVMODCETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEIVMODCETable_destroy(struct x25PLEIVMODCETable_data **thedata)
{
	struct x25PLEIVMODCETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMODCETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEIVMODCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMODCETable_add(struct x25PLEIVMODCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEIVMODCETable table data set.
 * Adds a table row structure to the x25PLEIVMODCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEIVMODCETable_add(struct x25PLEIVMODCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMODCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId,
				  thedata->x25PLEIVMOIdLen);
	header_complex_add_data(&x25PLEIVMODCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMODCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMODCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMODCETable_del(struct x25PLEIVMODCETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEIVMODCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEIVMODCETable_del(struct x25PLEIVMODCETable_data *thedata)
{
	struct x25PLEIVMODCETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMODCETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr =
		     header_complex_find_entry(x25PLEIVMODCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEIVMODCETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEIVMODCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEIVMODCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEIVMODCETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEIVMODCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEIVMODCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMODCETable_data *StorageTmp = x25PLEIVMODCETable_create();

	DEBUGMSGTL(("x25PLEIVMODCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId,
				  &StorageTmp->x25PLEIVMOIdLen);
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODCERowStatus, &tmpsize);
	x25PLEIVMODCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMODCETable", "done.\n"));
}

/*
 * store_x25PLEIVMODCETable(): store configuraiton file for x25PLEIVMODCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMODCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMODCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMODCETable", "storing data...  "));
	refresh_x25PLEIVMODCETable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMODCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMODCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMODCETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId,
						   &StorageTmp->x25PLEIVMOIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEIVMODCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEIVMODXETable_data *x25PLEIVMODXETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEIVMODXETable table.
 * Creates a new x25PLEIVMODXETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEIVMODXETable_data *
x25PLEIVMODXETable_create(void)
{
	struct x25PLEIVMODXETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEIVMODXETable_data);

	DEBUGMSGTL(("x25PLEIVMODXETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25PLEIVMODXETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEIVMODXETable_destroy(struct x25PLEIVMODXETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEIVMODXETable_destroy(struct x25PLEIVMODXETable_data **thedata)
{
	struct x25PLEIVMODXETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMODXETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25PLEIVMOId);
		StorageDel->x25PLEIVMOIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMODXETable_add(struct x25PLEIVMODXETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEIVMODXETable table data set.
 * Adds a table row structure to the x25PLEIVMODXETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEIVMODXETable_add(struct x25PLEIVMODXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEIVMODXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25PLEIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEIVMOId,
				  thedata->x25PLEIVMOIdLen);
	header_complex_add_data(&x25PLEIVMODXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEIVMODXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEIVMODXETable_del(struct x25PLEIVMODXETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEIVMODXETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEIVMODXETable_del(struct x25PLEIVMODXETable_data *thedata)
{
	struct x25PLEIVMODXETable_data *StorageDel;

	DEBUGMSGTL(("x25PLEIVMODXETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr =
		     header_complex_find_entry(x25PLEIVMODXETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEIVMODXETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEIVMODXETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEIVMODXETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEIVMODXETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEIVMODXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEIVMODXETable_data *StorageTmp = x25PLEIVMODXETable_create();

	DEBUGMSGTL(("x25PLEIVMODXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEIVMOId,
				  &StorageTmp->x25PLEIVMOIdLen);
	if (StorageTmp->x25PLEIVMOId == NULL) {
		config_perror("invalid specification for x25PLEIVMOId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODTECallDeflectionSubscription, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEMaxActiveCircuits,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERestartTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEMinimumRecallTimer,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERestartCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTEPacketSequencing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERegistrationTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PLEIVMODTERegistrationCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25PLEIVMODTERegistrationPermitted, &tmpsize);
	x25PLEIVMODXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEIVMODXETable", "done.\n"));
}

/*
 * store_x25PLEIVMODXETable(): store configuraiton file for x25PLEIVMODXETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEIVMODXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEIVMODXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEIVMODXETable", "storing data...  "));
	refresh_x25PLEIVMODXETable();
	(void) tmpsize;
	for (hcindex = x25PLEIVMODXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEIVMODXETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEIVMODXETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEIVMOId,
						   &StorageTmp->x25PLEIVMOIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25PLEIVMODTECallDeflectionSubscription,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEMaxActiveCircuits,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERestartTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEMinimumRecallTimer,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERestartCount,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTEPacketSequencing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERegistrationTime,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERegistrationCount,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PLEIVMODTERegistrationPermitted,
						   &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25VCTable_data *x25VCTable_create(void)
 * @brief create a fresh data structure representing a new row in the x25VCTable table.
 * Creates a new x25VCTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25VCTable_data *
x25VCTable_create(void)
{
	struct x25VCTable_data *StorageNew = SNMP_MALLOC_STRUCT(x25VCTable_data);

	DEBUGMSGTL(("x25VCTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25VCTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25VCTable_destroy(struct x25VCTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25VCTable_destroy(struct x25VCTable_data **thedata)
{
	struct x25VCTable_data *StorageDel;

	DEBUGMSGTL(("x25VCTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25VCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25VCTable_add(struct x25VCTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25VCTable table data set.
 * Adds a table row structure to the x25VCTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25VCTable_add(struct x25VCTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25VCTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	header_complex_add_data(&x25VCTableStorage, vars, thedata);
	DEBUGMSGTL(("x25VCTable", "registered an entry\n"));
	DEBUGMSGTL(("x25VCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25VCTable_del(struct x25VCTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25VCTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25VCTable_del(struct x25VCTable_data *thedata)
{
	struct x25VCTable_data *StorageDel;

	DEBUGMSGTL(("x25VCTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25VCTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25VCTableStorage, hciptr);
	}
	DEBUGMSGTL(("x25VCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25VCTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25VCTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25VCTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25VCTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25VCTable_data *StorageTmp = x25VCTable_create();

	DEBUGMSGTL(("x25VCTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCLogicalChannel, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCPacketSequencing, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCPacketSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCPacketSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCWindowSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCWindowSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCThroughputClassIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25VCThroughputClassOutgoing,
				  &tmpsize);
	x25VCTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25VCTable", "done.\n"));
}

/*
 * store_x25VCTable(): store configuraiton file for x25VCTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25VCTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25VCTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25VCTable", "storing data...  "));
	refresh_x25VCTable();
	(void) tmpsize;
	for (hcindex = x25VCTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25VCTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25VCTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25VCLogicalChannel, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25VCPacketSequencing, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25VCPacketSizeIncoming, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25VCPacketSizeOutgoing, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25VCWindowSizeIncoming, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25VCWindowSizeOutgoing, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25VCThroughputClassIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25VCThroughputClassOutgoing,
						   &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25VCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25VCDTETable_data *x25VCDTETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25VCDTETable table.
 * Creates a new x25VCDTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25VCDTETable_data *
x25VCDTETable_create(void)
{
	struct x25VCDTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25VCDTETable_data);

	DEBUGMSGTL(("x25VCDTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25VCDTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25VCDTETable_destroy(struct x25VCDTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25VCDTETable_destroy(struct x25VCDTETable_data **thedata)
{
	struct x25VCDTETable_data *StorageDel;

	DEBUGMSGTL(("x25VCDTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25VCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25VCDTETable_add(struct x25VCDTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25VCDTETable table data set.
 * Adds a table row structure to the x25VCDTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25VCDTETable_add(struct x25VCDTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25VCDTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	header_complex_add_data(&x25VCDTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25VCDTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25VCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25VCDTETable_del(struct x25VCDTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25VCDTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25VCDTETable_del(struct x25VCDTETable_data *thedata)
{
	struct x25VCDTETable_data *StorageDel;

	DEBUGMSGTL(("x25VCDTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25VCDTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25VCDTETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25VCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25VCDTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25VCDTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25VCDTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25VCDTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25VCDTETable_data *StorageTmp = x25VCDTETable_create();

	DEBUGMSGTL(("x25VCDTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEOctetsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEDataPacketsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEDataTimeouts, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25VCDTEInterruptPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEInterruptPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEInterruptTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTERemoteResets, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDTEResetTimeouts,
				  &tmpsize);
	x25VCDTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25VCDTETable", "done.\n"));
}

/*
 * store_x25VCDTETable(): store configuraiton file for x25VCDTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25VCDTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25VCDTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25VCDTETable", "storing data...  "));
	refresh_x25VCDTETable();
	(void) tmpsize;
	for (hcindex = x25VCDTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25VCDTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25VCDTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTEOctetsReceived, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTEOctetsSent, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTEDataPacketsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTEDataPacketsSent, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTEDataTimeouts, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTEInterruptPacketsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTEInterruptPacketsSent,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTEInterruptTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTEProviderResets, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTERemoteResets, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDTEResetTimeouts, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25VCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25VCDCETable_data *x25VCDCETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25VCDCETable table.
 * Creates a new x25VCDCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25VCDCETable_data *
x25VCDCETable_create(void)
{
	struct x25VCDCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25VCDCETable_data);

	DEBUGMSGTL(("x25VCDCETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25VCDCETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25VCDCETable_destroy(struct x25VCDCETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25VCDCETable_destroy(struct x25VCDCETable_data **thedata)
{
	struct x25VCDCETable_data *StorageDel;

	DEBUGMSGTL(("x25VCDCETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25VCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25VCDCETable_add(struct x25VCDCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25VCDCETable table data set.
 * Adds a table row structure to the x25VCDCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25VCDCETable_add(struct x25VCDCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25VCDCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	header_complex_add_data(&x25VCDCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25VCDCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25VCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25VCDCETable_del(struct x25VCDCETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25VCDCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25VCDCETable_del(struct x25VCDCETable_data *thedata)
{
	struct x25VCDCETable_data *StorageDel;

	DEBUGMSGTL(("x25VCDCETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25VCDCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25VCDCETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25VCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25VCDCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25VCDCETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25VCDCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25VCDCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25VCDCETable_data *StorageTmp = x25VCDCETable_create();

	DEBUGMSGTL(("x25VCDCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEOctetsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEDataPacketsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25VCDCEInterruptPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEInterruptPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCERemoteResets, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEResetTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCERemoteRestarts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEProviderDisconnects,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEX25SegmentsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDCEX25SegmentsSent,
				  &tmpsize);
	x25VCDCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25VCDCETable", "done.\n"));
}

/*
 * store_x25VCDCETable(): store configuraiton file for x25VCDCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25VCDCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25VCDCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25VCDCETable", "storing data...  "));
	refresh_x25VCDCETable();
	(void) tmpsize;
	for (hcindex = x25VCDCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25VCDCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25VCDCETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEOctetsReceived, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEOctetsSent, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEDataPacketsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEDataPacketsSent, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEInterruptPacketsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEInterruptPacketsSent,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEProviderResets, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCERemoteResets, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEResetTimeouts, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCERemoteRestarts, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEProviderDisconnects,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEX25SegmentsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDCEX25SegmentsSent, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25VCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25VCDXETable_data *x25VCDXETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25VCDXETable table.
 * Creates a new x25VCDXETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25VCDXETable_data *
x25VCDXETable_create(void)
{
	struct x25VCDXETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25VCDXETable_data);

	DEBUGMSGTL(("x25VCDXETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25VCDXETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25VCDXETable_destroy(struct x25VCDXETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25VCDXETable_destroy(struct x25VCDXETable_data **thedata)
{
	struct x25VCDXETable_data *StorageDel;

	DEBUGMSGTL(("x25VCDXETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25VCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25VCDXETable_add(struct x25VCDXETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25VCDXETable table data set.
 * Adds a table row structure to the x25VCDXETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25VCDXETable_add(struct x25VCDXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25VCDXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	header_complex_add_data(&x25VCDXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25VCDXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25VCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25VCDXETable_del(struct x25VCDXETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25VCDXETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25VCDXETable_del(struct x25VCDXETable_data *thedata)
{
	struct x25VCDXETable_data *StorageDel;

	DEBUGMSGTL(("x25VCDXETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25VCDXETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25VCDXETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25VCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25VCDXETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25VCDXETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25VCDXETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25VCDXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25VCDXETable_data *StorageTmp = x25VCDXETable_create();

	DEBUGMSGTL(("x25VCDXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEOctetsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEDataPacketsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEDataTimeouts, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25VCDXEInterruptPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEInterruptPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEInterruptTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXERemoteResets, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25VCDXEResetTimeouts,
				  &tmpsize);
	x25VCDXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25VCDXETable", "done.\n"));
}

/*
 * store_x25VCDXETable(): store configuraiton file for x25VCDXETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25VCDXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25VCDXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25VCDXETable", "storing data...  "));
	refresh_x25VCDXETable();
	(void) tmpsize;
	for (hcindex = x25VCDXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25VCDXETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25VCDXETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXEOctetsReceived, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXEOctetsSent, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXEDataPacketsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXEDataPacketsSent, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXEDataTimeouts, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXEInterruptPacketsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXEInterruptPacketsSent,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXEInterruptTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXEProviderResets, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXERemoteResets, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25VCDXEResetTimeouts, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25VCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PVCDTETable_data *x25PVCDTETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PVCDTETable table.
 * Creates a new x25PVCDTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PVCDTETable_data *
x25PVCDTETable_create(void)
{
	struct x25PVCDTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PVCDTETable_data);

	DEBUGMSGTL(("x25PVCDTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PVCDTERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PVCDTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PVCDTETable_destroy(struct x25PVCDTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PVCDTETable_destroy(struct x25PVCDTETable_data **thedata)
{
	struct x25PVCDTETable_data *StorageDel;

	DEBUGMSGTL(("x25PVCDTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PVCDTETable_add(struct x25PVCDTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PVCDTETable table data set.
 * Adds a table row structure to the x25PVCDTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PVCDTETable_add(struct x25PVCDTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PVCDTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	header_complex_add_data(&x25PVCDTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PVCDTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PVCDTETable_del(struct x25PVCDTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PVCDTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PVCDTETable_del(struct x25PVCDTETable_data *thedata)
{
	struct x25PVCDTETable_data *StorageDel;

	DEBUGMSGTL(("x25PVCDTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PVCDTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PVCDTETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PVCDTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PVCDTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PVCDTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PVCDTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PVCDTETable_data *StorageTmp = x25PVCDTETable_create();

	DEBUGMSGTL(("x25PVCDTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDTELogicalChannel,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDTERowStatus, &tmpsize);
	x25PVCDTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PVCDTETable", "done.\n"));
}

/*
 * store_x25PVCDTETable(): store configuraiton file for x25PVCDTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PVCDTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PVCDTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PVCDTETable", "storing data...  "));
	refresh_x25PVCDTETable();
	(void) tmpsize;
	for (hcindex = x25PVCDTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PVCDTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PVCDTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PVCDTELogicalChannel, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PVCDTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PVCDCETable_data *x25PVCDCETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PVCDCETable table.
 * Creates a new x25PVCDCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PVCDCETable_data *
x25PVCDCETable_create(void)
{
	struct x25PVCDCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PVCDCETable_data);

	DEBUGMSGTL(("x25PVCDCETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PVCDCERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PVCDCETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PVCDCETable_destroy(struct x25PVCDCETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PVCDCETable_destroy(struct x25PVCDCETable_data **thedata)
{
	struct x25PVCDCETable_data *StorageDel;

	DEBUGMSGTL(("x25PVCDCETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel->x25PVCDCERemoteDTEAddress);
		StorageDel->x25PVCDCERemoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PVCDCETable_add(struct x25PVCDCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PVCDCETable table data set.
 * Adds a table row structure to the x25PVCDCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PVCDCETable_add(struct x25PVCDCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PVCDCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	header_complex_add_data(&x25PVCDCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PVCDCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PVCDCETable_del(struct x25PVCDCETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PVCDCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PVCDCETable_del(struct x25PVCDCETable_data *thedata)
{
	struct x25PVCDCETable_data *StorageDel;

	DEBUGMSGTL(("x25PVCDCETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PVCDCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PVCDCETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PVCDCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PVCDCETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PVCDCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PVCDCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PVCDCETable_data *StorageTmp = x25PVCDCETable_create();

	DEBUGMSGTL(("x25PVCDCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDCELogicalChannel,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDCEChargingDirection,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDCEOperationalState,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PVCDCERemoteDTEAddress,
				  &StorageTmp->x25PVCDCERemoteDTEAddressLen);
	if (StorageTmp->x25PVCDCERemoteDTEAddress == NULL) {
		config_perror("invalid specification for x25PVCDCERemoteDTEAddress");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDCERemoteLogicalChannel,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDCERowStatus, &tmpsize);
	x25PVCDCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PVCDCETable", "done.\n"));
}

/*
 * store_x25PVCDCETable(): store configuraiton file for x25PVCDCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PVCDCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PVCDCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PVCDCETable", "storing data...  "));
	refresh_x25PVCDCETable();
	(void) tmpsize;
	for (hcindex = x25PVCDCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PVCDCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PVCDCETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PVCDCELogicalChannel, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PVCDCEChargingDirection,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PVCDCEOperationalState,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr,
						   &StorageTmp->x25PVCDCERemoteDTEAddress,
						   &StorageTmp->x25PVCDCERemoteDTEAddressLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PVCDCERemoteLogicalChannel,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PVCDCERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PVCDXETable_data *x25PVCDXETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PVCDXETable table.
 * Creates a new x25PVCDXETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PVCDXETable_data *
x25PVCDXETable_create(void)
{
	struct x25PVCDXETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PVCDXETable_data);

	DEBUGMSGTL(("x25PVCDXETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25PVCDXERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25PVCDXETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PVCDXETable_destroy(struct x25PVCDXETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PVCDXETable_destroy(struct x25PVCDXETable_data **thedata)
{
	struct x25PVCDXETable_data *StorageDel;

	DEBUGMSGTL(("x25PVCDXETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PVCDXETable_add(struct x25PVCDXETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PVCDXETable table data set.
 * Adds a table row structure to the x25PVCDXETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PVCDXETable_add(struct x25PVCDXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PVCDXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	header_complex_add_data(&x25PVCDXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25PVCDXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25PVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PVCDXETable_del(struct x25PVCDXETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PVCDXETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PVCDXETable_del(struct x25PVCDXETable_data *thedata)
{
	struct x25PVCDXETable_data *StorageDel;

	DEBUGMSGTL(("x25PVCDXETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25PVCDXETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PVCDXETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PVCDXETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PVCDXETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PVCDXETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PVCDXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PVCDXETable_data *StorageTmp = x25PVCDXETable_create();

	DEBUGMSGTL(("x25PVCDXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDXELogicalChannel,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25PVCDXERowStatus, &tmpsize);
	x25PVCDXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PVCDXETable", "done.\n"));
}

/*
 * store_x25PVCDXETable(): store configuraiton file for x25PVCDXETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PVCDXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PVCDXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PVCDXETable", "storing data...  "));
	refresh_x25PVCDXETable();
	(void) tmpsize;
	for (hcindex = x25PVCDXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PVCDXETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PVCDXETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PVCDXELogicalChannel, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25PVCDXERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25SVCIVMOTable_data *x25SVCIVMOTable_create(void)
 * @brief create a fresh data structure representing a new row in the x25SVCIVMOTable table.
 * Creates a new x25SVCIVMOTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25SVCIVMOTable_data *
x25SVCIVMOTable_create(void)
{
	struct x25SVCIVMOTable_data *StorageNew = SNMP_MALLOC_STRUCT(x25SVCIVMOTable_data);

	DEBUGMSGTL(("x25SVCIVMOTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25SVCIVMORowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25SVCIVMOTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25SVCIVMOTable_destroy(struct x25SVCIVMOTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25SVCIVMOTable_destroy(struct x25SVCIVMOTable_data **thedata)
{
	struct x25SVCIVMOTable_data *StorageDel;

	DEBUGMSGTL(("x25SVCIVMOTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25SVCIVMOId);
		StorageDel->x25SVCIVMOIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25SVCIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCIVMOTable_add(struct x25SVCIVMOTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25SVCIVMOTable table data set.
 * Adds a table row structure to the x25SVCIVMOTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25SVCIVMOTable_add(struct x25SVCIVMOTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCIVMOTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25SVCIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25SVCIVMOId,
				  thedata->x25SVCIVMOIdLen);
	header_complex_add_data(&x25SVCIVMOTableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCIVMOTable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCIVMOTable_del(struct x25SVCIVMOTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25SVCIVMOTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25SVCIVMOTable_del(struct x25SVCIVMOTable_data *thedata)
{
	struct x25SVCIVMOTable_data *StorageDel;

	DEBUGMSGTL(("x25SVCIVMOTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr =
		     header_complex_find_entry(x25SVCIVMOTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25SVCIVMOTableStorage, hciptr);
	}
	DEBUGMSGTL(("x25SVCIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25SVCIVMOTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25SVCIVMOTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25SVCIVMOTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25SVCIVMOTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCIVMOTable_data *StorageTmp = x25SVCIVMOTable_create();

	DEBUGMSGTL(("x25SVCIVMOTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCIVMOId,
				  &StorageTmp->x25SVCIVMOIdLen);
	if (StorageTmp->x25SVCIVMOId == NULL) {
		config_perror("invalid specification for x25SVCIVMOId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOFastSelect, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOPacketSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOPacketSizeOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOReverseCharging,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOThroughputClassIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOThroughputClassOutgoing,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOWindowSizeIncoming,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMOWindowSizeOutgoing,
				  &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMORowStatus, &tmpsize);
	x25SVCIVMOTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCIVMOTable", "done.\n"));
}

/*
 * store_x25SVCIVMOTable(): store configuraiton file for x25SVCIVMOTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCIVMOTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCIVMOTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCIVMOTable", "storing data...  "));
	refresh_x25SVCIVMOTable();
	(void) tmpsize;
	for (hcindex = x25SVCIVMOTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCIVMOTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25SVCIVMOTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25SVCIVMOId,
						   &StorageTmp->x25SVCIVMOIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMOFastSelect, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMOPacketSizeIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMOPacketSizeOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMOReverseCharging,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMOThroughputClassIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMOThroughputClassOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMOWindowSizeIncoming,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMOWindowSizeOutgoing,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMORowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25SVCIVMOTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25SVCIVMODTETable_data *x25SVCIVMODTETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25SVCIVMODTETable table.
 * Creates a new x25SVCIVMODTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25SVCIVMODTETable_data *
x25SVCIVMODTETable_create(void)
{
	struct x25SVCIVMODTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25SVCIVMODTETable_data);

	DEBUGMSGTL(("x25SVCIVMODTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25SVCIVMODTECallTime = 20000;
		StorageNew->x25SVCIVMODTEResetTime = 18000;
		StorageNew->x25SVCIVMODTEResetCount = 1;
		StorageNew->x25SVCIVMODTEInterruptTime = 18000;
		StorageNew->x25SVCIVMODTEClearTime = 18000;
		StorageNew->x25SVCIVMODTERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25SVCIVMODTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25SVCIVMODTETable_destroy(struct x25SVCIVMODTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25SVCIVMODTETable_destroy(struct x25SVCIVMODTETable_data **thedata)
{
	struct x25SVCIVMODTETable_data *StorageDel;

	DEBUGMSGTL(("x25SVCIVMODTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25SVCIVMOId);
		StorageDel->x25SVCIVMOIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25SVCIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCIVMODTETable_add(struct x25SVCIVMODTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25SVCIVMODTETable table data set.
 * Adds a table row structure to the x25SVCIVMODTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25SVCIVMODTETable_add(struct x25SVCIVMODTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCIVMODTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25SVCIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25SVCIVMOId,
				  thedata->x25SVCIVMOIdLen);
	header_complex_add_data(&x25SVCIVMODTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCIVMODTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCIVMODTETable_del(struct x25SVCIVMODTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25SVCIVMODTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25SVCIVMODTETable_del(struct x25SVCIVMODTETable_data *thedata)
{
	struct x25SVCIVMODTETable_data *StorageDel;

	DEBUGMSGTL(("x25SVCIVMODTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr =
		     header_complex_find_entry(x25SVCIVMODTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25SVCIVMODTETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25SVCIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25SVCIVMODTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25SVCIVMODTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25SVCIVMODTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25SVCIVMODTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCIVMODTETable_data *StorageTmp = x25SVCIVMODTETable_create();

	DEBUGMSGTL(("x25SVCIVMODTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCIVMOId,
				  &StorageTmp->x25SVCIVMOIdLen);
	if (StorageTmp->x25SVCIVMOId == NULL) {
		config_perror("invalid specification for x25SVCIVMOId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTECallTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEResetTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEResetCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEInterruptTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEClearTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEClearCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEWindowTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEDataTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTEDataCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTERejectTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTERejectCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODTERowStatus, &tmpsize);
	x25SVCIVMODTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCIVMODTETable", "done.\n"));
}

/*
 * store_x25SVCIVMODTETable(): store configuraiton file for x25SVCIVMODTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCIVMODTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCIVMODTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCIVMODTETable", "storing data...  "));
	refresh_x25SVCIVMODTETable();
	(void) tmpsize;
	for (hcindex = x25SVCIVMODTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCIVMODTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25SVCIVMODTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25SVCIVMOId,
						   &StorageTmp->x25SVCIVMOIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTECallTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTEResetTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTEResetCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTEInterruptTime,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTEClearTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTEClearCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTEWindowTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTEDataTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTEDataCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTERejectTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTERejectCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODTERowStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25SVCIVMODTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25SVCIVMODXETable_data *x25SVCIVMODXETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25SVCIVMODXETable table.
 * Creates a new x25SVCIVMODXETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25SVCIVMODXETable_data *
x25SVCIVMODXETable_create(void)
{
	struct x25SVCIVMODXETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25SVCIVMODXETable_data);

	DEBUGMSGTL(("x25SVCIVMODXETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->x25SVCIVMODXERowStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("x25SVCIVMODXETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25SVCIVMODXETable_destroy(struct x25SVCIVMODXETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25SVCIVMODXETable_destroy(struct x25SVCIVMODXETable_data **thedata)
{
	struct x25SVCIVMODXETable_data *StorageDel;

	DEBUGMSGTL(("x25SVCIVMODXETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25SVCIVMOId);
		StorageDel->x25SVCIVMOIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25SVCIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCIVMODXETable_add(struct x25SVCIVMODXETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25SVCIVMODXETable table data set.
 * Adds a table row structure to the x25SVCIVMODXETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25SVCIVMODXETable_add(struct x25SVCIVMODXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCIVMODXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25SVCIVMOId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25SVCIVMOId,
				  thedata->x25SVCIVMOIdLen);
	header_complex_add_data(&x25SVCIVMODXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCIVMODXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCIVMODXETable_del(struct x25SVCIVMODXETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25SVCIVMODXETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25SVCIVMODXETable_del(struct x25SVCIVMODXETable_data *thedata)
{
	struct x25SVCIVMODXETable_data *StorageDel;

	DEBUGMSGTL(("x25SVCIVMODXETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr =
		     header_complex_find_entry(x25SVCIVMODXETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25SVCIVMODXETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25SVCIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25SVCIVMODXETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25SVCIVMODXETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25SVCIVMODXETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25SVCIVMODXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCIVMODXETable_data *StorageTmp = x25SVCIVMODXETable_create();

	DEBUGMSGTL(("x25SVCIVMODXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCIVMOId,
				  &StorageTmp->x25SVCIVMOIdLen);
	if (StorageTmp->x25SVCIVMOId == NULL) {
		config_perror("invalid specification for x25SVCIVMOId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXECallTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEResetTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEClearTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEInterruptTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEResetCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEClearCount,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXERowStatus, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEWindowTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEDataTime, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXEDataCount, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXERejectTime,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCIVMODXERejectCount,
				  &tmpsize);
	x25SVCIVMODXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCIVMODXETable", "done.\n"));
}

/*
 * store_x25SVCIVMODXETable(): store configuraiton file for x25SVCIVMODXETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCIVMODXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCIVMODXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCIVMODXETable", "storing data...  "));
	refresh_x25SVCIVMODXETable();
	(void) tmpsize;
	for (hcindex = x25SVCIVMODXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCIVMODXETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25SVCIVMODXETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25SVCIVMOId,
						   &StorageTmp->x25SVCIVMOIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXECallTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXEResetTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXEClearTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXEInterruptTime,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXEResetCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXEClearCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXERowStatus, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXEWindowTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXEDataTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXEDataCount, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXERejectTime, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCIVMODXERejectCount, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25SVCIVMODXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25SVCDTETable_data *x25SVCDTETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25SVCDTETable table.
 * Creates a new x25SVCDTETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25SVCDTETable_data *
x25SVCDTETable_create(void)
{
	struct x25SVCDTETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25SVCDTETable_data);

	DEBUGMSGTL(("x25SVCDTETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25SVCDTETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25SVCDTETable_destroy(struct x25SVCDTETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25SVCDTETable_destroy(struct x25SVCDTETable_data **thedata)
{
	struct x25SVCDTETable_data *StorageDel;

	DEBUGMSGTL(("x25SVCDTETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel->x25SVCDTEOriginallyCalledAddress);
		StorageDel->x25SVCDTEOriginallyCalledAddressLen = 0;
		SNMP_FREE(StorageDel->x25SVCDTERemoteDTEAddress);
		StorageDel->x25SVCDTERemoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25SVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCDTETable_add(struct x25SVCDTETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25SVCDTETable table data set.
 * Adds a table row structure to the x25SVCDTETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25SVCDTETable_add(struct x25SVCDTETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCDTETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	header_complex_add_data(&x25SVCDTETableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCDTETable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCDTETable_del(struct x25SVCDTETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25SVCDTETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25SVCDTETable_del(struct x25SVCDTETable_data *thedata)
{
	struct x25SVCDTETable_data *StorageDel;

	DEBUGMSGTL(("x25SVCDTETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25SVCDTETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25SVCDTETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25SVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25SVCDTETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25SVCDTETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25SVCDTETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25SVCDTETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCDTETable_data *StorageTmp = x25SVCDTETable_create();

	DEBUGMSGTL(("x25SVCDTETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line = read_config_read_data(, line, &StorageTmp->x25SVCDTECallingAddressExtension, &);
	line = read_config_read_data(, line, &StorageTmp->x25SVCDTECalledAddressExtension, &);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDTEDirection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDTEFastSelect, &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line,
				  &StorageTmp->x25SVCDTEOriginallyCalledAddress,
				  &StorageTmp->x25SVCDTEOriginallyCalledAddressLen);
	if (StorageTmp->x25SVCDTEOriginallyCalledAddress == NULL) {
		config_perror("invalid specification for x25SVCDTEOriginallyCalledAddress");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDTERedirectReason,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCDTERemoteDTEAddress,
				  &StorageTmp->x25SVCDTERemoteDTEAddressLen);
	if (StorageTmp->x25SVCDTERemoteDTEAddress == NULL) {
		config_perror("invalid specification for x25SVCDTERemoteDTEAddress");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDTEReverseCharging,
				  &tmpsize);
	x25SVCDTETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCDTETable", "done.\n"));
}

/*
 * store_x25SVCDTETable(): store configuraiton file for x25SVCDTETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCDTETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCDTETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCDTETable", "storing data...  "));
	refresh_x25SVCDTETable();
	(void) tmpsize;
	for (hcindex = x25SVCDTETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCDTETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25SVCDTETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(, cptr,
						   &StorageTmp->x25SVCDTECallingAddressExtension,
						   &);
			cptr =
			    read_config_store_data(, cptr,
						   &StorageTmp->x25SVCDTECalledAddressExtension, &);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDTEDirection, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDTEFastSelect, &tmpsize);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr,
						   &StorageTmp->x25SVCDTEOriginallyCalledAddress,
						   &StorageTmp->
						   x25SVCDTEOriginallyCalledAddressLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDTERedirectReason, &tmpsize);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr,
						   &StorageTmp->x25SVCDTERemoteDTEAddress,
						   &StorageTmp->x25SVCDTERemoteDTEAddressLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDTEReverseCharging, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25SVCDTETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25SVCDCETable_data *x25SVCDCETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25SVCDCETable table.
 * Creates a new x25SVCDCETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25SVCDCETable_data *
x25SVCDCETable_create(void)
{
	struct x25SVCDCETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25SVCDCETable_data);

	DEBUGMSGTL(("x25SVCDCETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25SVCDCETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25SVCDCETable_destroy(struct x25SVCDCETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25SVCDCETable_destroy(struct x25SVCDCETable_data **thedata)
{
	struct x25SVCDCETable_data *StorageDel;

	DEBUGMSGTL(("x25SVCDCETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel->x25SVCDCERemoteDTEAddress);
		StorageDel->x25SVCDCERemoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25SVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCDCETable_add(struct x25SVCDCETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25SVCDCETable table data set.
 * Adds a table row structure to the x25SVCDCETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25SVCDCETable_add(struct x25SVCDCETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCDCETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	header_complex_add_data(&x25SVCDCETableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCDCETable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCDCETable_del(struct x25SVCDCETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25SVCDCETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25SVCDCETable_del(struct x25SVCDCETable_data *thedata)
{
	struct x25SVCDCETable_data *StorageDel;

	DEBUGMSGTL(("x25SVCDCETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25SVCDCETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25SVCDCETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25SVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25SVCDCETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25SVCDCETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25SVCDCETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25SVCDCETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCDCETable_data *StorageTmp = x25SVCDCETable_create();

	DEBUGMSGTL(("x25SVCDCETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDCEChargingDirection,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDCECUGSelection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDCEDirection, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDCEFastSelect, &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCDCERemoteDTEAddress,
				  &StorageTmp->x25SVCDCERemoteDTEAddressLen);
	if (StorageTmp->x25SVCDCERemoteDTEAddress == NULL) {
		config_perror("invalid specification for x25SVCDCERemoteDTEAddress");
		return;
	}
	line =
	    read_config_read_data(ASN_INTEGER, line,
				  &StorageTmp->x25SVCDCETransitDelaySelectionAndIndication,
				  &tmpsize);
	x25SVCDCETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCDCETable", "done.\n"));
}

/*
 * store_x25SVCDCETable(): store configuraiton file for x25SVCDCETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCDCETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCDCETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCDCETable", "storing data...  "));
	refresh_x25SVCDCETable();
	(void) tmpsize;
	for (hcindex = x25SVCDCETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCDCETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25SVCDCETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDCEChargingDirection,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDCECUGSelection, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDCEDirection, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDCEFastSelect, &tmpsize);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr,
						   &StorageTmp->x25SVCDCERemoteDTEAddress,
						   &StorageTmp->x25SVCDCERemoteDTEAddressLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->
						   x25SVCDCETransitDelaySelectionAndIndication,
						   &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25SVCDCETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25SVCDXETable_data *x25SVCDXETable_create(void)
 * @brief create a fresh data structure representing a new row in the x25SVCDXETable table.
 * Creates a new x25SVCDXETable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25SVCDXETable_data *
x25SVCDXETable_create(void)
{
	struct x25SVCDXETable_data *StorageNew = SNMP_MALLOC_STRUCT(x25SVCDXETable_data);

	DEBUGMSGTL(("x25SVCDXETable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25SVCDXETable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25SVCDXETable_destroy(struct x25SVCDXETable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25SVCDXETable_destroy(struct x25SVCDXETable_data **thedata)
{
	struct x25SVCDXETable_data *StorageDel;

	DEBUGMSGTL(("x25SVCDXETable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel->x25SVCDXERemoteDTEAddress);
		StorageDel->x25SVCDXERemoteDTEAddressLen = 0;
		SNMP_FREE(StorageDel->x25SVCDXEOriginallyCalledAddress);
		StorageDel->x25SVCDXEOriginallyCalledAddressLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25SVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCDXETable_add(struct x25SVCDXETable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25SVCDXETable table data set.
 * Adds a table row structure to the x25SVCDXETable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25SVCDXETable_add(struct x25SVCDXETable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25SVCDXETable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	header_complex_add_data(&x25SVCDXETableStorage, vars, thedata);
	DEBUGMSGTL(("x25SVCDXETable", "registered an entry\n"));
	DEBUGMSGTL(("x25SVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25SVCDXETable_del(struct x25SVCDXETable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25SVCDXETable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25SVCDXETable_del(struct x25SVCDXETable_data *thedata)
{
	struct x25SVCDXETable_data *StorageDel;

	DEBUGMSGTL(("x25SVCDXETable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25SVCDXETableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25SVCDXETableStorage, hciptr);
	}
	DEBUGMSGTL(("x25SVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25SVCDXETable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25SVCDXETable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25SVCDXETable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25SVCDXETable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25SVCDXETable_data *StorageTmp = x25SVCDXETable_create();

	DEBUGMSGTL(("x25SVCDXETable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDXEDirection, &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25SVCDXERemoteDTEAddress,
				  &StorageTmp->x25SVCDXERemoteDTEAddressLen);
	if (StorageTmp->x25SVCDXERemoteDTEAddress == NULL) {
		config_perror("invalid specification for x25SVCDXERemoteDTEAddress");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDXEFastSelect, &tmpsize);
	line =
	    read_config_read_data(ASN_INTEGER, line, &StorageTmp->x25SVCDXERedirectReason,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_OCTET_STR, line,
				  &StorageTmp->x25SVCDXEOriginallyCalledAddress,
				  &StorageTmp->x25SVCDXEOriginallyCalledAddressLen);
	if (StorageTmp->x25SVCDXEOriginallyCalledAddress == NULL) {
		config_perror("invalid specification for x25SVCDXEOriginallyCalledAddress");
		return;
	}
	line = read_config_read_data(, line, &StorageTmp->x25SVCDXECallingAddressExtension, &);
	line = read_config_read_data(, line, &StorageTmp->x25SVCDXECalledAddressExtension, &);
	x25SVCDXETable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25SVCDXETable", "done.\n"));
}

/*
 * store_x25SVCDXETable(): store configuraiton file for x25SVCDXETable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25SVCDXETable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25SVCDXETable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25SVCDXETable", "storing data...  "));
	refresh_x25SVCDXETable();
	(void) tmpsize;
	for (hcindex = x25SVCDXETableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25SVCDXETable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25SVCDXETable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDXEDirection, &tmpsize);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr,
						   &StorageTmp->x25SVCDXERemoteDTEAddress,
						   &StorageTmp->x25SVCDXERemoteDTEAddressLen);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDXEFastSelect, &tmpsize);
			cptr =
			    read_config_store_data(ASN_INTEGER, cptr,
						   &StorageTmp->x25SVCDXERedirectReason, &tmpsize);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr,
						   &StorageTmp->x25SVCDXEOriginallyCalledAddress,
						   &StorageTmp->
						   x25SVCDXEOriginallyCalledAddressLen);
			cptr =
			    read_config_store_data(, cptr,
						   &StorageTmp->x25SVCDXECallingAddressExtension,
						   &);
			cptr =
			    read_config_store_data(, cptr,
						   &StorageTmp->x25SVCDXECalledAddressExtension, &);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25SVCDXETable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25DSCTable_data *x25DSCTable_create(void)
 * @brief create a fresh data structure representing a new row in the x25DSCTable table.
 * Creates a new x25DSCTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25DSCTable_data *
x25DSCTable_create(void)
{
	struct x25DSCTable_data *StorageNew = SNMP_MALLOC_STRUCT(x25DSCTable_data);

	DEBUGMSGTL(("x25DSCTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25DSCTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25DSCTable_destroy(struct x25DSCTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25DSCTable_destroy(struct x25DSCTable_data **thedata)
{
	struct x25DSCTable_data *StorageDel;

	DEBUGMSGTL(("x25DSCTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel->x25VCId);
		StorageDel->x25VCIdLen = 0;
		SNMP_FREE(StorageDel->x25DSCId);
		StorageDel->x25DSCIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25DSCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25DSCTable_add(struct x25DSCTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25DSCTable table data set.
 * Adds a table row structure to the x25DSCTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25DSCTable_add(struct x25DSCTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25DSCTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	/* x25VCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25VCId,
				  thedata->x25VCIdLen);
	/* x25DSCId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25DSCId,
				  thedata->x25DSCIdLen);
	header_complex_add_data(&x25DSCTableStorage, vars, thedata);
	DEBUGMSGTL(("x25DSCTable", "registered an entry\n"));
	DEBUGMSGTL(("x25DSCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25DSCTable_del(struct x25DSCTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25DSCTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25DSCTable_del(struct x25DSCTable_data *thedata)
{
	struct x25DSCTable_data *StorageDel;

	DEBUGMSGTL(("x25DSCTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(x25DSCTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25DSCTableStorage, hciptr);
	}
	DEBUGMSGTL(("x25DSCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25DSCTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25DSCTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25DSCTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25DSCTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25DSCTable_data *StorageTmp = x25DSCTable_create();

	DEBUGMSGTL(("x25DSCTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25VCId,
				  &StorageTmp->x25VCIdLen);
	if (StorageTmp->x25VCId == NULL) {
		config_perror("invalid specification for x25VCId");
		return;
	}
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25DSCId,
				  &StorageTmp->x25DSCIdLen);
	if (StorageTmp->x25DSCId == NULL) {
		config_perror("invalid specification for x25DSCId");
		return;
	}
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25DSCResetRequestIndicationPackets, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25DSCSegmentsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25DSCSegmentsReceived,
				  &tmpsize);
	x25DSCTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25DSCTable", "done.\n"));
}

/*
 * store_x25DSCTable(): store configuraiton file for x25DSCTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25DSCTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25DSCTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25DSCTable", "storing data...  "));
	refresh_x25DSCTable();
	(void) tmpsize;
	for (hcindex = x25DSCTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25DSCTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25DSCTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25VCId,
						   &StorageTmp->x25VCIdLen);
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25DSCId,
						   &StorageTmp->x25DSCIdLen);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25DSCResetRequestIndicationPackets,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25DSCSegmentsSent, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25DSCSegmentsReceived, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25DSCTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEDTEStatsTable_data *x25PLEDTEStatsTable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEDTEStatsTable table.
 * Creates a new x25PLEDTEStatsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEDTEStatsTable_data *
x25PLEDTEStatsTable_create(void)
{
	struct x25PLEDTEStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEDTEStatsTable_data);

	DEBUGMSGTL(("x25PLEDTEStatsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25PLEDTEStatsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEDTEStatsTable_destroy(struct x25PLEDTEStatsTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEDTEStatsTable_destroy(struct x25PLEDTEStatsTable_data **thedata)
{
	struct x25PLEDTEStatsTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDTEStatsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEDTEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDTEStatsTable_add(struct x25PLEDTEStatsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEDTEStatsTable table data set.
 * Adds a table row structure to the x25PLEDTEStatsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEDTEStatsTable_add(struct x25PLEDTEStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDTEStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLEDTEStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDTEStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDTEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDTEStatsTable_del(struct x25PLEDTEStatsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEDTEStatsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEDTEStatsTable_del(struct x25PLEDTEStatsTable_data *thedata)
{
	struct x25PLEDTEStatsTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDTEStatsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr =
		     header_complex_find_entry(x25PLEDTEStatsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEDTEStatsTableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEDTEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEDTEStatsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEDTEStatsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEDTEStatsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEDTEStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDTEStatsTable_data *StorageTmp = x25PLEDTEStatsTable_create();

	DEBUGMSGTL(("x25PLEDTEStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsCallAttempts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsProtocolErrorsDetectedLocally,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsProtocolErrorsAccusedOf, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsCallCountsExceeded, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsOctetsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsCallTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsCallsConnected,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsDataPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsDataTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsProviderDisconnects, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsRemoteResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsRemoteRestarts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsResetTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsRestartCountsExceeded, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDTEStatsClearTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDTEStatsClearCountsExceeded, &tmpsize);
	x25PLEDTEStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDTEStatsTable", "done.\n"));
}

/*
 * store_x25PLEDTEStatsTable(): store configuraiton file for x25PLEDTEStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDTEStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDTEStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDTEStatsTable", "storing data...  "));
	refresh_x25PLEDTEStatsTable();
	(void) tmpsize;
	for (hcindex = x25PLEDTEStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDTEStatsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEDTEStatsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsCallAttempts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->
						   x25PLEDTEStatsProtocolErrorsDetectedLocally,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->
						   x25PLEDTEStatsProtocolErrorsAccusedOf, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsCallCountsExceeded,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsOctetsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsOctetsSent, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsCallTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsCallsConnected,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsDataPacketsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsDataPacketsSent,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsDataTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsProviderResets,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsProviderDisconnects,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsRemoteResets,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsRemoteRestarts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsResetTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsRestartCountsExceeded,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsClearTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDTEStatsClearCountsExceeded,
						   &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEDTEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEDCEStatsTable_data *x25PLEDCEStatsTable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEDCEStatsTable table.
 * Creates a new x25PLEDCEStatsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEDCEStatsTable_data *
x25PLEDCEStatsTable_create(void)
{
	struct x25PLEDCEStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEDCEStatsTable_data);

	DEBUGMSGTL(("x25PLEDCEStatsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25PLEDCEStatsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEDCEStatsTable_destroy(struct x25PLEDCEStatsTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEDCEStatsTable_destroy(struct x25PLEDCEStatsTable_data **thedata)
{
	struct x25PLEDCEStatsTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDCEStatsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEDCEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDCEStatsTable_add(struct x25PLEDCEStatsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEDCEStatsTable table data set.
 * Adds a table row structure to the x25PLEDCEStatsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEDCEStatsTable_add(struct x25PLEDCEStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDCEStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLEDCEStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDCEStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDCEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDCEStatsTable_del(struct x25PLEDCEStatsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEDCEStatsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEDCEStatsTable_del(struct x25PLEDCEStatsTable_data *thedata)
{
	struct x25PLEDCEStatsTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDCEStatsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr =
		     header_complex_find_entry(x25PLEDCEStatsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEDCEStatsTableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEDCEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEDCEStatsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEDCEStatsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEDCEStatsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEDCEStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDCEStatsTable_data *StorageTmp = x25PLEDCEStatsTable_create();

	DEBUGMSGTL(("x25PLEDCEStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsCallAttempts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsCallsConnected,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsOctetsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDCEStatsDataPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDCEStatsInterruptPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDCEStatsInterruptPacketsSent, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDCEStatsProviderDisconnects, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsRemoteResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsRemoteRestarts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsResetTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDCEStatsX25SegmentsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDCEStatsX25SegmentsSent,
				  &tmpsize);
	x25PLEDCEStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDCEStatsTable", "done.\n"));
}

/*
 * store_x25PLEDCEStatsTable(): store configuraiton file for x25PLEDCEStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDCEStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDCEStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDCEStatsTable", "storing data...  "));
	refresh_x25PLEDCEStatsTable();
	(void) tmpsize;
	for (hcindex = x25PLEDCEStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDCEStatsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEDCEStatsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsCallAttempts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsCallsConnected,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsOctetsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsOctetsSent, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsDataPacketsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsDataPacketsSent,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->
						   x25PLEDCEStatsInterruptPacketsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsInterruptPacketsSent,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsProviderResets,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsProviderDisconnects,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsRemoteResets,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsRemoteRestarts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsResetTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsX25SegmentsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDCEStatsX25SegmentsSent,
						   &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEDCEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct x25PLEDXEStatsTable_data *x25PLEDXEStatsTable_create(void)
 * @brief create a fresh data structure representing a new row in the x25PLEDXEStatsTable table.
 * Creates a new x25PLEDXEStatsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct x25PLEDXEStatsTable_data *
x25PLEDXEStatsTable_create(void)
{
	struct x25PLEDXEStatsTable_data *StorageNew = SNMP_MALLOC_STRUCT(x25PLEDXEStatsTable_data);

	DEBUGMSGTL(("x25PLEDXEStatsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("x25PLEDXEStatsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int x25PLEDXEStatsTable_destroy(struct x25PLEDXEStatsTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
x25PLEDXEStatsTable_destroy(struct x25PLEDXEStatsTable_data **thedata)
{
	struct x25PLEDXEStatsTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDXEStatsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->x25PLEId);
		StorageDel->x25PLEIdLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("x25PLEDXEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDXEStatsTable_add(struct x25PLEDXEStatsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the x25PLEDXEStatsTable table data set.
 * Adds a table row structure to the x25PLEDXEStatsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
x25PLEDXEStatsTable_add(struct x25PLEDXEStatsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("x25PLEDXEStatsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* x25PLEId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (u_char *) thedata->x25PLEId,
				  thedata->x25PLEIdLen);
	header_complex_add_data(&x25PLEDXEStatsTableStorage, vars, thedata);
	DEBUGMSGTL(("x25PLEDXEStatsTable", "registered an entry\n"));
	DEBUGMSGTL(("x25PLEDXEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int x25PLEDXEStatsTable_del(struct x25PLEDXEStatsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the x25PLEDXEStatsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
x25PLEDXEStatsTable_del(struct x25PLEDXEStatsTable_data *thedata)
{
	struct x25PLEDXEStatsTable_data *StorageDel;

	DEBUGMSGTL(("x25PLEDXEStatsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr =
		     header_complex_find_entry(x25PLEDXEStatsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&x25PLEDXEStatsTableStorage, hciptr);
	}
	DEBUGMSGTL(("x25PLEDXEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_x25PLEDXEStatsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for x25PLEDXEStatsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case x25PLEDXEStatsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_x25PLEDXEStatsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct x25PLEDXEStatsTable_data *StorageTmp = x25PLEDXEStatsTable_create();

	DEBUGMSGTL(("x25PLEDXEStatsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line =
	    read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->x25PLEId,
				  &StorageTmp->x25PLEIdLen);
	if (StorageTmp->x25PLEId == NULL) {
		config_perror("invalid specification for x25PLEId");
		return;
	}
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsCallAttempts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsProtocolErrorsDetectedLocally,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsProtocolErrorsAccusedOf, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsCallCountsExceeded, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsOctetsReceived,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsOctetsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsCallTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsCallsConnected,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsClearTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsDataPacketsReceived, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsDataPacketsSent,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsDataTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsProviderResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsProviderDisconnects, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsRemoteResets,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsRemoteRestarts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line, &StorageTmp->x25PLEDXEStatsResetTimeouts,
				  &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsRestartCountsExceeded, &tmpsize);
	line =
	    read_config_read_data(ASN_COUNTER64, line,
				  &StorageTmp->x25PLEDXEStatsClearCountsExceeded, &tmpsize);
	x25PLEDXEStatsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("x25PLEDXEStatsTable", "done.\n"));
}

/*
 * store_x25PLEDXEStatsTable(): store configuraiton file for x25PLEDXEStatsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_x25PLEDXEStatsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct x25PLEDXEStatsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("x25PLEDXEStatsTable", "storing data...  "));
	refresh_x25PLEDXEStatsTable();
	(void) tmpsize;
	for (hcindex = x25PLEDXEStatsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct x25PLEDXEStatsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "x25PLEDXEStatsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr =
			    read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->x25PLEId,
						   &StorageTmp->x25PLEIdLen);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsCallAttempts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->
						   x25PLEDXEStatsProtocolErrorsDetectedLocally,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->
						   x25PLEDXEStatsProtocolErrorsAccusedOf, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsCallCountsExceeded,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsOctetsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsOctetsSent, &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsCallTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsCallsConnected,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsClearTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsDataPacketsReceived,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsDataPacketsSent,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsDataTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsProviderResets,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsProviderDisconnects,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsRemoteResets,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsRemoteRestarts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsResetTimeouts,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsRestartCountsExceeded,
						   &tmpsize);
			cptr =
			    read_config_store_data(ASN_COUNTER64, cptr,
						   &StorageTmp->x25PLEDXEStatsClearCountsExceeded,
						   &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("x25PLEDXEStatsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_x25PLETable(void)
 * @brief refresh the scalar values of the x25PLETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLETable(void)
{
	if (x25PLETable_refresh == 0)
		return;
	x25PLETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLETable_row(struct x25PLETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLETable_row(struct x25PLETable_data *StorageTmp)
{
	if (StorageTmp->x25PLETable_request == sa_request)
		return;
	StorageTmp->x25PLETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		WriteMethod ** write_method)
{
	struct x25PLETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEOperationalState);
		return (u_char *) &StorageTmp->x25PLEOperationalState;
	case X25PLEADMINISTRATIVESTATE:
		*write_method = write_x25PLEAdministrativeState;
		*var_len = sizeof(StorageTmp->x25PLEAdministrativeState);
		return (u_char *) &StorageTmp->x25PLEAdministrativeState;
	case X25PLEPROTOCOLVERSIONSSUPPORTED:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25PLEProtocolVersionsSupportedLen;
		return (u_char *) StorageTmp->x25PLEProtocolVersionsSupported;
	case X25PLELOCALDTEADDRESS:
		*write_method = write_x25PLELocalDTEAddress;
		*var_len = StorageTmp->x25PLELocalDTEAddressLen;
		return (u_char *) StorageTmp->x25PLELocalDTEAddress;
	case X25PLEINTERFACEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEInterfaceMode);
		return (u_char *) &StorageTmp->x25PLEInterfaceMode;
	case X25PLEFACILITYNONNEGOTIABLE:
		*write_method = write_x25PLEFacilityNonNegotiable;
		*var_len = StorageTmp->x25PLEFacilityNonNegotiableLen;
		return (u_char *) StorageTmp->x25PLEFacilityNonNegotiable;
	case X25PLEFACILITYAVAILABILITY:
		*write_method = write_x25PLEFacilityAvailability;
		*var_len = StorageTmp->x25PLEFacilityAvailabilityLen;
		return (u_char *) StorageTmp->x25PLEFacilityAvailability;
	case X25PLEFACILITYNEGOTIATION:
		*write_method = write_x25PLEFacilityNegotiation;
		*var_len = StorageTmp->x25PLEFacilityNegotiationLen;
		return (u_char *) StorageTmp->x25PLEFacilityNegotiation;
	case X25PLEFACILITYWHILEIDLE:
		*write_method = write_x25PLEFacilityWhileIdle;
		*var_len = StorageTmp->x25PLEFacilityWhileIdleLen;
		return (u_char *) StorageTmp->x25PLEFacilityWhileIdle;
	case X25PLEPACKETSEQUENCENUMBERING:
		*write_method = write_x25PLEPacketSequenceNumbering;
		*var_len = sizeof(StorageTmp->x25PLEPacketSequenceNumbering);
		return (u_char *) &StorageTmp->x25PLEPacketSequenceNumbering;
	case X25PLEDEFAULTPACKETSIZEINCOMING:
		*write_method = write_x25PLEDefaultPacketSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDefaultPacketSizeIncoming);
		return (u_char *) &StorageTmp->x25PLEDefaultPacketSizeIncoming;
	case X25PLEDEFAULTPACKETSIZEOUTGOING:
		*write_method = write_x25PLEDefaultPacketSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDefaultPacketSizeOutgoing);
		return (u_char *) &StorageTmp->x25PLEDefaultPacketSizeOutgoing;
	case X25PLEDEFAULTWINDOWSIZEINCOMING:
		*write_method = write_x25PLEDefaultWindowSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDefaultWindowSizeIncoming);
		return (u_char *) &StorageTmp->x25PLEDefaultWindowSizeIncoming;
	case X25PLEDEFAULTWINDOWSIZEOUTGOING:
		*write_method = write_x25PLEDefaultWindowSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDefaultWindowSizeOutgoing);
		return (u_char *) &StorageTmp->x25PLEDefaultWindowSizeOutgoing;
	case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25PLEDefaultThroughputClassIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDefaultThroughputClassIncoming);
		return (u_char *) &StorageTmp->x25PLEDefaultThroughputClassIncoming;
	case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25PLEDefaultThroughputClassOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDefaultThroughputClassOutgoing);
		return (u_char *) &StorageTmp->x25PLEDefaultThroughputClassOutgoing;
	case X25PLESNSERVICEPROVIDER:
		*write_method = write_x25PLESNServiceProvider;
		*var_len = StorageTmp->x25PLESNServiceProviderLen;
		return (u_char *) StorageTmp->x25PLESNServiceProvider;
	case X25PLESNSAP:
		*write_method = write_x25PLESNSAP;
		*var_len = StorageTmp->x25PLESNSAPLen;
		return (u_char *) StorageTmp->x25PLESNSAP;
	case X25PLELOGICALCHANNELASSIGNMENTHIC:
		*write_method = write_x25PLELogicalChannelAssignmentHIC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentHIC);
		return (u_char *) &StorageTmp->x25PLELogicalChannelAssignmentHIC;
	case X25PLELOGICALCHANNELASSIGNMENTLIC:
		*write_method = write_x25PLELogicalChannelAssignmentLIC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentLIC);
		return (u_char *) &StorageTmp->x25PLELogicalChannelAssignmentLIC;
	case X25PLELOGICALCHANNELASSIGNMENTHTC:
		*write_method = write_x25PLELogicalChannelAssignmentHTC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentHTC);
		return (u_char *) &StorageTmp->x25PLELogicalChannelAssignmentHTC;
	case X25PLELOGICALCHANNELASSIGNMENTLTC:
		*write_method = write_x25PLELogicalChannelAssignmentLTC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentLTC);
		return (u_char *) &StorageTmp->x25PLELogicalChannelAssignmentLTC;
	case X25PLELOGICALCHANNELASSIGNMENTHOC:
		*write_method = write_x25PLELogicalChannelAssignmentHOC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentHOC);
		return (u_char *) &StorageTmp->x25PLELogicalChannelAssignmentHOC;
	case X25PLELOGICALCHANNELASSIGNMENTLOC:
		*write_method = write_x25PLELogicalChannelAssignmentLOC;
		*var_len = sizeof(StorageTmp->x25PLELogicalChannelAssignmentLOC);
		return (u_char *) &StorageTmp->x25PLELogicalChannelAssignmentLOC;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEIVMOTable(void)
 * @brief refresh the scalar values of the x25PLEIVMOTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMOTable(void)
{
	if (x25PLEIVMOTable_refresh == 0)
		return;
	x25PLEIVMOTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEIVMOTable_row(struct x25PLEIVMOTable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEIVMOTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEIVMOTable_row(struct x25PLEIVMOTable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMOTable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMOTable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEIVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEIVMOTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLEIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		    WriteMethod ** write_method)
{
	struct x25PLEIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEIVMOINTERFACEMODE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEIVMOInterfaceMode);
		return (u_char *) &StorageTmp->x25PLEIVMOInterfaceMode;
	case X25PLEIVMODEFAULTPACKETSIZEINCOMING:
		*write_method = write_x25PLEIVMODefaultPacketSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultPacketSizeIncoming);
		return (u_char *) &StorageTmp->x25PLEIVMODefaultPacketSizeIncoming;
	case X25PLEIVMODEFAULTPACKETSIZEOUTGOING:
		*write_method = write_x25PLEIVMODefaultPacketSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing);
		return (u_char *) &StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25PLEIVMODefaultThroughputClassIncoming;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultThroughputClassIncoming);
		return (u_char *) &StorageTmp->x25PLEIVMODefaultThroughputClassIncoming;
	case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25PLEIVMODefaultThroughputClassOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing);
		return (u_char *) &StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing;
	case X25PLEIVMODEFAULTWINDOWSIZEINCOMING:
		*write_method = write_x25PLEIVMODefaultWindowSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultWindowSizeIncoming);
		return (u_char *) &StorageTmp->x25PLEIVMODefaultWindowSizeIncoming;
	case X25PLEIVMODEFAULTWINDOWSIZEOUTGOING:
		*write_method = write_x25PLEIVMODefaultWindowSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing);
		return (u_char *) &StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing;
	case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION:
		*write_method = write_x25PLEIVMOFlowControlParameterNegotiation;
		*var_len = sizeof(StorageTmp->x25PLEIVMOFlowControlParameterNegotiation);
		return (u_char *) &StorageTmp->x25PLEIVMOFlowControlParameterNegotiation;
	case X25PLEIVMOLOCALDTEADDRESS:
		*write_method = write_x25PLEIVMOLocalDTEAddress;
		*var_len = StorageTmp->x25PLEIVMOLocalDTEAddressLen;
		return (u_char *) StorageTmp->x25PLEIVMOLocalDTEAddress;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHPC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHPC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC);
		return (u_char *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLPC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLPC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC);
		return (u_char *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHIC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHIC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC);
		return (u_char *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLIC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLIC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC);
		return (u_char *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHTC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHTC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC);
		return (u_char *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLTC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLTC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC);
		return (u_char *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTHOC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentHOC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC);
		return (u_char *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC;
	case X25PLEIVMOLOGICALCHANNELASSIGNMENTLOC:
		*write_method = write_x25PLEIVMOLogicalChannelAssignmentLOC;
		*var_len = sizeof(StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC);
		return (u_char *) &StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC;
	case X25PLEIVMOSNSERVICEPROVIDER:
		*write_method = write_x25PLEIVMOSNServiceProvider;
		*var_len = StorageTmp->x25PLEIVMOSNServiceProviderLen;
		return (u_char *) StorageTmp->x25PLEIVMOSNServiceProvider;
	case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION:
		*write_method = write_x25PLEIVMOThroughputClassNegotiation;
		*var_len = sizeof(StorageTmp->x25PLEIVMOThroughputClassNegotiation);
		return (u_char *) &StorageTmp->x25PLEIVMOThroughputClassNegotiation;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEDTETable(void)
 * @brief refresh the scalar values of the x25PLEDTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEDTETable(void)
{
	if (x25PLEDTETable_refresh == 0)
		return;
	x25PLEDTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEDTETable_row(struct x25PLEDTETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEDTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEDTETable_row(struct x25PLEDTETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDTETable_request == sa_request)
		return;
	StorageTmp->x25PLEDTETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEDTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEDTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLEDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PLEDTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEDTEPACKETSEQUENCING:
		*write_method = write_x25PLEDTEPacketSequencing;
		*var_len = sizeof(StorageTmp->x25PLEDTEPacketSequencing);
		return (u_char *) &StorageTmp->x25PLEDTEPacketSequencing;
	case X25PLEDTEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEDTEMaxActiveCircuits;
		*var_len = sizeof(StorageTmp->x25PLEDTEMaxActiveCircuits);
		return (u_char *) &StorageTmp->x25PLEDTEMaxActiveCircuits;
	case X25PLEDTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEDTECallDeflectionSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDTECallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEDTECallDeflectionSubscription;
	case X25PLEDTERESTARTTIME:
		*write_method = write_x25PLEDTERestartTime;
		*var_len = sizeof(StorageTmp->x25PLEDTERestartTime);
		return (u_char *) &StorageTmp->x25PLEDTERestartTime;
	case X25PLEDTERESTARTCOUNT:
		*write_method = write_x25PLEDTERestartCount;
		*var_len = sizeof(StorageTmp->x25PLEDTERestartCount);
		return (u_char *) &StorageTmp->x25PLEDTERestartCount;
	case X25PLEDTEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEDTEMinimumRecallTimer;
		*var_len = sizeof(StorageTmp->x25PLEDTEMinimumRecallTimer);
		return (u_char *) &StorageTmp->x25PLEDTEMinimumRecallTimer;
	case X25PLEDTEREGISTRATIONTIME:
		*write_method = write_x25PLEDTERegistrationTime;
		*var_len = sizeof(StorageTmp->x25PLEDTERegistrationTime);
		return (u_char *) &StorageTmp->x25PLEDTERegistrationTime;
	case X25PLEDTEREGISTRATIONCOUNT:
		*write_method = write_x25PLEDTERegistrationCount;
		*var_len = sizeof(StorageTmp->x25PLEDTERegistrationCount);
		return (u_char *) &StorageTmp->x25PLEDTERegistrationCount;
	case X25PLEDTEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEDTERegistrationPermitted;
		*var_len = sizeof(StorageTmp->x25PLEDTERegistrationPermitted);
		return (u_char *) &StorageTmp->x25PLEDTERegistrationPermitted;
	case X25PLEDTEPROFILE:
		*write_method = write_x25PLEDTEProfile;
		*var_len = StorageTmp->x25PLEDTEProfileLen;
		return (u_char *) StorageTmp->x25PLEDTEProfile;
	case X25PLEDTEROWSTATUS:
		*write_method = write_x25PLEDTERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEDTERowStatus);
		return (u_char *) &StorageTmp->x25PLEDTERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEDCETable(void)
 * @brief refresh the scalar values of the x25PLEDCETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEDCETable(void)
{
	if (x25PLEDCETable_refresh == 0)
		return;
	x25PLEDCETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEDCETable_row(struct x25PLEDCETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEDCETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEDCETable_row(struct x25PLEDCETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDCETable_request == sa_request)
		return;
	StorageTmp->x25PLEDCETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEDCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEDCETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLEDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PLEDCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEDCEPACKETSEQUENCING:
		*write_method = write_x25PLEDCEPacketSequencing;
		*var_len = sizeof(StorageTmp->x25PLEDCEPacketSequencing);
		return (u_char *) &StorageTmp->x25PLEDCEPacketSequencing;
	case X25PLEDCECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEDCECallDeflectionSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCECallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEDCECallDeflectionSubscription;
	case X25PLEDCECUG:
		*write_method = write_x25PLEDCECUG;
		*var_len = sizeof(StorageTmp->x25PLEDCECUG);
		return (u_char *) &StorageTmp->x25PLEDCECUG;
	case X25PLEDCEFASTSELECTACCEPTANCE:
		*write_method = write_x25PLEDCEFastSelectAcceptance;
		*var_len = sizeof(StorageTmp->x25PLEDCEFastSelectAcceptance);
		return (u_char *) &StorageTmp->x25PLEDCEFastSelectAcceptance;
	case X25PLEDCEINCOMINGCALLSBARRED:
		*write_method = write_x25PLEDCEIncomingCallsBarred;
		*var_len = sizeof(StorageTmp->x25PLEDCEIncomingCallsBarred);
		return (u_char *) &StorageTmp->x25PLEDCEIncomingCallsBarred;
	case X25PLEDCEONEWAYLOGICALCHANNELOUTGOING:
		*write_method = write_x25PLEDCEOneWayLogicalChannelOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing);
		return (u_char *) &StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing;
	case X25PLEDCEOUTGOINGCALLSBARRED:
		*write_method = write_x25PLEDCEOutgoingCallsBarred;
		*var_len = sizeof(StorageTmp->x25PLEDCEOutgoingCallsBarred);
		return (u_char *) &StorageTmp->x25PLEDCEOutgoingCallsBarred;
	case X25PLEDCEBILATERALCUG:
		*write_method = write_x25PLEDCEBilateralCUG;
		*var_len = sizeof(StorageTmp->x25PLEDCEBilateralCUG);
		return (u_char *) &StorageTmp->x25PLEDCEBilateralCUG;
	case X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS:
		*write_method = write_x25PLEDCEBilateralCUGWithOutgoingAccess;
		*var_len = sizeof(StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess);
		return (u_char *) &StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess;
	case X25PLEDCECALLREDIRECTION:
		*write_method = write_x25PLEDCECallRedirection;
		*var_len = sizeof(StorageTmp->x25PLEDCECallRedirection);
		return (u_char *) &StorageTmp->x25PLEDCECallRedirection;
	case X25PLEDCECHARGINGINFORMATION:
		*write_method = write_x25PLEDCEChargingInformation;
		*var_len = sizeof(StorageTmp->x25PLEDCEChargingInformation);
		return (u_char *) &StorageTmp->x25PLEDCEChargingInformation;
	case X25PLEDCECUGWITHINCOMINGACCESS:
		*write_method = write_x25PLEDCECUGWithIncomingAccess;
		*var_len = sizeof(StorageTmp->x25PLEDCECUGWithIncomingAccess);
		return (u_char *) &StorageTmp->x25PLEDCECUGWithIncomingAccess;
	case X25PLEDCECUGWITHOUTGOINGACCESS:
		*write_method = write_x25PLEDCECUGWithOutgoingAccess;
		*var_len = sizeof(StorageTmp->x25PLEDCECUGWithOutgoingAccess);
		return (u_char *) &StorageTmp->x25PLEDCECUGWithOutgoingAccess;
	case X25PLEDCEDBITMODIFICATION:
		*write_method = write_x25PLEDCEDBitModification;
		*var_len = sizeof(StorageTmp->x25PLEDCEDBitModification);
		return (u_char *) &StorageTmp->x25PLEDCEDBitModification;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSSUBSCRIPTION:
		*write_method = write_x25PLEDCEDefaultThroughputClassSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCEDefaultThroughputClassSubscription);
		return (u_char *) &StorageTmp->x25PLEDCEDefaultThroughputClassSubscription;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSSUPPORTED:
		*write_method = write_x25PLEDCEDefaultThroughputClassSupported;
		*var_len = StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen;
		return (u_char *) StorageTmp->x25PLEDCEDefaultThroughputClassSupported;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25PLEDCEDefaultThroughputClassIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDCEDefaultThroughputClassIncoming);
		return (u_char *) &StorageTmp->x25PLEDCEDefaultThroughputClassIncoming;
	case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25PLEDCEDefaultThroughputClassOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing);
		return (u_char *) &StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing;
	case X25PLEDCEHUNTGROUP:
		*write_method = write_x25PLEDCEHuntGroup;
		*var_len = sizeof(StorageTmp->x25PLEDCEHuntGroup);
		return (u_char *) &StorageTmp->x25PLEDCEHuntGroup;
	case X25PLEDCEINCOMINGCALLBARREDWITHINCUG:
		*write_method = write_x25PLEDCEIncomingCallBarredWithinCUG;
		*var_len = sizeof(StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG);
		return (u_char *) &StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG;
	case X25PLEDCELOCALCHARGINGPREVENTION:
		*write_method = write_x25PLEDCELocalChargingPrevention;
		*var_len = sizeof(StorageTmp->x25PLEDCELocalChargingPrevention);
		return (u_char *) &StorageTmp->x25PLEDCELocalChargingPrevention;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZESUBSCRIPTION:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription);
		return (u_char *) &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeMaximum;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum);
		return (u_char *) &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming);
		return (u_char *) &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming;
	case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING:
		*write_method = write_x25PLEDCENonStandardDefaultPacketSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing);
		return (u_char *) &StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZESUBSCRIPTION:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription);
		return (u_char *) &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEMAXIMUM:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeMaximum;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum);
		return (u_char *) &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEINCOMING:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming);
		return (u_char *) &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming;
	case X25PLEDCENONSTANDARDDEFAULTWINDOWSIZEOUTGOING:
		*write_method = write_x25PLEDCENonStandardDefaultWindowSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing);
		return (u_char *) &StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing;
	case X25PLEDCENUIOVERRIDE:
		*write_method = write_x25PLEDCENUIOverride;
		*var_len = sizeof(StorageTmp->x25PLEDCENUIOverride);
		return (u_char *) &StorageTmp->x25PLEDCENUIOverride;
	case X25PLEDCENUISUBSCRIPTION:
		*write_method = write_x25PLEDCENUISubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCENUISubscription);
		return (u_char *) &StorageTmp->x25PLEDCENUISubscription;
	case X25PLEDCEONEWAYLOGICALCHANNELINCOMING:
		*write_method = write_x25PLEDCEOneWayLogicalChannelIncoming;
		*var_len = sizeof(StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming);
		return (u_char *) &StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming;
	case X25PLEDCEONLINEFACILITYREGISTRATION:
		*write_method = write_x25PLEDCEOnlineFacilityRegistration;
		*var_len = sizeof(StorageTmp->x25PLEDCEOnlineFacilityRegistration);
		return (u_char *) &StorageTmp->x25PLEDCEOnlineFacilityRegistration;
	case X25PLEDCEOUTGOINGCALLBARREDWITHINCUG:
		*write_method = write_x25PLEDCEOutgoingCallBarredWithinCUG;
		*var_len = sizeof(StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG);
		return (u_char *) &StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG;
	case X25PLEDCEPACKETRETRANSMISSION:
		*write_method = write_x25PLEDCEPacketRetransmission;
		*var_len = sizeof(StorageTmp->x25PLEDCEPacketRetransmission);
		return (u_char *) &StorageTmp->x25PLEDCEPacketRetransmission;
	case X25PLEDCEREVERSECHARGINGACCEPTANCE:
		*write_method = write_x25PLEDCEReverseChargingAcceptance;
		*var_len = sizeof(StorageTmp->x25PLEDCEReverseChargingAcceptance);
		return (u_char *) &StorageTmp->x25PLEDCEReverseChargingAcceptance;
	case X25PLEDCEROASUBSCRIPTION:
		*write_method = write_x25PLEDCEROASubscription;
		*var_len = sizeof(StorageTmp->x25PLEDCEROASubscription);
		return (u_char *) &StorageTmp->x25PLEDCEROASubscription;
	case X25PLEDCERESTARTINDICATION:
		*write_method = write_x25PLEDCERestartIndication;
		*var_len = sizeof(StorageTmp->x25PLEDCERestartIndication);
		return (u_char *) &StorageTmp->x25PLEDCERestartIndication;
	case X25PLEDCERESTARTCOUNT:
		*write_method = write_x25PLEDCERestartCount;
		*var_len = sizeof(StorageTmp->x25PLEDCERestartCount);
		return (u_char *) &StorageTmp->x25PLEDCERestartCount;
	case X25PLEDCEINCOMINGCALL:
		*write_method = write_x25PLEDCEIncomingCall;
		*var_len = sizeof(StorageTmp->x25PLEDCEIncomingCall);
		return (u_char *) &StorageTmp->x25PLEDCEIncomingCall;
	case X25PLEDCECALLCOUNT:
		*write_method = write_x25PLEDCECallCount;
		*var_len = sizeof(StorageTmp->x25PLEDCECallCount);
		return (u_char *) &StorageTmp->x25PLEDCECallCount;
	case X25PLEDCERESETINDICATION:
		*write_method = write_x25PLEDCEResetIndication;
		*var_len = sizeof(StorageTmp->x25PLEDCEResetIndication);
		return (u_char *) &StorageTmp->x25PLEDCEResetIndication;
	case X25PLEDCERESETCOUNT:
		*write_method = write_x25PLEDCEResetCount;
		*var_len = sizeof(StorageTmp->x25PLEDCEResetCount);
		return (u_char *) &StorageTmp->x25PLEDCEResetCount;
	case X25PLEDCECLEARINDICATION:
		*write_method = write_x25PLEDCEClearIndication;
		*var_len = sizeof(StorageTmp->x25PLEDCEClearIndication);
		return (u_char *) &StorageTmp->x25PLEDCEClearIndication;
	case X25PLEDCECLEARCOUNT:
		*write_method = write_x25PLEDCEClearCount;
		*var_len = sizeof(StorageTmp->x25PLEDCEClearCount);
		return (u_char *) &StorageTmp->x25PLEDCEClearCount;
	case X25PLEDCEPROFILE:
		*write_method = write_x25PLEDCEProfile;
		*var_len = StorageTmp->x25PLEDCEProfileLen;
		return (u_char *) StorageTmp->x25PLEDCEProfile;
	case X25PLEDCEROWSTATUS:
		*write_method = write_x25PLEDCERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEDCERowStatus);
		return (u_char *) &StorageTmp->x25PLEDCERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEDXETable(void)
 * @brief refresh the scalar values of the x25PLEDXETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEDXETable(void)
{
	if (x25PLEDXETable_refresh == 0)
		return;
	x25PLEDXETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEDXETable_row(struct x25PLEDXETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEDXETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEDXETable_row(struct x25PLEDXETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDXETable_request == sa_request)
		return;
	StorageTmp->x25PLEDXETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEDXETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEDXETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLEDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PLEDXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEDXEPACKETSEQUENCING:
		*write_method = write_x25PLEDXEPacketSequencing;
		*var_len = sizeof(StorageTmp->x25PLEDXEPacketSequencing);
		return (u_char *) &StorageTmp->x25PLEDXEPacketSequencing;
	case X25PLEDXEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEDXEMaxActiveCircuits;
		*var_len = sizeof(StorageTmp->x25PLEDXEMaxActiveCircuits);
		return (u_char *) &StorageTmp->x25PLEDXEMaxActiveCircuits;
	case X25PLEDXECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEDXECallDeflectionSubscription;
		*var_len = sizeof(StorageTmp->x25PLEDXECallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEDXECallDeflectionSubscription;
	case X25PLEDXERESTARTTIME:
		*write_method = write_x25PLEDXERestartTime;
		*var_len = sizeof(StorageTmp->x25PLEDXERestartTime);
		return (u_char *) &StorageTmp->x25PLEDXERestartTime;
	case X25PLEDXERESTARTCOUNT:
		*write_method = write_x25PLEDXERestartCount;
		*var_len = sizeof(StorageTmp->x25PLEDXERestartCount);
		return (u_char *) &StorageTmp->x25PLEDXERestartCount;
	case X25PLEDXEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEDXEMinimumRecallTimer;
		*var_len = sizeof(StorageTmp->x25PLEDXEMinimumRecallTimer);
		return (u_char *) &StorageTmp->x25PLEDXEMinimumRecallTimer;
	case X25PLEDXEREGISTRATIONTIME:
		*write_method = write_x25PLEDXERegistrationTime;
		*var_len = sizeof(StorageTmp->x25PLEDXERegistrationTime);
		return (u_char *) &StorageTmp->x25PLEDXERegistrationTime;
	case X25PLEDXEREGISTRATIONCOUNT:
		*write_method = write_x25PLEDXERegistrationCount;
		*var_len = sizeof(StorageTmp->x25PLEDXERegistrationCount);
		return (u_char *) &StorageTmp->x25PLEDXERegistrationCount;
	case X25PLEDXEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEDXERegistrationPermitted;
		*var_len = sizeof(StorageTmp->x25PLEDXERegistrationPermitted);
		return (u_char *) &StorageTmp->x25PLEDXERegistrationPermitted;
	case X25PLEDXEPLECLIENTMONAME:
		*write_method = write_x25PLEDXEPLEClientMOName;
		*var_len = StorageTmp->x25PLEDXEPLEClientMONameLen;
		return (u_char *) StorageTmp->x25PLEDXEPLEClientMOName;
	case X25PLEDXEPROFILE:
		*write_method = write_x25PLEDXEProfile;
		*var_len = StorageTmp->x25PLEDXEProfileLen;
		return (u_char *) StorageTmp->x25PLEDXEProfile;
	case X25PLEDXEROWSTATUS:
		*write_method = write_x25PLEDXERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEDXERowStatus);
		return (u_char *) &StorageTmp->x25PLEDXERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEIVMODTETable(void)
 * @brief refresh the scalar values of the x25PLEIVMODTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMODTETable(void)
{
	if (x25PLEIVMODTETable_refresh == 0)
		return;
	x25PLEIVMODTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEIVMODTETable_row(struct x25PLEIVMODTETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEIVMODTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEIVMODTETable_row(struct x25PLEIVMODTETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMODTETable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMODTETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEIVMODTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEIVMODTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLEIVMODTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEIVMODTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMODTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMODTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEIVMODTECallDeflectionSubscription;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTECallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEIVMODTECallDeflectionSubscription;
	case X25PLEIVMODTECALLTIME:
		*write_method = write_x25PLEIVMODTECallTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTECallTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTECallTime;
	case X25PLEIVMODTECLEARTIME:
		*write_method = write_x25PLEIVMODTEClearTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEClearTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTEClearTime;
	case X25PLEIVMODTECLEARCOUNT:
		*write_method = write_x25PLEIVMODTEClearCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEClearCount);
		return (u_char *) &StorageTmp->x25PLEIVMODTEClearCount;
	case X25PLEIVMODTEPACKETSEQUENCING:
		*write_method = write_x25PLEIVMODTEPacketSequencing;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEPacketSequencing);
		return (u_char *) &StorageTmp->x25PLEIVMODTEPacketSequencing;
	case X25PLEIVMODTEINTERRUPTTIME:
		*write_method = write_x25PLEIVMODTEInterruptTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEInterruptTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTEInterruptTime;
	case X25PLEIVMODTEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEIVMODTEMaxActiveCircuits;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEMaxActiveCircuits);
		return (u_char *) &StorageTmp->x25PLEIVMODTEMaxActiveCircuits;
	case X25PLEIVMODTEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEIVMODTEMinimumRecallTimer;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEMinimumRecallTimer);
		return (u_char *) &StorageTmp->x25PLEIVMODTEMinimumRecallTimer;
	case X25PLEIVMODTERESETTIME:
		*write_method = write_x25PLEIVMODTEResetTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEResetTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTEResetTime;
	case X25PLEIVMODTERESETCOUNT:
		*write_method = write_x25PLEIVMODTEResetCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEResetCount);
		return (u_char *) &StorageTmp->x25PLEIVMODTEResetCount;
	case X25PLEIVMODTERESTARTTIME:
		*write_method = write_x25PLEIVMODTERestartTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERestartTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTERestartTime;
	case X25PLEIVMODTERESTARTCOUNT:
		*write_method = write_x25PLEIVMODTERestartCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERestartCount);
		return (u_char *) &StorageTmp->x25PLEIVMODTERestartCount;
	case X25PLEIVMODTEWINDOWTIME:
		*write_method = write_x25PLEIVMODTEWindowTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEWindowTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTEWindowTime;
	case X25PLEIVMODTEDATATIME:
		*write_method = write_x25PLEIVMODTEDataTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEDataTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTEDataTime;
	case X25PLEIVMODTEDATACOUNT:
		*write_method = write_x25PLEIVMODTEDataCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEDataCount);
		return (u_char *) &StorageTmp->x25PLEIVMODTEDataCount;
	case X25PLEIVMODTEREJECTTIME:
		*write_method = write_x25PLEIVMODTERejectTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERejectTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTERejectTime;
	case X25PLEIVMODTEREJECTCOUNT:
		*write_method = write_x25PLEIVMODTERejectCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERejectCount);
		return (u_char *) &StorageTmp->x25PLEIVMODTERejectCount;
	case X25PLEIVMODTEREGISTRATIONTIME:
		*write_method = write_x25PLEIVMODTERegistrationTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTERegistrationTime;
	case X25PLEIVMODTEREGISTRATIONCOUNT:
		*write_method = write_x25PLEIVMODTERegistrationCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationCount);
		return (u_char *) &StorageTmp->x25PLEIVMODTERegistrationCount;
	case X25PLEIVMODTEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEIVMODTERegistrationPermitted;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationPermitted);
		return (u_char *) &StorageTmp->x25PLEIVMODTERegistrationPermitted;
	case X25PLEIVMODTEROWSTATUS:
		*write_method = write_x25PLEIVMODTERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERowStatus);
		return (u_char *) &StorageTmp->x25PLEIVMODTERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEIVMODCETable(void)
 * @brief refresh the scalar values of the x25PLEIVMODCETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMODCETable(void)
{
	if (x25PLEIVMODCETable_refresh == 0)
		return;
	x25PLEIVMODCETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEIVMODCETable_row(struct x25PLEIVMODCETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEIVMODCETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEIVMODCETable_row(struct x25PLEIVMODCETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMODCETable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMODCETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEIVMODCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEIVMODCETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLEIVMODCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct x25PLEIVMODCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEIVMODCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMODCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEIVMODCETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMODCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEIVMODCEROWSTATUS:
		*write_method = write_x25PLEIVMODCERowStatus;
		*var_len = sizeof(StorageTmp->x25PLEIVMODCERowStatus);
		return (u_char *) &StorageTmp->x25PLEIVMODCERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEIVMODXETable(void)
 * @brief refresh the scalar values of the x25PLEIVMODXETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEIVMODXETable(void)
{
	if (x25PLEIVMODXETable_refresh == 0)
		return;
	x25PLEIVMODXETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEIVMODXETable_row(struct x25PLEIVMODXETable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEIVMODXETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEIVMODXETable_row(struct x25PLEIVMODXETable_data *StorageTmp)
{
	if (StorageTmp->x25PLEIVMODXETable_request == sa_request)
		return;
	StorageTmp->x25PLEIVMODXETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEIVMODXETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEIVMODXETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLEIVMODXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEIVMODXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEIVMODXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEIVMODXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEIVMODTECALLDEFLECTIONSUBSCRIPTION:
		*write_method = write_x25PLEIVMODTECallDeflectionSubscription;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTECallDeflectionSubscription);
		return (u_char *) &StorageTmp->x25PLEIVMODTECallDeflectionSubscription;
	case X25PLEIVMODTEMAXACTIVECIRCUITS:
		*write_method = write_x25PLEIVMODTEMaxActiveCircuits;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEMaxActiveCircuits);
		return (u_char *) &StorageTmp->x25PLEIVMODTEMaxActiveCircuits;
	case X25PLEIVMODTERESTARTTIME:
		*write_method = write_x25PLEIVMODTERestartTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERestartTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTERestartTime;
	case X25PLEIVMODTEMINIMUMRECALLTIMER:
		*write_method = write_x25PLEIVMODTEMinimumRecallTimer;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEMinimumRecallTimer);
		return (u_char *) &StorageTmp->x25PLEIVMODTEMinimumRecallTimer;
	case X25PLEIVMODTERESTARTCOUNT:
		*write_method = write_x25PLEIVMODTERestartCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERestartCount);
		return (u_char *) &StorageTmp->x25PLEIVMODTERestartCount;
	case X25PLEIVMODTEPACKETSEQUENCING:
		*write_method = write_x25PLEIVMODTEPacketSequencing;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTEPacketSequencing);
		return (u_char *) &StorageTmp->x25PLEIVMODTEPacketSequencing;
	case X25PLEIVMODTEREGISTRATIONTIME:
		*write_method = write_x25PLEIVMODTERegistrationTime;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationTime);
		return (u_char *) &StorageTmp->x25PLEIVMODTERegistrationTime;
	case X25PLEIVMODTEREGISTRATIONCOUNT:
		*write_method = write_x25PLEIVMODTERegistrationCount;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationCount);
		return (u_char *) &StorageTmp->x25PLEIVMODTERegistrationCount;
	case X25PLEIVMODTEREGISTRATIONPERMITTED:
		*write_method = write_x25PLEIVMODTERegistrationPermitted;
		*var_len = sizeof(StorageTmp->x25PLEIVMODTERegistrationPermitted);
		return (u_char *) &StorageTmp->x25PLEIVMODTERegistrationPermitted;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25VCTable(void)
 * @brief refresh the scalar values of the x25VCTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25VCTable(void)
{
	if (x25VCTable_refresh == 0)
		return;
	x25VCTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25VCTable_row(struct x25VCTable_data *StorageTmp)
 * @brief refresh the contents of the x25VCTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25VCTable_row(struct x25VCTable_data *StorageTmp)
{
	if (StorageTmp->x25VCTable_request == sa_request)
		return;
	StorageTmp->x25VCTable_request = sa_request;
}

/**
 * @fn u_char *var_x25VCTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25VCTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25VCTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
	       WriteMethod ** write_method)
{
	struct x25VCTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25VCTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25VCTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25VCTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25VCLOGICALCHANNEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCLogicalChannel);
		return (u_char *) &StorageTmp->x25VCLogicalChannel;
	case X25VCPACKETSEQUENCING:
		*write_method = write_x25VCPacketSequencing;
		*var_len = sizeof(StorageTmp->x25VCPacketSequencing);
		return (u_char *) &StorageTmp->x25VCPacketSequencing;
	case X25VCPACKETSIZEINCOMING:
		*write_method = write_x25VCPacketSizeIncoming;
		*var_len = sizeof(StorageTmp->x25VCPacketSizeIncoming);
		return (u_char *) &StorageTmp->x25VCPacketSizeIncoming;
	case X25VCPACKETSIZEOUTGOING:
		*write_method = write_x25VCPacketSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25VCPacketSizeOutgoing);
		return (u_char *) &StorageTmp->x25VCPacketSizeOutgoing;
	case X25VCWINDOWSIZEINCOMING:
		*write_method = write_x25VCWindowSizeIncoming;
		*var_len = sizeof(StorageTmp->x25VCWindowSizeIncoming);
		return (u_char *) &StorageTmp->x25VCWindowSizeIncoming;
	case X25VCWINDOWSIZEOUTGOING:
		*write_method = write_x25VCWindowSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25VCWindowSizeOutgoing);
		return (u_char *) &StorageTmp->x25VCWindowSizeOutgoing;
	case X25VCTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25VCThroughputClassIncoming;
		*var_len = sizeof(StorageTmp->x25VCThroughputClassIncoming);
		return (u_char *) &StorageTmp->x25VCThroughputClassIncoming;
	case X25VCTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25VCThroughputClassOutgoing;
		*var_len = sizeof(StorageTmp->x25VCThroughputClassOutgoing);
		return (u_char *) &StorageTmp->x25VCThroughputClassOutgoing;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25VCDTETable(void)
 * @brief refresh the scalar values of the x25VCDTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25VCDTETable(void)
{
	if (x25VCDTETable_refresh == 0)
		return;
	x25VCDTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25VCDTETable_row(struct x25VCDTETable_data *StorageTmp)
 * @brief refresh the contents of the x25VCDTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25VCDTETable_row(struct x25VCDTETable_data *StorageTmp)
{
	if (StorageTmp->x25VCDTETable_request == sa_request)
		return;
	StorageTmp->x25VCDTETable_request = sa_request;
}

/**
 * @fn u_char *var_x25VCDTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25VCDTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25VCDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		  WriteMethod ** write_method)
{
	struct x25VCDTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25VCDTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25VCDTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25VCDTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25VCDTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25VCDTEOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEOctetsReceived);
		return (u_char *) &StorageTmp->x25VCDTEOctetsReceived;
	case X25VCDTEOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEOctetsSent);
		return (u_char *) &StorageTmp->x25VCDTEOctetsSent;
	case X25VCDTEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEDataPacketsReceived);
		return (u_char *) &StorageTmp->x25VCDTEDataPacketsReceived;
	case X25VCDTEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEDataPacketsSent);
		return (u_char *) &StorageTmp->x25VCDTEDataPacketsSent;
	case X25VCDTEDATATIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEDataTimeouts);
		return (u_char *) &StorageTmp->x25VCDTEDataTimeouts;
	case X25VCDTEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEInterruptPacketsReceived);
		return (u_char *) &StorageTmp->x25VCDTEInterruptPacketsReceived;
	case X25VCDTEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEInterruptPacketsSent);
		return (u_char *) &StorageTmp->x25VCDTEInterruptPacketsSent;
	case X25VCDTEINTERRUPTTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEInterruptTimeouts);
		return (u_char *) &StorageTmp->x25VCDTEInterruptTimeouts;
	case X25VCDTEPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEProviderResets);
		return (u_char *) &StorageTmp->x25VCDTEProviderResets;
	case X25VCDTEREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTERemoteResets);
		return (u_char *) &StorageTmp->x25VCDTERemoteResets;
	case X25VCDTERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDTEResetTimeouts);
		return (u_char *) &StorageTmp->x25VCDTEResetTimeouts;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25VCDCETable(void)
 * @brief refresh the scalar values of the x25VCDCETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25VCDCETable(void)
{
	if (x25VCDCETable_refresh == 0)
		return;
	x25VCDCETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25VCDCETable_row(struct x25VCDCETable_data *StorageTmp)
 * @brief refresh the contents of the x25VCDCETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25VCDCETable_row(struct x25VCDCETable_data *StorageTmp)
{
	if (StorageTmp->x25VCDCETable_request == sa_request)
		return;
	StorageTmp->x25VCDCETable_request = sa_request;
}

/**
 * @fn u_char *var_x25VCDCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25VCDCETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25VCDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		  WriteMethod ** write_method)
{
	struct x25VCDCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25VCDCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25VCDCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25VCDCETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25VCDCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25VCDCEOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEOctetsReceived);
		return (u_char *) &StorageTmp->x25VCDCEOctetsReceived;
	case X25VCDCEOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEOctetsSent);
		return (u_char *) &StorageTmp->x25VCDCEOctetsSent;
	case X25VCDCEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEDataPacketsReceived);
		return (u_char *) &StorageTmp->x25VCDCEDataPacketsReceived;
	case X25VCDCEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEDataPacketsSent);
		return (u_char *) &StorageTmp->x25VCDCEDataPacketsSent;
	case X25VCDCEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEInterruptPacketsReceived);
		return (u_char *) &StorageTmp->x25VCDCEInterruptPacketsReceived;
	case X25VCDCEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEInterruptPacketsSent);
		return (u_char *) &StorageTmp->x25VCDCEInterruptPacketsSent;
	case X25VCDCEPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEProviderResets);
		return (u_char *) &StorageTmp->x25VCDCEProviderResets;
	case X25VCDCEREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCERemoteResets);
		return (u_char *) &StorageTmp->x25VCDCERemoteResets;
	case X25VCDCERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEResetTimeouts);
		return (u_char *) &StorageTmp->x25VCDCEResetTimeouts;
	case X25VCDCEREMOTERESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCERemoteRestarts);
		return (u_char *) &StorageTmp->x25VCDCERemoteRestarts;
	case X25VCDCEPROVIDERDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEProviderDisconnects);
		return (u_char *) &StorageTmp->x25VCDCEProviderDisconnects;
	case X25VCDCEX25SEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEX25SegmentsReceived);
		return (u_char *) &StorageTmp->x25VCDCEX25SegmentsReceived;
	case X25VCDCEX25SEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDCEX25SegmentsSent);
		return (u_char *) &StorageTmp->x25VCDCEX25SegmentsSent;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25VCDXETable(void)
 * @brief refresh the scalar values of the x25VCDXETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25VCDXETable(void)
{
	if (x25VCDXETable_refresh == 0)
		return;
	x25VCDXETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25VCDXETable_row(struct x25VCDXETable_data *StorageTmp)
 * @brief refresh the contents of the x25VCDXETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25VCDXETable_row(struct x25VCDXETable_data *StorageTmp)
{
	if (StorageTmp->x25VCDXETable_request == sa_request)
		return;
	StorageTmp->x25VCDXETable_request = sa_request;
}

/**
 * @fn u_char *var_x25VCDXETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25VCDXETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25VCDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		  WriteMethod ** write_method)
{
	struct x25VCDXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25VCDXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25VCDXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25VCDXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25VCDXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25VCDXEOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEOctetsReceived);
		return (u_char *) &StorageTmp->x25VCDXEOctetsReceived;
	case X25VCDXEOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEOctetsSent);
		return (u_char *) &StorageTmp->x25VCDXEOctetsSent;
	case X25VCDXEDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEDataPacketsReceived);
		return (u_char *) &StorageTmp->x25VCDXEDataPacketsReceived;
	case X25VCDXEDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEDataPacketsSent);
		return (u_char *) &StorageTmp->x25VCDXEDataPacketsSent;
	case X25VCDXEDATATIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEDataTimeouts);
		return (u_char *) &StorageTmp->x25VCDXEDataTimeouts;
	case X25VCDXEINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEInterruptPacketsReceived);
		return (u_char *) &StorageTmp->x25VCDXEInterruptPacketsReceived;
	case X25VCDXEINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEInterruptPacketsSent);
		return (u_char *) &StorageTmp->x25VCDXEInterruptPacketsSent;
	case X25VCDXEINTERRUPTTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEInterruptTimeouts);
		return (u_char *) &StorageTmp->x25VCDXEInterruptTimeouts;
	case X25VCDXEPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEProviderResets);
		return (u_char *) &StorageTmp->x25VCDXEProviderResets;
	case X25VCDXEREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXERemoteResets);
		return (u_char *) &StorageTmp->x25VCDXERemoteResets;
	case X25VCDXERESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25VCDXEResetTimeouts);
		return (u_char *) &StorageTmp->x25VCDXEResetTimeouts;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PVCDTETable(void)
 * @brief refresh the scalar values of the x25PVCDTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PVCDTETable(void)
{
	if (x25PVCDTETable_refresh == 0)
		return;
	x25PVCDTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PVCDTETable_row(struct x25PVCDTETable_data *StorageTmp)
 * @brief refresh the contents of the x25PVCDTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PVCDTETable_row(struct x25PVCDTETable_data *StorageTmp)
{
	if (StorageTmp->x25PVCDTETable_request == sa_request)
		return;
	StorageTmp->x25PVCDTETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PVCDTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PVCDTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PVCDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PVCDTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PVCDTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PVCDTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PVCDTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PVCDTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PVCDTELOGICALCHANNEL:
		*write_method = write_x25PVCDTELogicalChannel;
		*var_len = sizeof(StorageTmp->x25PVCDTELogicalChannel);
		return (u_char *) &StorageTmp->x25PVCDTELogicalChannel;
	case X25PVCDTEROWSTATUS:
		*write_method = write_x25PVCDTERowStatus;
		*var_len = sizeof(StorageTmp->x25PVCDTERowStatus);
		return (u_char *) &StorageTmp->x25PVCDTERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PVCDCETable(void)
 * @brief refresh the scalar values of the x25PVCDCETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PVCDCETable(void)
{
	if (x25PVCDCETable_refresh == 0)
		return;
	x25PVCDCETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PVCDCETable_row(struct x25PVCDCETable_data *StorageTmp)
 * @brief refresh the contents of the x25PVCDCETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PVCDCETable_row(struct x25PVCDCETable_data *StorageTmp)
{
	if (StorageTmp->x25PVCDCETable_request == sa_request)
		return;
	StorageTmp->x25PVCDCETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PVCDCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PVCDCETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PVCDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PVCDCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PVCDCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PVCDCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PVCDCETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PVCDCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PVCDCELOGICALCHANNEL:
		*write_method = write_x25PVCDCELogicalChannel;
		*var_len = sizeof(StorageTmp->x25PVCDCELogicalChannel);
		return (u_char *) &StorageTmp->x25PVCDCELogicalChannel;
	case X25PVCDCECHARGINGDIRECTION:
		*write_method = write_x25PVCDCEChargingDirection;
		*var_len = sizeof(StorageTmp->x25PVCDCEChargingDirection);
		return (u_char *) &StorageTmp->x25PVCDCEChargingDirection;
	case X25PVCDCEOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PVCDCEOperationalState);
		return (u_char *) &StorageTmp->x25PVCDCEOperationalState;
	case X25PVCDCEREMOTEDTEADDRESS:
		*write_method = write_x25PVCDCERemoteDTEAddress;
		*var_len = StorageTmp->x25PVCDCERemoteDTEAddressLen;
		return (u_char *) StorageTmp->x25PVCDCERemoteDTEAddress;
	case X25PVCDCEREMOTELOGICALCHANNEL:
		*write_method = write_x25PVCDCERemoteLogicalChannel;
		*var_len = sizeof(StorageTmp->x25PVCDCERemoteLogicalChannel);
		return (u_char *) &StorageTmp->x25PVCDCERemoteLogicalChannel;
	case X25PVCDCEROWSTATUS:
		*write_method = write_x25PVCDCERowStatus;
		*var_len = sizeof(StorageTmp->x25PVCDCERowStatus);
		return (u_char *) &StorageTmp->x25PVCDCERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PVCDXETable(void)
 * @brief refresh the scalar values of the x25PVCDXETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PVCDXETable(void)
{
	if (x25PVCDXETable_refresh == 0)
		return;
	x25PVCDXETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PVCDXETable_row(struct x25PVCDXETable_data *StorageTmp)
 * @brief refresh the contents of the x25PVCDXETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PVCDXETable_row(struct x25PVCDXETable_data *StorageTmp)
{
	if (StorageTmp->x25PVCDXETable_request == sa_request)
		return;
	StorageTmp->x25PVCDXETable_request = sa_request;
}

/**
 * @fn u_char *var_x25PVCDXETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PVCDXETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PVCDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25PVCDXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PVCDXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PVCDXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PVCDXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PVCDXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PVCDXELOGICALCHANNEL:
		*write_method = write_x25PVCDXELogicalChannel;
		*var_len = sizeof(StorageTmp->x25PVCDXELogicalChannel);
		return (u_char *) &StorageTmp->x25PVCDXELogicalChannel;
	case X25PVCDXEROWSTATUS:
		*write_method = write_x25PVCDXERowStatus;
		*var_len = sizeof(StorageTmp->x25PVCDXERowStatus);
		return (u_char *) &StorageTmp->x25PVCDXERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25SVCIVMOTable(void)
 * @brief refresh the scalar values of the x25SVCIVMOTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25SVCIVMOTable(void)
{
	if (x25SVCIVMOTable_refresh == 0)
		return;
	x25SVCIVMOTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25SVCIVMOTable_row(struct x25SVCIVMOTable_data *StorageTmp)
 * @brief refresh the contents of the x25SVCIVMOTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25SVCIVMOTable_row(struct x25SVCIVMOTable_data *StorageTmp)
{
	if (StorageTmp->x25SVCIVMOTable_request == sa_request)
		return;
	StorageTmp->x25SVCIVMOTable_request = sa_request;
}

/**
 * @fn u_char *var_x25SVCIVMOTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25SVCIVMOTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25SVCIVMOTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		    WriteMethod ** write_method)
{
	struct x25SVCIVMOTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCIVMOTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCIVMOTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCIVMOTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25SVCIVMOID:
		*write_method = write_x25SVCIVMOId;
		*var_len = StorageTmp->x25SVCIVMOIdLen;
		return (u_char *) StorageTmp->x25SVCIVMOId;
	case X25SVCIVMOFASTSELECT:
		*write_method = write_x25SVCIVMOFastSelect;
		*var_len = sizeof(StorageTmp->x25SVCIVMOFastSelect);
		return (u_char *) &StorageTmp->x25SVCIVMOFastSelect;
	case X25SVCIVMOPACKETSIZEINCOMING:
		*write_method = write_x25SVCIVMOPacketSizeIncoming;
		*var_len = sizeof(StorageTmp->x25SVCIVMOPacketSizeIncoming);
		return (u_char *) &StorageTmp->x25SVCIVMOPacketSizeIncoming;
	case X25SVCIVMOPACKETSIZEOUTGOING:
		*write_method = write_x25SVCIVMOPacketSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25SVCIVMOPacketSizeOutgoing);
		return (u_char *) &StorageTmp->x25SVCIVMOPacketSizeOutgoing;
	case X25SVCIVMOREVERSECHARGING:
		*write_method = write_x25SVCIVMOReverseCharging;
		*var_len = sizeof(StorageTmp->x25SVCIVMOReverseCharging);
		return (u_char *) &StorageTmp->x25SVCIVMOReverseCharging;
	case X25SVCIVMOTHROUGHPUTCLASSINCOMING:
		*write_method = write_x25SVCIVMOThroughputClassIncoming;
		*var_len = sizeof(StorageTmp->x25SVCIVMOThroughputClassIncoming);
		return (u_char *) &StorageTmp->x25SVCIVMOThroughputClassIncoming;
	case X25SVCIVMOTHROUGHPUTCLASSOUTGOING:
		*write_method = write_x25SVCIVMOThroughputClassOutgoing;
		*var_len = sizeof(StorageTmp->x25SVCIVMOThroughputClassOutgoing);
		return (u_char *) &StorageTmp->x25SVCIVMOThroughputClassOutgoing;
	case X25SVCIVMOWINDOWSIZEINCOMING:
		*write_method = write_x25SVCIVMOWindowSizeIncoming;
		*var_len = sizeof(StorageTmp->x25SVCIVMOWindowSizeIncoming);
		return (u_char *) &StorageTmp->x25SVCIVMOWindowSizeIncoming;
	case X25SVCIVMOWINDOWSIZEOUTGOING:
		*write_method = write_x25SVCIVMOWindowSizeOutgoing;
		*var_len = sizeof(StorageTmp->x25SVCIVMOWindowSizeOutgoing);
		return (u_char *) &StorageTmp->x25SVCIVMOWindowSizeOutgoing;
	case X25SVCIVMOROWSTATUS:
		*write_method = write_x25SVCIVMORowStatus;
		*var_len = sizeof(StorageTmp->x25SVCIVMORowStatus);
		return (u_char *) &StorageTmp->x25SVCIVMORowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25SVCIVMODTETable(void)
 * @brief refresh the scalar values of the x25SVCIVMODTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25SVCIVMODTETable(void)
{
	if (x25SVCIVMODTETable_refresh == 0)
		return;
	x25SVCIVMODTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25SVCIVMODTETable_row(struct x25SVCIVMODTETable_data *StorageTmp)
 * @brief refresh the contents of the x25SVCIVMODTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25SVCIVMODTETable_row(struct x25SVCIVMODTETable_data *StorageTmp)
{
	if (StorageTmp->x25SVCIVMODTETable_request == sa_request)
		return;
	StorageTmp->x25SVCIVMODTETable_request = sa_request;
}

/**
 * @fn u_char *var_x25SVCIVMODTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25SVCIVMODTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25SVCIVMODTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCIVMODTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCIVMODTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCIVMODTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25SVCIVMODTECALLTIME:
		*write_method = write_x25SVCIVMODTECallTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTECallTime);
		return (u_char *) &StorageTmp->x25SVCIVMODTECallTime;
	case X25SVCIVMODTERESETTIME:
		*write_method = write_x25SVCIVMODTEResetTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEResetTime);
		return (u_char *) &StorageTmp->x25SVCIVMODTEResetTime;
	case X25SVCIVMODTERESETCOUNT:
		*write_method = write_x25SVCIVMODTEResetCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEResetCount);
		return (u_char *) &StorageTmp->x25SVCIVMODTEResetCount;
	case X25SVCIVMODTEINTERRUPTTIME:
		*write_method = write_x25SVCIVMODTEInterruptTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEInterruptTime);
		return (u_char *) &StorageTmp->x25SVCIVMODTEInterruptTime;
	case X25SVCIVMODTECLEARTIME:
		*write_method = write_x25SVCIVMODTEClearTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEClearTime);
		return (u_char *) &StorageTmp->x25SVCIVMODTEClearTime;
	case X25SVCIVMODTECLEARCOUNT:
		*write_method = write_x25SVCIVMODTEClearCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEClearCount);
		return (u_char *) &StorageTmp->x25SVCIVMODTEClearCount;
	case X25SVCIVMODTEWINDOWTIME:
		*write_method = write_x25SVCIVMODTEWindowTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEWindowTime);
		return (u_char *) &StorageTmp->x25SVCIVMODTEWindowTime;
	case X25SVCIVMODTEDATATIME:
		*write_method = write_x25SVCIVMODTEDataTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEDataTime);
		return (u_char *) &StorageTmp->x25SVCIVMODTEDataTime;
	case X25SVCIVMODTEDATACOUNT:
		*write_method = write_x25SVCIVMODTEDataCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTEDataCount);
		return (u_char *) &StorageTmp->x25SVCIVMODTEDataCount;
	case X25SVCIVMODTEREJECTTIME:
		*write_method = write_x25SVCIVMODTERejectTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTERejectTime);
		return (u_char *) &StorageTmp->x25SVCIVMODTERejectTime;
	case X25SVCIVMODTEREJECTCOUNT:
		*write_method = write_x25SVCIVMODTERejectCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTERejectCount);
		return (u_char *) &StorageTmp->x25SVCIVMODTERejectCount;
	case X25SVCIVMODTEROWSTATUS:
		*write_method = write_x25SVCIVMODTERowStatus;
		*var_len = sizeof(StorageTmp->x25SVCIVMODTERowStatus);
		return (u_char *) &StorageTmp->x25SVCIVMODTERowStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25SVCIVMODXETable(void)
 * @brief refresh the scalar values of the x25SVCIVMODXETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25SVCIVMODXETable(void)
{
	if (x25SVCIVMODXETable_refresh == 0)
		return;
	x25SVCIVMODXETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25SVCIVMODXETable_row(struct x25SVCIVMODXETable_data *StorageTmp)
 * @brief refresh the contents of the x25SVCIVMODXETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25SVCIVMODXETable_row(struct x25SVCIVMODXETable_data *StorageTmp)
{
	if (StorageTmp->x25SVCIVMODXETable_request == sa_request)
		return;
	StorageTmp->x25SVCIVMODXETable_request = sa_request;
}

/**
 * @fn u_char *var_x25SVCIVMODXETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25SVCIVMODXETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25SVCIVMODXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		       WriteMethod ** write_method)
{
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCIVMODXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCIVMODXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCIVMODXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25SVCIVMODXECALLTIME:
		*write_method = write_x25SVCIVMODXECallTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXECallTime);
		return (u_char *) &StorageTmp->x25SVCIVMODXECallTime;
	case X25SVCIVMODXERESETTIME:
		*write_method = write_x25SVCIVMODXEResetTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEResetTime);
		return (u_char *) &StorageTmp->x25SVCIVMODXEResetTime;
	case X25SVCIVMODXECLEARTIME:
		*write_method = write_x25SVCIVMODXEClearTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEClearTime);
		return (u_char *) &StorageTmp->x25SVCIVMODXEClearTime;
	case X25SVCIVMODXEINTERRUPTTIME:
		*write_method = write_x25SVCIVMODXEInterruptTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEInterruptTime);
		return (u_char *) &StorageTmp->x25SVCIVMODXEInterruptTime;
	case X25SVCIVMODXERESETCOUNT:
		*write_method = write_x25SVCIVMODXEResetCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEResetCount);
		return (u_char *) &StorageTmp->x25SVCIVMODXEResetCount;
	case X25SVCIVMODXECLEARCOUNT:
		*write_method = write_x25SVCIVMODXEClearCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEClearCount);
		return (u_char *) &StorageTmp->x25SVCIVMODXEClearCount;
	case X25SVCIVMODXEROWSTATUS:
		*write_method = write_x25SVCIVMODXERowStatus;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXERowStatus);
		return (u_char *) &StorageTmp->x25SVCIVMODXERowStatus;
	case X25SVCIVMODXEWINDOWTIME:
		*write_method = write_x25SVCIVMODXEWindowTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEWindowTime);
		return (u_char *) &StorageTmp->x25SVCIVMODXEWindowTime;
	case X25SVCIVMODXEDATATIME:
		*write_method = write_x25SVCIVMODXEDataTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEDataTime);
		return (u_char *) &StorageTmp->x25SVCIVMODXEDataTime;
	case X25SVCIVMODXEDATACOUNT:
		*write_method = write_x25SVCIVMODXEDataCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXEDataCount);
		return (u_char *) &StorageTmp->x25SVCIVMODXEDataCount;
	case X25SVCIVMODXEREJECTTIME:
		*write_method = write_x25SVCIVMODXERejectTime;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXERejectTime);
		return (u_char *) &StorageTmp->x25SVCIVMODXERejectTime;
	case X25SVCIVMODXEREJECTCOUNT:
		*write_method = write_x25SVCIVMODXERejectCount;
		*var_len = sizeof(StorageTmp->x25SVCIVMODXERejectCount);
		return (u_char *) &StorageTmp->x25SVCIVMODXERejectCount;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25SVCDTETable(void)
 * @brief refresh the scalar values of the x25SVCDTETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25SVCDTETable(void)
{
	if (x25SVCDTETable_refresh == 0)
		return;
	x25SVCDTETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25SVCDTETable_row(struct x25SVCDTETable_data *StorageTmp)
 * @brief refresh the contents of the x25SVCDTETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25SVCDTETable_row(struct x25SVCDTETable_data *StorageTmp)
{
	if (StorageTmp->x25SVCDTETable_request == sa_request)
		return;
	StorageTmp->x25SVCDTETable_request = sa_request;
}

/**
 * @fn u_char *var_x25SVCDTETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25SVCDTETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25SVCDTETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25SVCDTETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCDTETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCDTETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCDTETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCDTETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25SVCDTECALLINGADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDTECallingAddressExtension;
		return (u_char *) StorageTmp->x25SVCDTECallingAddressExtension;
	case X25SVCDTECALLEDADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDTECalledAddressExtension;
		return (u_char *) StorageTmp->x25SVCDTECalledAddressExtension;
	case X25SVCDTEDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDTEDirection);
		return (u_char *) &StorageTmp->x25SVCDTEDirection;
	case X25SVCDTEFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDTEFastSelect);
		return (u_char *) &StorageTmp->x25SVCDTEFastSelect;
	case X25SVCDTEORIGINALLYCALLEDADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDTEOriginallyCalledAddressLen;
		return (u_char *) StorageTmp->x25SVCDTEOriginallyCalledAddress;
	case X25SVCDTEREDIRECTREASON:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDTERedirectReason);
		return (u_char *) &StorageTmp->x25SVCDTERedirectReason;
	case X25SVCDTEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDTERemoteDTEAddressLen;
		return (u_char *) StorageTmp->x25SVCDTERemoteDTEAddress;
	case X25SVCDTEREVERSECHARGING:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDTEReverseCharging);
		return (u_char *) &StorageTmp->x25SVCDTEReverseCharging;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25SVCDCETable(void)
 * @brief refresh the scalar values of the x25SVCDCETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25SVCDCETable(void)
{
	if (x25SVCDCETable_refresh == 0)
		return;
	x25SVCDCETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25SVCDCETable_row(struct x25SVCDCETable_data *StorageTmp)
 * @brief refresh the contents of the x25SVCDCETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25SVCDCETable_row(struct x25SVCDCETable_data *StorageTmp)
{
	if (StorageTmp->x25SVCDCETable_request == sa_request)
		return;
	StorageTmp->x25SVCDCETable_request = sa_request;
}

/**
 * @fn u_char *var_x25SVCDCETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25SVCDCETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25SVCDCETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25SVCDCETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCDCETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCDCETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCDCETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCDCETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25SVCDCECHARGINGDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDCEChargingDirection);
		return (u_char *) &StorageTmp->x25SVCDCEChargingDirection;
	case X25SVCDCECUGSELECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDCECUGSelection);
		return (u_char *) &StorageTmp->x25SVCDCECUGSelection;
	case X25SVCDCEDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDCEDirection);
		return (u_char *) &StorageTmp->x25SVCDCEDirection;
	case X25SVCDCEFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDCEFastSelect);
		return (u_char *) &StorageTmp->x25SVCDCEFastSelect;
	case X25SVCDCEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDCERemoteDTEAddressLen;
		return (u_char *) StorageTmp->x25SVCDCERemoteDTEAddress;
	case X25SVCDCETRANSITDELAYSELECTIONANDINDICATION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDCETransitDelaySelectionAndIndication);
		return (u_char *) &StorageTmp->x25SVCDCETransitDelaySelectionAndIndication;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25SVCDXETable(void)
 * @brief refresh the scalar values of the x25SVCDXETable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25SVCDXETable(void)
{
	if (x25SVCDXETable_refresh == 0)
		return;
	x25SVCDXETable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25SVCDXETable_row(struct x25SVCDXETable_data *StorageTmp)
 * @brief refresh the contents of the x25SVCDXETable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25SVCDXETable_row(struct x25SVCDXETable_data *StorageTmp)
{
	if (StorageTmp->x25SVCDXETable_request == sa_request)
		return;
	StorageTmp->x25SVCDXETable_request = sa_request;
}

/**
 * @fn u_char *var_x25SVCDXETable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25SVCDXETable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25SVCDXETable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		   WriteMethod ** write_method)
{
	struct x25SVCDXETable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25SVCDXETable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25SVCDXETable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25SVCDXETableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25SVCDXETable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25SVCDXEDIRECTION:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDXEDirection);
		return (u_char *) &StorageTmp->x25SVCDXEDirection;
	case X25SVCDXEREMOTEDTEADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDXERemoteDTEAddressLen;
		return (u_char *) StorageTmp->x25SVCDXERemoteDTEAddress;
	case X25SVCDXEFASTSELECT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDXEFastSelect);
		return (u_char *) &StorageTmp->x25SVCDXEFastSelect;
	case X25SVCDXEREDIRECTREASON:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25SVCDXERedirectReason);
		return (u_char *) &StorageTmp->x25SVCDXERedirectReason;
	case X25SVCDXEORIGINALLYCALLEDADDRESS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDXEOriginallyCalledAddressLen;
		return (u_char *) StorageTmp->x25SVCDXEOriginallyCalledAddress;
	case X25SVCDXECALLINGADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDXECallingAddressExtension;
		return (u_char *) StorageTmp->x25SVCDXECallingAddressExtension;
	case X25SVCDXECALLEDADDRESSEXTENSION:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25SVCDXECalledAddressExtension;
		return (u_char *) StorageTmp->x25SVCDXECalledAddressExtension;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25DSCTable(void)
 * @brief refresh the scalar values of the x25DSCTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25DSCTable(void)
{
	if (x25DSCTable_refresh == 0)
		return;
	x25DSCTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25DSCTable_row(struct x25DSCTable_data *StorageTmp)
 * @brief refresh the contents of the x25DSCTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25DSCTable_row(struct x25DSCTable_data *StorageTmp)
{
	if (StorageTmp->x25DSCTable_request == sa_request)
		return;
	StorageTmp->x25DSCTable_request = sa_request;
}

/**
 * @fn u_char *var_x25DSCTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25DSCTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25DSCTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
		WriteMethod ** write_method)
{
	struct x25DSCTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25DSCTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25DSCTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25DSCTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25DSCTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25DSCID:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->x25DSCIdLen;
		return (u_char *) StorageTmp->x25DSCId;
	case X25DSCRESETREQUESTINDICATIONPACKETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25DSCResetRequestIndicationPackets);
		return (u_char *) &StorageTmp->x25DSCResetRequestIndicationPackets;
	case X25DSCSEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25DSCSegmentsSent);
		return (u_char *) &StorageTmp->x25DSCSegmentsSent;
	case X25DSCSEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25DSCSegmentsReceived);
		return (u_char *) &StorageTmp->x25DSCSegmentsReceived;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEDTEStatsTable(void)
 * @brief refresh the scalar values of the x25PLEDTEStatsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEDTEStatsTable(void)
{
	if (x25PLEDTEStatsTable_refresh == 0)
		return;
	x25PLEDTEStatsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEDTEStatsTable_row(struct x25PLEDTEStatsTable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEDTEStatsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEDTEStatsTable_row(struct x25PLEDTEStatsTable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDTEStatsTable_request == sa_request)
		return;
	StorageTmp->x25PLEDTEStatsTable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEDTEStatsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEDTEStatsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLEDTEStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
			WriteMethod ** write_method)
{
	struct x25PLEDTEStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDTEStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDTEStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDTEStatsTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDTEStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEDTESTATSCALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsCallAttempts);
		return (u_char *) &StorageTmp->x25PLEDTEStatsCallAttempts;
	case X25PLEDTESTATSPROTOCOLERRORSDETECTEDLOCALLY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsProtocolErrorsDetectedLocally);
		return (u_char *) &StorageTmp->x25PLEDTEStatsProtocolErrorsDetectedLocally;
	case X25PLEDTESTATSPROTOCOLERRORSACCUSEDOF:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsProtocolErrorsAccusedOf);
		return (u_char *) &StorageTmp->x25PLEDTEStatsProtocolErrorsAccusedOf;
	case X25PLEDTESTATSCALLCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsCallCountsExceeded);
		return (u_char *) &StorageTmp->x25PLEDTEStatsCallCountsExceeded;
	case X25PLEDTESTATSOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsOctetsReceived);
		return (u_char *) &StorageTmp->x25PLEDTEStatsOctetsReceived;
	case X25PLEDTESTATSOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsOctetsSent);
		return (u_char *) &StorageTmp->x25PLEDTEStatsOctetsSent;
	case X25PLEDTESTATSCALLTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsCallTimeouts);
		return (u_char *) &StorageTmp->x25PLEDTEStatsCallTimeouts;
	case X25PLEDTESTATSCALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsCallsConnected);
		return (u_char *) &StorageTmp->x25PLEDTEStatsCallsConnected;
	case X25PLEDTESTATSDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsDataPacketsReceived);
		return (u_char *) &StorageTmp->x25PLEDTEStatsDataPacketsReceived;
	case X25PLEDTESTATSDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsDataPacketsSent);
		return (u_char *) &StorageTmp->x25PLEDTEStatsDataPacketsSent;
	case X25PLEDTESTATSDATATIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsDataTimeouts);
		return (u_char *) &StorageTmp->x25PLEDTEStatsDataTimeouts;
	case X25PLEDTESTATSPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsProviderResets);
		return (u_char *) &StorageTmp->x25PLEDTEStatsProviderResets;
	case X25PLEDTESTATSPROVIDERDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsProviderDisconnects);
		return (u_char *) &StorageTmp->x25PLEDTEStatsProviderDisconnects;
	case X25PLEDTESTATSREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsRemoteResets);
		return (u_char *) &StorageTmp->x25PLEDTEStatsRemoteResets;
	case X25PLEDTESTATSREMOTERESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsRemoteRestarts);
		return (u_char *) &StorageTmp->x25PLEDTEStatsRemoteRestarts;
	case X25PLEDTESTATSRESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsResetTimeouts);
		return (u_char *) &StorageTmp->x25PLEDTEStatsResetTimeouts;
	case X25PLEDTESTATSRESTARTCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsRestartCountsExceeded);
		return (u_char *) &StorageTmp->x25PLEDTEStatsRestartCountsExceeded;
	case X25PLEDTESTATSCLEARTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsClearTimeouts);
		return (u_char *) &StorageTmp->x25PLEDTEStatsClearTimeouts;
	case X25PLEDTESTATSCLEARCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDTEStatsClearCountsExceeded);
		return (u_char *) &StorageTmp->x25PLEDTEStatsClearCountsExceeded;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEDCEStatsTable(void)
 * @brief refresh the scalar values of the x25PLEDCEStatsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEDCEStatsTable(void)
{
	if (x25PLEDCEStatsTable_refresh == 0)
		return;
	x25PLEDCEStatsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEDCEStatsTable_row(struct x25PLEDCEStatsTable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEDCEStatsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEDCEStatsTable_row(struct x25PLEDCEStatsTable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDCEStatsTable_request == sa_request)
		return;
	StorageTmp->x25PLEDCEStatsTable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEDCEStatsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEDCEStatsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLEDCEStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
			WriteMethod ** write_method)
{
	struct x25PLEDCEStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDCEStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDCEStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDCEStatsTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDCEStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEDCESTATSCALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsCallAttempts);
		return (u_char *) &StorageTmp->x25PLEDCEStatsCallAttempts;
	case X25PLEDCESTATSCALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsCallsConnected);
		return (u_char *) &StorageTmp->x25PLEDCEStatsCallsConnected;
	case X25PLEDCESTATSOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsOctetsReceived);
		return (u_char *) &StorageTmp->x25PLEDCEStatsOctetsReceived;
	case X25PLEDCESTATSOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsOctetsSent);
		return (u_char *) &StorageTmp->x25PLEDCEStatsOctetsSent;
	case X25PLEDCESTATSDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsDataPacketsReceived);
		return (u_char *) &StorageTmp->x25PLEDCEStatsDataPacketsReceived;
	case X25PLEDCESTATSDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsDataPacketsSent);
		return (u_char *) &StorageTmp->x25PLEDCEStatsDataPacketsSent;
	case X25PLEDCESTATSINTERRUPTPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsInterruptPacketsReceived);
		return (u_char *) &StorageTmp->x25PLEDCEStatsInterruptPacketsReceived;
	case X25PLEDCESTATSINTERRUPTPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsInterruptPacketsSent);
		return (u_char *) &StorageTmp->x25PLEDCEStatsInterruptPacketsSent;
	case X25PLEDCESTATSPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsProviderResets);
		return (u_char *) &StorageTmp->x25PLEDCEStatsProviderResets;
	case X25PLEDCESTATSPROVIDERDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsProviderDisconnects);
		return (u_char *) &StorageTmp->x25PLEDCEStatsProviderDisconnects;
	case X25PLEDCESTATSREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsRemoteResets);
		return (u_char *) &StorageTmp->x25PLEDCEStatsRemoteResets;
	case X25PLEDCESTATSREMOTERESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsRemoteRestarts);
		return (u_char *) &StorageTmp->x25PLEDCEStatsRemoteRestarts;
	case X25PLEDCESTATSRESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsResetTimeouts);
		return (u_char *) &StorageTmp->x25PLEDCEStatsResetTimeouts;
	case X25PLEDCESTATSX25SEGMENTSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsX25SegmentsReceived);
		return (u_char *) &StorageTmp->x25PLEDCEStatsX25SegmentsReceived;
	case X25PLEDCESTATSX25SEGMENTSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDCEStatsX25SegmentsSent);
		return (u_char *) &StorageTmp->x25PLEDCEStatsX25SegmentsSent;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_x25PLEDXEStatsTable(void)
 * @brief refresh the scalar values of the x25PLEDXEStatsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_x25PLEDXEStatsTable(void)
{
	if (x25PLEDXEStatsTable_refresh == 0)
		return;
	x25PLEDXEStatsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_x25PLEDXEStatsTable_row(struct x25PLEDXEStatsTable_data *StorageTmp)
 * @brief refresh the contents of the x25PLEDXEStatsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_x25PLEDXEStatsTable_row(struct x25PLEDXEStatsTable_data *StorageTmp)
{
	if (StorageTmp->x25PLEDXEStatsTable_request == sa_request)
		return;
	StorageTmp->x25PLEDXEStatsTable_request = sa_request;
}

/**
 * @fn u_char *var_x25PLEDXEStatsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in x25PLEDXEStatsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_x25PLPMIB above.
 */
u_char *
var_x25PLEDXEStatsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len,
			WriteMethod ** write_method)
{
	struct x25PLEDXEStatsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("x25PLPMIB", "var_x25PLEDXEStatsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_x25PLEDXEStatsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp =
	     header_complex(x25PLEDXEStatsTableStorage, vp, name, length, exact, var_len,
			    write_method)) == NULL)
		return NULL;
	refresh_x25PLEDXEStatsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case X25PLEDXESTATSCALLATTEMPTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsCallAttempts);
		return (u_char *) &StorageTmp->x25PLEDXEStatsCallAttempts;
	case X25PLEDXESTATSPROTOCOLERRORSDETECTEDLOCALLY:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsProtocolErrorsDetectedLocally);
		return (u_char *) &StorageTmp->x25PLEDXEStatsProtocolErrorsDetectedLocally;
	case X25PLEDXESTATSPROTOCOLERRORSACCUSEDOF:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsProtocolErrorsAccusedOf);
		return (u_char *) &StorageTmp->x25PLEDXEStatsProtocolErrorsAccusedOf;
	case X25PLEDXESTATSCALLCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsCallCountsExceeded);
		return (u_char *) &StorageTmp->x25PLEDXEStatsCallCountsExceeded;
	case X25PLEDXESTATSOCTETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsOctetsReceived);
		return (u_char *) &StorageTmp->x25PLEDXEStatsOctetsReceived;
	case X25PLEDXESTATSOCTETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsOctetsSent);
		return (u_char *) &StorageTmp->x25PLEDXEStatsOctetsSent;
	case X25PLEDXESTATSCALLTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsCallTimeouts);
		return (u_char *) &StorageTmp->x25PLEDXEStatsCallTimeouts;
	case X25PLEDXESTATSCALLSCONNECTED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsCallsConnected);
		return (u_char *) &StorageTmp->x25PLEDXEStatsCallsConnected;
	case X25PLEDXESTATSCLEARTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsClearTimeouts);
		return (u_char *) &StorageTmp->x25PLEDXEStatsClearTimeouts;
	case X25PLEDXESTATSDATAPACKETSRECEIVED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsDataPacketsReceived);
		return (u_char *) &StorageTmp->x25PLEDXEStatsDataPacketsReceived;
	case X25PLEDXESTATSDATAPACKETSSENT:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsDataPacketsSent);
		return (u_char *) &StorageTmp->x25PLEDXEStatsDataPacketsSent;
	case X25PLEDXESTATSDATATIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsDataTimeouts);
		return (u_char *) &StorageTmp->x25PLEDXEStatsDataTimeouts;
	case X25PLEDXESTATSPROVIDERRESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsProviderResets);
		return (u_char *) &StorageTmp->x25PLEDXEStatsProviderResets;
	case X25PLEDXESTATSPROVIDERDISCONNECTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsProviderDisconnects);
		return (u_char *) &StorageTmp->x25PLEDXEStatsProviderDisconnects;
	case X25PLEDXESTATSREMOTERESETS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsRemoteResets);
		return (u_char *) &StorageTmp->x25PLEDXEStatsRemoteResets;
	case X25PLEDXESTATSREMOTERESTARTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsRemoteRestarts);
		return (u_char *) &StorageTmp->x25PLEDXEStatsRemoteRestarts;
	case X25PLEDXESTATSRESETTIMEOUTS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsResetTimeouts);
		return (u_char *) &StorageTmp->x25PLEDXEStatsResetTimeouts;
	case X25PLEDXESTATSRESTARTCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsRestartCountsExceeded);
		return (u_char *) &StorageTmp->x25PLEDXEStatsRestartCountsExceeded;
	case X25PLEDXESTATSCLEARCOUNTSEXCEEDED:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->x25PLEDXEStatsClearCountsExceeded);
		return (u_char *) &StorageTmp->x25PLEDXEStatsClearCountsExceeded;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn int write_x25PLEAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEAdministrativeState(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEAdministrativeState entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEADMINISTRATIVESTATE_LOCKED:
		case X25PLEADMINISTRATIVESTATE_UNLOCKED:
		case X25PLEADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEAdministrativeState;
		StorageTmp->x25PLEAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLELocalDTEAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLELocalDTEAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLELocalDTEAddress entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELocalDTEAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..18 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN
		    || ((0 > var_val_len || var_val_len > 18))) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELocalDTEAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLELocalDTEAddress;
		old_length = StorageTmp->x25PLELocalDTEAddressLen;
		StorageTmp->x25PLELocalDTEAddress = string;
		StorageTmp->x25PLELocalDTEAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELocalDTEAddress = old_value;
		StorageTmp->x25PLELocalDTEAddressLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEFacilityNonNegotiable(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEFacilityNonNegotiable(int action, u_char *var_val, u_char var_val_type,
				  size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEFacilityNonNegotiable entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityNonNegotiable not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityNonNegotiable: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEFacilityNonNegotiable;
		old_length = StorageTmp->x25PLEFacilityNonNegotiableLen;
		StorageTmp->x25PLEFacilityNonNegotiable = string;
		StorageTmp->x25PLEFacilityNonNegotiableLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEFacilityNonNegotiable = old_value;
		StorageTmp->x25PLEFacilityNonNegotiableLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEFacilityAvailability(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEFacilityAvailability(int action, u_char *var_val, u_char var_val_type,
				 size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEFacilityAvailability entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityAvailability not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN
		    || var_val_len != ((15 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityAvailability: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (15 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityAvailability: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEFacilityAvailability;
		old_length = StorageTmp->x25PLEFacilityAvailabilityLen;
		StorageTmp->x25PLEFacilityAvailability = string;
		StorageTmp->x25PLEFacilityAvailabilityLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEFacilityAvailability = old_value;
		StorageTmp->x25PLEFacilityAvailabilityLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEFacilityNegotiation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEFacilityNegotiation(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEFacilityNegotiation entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityNegotiation not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN
		    || var_val_len != ((15 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityNegotiation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (15 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityNegotiation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEFacilityNegotiation;
		old_length = StorageTmp->x25PLEFacilityNegotiationLen;
		StorageTmp->x25PLEFacilityNegotiation = string;
		StorageTmp->x25PLEFacilityNegotiationLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEFacilityNegotiation = old_value;
		StorageTmp->x25PLEFacilityNegotiationLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEFacilityWhileIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEFacilityWhileIdle(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEFacilityWhileIdle entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityWhileIdle not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN
		    || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityWhileIdle: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEFacilityWhileIdle: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEFacilityWhileIdle;
		old_length = StorageTmp->x25PLEFacilityWhileIdleLen;
		StorageTmp->x25PLEFacilityWhileIdle = string;
		StorageTmp->x25PLEFacilityWhileIdleLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEFacilityWhileIdle = old_value;
		StorageTmp->x25PLEFacilityWhileIdleLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEPacketSequenceNumbering(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEPacketSequenceNumbering(int action, u_char *var_val, u_char var_val_type,
				    size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEPacketSequenceNumbering entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEPacketSequenceNumbering not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEPacketSequenceNumbering: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEPACKETSEQUENCENUMBERING_DEFAULT:
		case X25PLEPACKETSEQUENCENUMBERING_MODULO8:
		case X25PLEPACKETSEQUENCENUMBERING_MODULO128:
		case X25PLEPACKETSEQUENCENUMBERING_MODULO32768:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEPacketSequenceNumbering: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEPacketSequenceNumbering;
		StorageTmp->x25PLEPacketSequenceNumbering = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEPacketSequenceNumbering = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDefaultPacketSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDefaultPacketSizeIncoming(int action, u_char *var_val, u_char var_val_type,
				      size_t var_val_len, u_char *statP, oid * name,
				      size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDefaultPacketSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultPacketSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDEFAULTPACKETSIZEINCOMING_DEFAULT:
		case X25PLEDEFAULTPACKETSIZEINCOMING_PSIZE16:
		case X25PLEDEFAULTPACKETSIZEINCOMING_PSIZE32:
		case X25PLEDEFAULTPACKETSIZEINCOMING_PSIZE64:
		case X25PLEDEFAULTPACKETSIZEINCOMING_PSIZE128:
		case X25PLEDEFAULTPACKETSIZEINCOMING_PSIZE256:
		case X25PLEDEFAULTPACKETSIZEINCOMING_PSIZE512:
		case X25PLEDEFAULTPACKETSIZEINCOMING_PSIZE1024:
		case X25PLEDEFAULTPACKETSIZEINCOMING_PSIZE2048:
		case X25PLEDEFAULTPACKETSIZEINCOMING_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultPacketSizeIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDefaultPacketSizeIncoming;
		StorageTmp->x25PLEDefaultPacketSizeIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultPacketSizeIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDefaultPacketSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDefaultPacketSizeOutgoing(int action, u_char *var_val, u_char var_val_type,
				      size_t var_val_len, u_char *statP, oid * name,
				      size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDefaultPacketSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultPacketSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDEFAULTPACKETSIZEOUTGOING_DEFAULT:
		case X25PLEDEFAULTPACKETSIZEOUTGOING_PSIZE16:
		case X25PLEDEFAULTPACKETSIZEOUTGOING_PSIZE32:
		case X25PLEDEFAULTPACKETSIZEOUTGOING_PSIZE64:
		case X25PLEDEFAULTPACKETSIZEOUTGOING_PSIZE128:
		case X25PLEDEFAULTPACKETSIZEOUTGOING_PSIZE256:
		case X25PLEDEFAULTPACKETSIZEOUTGOING_PSIZE512:
		case X25PLEDEFAULTPACKETSIZEOUTGOING_PSIZE1024:
		case X25PLEDEFAULTPACKETSIZEOUTGOING_PSIZE2048:
		case X25PLEDEFAULTPACKETSIZEOUTGOING_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultPacketSizeOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDefaultPacketSizeOutgoing;
		StorageTmp->x25PLEDefaultPacketSizeOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultPacketSizeOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDefaultWindowSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDefaultWindowSizeIncoming(int action, u_char *var_val, u_char var_val_type,
				      size_t var_val_len, u_char *statP, oid * name,
				      size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDefaultWindowSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultWindowSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..32768 */
		if ((1 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultWindowSizeIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDefaultWindowSizeIncoming;
		StorageTmp->x25PLEDefaultWindowSizeIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultWindowSizeIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDefaultWindowSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDefaultWindowSizeOutgoing(int action, u_char *var_val, u_char var_val_type,
				      size_t var_val_len, u_char *statP, oid * name,
				      size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDefaultWindowSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultWindowSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..32768 */
		if ((1 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultWindowSizeOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDefaultWindowSizeOutgoing;
		StorageTmp->x25PLEDefaultWindowSizeOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultWindowSizeOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDefaultThroughputClassIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDefaultThroughputClassIncoming(int action, u_char *var_val, u_char var_val_type,
					   size_t var_val_len, u_char *statP, oid * name,
					   size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDefaultThroughputClassIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultThroughputClassIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_DEFAULT:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B75:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B150:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B300:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B600:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1200:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B2400:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B4800:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B9600:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B19200:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B48000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B64000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B128000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B192000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B256000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B320000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B384000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B448000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B512000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B576000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B640000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B704000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B768000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B832000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B896000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B960000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1024000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1088000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1792000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1152000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1216000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1280000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1344000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1408000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1472000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1536000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1600000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1664000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1728000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1856000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1920000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B1984000:
		case X25PLEDEFAULTTHROUGHPUTCLASSINCOMING_B2048000:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultThroughputClassIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDefaultThroughputClassIncoming;
		StorageTmp->x25PLEDefaultThroughputClassIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultThroughputClassIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDefaultThroughputClassOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDefaultThroughputClassOutgoing(int action, u_char *var_val, u_char var_val_type,
					   size_t var_val_len, u_char *statP, oid * name,
					   size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDefaultThroughputClassOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultThroughputClassOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_DEFAULT:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B75:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B150:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B300:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B600:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1200:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B2400:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B4800:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B9600:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B19200:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B48000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B64000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B128000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B192000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B256000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B320000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B384000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B448000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B512000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B576000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B640000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B704000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B768000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B832000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B896000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B960000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1024000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1088000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1792000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1152000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1216000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1280000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1344000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1408000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1472000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1536000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1600000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1664000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1728000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1856000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1920000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B1984000:
		case X25PLEDEFAULTTHROUGHPUTCLASSOUTGOING_B2048000:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDefaultThroughputClassOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDefaultThroughputClassOutgoing;
		StorageTmp->x25PLEDefaultThroughputClassOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDefaultThroughputClassOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLESNServiceProvider(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLESNServiceProvider(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLESNServiceProvider entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLESNServiceProvider not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len
		    || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLESNServiceProvider: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid =
		     snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLESNServiceProvider;
		old_length = StorageTmp->x25PLESNServiceProviderLen;
		StorageTmp->x25PLESNServiceProvider = objid;
		StorageTmp->x25PLESNServiceProviderLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLESNServiceProvider = old_value;
		StorageTmp->x25PLESNServiceProviderLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLESNSAP(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLESNSAP(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		  u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLESNSAP entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLESNSAP not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len
		    || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLESNSAP: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid =
		     snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLESNSAP;
		old_length = StorageTmp->x25PLESNSAPLen;
		StorageTmp->x25PLESNSAP = objid;
		StorageTmp->x25PLESNSAPLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLESNSAP = old_value;
		StorageTmp->x25PLESNSAPLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLELogicalChannelAssignmentHIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLELogicalChannelAssignmentHIC(int action, u_char *var_val, u_char var_val_type,
					size_t var_val_len, u_char *statP, oid * name,
					size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentHIC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHIC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLELogicalChannelAssignmentHIC;
		StorageTmp->x25PLELogicalChannelAssignmentHIC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentHIC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLELogicalChannelAssignmentLIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLELogicalChannelAssignmentLIC(int action, u_char *var_val, u_char var_val_type,
					size_t var_val_len, u_char *statP, oid * name,
					size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentLIC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLIC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLELogicalChannelAssignmentLIC;
		StorageTmp->x25PLELogicalChannelAssignmentLIC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentLIC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLELogicalChannelAssignmentHTC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLELogicalChannelAssignmentHTC(int action, u_char *var_val, u_char var_val_type,
					size_t var_val_len, u_char *statP, oid * name,
					size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentHTC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHTC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHTC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLELogicalChannelAssignmentHTC;
		StorageTmp->x25PLELogicalChannelAssignmentHTC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentHTC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLELogicalChannelAssignmentLTC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLELogicalChannelAssignmentLTC(int action, u_char *var_val, u_char var_val_type,
					size_t var_val_len, u_char *statP, oid * name,
					size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentLTC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLTC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLTC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLELogicalChannelAssignmentLTC;
		StorageTmp->x25PLELogicalChannelAssignmentLTC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentLTC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLELogicalChannelAssignmentHOC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLELogicalChannelAssignmentHOC(int action, u_char *var_val, u_char var_val_type,
					size_t var_val_len, u_char *statP, oid * name,
					size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentHOC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHOC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentHOC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLELogicalChannelAssignmentHOC;
		StorageTmp->x25PLELogicalChannelAssignmentHOC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentHOC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLELogicalChannelAssignmentLOC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLELogicalChannelAssignmentLOC(int action, u_char *var_val, u_char var_val_type,
					size_t var_val_len, u_char *statP, oid * name,
					size_t name_len)
{
	static long old_value;
	struct x25PLETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLELogicalChannelAssignmentLOC entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLOC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLELogicalChannelAssignmentLOC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLELogicalChannelAssignmentLOC;
		StorageTmp->x25PLELogicalChannelAssignmentLOC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLELogicalChannelAssignmentLOC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODefaultPacketSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODefaultPacketSizeIncoming(int action, u_char *var_val, u_char var_val_type,
					  size_t var_val_len, u_char *statP, oid * name,
					  size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultPacketSizeIncoming entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultPacketSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case X25PLEIVMODEFAULTPACKETSIZEINCOMING_DEFAULT:
		case X25PLEIVMODEFAULTPACKETSIZEINCOMING_PSIZE16:
		case X25PLEIVMODEFAULTPACKETSIZEINCOMING_PSIZE32:
		case X25PLEIVMODEFAULTPACKETSIZEINCOMING_PSIZE64:
		case X25PLEIVMODEFAULTPACKETSIZEINCOMING_PSIZE128:
		case X25PLEIVMODEFAULTPACKETSIZEINCOMING_PSIZE256:
		case X25PLEIVMODEFAULTPACKETSIZEINCOMING_PSIZE512:
		case X25PLEIVMODEFAULTPACKETSIZEINCOMING_PSIZE1024:
		case X25PLEIVMODEFAULTPACKETSIZEINCOMING_PSIZE2048:
		case X25PLEIVMODEFAULTPACKETSIZEINCOMING_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultPacketSizeIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODefaultPacketSizeIncoming;
		StorageTmp->x25PLEIVMODefaultPacketSizeIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultPacketSizeIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODefaultPacketSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODefaultPacketSizeOutgoing(int action, u_char *var_val, u_char var_val_type,
					  size_t var_val_len, u_char *statP, oid * name,
					  size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultPacketSizeOutgoing entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultPacketSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case X25PLEIVMODEFAULTPACKETSIZEOUTGOING_DEFAULT:
		case X25PLEIVMODEFAULTPACKETSIZEOUTGOING_PSIZE16:
		case X25PLEIVMODEFAULTPACKETSIZEOUTGOING_PSIZE32:
		case X25PLEIVMODEFAULTPACKETSIZEOUTGOING_PSIZE64:
		case X25PLEIVMODEFAULTPACKETSIZEOUTGOING_PSIZE128:
		case X25PLEIVMODEFAULTPACKETSIZEOUTGOING_PSIZE256:
		case X25PLEIVMODEFAULTPACKETSIZEOUTGOING_PSIZE512:
		case X25PLEIVMODEFAULTPACKETSIZEOUTGOING_PSIZE1024:
		case X25PLEIVMODEFAULTPACKETSIZEOUTGOING_PSIZE2048:
		case X25PLEIVMODEFAULTPACKETSIZEOUTGOING_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultPacketSizeOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing;
		StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultPacketSizeOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODefaultThroughputClassIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODefaultThroughputClassIncoming(int action, u_char *var_val, u_char var_val_type,
					       size_t var_val_len, u_char *statP, oid * name,
					       size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultThroughputClassIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultThroughputClassIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value none ( 0 ) */
		switch (set_value) {
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_DEFAULT:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B75:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B150:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B300:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B600:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1200:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B2400:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B4800:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B9600:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B19200:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B48000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B64000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B128000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B192000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B256000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B320000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B384000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B448000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B512000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B576000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B640000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B704000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B768000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B832000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B896000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B960000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1024000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1088000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1792000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1152000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1216000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1280000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1344000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1408000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1472000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1536000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1600000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1664000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1728000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1856000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1920000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B1984000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSINCOMING_B2048000:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultThroughputClassIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODefaultThroughputClassIncoming;
		StorageTmp->x25PLEIVMODefaultThroughputClassIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultThroughputClassIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODefaultThroughputClassOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODefaultThroughputClassOutgoing(int action, u_char *var_val, u_char var_val_type,
					       size_t var_val_len, u_char *statP, oid * name,
					       size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultThroughputClassOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultThroughputClassOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value none ( 0 ) */
		switch (set_value) {
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_DEFAULT:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B75:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B150:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B300:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B600:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1200:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B2400:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B4800:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B9600:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B19200:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B48000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B64000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B128000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B192000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B256000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B320000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B384000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B448000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B512000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B576000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B640000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B704000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B768000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B832000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B896000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B960000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1024000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1088000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1792000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1152000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1216000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1280000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1344000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1408000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1472000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1536000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1600000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1664000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1728000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1856000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1920000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B1984000:
		case X25PLEIVMODEFAULTTHROUGHPUTCLASSOUTGOING_B2048000:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultThroughputClassOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing;
		StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultThroughputClassOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODefaultWindowSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODefaultWindowSizeIncoming(int action, u_char *var_val, u_char var_val_type,
					  size_t var_val_len, u_char *statP, oid * name,
					  size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultWindowSizeIncoming entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultWindowSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 1..32768 */
		if ((1 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultWindowSizeIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODefaultWindowSizeIncoming;
		StorageTmp->x25PLEIVMODefaultWindowSizeIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultWindowSizeIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODefaultWindowSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODefaultWindowSizeOutgoing(int action, u_char *var_val, u_char var_val_type,
					  size_t var_val_len, u_char *statP, oid * name,
					  size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODefaultWindowSizeOutgoing entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultWindowSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 1..32768 */
		if ((1 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODefaultWindowSizeOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing;
		StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODefaultWindowSizeOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOFlowControlParameterNegotiation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOFlowControlParameterNegotiation(int action, u_char *var_val, u_char var_val_type,
						size_t var_val_len, u_char *statP, oid * name,
						size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOFlowControlParameterNegotiation entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOFlowControlParameterNegotiation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOFlowControlParameterNegotiation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION_UNKNOWN:
		case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION_BASIC:
		case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION_NOTSUBSCRIBED:
		case X25PLEIVMOFLOWCONTROLPARAMETERNEGOTIATION_EXTENDED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOFlowControlParameterNegotiation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOFlowControlParameterNegotiation;
		StorageTmp->x25PLEIVMOFlowControlParameterNegotiation = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOFlowControlParameterNegotiation = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOLocalDTEAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOLocalDTEAddress(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMOLocalDTEAddress entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLocalDTEAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..18 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN
		    || ((0 > var_val_len || var_val_len > 18))) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLocalDTEAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOLocalDTEAddress;
		old_length = StorageTmp->x25PLEIVMOLocalDTEAddressLen;
		StorageTmp->x25PLEIVMOLocalDTEAddress = string;
		StorageTmp->x25PLEIVMOLocalDTEAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLocalDTEAddress = old_value;
		StorageTmp->x25PLEIVMOLocalDTEAddressLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOLogicalChannelAssignmentHPC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOLogicalChannelAssignmentHPC(int action, u_char *var_val, u_char var_val_type,
					    size_t var_val_len, u_char *statP, oid * name,
					    size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentHPC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHPC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHPC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHPC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHPC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOLogicalChannelAssignmentLPC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOLogicalChannelAssignmentLPC(int action, u_char *var_val, u_char var_val_type,
					    size_t var_val_len, u_char *statP, oid * name,
					    size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentLPC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLPC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLPC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLPC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLPC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOLogicalChannelAssignmentHIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOLogicalChannelAssignmentHIC(int action, u_char *var_val, u_char var_val_type,
					    size_t var_val_len, u_char *statP, oid * name,
					    size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentHIC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHIC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHIC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOLogicalChannelAssignmentLIC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOLogicalChannelAssignmentLIC(int action, u_char *var_val, u_char var_val_type,
					    size_t var_val_len, u_char *statP, oid * name,
					    size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentLIC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLIC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLIC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLIC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLIC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOLogicalChannelAssignmentHTC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOLogicalChannelAssignmentHTC(int action, u_char *var_val, u_char var_val_type,
					    size_t var_val_len, u_char *statP, oid * name,
					    size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentHTC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHTC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHTC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHTC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOLogicalChannelAssignmentLTC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOLogicalChannelAssignmentLTC(int action, u_char *var_val, u_char var_val_type,
					    size_t var_val_len, u_char *statP, oid * name,
					    size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentLTC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLTC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLTC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLTC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLTC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOLogicalChannelAssignmentHOC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOLogicalChannelAssignmentHOC(int action, u_char *var_val, u_char var_val_type,
					    size_t var_val_len, u_char *statP, oid * name,
					    size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentHOC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHOC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentHOC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentHOC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOLogicalChannelAssignmentLOC(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOLogicalChannelAssignmentLOC(int action, u_char *var_val, u_char var_val_type,
					    size_t var_val_len, u_char *statP, oid * name,
					    size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOLogicalChannelAssignmentLOC entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLOC not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLOC: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOLogicalChannelAssignmentLOC: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC;
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOLogicalChannelAssignmentLOC = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOSNServiceProvider(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOSNServiceProvider(int action, u_char *var_val, u_char var_val_type,
				  size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMOSNServiceProvider entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOSNServiceProvider not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len
		    || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOSNServiceProvider: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid =
		     snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOSNServiceProvider;
		old_length = StorageTmp->x25PLEIVMOSNServiceProviderLen;
		StorageTmp->x25PLEIVMOSNServiceProvider = objid;
		StorageTmp->x25PLEIVMOSNServiceProviderLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOSNServiceProvider = old_value;
		StorageTmp->x25PLEIVMOSNServiceProviderLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMOThroughputClassNegotiation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMOThroughputClassNegotiation(int action, u_char *var_val, u_char var_val_type,
					   size_t var_val_len, u_char *statP, oid * name,
					   size_t name_len)
{
	static long old_value;
	struct x25PLEIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMOThroughputClassNegotiation entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOThroughputClassNegotiation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOThroughputClassNegotiation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value notsubscribed ( 2 ) */
		switch (set_value) {
		case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION_UNKNOWN:
		case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION_BASIC:
		case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION_NOTSUBSCRIBED:
		case X25PLEIVMOTHROUGHPUTCLASSNEGOTIATION_EXTENDED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMOThroughputClassNegotiation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMOThroughputClassNegotiation;
		StorageTmp->x25PLEIVMOThroughputClassNegotiation = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMOThroughputClassNegotiation = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTEPacketSequencing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDTEPacketSequencing(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTEPacketSequencing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDTEPacketSequencing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		switch (set_value) {
		case X25PLEDTEPACKETSEQUENCING_DEFAULT:
		case X25PLEDTEPACKETSEQUENCING_MODULO8:
		case X25PLEDTEPACKETSEQUENCING_MODULO128:
		case X25PLEDTEPACKETSEQUENCING_MODULO32768:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEPacketSequencing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDTEPacketSequencing;
		StorageTmp->x25PLEDTEPacketSequencing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTEPacketSequencing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTEMaxActiveCircuits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDTEMaxActiveCircuits(int action, u_char *var_val, u_char var_val_type,
				 size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTEMaxActiveCircuits entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDTEMaxActiveCircuits: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEMaxActiveCircuits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4096 */
		if ((0 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEMaxActiveCircuits: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDTEMaxActiveCircuits;
		StorageTmp->x25PLEDTEMaxActiveCircuits = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTEMaxActiveCircuits = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTECallDeflectionSubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDTECallDeflectionSubscription(int action, u_char *var_val, u_char var_val_type,
					  size_t var_val_len, u_char *statP, oid * name,
					  size_t name_len)
{
	static long old_value;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDTECallDeflectionSubscription entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDTECallDeflectionSubscription: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTECallDeflectionSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTECallDeflectionSubscription: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDTECallDeflectionSubscription;
		StorageTmp->x25PLEDTECallDeflectionSubscription = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTECallDeflectionSubscription = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTERestartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDTERestartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			   u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTERestartTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDTERestartTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERestartTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 18000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERestartTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDTERestartTime;
		StorageTmp->x25PLEDTERestartTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTERestartTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTERestartCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDTERestartCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTERestartCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDTERestartCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERestartCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDTERestartCount;
		StorageTmp->x25PLEDTERestartCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTERestartCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTEMinimumRecallTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDTEMinimumRecallTimer(int action, u_char *var_val, u_char var_val_type,
				  size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTEMinimumRecallTimer entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDTEMinimumRecallTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEMinimumRecallTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEMinimumRecallTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDTEMinimumRecallTimer;
		StorageTmp->x25PLEDTEMinimumRecallTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTEMinimumRecallTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTERegistrationTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDTERegistrationTime(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTERegistrationTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDTERegistrationTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 30000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDTERegistrationTime;
		StorageTmp->x25PLEDTERegistrationTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTERegistrationTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTERegistrationCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDTERegistrationCount(int action, u_char *var_val, u_char var_val_type,
				 size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTERegistrationCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDTERegistrationCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDTERegistrationCount;
		StorageTmp->x25PLEDTERegistrationCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTERegistrationCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTERegistrationPermitted(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDTERegistrationPermitted(int action, u_char *var_val, u_char var_val_type,
				     size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTERegistrationPermitted entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDTERegistrationPermitted: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationPermitted: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTERegistrationPermitted: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDTERegistrationPermitted;
		StorageTmp->x25PLEDTERegistrationPermitted = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTERegistrationPermitted = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTEProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDTEProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		       u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct x25PLEDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDTEProfile entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDTEProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len
		    || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDTEProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid =
		     snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDTEProfile;
		old_length = StorageTmp->x25PLEDTEProfileLen;
		StorageTmp->x25PLEDTEProfile = objid;
		StorageTmp->x25PLEDTEProfileLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDTEProfile = old_value;
		StorageTmp->x25PLEDTEProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEPacketSequencing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEPacketSequencing(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEPacketSequencing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEPacketSequencing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCEPACKETSEQUENCING_DEFAULT:
		case X25PLEDCEPACKETSEQUENCING_MODULO8:
		case X25PLEDCEPACKETSEQUENCING_MODULO128:
		case X25PLEDCEPACKETSEQUENCING_MODULO32768:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEPacketSequencing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEPacketSequencing;
		StorageTmp->x25PLEDCEPacketSequencing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEPacketSequencing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCECallDeflectionSubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCECallDeflectionSubscription(int action, u_char *var_val, u_char var_val_type,
					  size_t var_val_len, u_char *statP, oid * name,
					  size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCECallDeflectionSubscription entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCECallDeflectionSubscription: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallDeflectionSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallDeflectionSubscription: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCECallDeflectionSubscription;
		StorageTmp->x25PLEDCECallDeflectionSubscription = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECallDeflectionSubscription = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCECUG(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCECUG(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		   u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCECUG entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCECUG: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDCECUG: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCECUG_UNKNOWN:
		case X25PLEDCECUG_BASIC:
		case X25PLEDCECUG_NOTSUBSCRIBED:
		case X25PLEDCECUG_EXTENDED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDCECUG: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCECUG;
		StorageTmp->x25PLEDCECUG = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECUG = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEFastSelectAcceptance(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEFastSelectAcceptance(int action, u_char *var_val, u_char var_val_type,
				    size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEFastSelectAcceptance entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEFastSelectAcceptance: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEFastSelectAcceptance not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEFastSelectAcceptance: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEFastSelectAcceptance: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEFastSelectAcceptance;
		StorageTmp->x25PLEDCEFastSelectAcceptance = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEFastSelectAcceptance = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEIncomingCallsBarred(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEIncomingCallsBarred(int action, u_char *var_val, u_char var_val_type,
				   size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEIncomingCallsBarred entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEIncomingCallsBarred: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCallsBarred not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCallsBarred: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCallsBarred: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEIncomingCallsBarred;
		StorageTmp->x25PLEDCEIncomingCallsBarred = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEIncomingCallsBarred = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEOneWayLogicalChannelOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEOneWayLogicalChannelOutgoing(int action, u_char *var_val, u_char var_val_type,
					    size_t var_val_len, u_char *statP, oid * name,
					    size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEOneWayLogicalChannelOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEOneWayLogicalChannelOutgoing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOneWayLogicalChannelOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOneWayLogicalChannelOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOneWayLogicalChannelOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing;
		StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEOneWayLogicalChannelOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEOutgoingCallsBarred(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEOutgoingCallsBarred(int action, u_char *var_val, u_char var_val_type,
				   size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEOutgoingCallsBarred entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEOutgoingCallsBarred: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOutgoingCallsBarred not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOutgoingCallsBarred: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOutgoingCallsBarred: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEOutgoingCallsBarred;
		StorageTmp->x25PLEDCEOutgoingCallsBarred = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEOutgoingCallsBarred = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEBilateralCUG(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEBilateralCUG(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEBilateralCUG entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEBilateralCUG: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEBilateralCUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEBilateralCUG: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCEBILATERALCUG_UNKNOWN:
		case X25PLEDCEBILATERALCUG_BASIC:
		case X25PLEDCEBILATERALCUG_NOTSUBSCRIBED:
		case X25PLEDCEBILATERALCUG_EXTENDED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEBilateralCUG: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEBilateralCUG;
		StorageTmp->x25PLEDCEBilateralCUG = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEBilateralCUG = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEBilateralCUGWithOutgoingAccess(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEBilateralCUGWithOutgoingAccess(int action, u_char *var_val, u_char var_val_type,
					      size_t var_val_len, u_char *statP, oid * name,
					      size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEBilateralCUGWithOutgoingAccess entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEBilateralCUGWithOutgoingAccess: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEBilateralCUGWithOutgoingAccess not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEBilateralCUGWithOutgoingAccess: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS_UNKNOWN:
		case X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS_BASIC:
		case X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS_NOTSUBSCRIBED:
		case X25PLEDCEBILATERALCUGWITHOUTGOINGACCESS_EXTENDED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEBilateralCUGWithOutgoingAccess: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess;
		StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEBilateralCUGWithOutgoingAccess = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCECallRedirection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCECallRedirection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCECallRedirection entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCECallRedirection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallRedirection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallRedirection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallRedirection: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCECallRedirection;
		StorageTmp->x25PLEDCECallRedirection = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECallRedirection = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEChargingInformation(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEChargingInformation(int action, u_char *var_val, u_char var_val_type,
				   size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEChargingInformation entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEChargingInformation: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEChargingInformation not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEChargingInformation: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEChargingInformation: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEChargingInformation;
		StorageTmp->x25PLEDCEChargingInformation = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEChargingInformation = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCECUGWithIncomingAccess(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCECUGWithIncomingAccess(int action, u_char *var_val, u_char var_val_type,
				     size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCECUGWithIncomingAccess entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCECUGWithIncomingAccess: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECUGWithIncomingAccess not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECUGWithIncomingAccess: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCECUGWITHINCOMINGACCESS_UNKNOWN:
		case X25PLEDCECUGWITHINCOMINGACCESS_BASIC:
		case X25PLEDCECUGWITHINCOMINGACCESS_NOTSUBSCRIBED:
		case X25PLEDCECUGWITHINCOMINGACCESS_EXTENDED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECUGWithIncomingAccess: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCECUGWithIncomingAccess;
		StorageTmp->x25PLEDCECUGWithIncomingAccess = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECUGWithIncomingAccess = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCECUGWithOutgoingAccess(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCECUGWithOutgoingAccess(int action, u_char *var_val, u_char var_val_type,
				     size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCECUGWithOutgoingAccess entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCECUGWithOutgoingAccess: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECUGWithOutgoingAccess not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECUGWithOutgoingAccess: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCECUGWITHOUTGOINGACCESS_UNKNOWN:
		case X25PLEDCECUGWITHOUTGOINGACCESS_BASIC:
		case X25PLEDCECUGWITHOUTGOINGACCESS_NOTSUBSCRIBED:
		case X25PLEDCECUGWITHOUTGOINGACCESS_EXTENDED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECUGWithOutgoingAccess: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCECUGWithOutgoingAccess;
		StorageTmp->x25PLEDCECUGWithOutgoingAccess = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECUGWithOutgoingAccess = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEDBitModification(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEDBitModification(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEDBitModification entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEDBitModification: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDBitModification not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDBitModification: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDBitModification: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEDBitModification;
		StorageTmp->x25PLEDCEDBitModification = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEDBitModification = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEDefaultThroughputClassSubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEDefaultThroughputClassSubscription(int action, u_char *var_val, u_char var_val_type,
						  size_t var_val_len, u_char *statP, oid * name,
						  size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEDefaultThroughputClassSubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEDefaultThroughputClassSubscription: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassSubscription: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEDefaultThroughputClassSubscription;
		StorageTmp->x25PLEDCEDefaultThroughputClassSubscription = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEDefaultThroughputClassSubscription = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEDefaultThroughputClassSupported(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEDefaultThroughputClassSupported(int action, u_char *var_val, u_char var_val_type,
					       size_t var_val_len, u_char *statP, oid * name,
					       size_t name_len)
{
	static uint8_t *old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEDefaultThroughputClassSupported entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEDefaultThroughputClassSupported: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassSupported not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN
		    || var_val_len != ((44 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassSupported: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (44 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassSupported: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEDefaultThroughputClassSupported;
		old_length = StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen;
		StorageTmp->x25PLEDCEDefaultThroughputClassSupported = string;
		StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEDefaultThroughputClassSupported = old_value;
		StorageTmp->x25PLEDCEDefaultThroughputClassSupportedLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEDefaultThroughputClassIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEDefaultThroughputClassIncoming(int action, u_char *var_val, u_char var_val_type,
					      size_t var_val_len, u_char *statP, oid * name,
					      size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEDefaultThroughputClassIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEDefaultThroughputClassIncoming: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_DEFAULT:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B75:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B150:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B300:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B600:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1200:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B2400:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B4800:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B9600:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B19200:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B48000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B64000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B128000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B192000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B256000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B320000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B384000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B448000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B512000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B576000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B640000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B704000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B768000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B832000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B896000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B960000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1024000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1088000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1792000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1152000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1216000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1280000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1344000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1408000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1472000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1536000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1600000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1664000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1728000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1856000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1920000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B1984000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSINCOMING_B2048000:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEDefaultThroughputClassIncoming;
		StorageTmp->x25PLEDCEDefaultThroughputClassIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEDefaultThroughputClassIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEDefaultThroughputClassOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEDefaultThroughputClassOutgoing(int action, u_char *var_val, u_char var_val_type,
					      size_t var_val_len, u_char *statP, oid * name,
					      size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEDefaultThroughputClassOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEDefaultThroughputClassOutgoing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_DEFAULT:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B75:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B150:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B300:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B600:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1200:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B2400:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B4800:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B9600:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B19200:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B48000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B64000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B128000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B192000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B256000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B320000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B384000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B448000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B512000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B576000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B640000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B704000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B768000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B832000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B896000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B960000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1024000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1088000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1792000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1152000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1216000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1280000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1344000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1408000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1472000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1536000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1600000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1664000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1728000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1856000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1920000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B1984000:
		case X25PLEDCEDEFAULTTHROUGHPUTCLASSOUTGOING_B2048000:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEDefaultThroughputClassOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing;
		StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEDefaultThroughputClassOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEHuntGroup(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEHuntGroup(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			 u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEHuntGroup entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEHuntGroup: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEHuntGroup not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEHuntGroup: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEHuntGroup: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEHuntGroup;
		StorageTmp->x25PLEDCEHuntGroup = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEHuntGroup = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEIncomingCallBarredWithinCUG(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEIncomingCallBarredWithinCUG(int action, u_char *var_val, u_char var_val_type,
					   size_t var_val_len, u_char *statP, oid * name,
					   size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEIncomingCallBarredWithinCUG entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEIncomingCallBarredWithinCUG: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCallBarredWithinCUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCallBarredWithinCUG: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCallBarredWithinCUG: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG;
		StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEIncomingCallBarredWithinCUG = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCELocalChargingPrevention(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCELocalChargingPrevention(int action, u_char *var_val, u_char var_val_type,
				       size_t var_val_len, u_char *statP, oid * name,
				       size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCELocalChargingPrevention entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCELocalChargingPrevention: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCELocalChargingPrevention not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCELocalChargingPrevention: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCELocalChargingPrevention: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCELocalChargingPrevention;
		StorageTmp->x25PLEDCELocalChargingPrevention = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCELocalChargingPrevention = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCENonStandardDefaultPacketSizeSubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCENonStandardDefaultPacketSizeSubscription(int action, u_char *var_val,
							u_char var_val_type, size_t var_val_len,
							u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultPacketSizeSubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCENonStandardDefaultPacketSizeSubscription: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeSubscription: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription;
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeSubscription = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCENonStandardDefaultPacketSizeMaximum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCENonStandardDefaultPacketSizeMaximum(int action, u_char *var_val, u_char var_val_type,
						   size_t var_val_len, u_char *statP, oid * name,
						   size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultPacketSizeMaximum entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCENonStandardDefaultPacketSizeMaximum: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeMaximum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeMaximum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM_DEFAULT:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM_PSIZE16:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM_PSIZE32:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM_PSIZE64:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM_PSIZE128:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM_PSIZE256:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM_PSIZE512:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM_PSIZE1024:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM_PSIZE2048:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEMAXIMUM_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeMaximum: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum;
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeMaximum = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCENonStandardDefaultPacketSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCENonStandardDefaultPacketSizeIncoming(int action, u_char *var_val,
						    u_char var_val_type, size_t var_val_len,
						    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultPacketSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCENonStandardDefaultPacketSizeIncoming: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING_DEFAULT:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING_PSIZE16:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING_PSIZE32:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING_PSIZE64:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING_PSIZE128:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING_PSIZE256:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING_PSIZE512:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING_PSIZE1024:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING_PSIZE2048:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEINCOMING_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming;
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCENonStandardDefaultPacketSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCENonStandardDefaultPacketSizeOutgoing(int action, u_char *var_val,
						    u_char var_val_type, size_t var_val_len,
						    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultPacketSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCENonStandardDefaultPacketSizeOutgoing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING_DEFAULT:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING_PSIZE16:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING_PSIZE32:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING_PSIZE64:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING_PSIZE128:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING_PSIZE256:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING_PSIZE512:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING_PSIZE1024:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING_PSIZE2048:
		case X25PLEDCENONSTANDARDDEFAULTPACKETSIZEOUTGOING_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultPacketSizeOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing;
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultPacketSizeOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCENonStandardDefaultWindowSizeSubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCENonStandardDefaultWindowSizeSubscription(int action, u_char *var_val,
							u_char var_val_type, size_t var_val_len,
							u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultWindowSizeSubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCENonStandardDefaultWindowSizeSubscription: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeSubscription: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription;
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeSubscription = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCENonStandardDefaultWindowSizeMaximum(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCENonStandardDefaultWindowSizeMaximum(int action, u_char *var_val, u_char var_val_type,
						   size_t var_val_len, u_char *statP, oid * name,
						   size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultWindowSizeMaximum entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCENonStandardDefaultWindowSizeMaximum: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeMaximum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeMaximum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum;
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeMaximum = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCENonStandardDefaultWindowSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCENonStandardDefaultWindowSizeIncoming(int action, u_char *var_val,
						    u_char var_val_type, size_t var_val_len,
						    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultWindowSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCENonStandardDefaultWindowSizeIncoming: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..32768 */
		if ((1 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming;
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCENonStandardDefaultWindowSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCENonStandardDefaultWindowSizeOutgoing(int action, u_char *var_val,
						    u_char var_val_type, size_t var_val_len,
						    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCENonStandardDefaultWindowSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCENonStandardDefaultWindowSizeOutgoing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..32768 */
		if ((1 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENonStandardDefaultWindowSizeOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing;
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENonStandardDefaultWindowSizeOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCENUIOverride(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCENUIOverride(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			   u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCENUIOverride entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCENUIOverride: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENUIOverride not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENUIOverride: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENUIOverride: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCENUIOverride;
		StorageTmp->x25PLEDCENUIOverride = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENUIOverride = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCENUISubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCENUISubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCENUISubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCENUISubscription: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENUISubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENUISubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCENUISubscription: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCENUISubscription;
		StorageTmp->x25PLEDCENUISubscription = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCENUISubscription = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEOneWayLogicalChannelIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEOneWayLogicalChannelIncoming(int action, u_char *var_val, u_char var_val_type,
					    size_t var_val_len, u_char *statP, oid * name,
					    size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEOneWayLogicalChannelIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEOneWayLogicalChannelIncoming: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOneWayLogicalChannelIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOneWayLogicalChannelIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOneWayLogicalChannelIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming;
		StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEOneWayLogicalChannelIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEOnlineFacilityRegistration(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEOnlineFacilityRegistration(int action, u_char *var_val, u_char var_val_type,
					  size_t var_val_len, u_char *statP, oid * name,
					  size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEOnlineFacilityRegistration entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEOnlineFacilityRegistration: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOnlineFacilityRegistration not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOnlineFacilityRegistration: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOnlineFacilityRegistration: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEOnlineFacilityRegistration;
		StorageTmp->x25PLEDCEOnlineFacilityRegistration = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEOnlineFacilityRegistration = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEOutgoingCallBarredWithinCUG(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEOutgoingCallBarredWithinCUG(int action, u_char *var_val, u_char var_val_type,
					   size_t var_val_len, u_char *statP, oid * name,
					   size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEOutgoingCallBarredWithinCUG entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEOutgoingCallBarredWithinCUG: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOutgoingCallBarredWithinCUG not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOutgoingCallBarredWithinCUG: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEOutgoingCallBarredWithinCUG: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG;
		StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEOutgoingCallBarredWithinCUG = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEPacketRetransmission(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEPacketRetransmission(int action, u_char *var_val, u_char var_val_type,
				    size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEPacketRetransmission entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEPacketRetransmission: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEPacketRetransmission not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEPacketRetransmission: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEPacketRetransmission: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEPacketRetransmission;
		StorageTmp->x25PLEDCEPacketRetransmission = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEPacketRetransmission = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEReverseChargingAcceptance(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEReverseChargingAcceptance(int action, u_char *var_val, u_char var_val_type,
					 size_t var_val_len, u_char *statP, oid * name,
					 size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDCEReverseChargingAcceptance entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEReverseChargingAcceptance: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEReverseChargingAcceptance not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEReverseChargingAcceptance: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEReverseChargingAcceptance: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEReverseChargingAcceptance;
		StorageTmp->x25PLEDCEReverseChargingAcceptance = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEReverseChargingAcceptance = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEROASubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEROASubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEROASubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEROASubscription: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEROASubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEROASubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEDCEROASUBSCRIPTION_UNKNOWN:
		case X25PLEDCEROASUBSCRIPTION_BASIC:
		case X25PLEDCEROASUBSCRIPTION_NOTSUBSCRIBED:
		case X25PLEDCEROASUBSCRIPTION_EXTENDED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEROASubscription: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEROASubscription;
		StorageTmp->x25PLEDCEROASubscription = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEROASubscription = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCERestartIndication(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCERestartIndication(int action, u_char *var_val, u_char var_val_type,
				 size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCERestartIndication entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCERestartIndication: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCERestartIndication not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCERestartIndication: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCERestartIndication: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCERestartIndication;
		StorageTmp->x25PLEDCERestartIndication = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCERestartIndication = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCERestartCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCERestartCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCERestartCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCERestartCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCERestartCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCERestartCount;
		StorageTmp->x25PLEDCERestartCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCERestartCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEIncomingCall(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEIncomingCall(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEIncomingCall entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEIncomingCall: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCall not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCall: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 18000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEIncomingCall: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEIncomingCall;
		StorageTmp->x25PLEDCEIncomingCall = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEIncomingCall = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCECallCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCECallCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			 u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCECallCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCECallCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCECallCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCECallCount;
		StorageTmp->x25PLEDCECallCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCECallCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEResetIndication(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEResetIndication(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEResetIndication entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEResetIndication: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEResetIndication not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEResetIndication: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEResetIndication: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEResetIndication;
		StorageTmp->x25PLEDCEResetIndication = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEResetIndication = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEResetCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEResetCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			  u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEResetCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEResetCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEResetCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEResetCount;
		StorageTmp->x25PLEDCEResetCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEResetCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEClearIndication(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEClearIndication(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEClearIndication entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEClearIndication: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEClearIndication not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEClearIndication: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEClearIndication: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEClearIndication;
		StorageTmp->x25PLEDCEClearIndication = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEClearIndication = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEClearCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEClearCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			  u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEClearCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEClearCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEClearCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEClearCount;
		StorageTmp->x25PLEDCEClearCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEClearCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCEProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDCEProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		       u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct x25PLEDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDCEProfile entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDCEProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len
		    || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDCEProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid =
		     snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDCEProfile;
		old_length = StorageTmp->x25PLEDCEProfileLen;
		StorageTmp->x25PLEDCEProfile = objid;
		StorageTmp->x25PLEDCEProfileLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDCEProfile = old_value;
		StorageTmp->x25PLEDCEProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXEPacketSequencing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXEPacketSequencing(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXEPacketSequencing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXEPacketSequencing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXEPacketSequencing;
		StorageTmp->x25PLEDXEPacketSequencing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXEPacketSequencing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXEMaxActiveCircuits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXEMaxActiveCircuits(int action, u_char *var_val, u_char var_val_type,
				 size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXEMaxActiveCircuits entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXEMaxActiveCircuits: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEMaxActiveCircuits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4096 */
		if ((0 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEMaxActiveCircuits: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXEMaxActiveCircuits;
		StorageTmp->x25PLEDXEMaxActiveCircuits = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXEMaxActiveCircuits = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXECallDeflectionSubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXECallDeflectionSubscription(int action, u_char *var_val, u_char var_val_type,
					  size_t var_val_len, u_char *statP, oid * name,
					  size_t name_len)
{
	static long old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEDXECallDeflectionSubscription entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXECallDeflectionSubscription: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXECallDeflectionSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXECallDeflectionSubscription: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXECallDeflectionSubscription;
		StorageTmp->x25PLEDXECallDeflectionSubscription = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXECallDeflectionSubscription = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXERestartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXERestartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			   u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXERestartTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXERestartTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERestartTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 18000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERestartTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXERestartTime;
		StorageTmp->x25PLEDXERestartTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXERestartTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXERestartCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXERestartCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXERestartCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXERestartCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERestartCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXERestartCount;
		StorageTmp->x25PLEDXERestartCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXERestartCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXEMinimumRecallTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXEMinimumRecallTimer(int action, u_char *var_val, u_char var_val_type,
				  size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXEMinimumRecallTimer entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXEMinimumRecallTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEMinimumRecallTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEMinimumRecallTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXEMinimumRecallTimer;
		StorageTmp->x25PLEDXEMinimumRecallTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXEMinimumRecallTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXERegistrationTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXERegistrationTime(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXERegistrationTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXERegistrationTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 30000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXERegistrationTime;
		StorageTmp->x25PLEDXERegistrationTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXERegistrationTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXERegistrationCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXERegistrationCount(int action, u_char *var_val, u_char var_val_type,
				 size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXERegistrationCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXERegistrationCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXERegistrationCount;
		StorageTmp->x25PLEDXERegistrationCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXERegistrationCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXERegistrationPermitted(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXERegistrationPermitted(int action, u_char *var_val, u_char var_val_type,
				     size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXERegistrationPermitted entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXERegistrationPermitted: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationPermitted: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2 */
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXERegistrationPermitted: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXERegistrationPermitted;
		StorageTmp->x25PLEDXERegistrationPermitted = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXERegistrationPermitted = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXEPLEClientMOName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXEPLEClientMOName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXEPLEClientMOName entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXEPLEClientMOName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEPLEClientMOName not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len
		    || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEPLEClientMOName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid =
		     snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXEPLEClientMOName;
		old_length = StorageTmp->x25PLEDXEPLEClientMONameLen;
		StorageTmp->x25PLEDXEPLEClientMOName = objid;
		StorageTmp->x25PLEDXEPLEClientMONameLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXEPLEClientMOName = old_value;
		StorageTmp->x25PLEDXEPLEClientMONameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXEProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEDXEProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		       u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct x25PLEDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEDXEProfile entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEDXEProfile: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len
		    || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEDXEProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid =
		     snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEDXEProfile;
		old_length = StorageTmp->x25PLEDXEProfileLen;
		StorageTmp->x25PLEDXEProfile = objid;
		StorageTmp->x25PLEDXEProfileLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEDXEProfile = old_value;
		StorageTmp->x25PLEDXEProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTECallDeflectionSubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTECallDeflectionSubscription(int action, u_char *var_val, u_char var_val_type,
					      size_t var_val_len, u_char *statP, oid * name,
					      size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODTECallDeflectionSubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTECallDeflectionSubscription: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallDeflectionSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallDeflectionSubscription: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTECallDeflectionSubscription;
		StorageTmp->x25PLEIVMODTECallDeflectionSubscription = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTECallDeflectionSubscription = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTECallTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTECallTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTECallTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTECallTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTECallTime;
		StorageTmp->x25PLEIVMODTECallTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTECallTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEClearTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEClearTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEClearTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEClearTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEClearTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEClearTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEClearTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEClearTime;
		StorageTmp->x25PLEIVMODTEClearTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEClearTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEClearCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEClearCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEClearCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEClearCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEClearCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEClearCount;
		StorageTmp->x25PLEIVMODTEClearCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEClearCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEPacketSequencing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEPacketSequencing(int action, u_char *var_val, u_char var_val_type,
				    size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEPacketSequencing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEPacketSequencing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25PLEIVMODTEPACKETSEQUENCING_DEFAULT:
		case X25PLEIVMODTEPACKETSEQUENCING_MODULO8:
		case X25PLEIVMODTEPACKETSEQUENCING_MODULO128:
		case X25PLEIVMODTEPACKETSEQUENCING_MODULO32768:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEPacketSequencing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEPacketSequencing;
		StorageTmp->x25PLEIVMODTEPacketSequencing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEPacketSequencing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEInterruptTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEInterruptTime(int action, u_char *var_val, u_char var_val_type,
				 size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEInterruptTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEInterruptTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEInterruptTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEInterruptTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEInterruptTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEInterruptTime;
		StorageTmp->x25PLEIVMODTEInterruptTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEInterruptTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEMaxActiveCircuits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEMaxActiveCircuits(int action, u_char *var_val, u_char var_val_type,
				     size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEMaxActiveCircuits entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEMaxActiveCircuits: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMaxActiveCircuits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..4096 */
		if ((0 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMaxActiveCircuits: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEMaxActiveCircuits;
		StorageTmp->x25PLEIVMODTEMaxActiveCircuits = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEMaxActiveCircuits = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEMinimumRecallTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEMinimumRecallTimer(int action, u_char *var_val, u_char var_val_type,
				      size_t var_val_len, u_char *statP, oid * name,
				      size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEMinimumRecallTimer entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEMinimumRecallTimer: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMinimumRecallTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMinimumRecallTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEMinimumRecallTimer;
		StorageTmp->x25PLEIVMODTEMinimumRecallTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEMinimumRecallTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEResetTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEResetTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEResetTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEResetTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEResetTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEResetTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEResetTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEResetTime;
		StorageTmp->x25PLEIVMODTEResetTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEResetTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEResetCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEResetCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEResetCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEResetCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEResetCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEResetCount;
		StorageTmp->x25PLEIVMODTEResetCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEResetCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERestartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERestartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERestartTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTERestartTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERestartTime;
		StorageTmp->x25PLEIVMODTERestartTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERestartTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERestartCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERestartCount(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERestartCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTERestartCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERestartCount;
		StorageTmp->x25PLEIVMODTERestartCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERestartCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEWindowTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEWindowTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEWindowTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEWindowTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEWindowTime;
		StorageTmp->x25PLEIVMODTEWindowTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEWindowTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEDataTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEDataTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEDataTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEDataTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEDataTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEDataTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEDataTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEDataTime;
		StorageTmp->x25PLEIVMODTEDataTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEDataTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEDataCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEDataCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEDataCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTEDataCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEDataCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEDataCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEDataCount;
		StorageTmp->x25PLEIVMODTEDataCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEDataCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERejectTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERejectTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERejectTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTERejectTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERejectTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERejectTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERejectTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERejectTime;
		StorageTmp->x25PLEIVMODTERejectTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERejectTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERejectCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERejectCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERejectCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTERejectCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERejectCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERejectCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERejectCount;
		StorageTmp->x25PLEIVMODTERejectCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERejectCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERegistrationTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERegistrationTime(int action, u_char *var_val, u_char var_val_type,
				    size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERegistrationTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTERegistrationTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERegistrationTime;
		StorageTmp->x25PLEIVMODTERegistrationTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERegistrationCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERegistrationCount(int action, u_char *var_val, u_char var_val_type,
				     size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERegistrationCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTERegistrationCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERegistrationCount;
		StorageTmp->x25PLEIVMODTERegistrationCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERegistrationPermitted(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERegistrationPermitted(int action, u_char *var_val, u_char var_val_type,
					 size_t var_val_len, u_char *statP, oid * name,
					 size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODTERegistrationPermitted entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PLEIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PLEIVMODTERegistrationPermitted: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationPermitted: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationPermitted: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERegistrationPermitted;
		StorageTmp->x25PLEIVMODTERegistrationPermitted = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationPermitted = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTECallDeflectionSubscription(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTECallDeflectionSubscription(int action, u_char *var_val, u_char var_val_type,
					      size_t var_val_len, u_char *statP, oid * name,
					      size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODTECallDeflectionSubscription entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallDeflectionSubscription not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallDeflectionSubscription: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTECallDeflectionSubscription: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTECallDeflectionSubscription;
		StorageTmp->x25PLEIVMODTECallDeflectionSubscription = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTECallDeflectionSubscription = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEMaxActiveCircuits(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEMaxActiveCircuits(int action, u_char *var_val, u_char var_val_type,
				     size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEMaxActiveCircuits entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMaxActiveCircuits not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMaxActiveCircuits: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..4096 */
		if ((0 > set_value || set_value > 4096)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMaxActiveCircuits: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEMaxActiveCircuits;
		StorageTmp->x25PLEIVMODTEMaxActiveCircuits = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEMaxActiveCircuits = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERestartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERestartTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERestartTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERestartTime;
		StorageTmp->x25PLEIVMODTERestartTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERestartTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEMinimumRecallTimer(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEMinimumRecallTimer(int action, u_char *var_val, u_char var_val_type,
				      size_t var_val_len, u_char *statP, oid * name,
				      size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEMinimumRecallTimer entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMinimumRecallTimer not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMinimumRecallTimer: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEMinimumRecallTimer: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEMinimumRecallTimer;
		StorageTmp->x25PLEIVMODTEMinimumRecallTimer = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEMinimumRecallTimer = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERestartCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERestartCount(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERestartCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERestartCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERestartCount;
		StorageTmp->x25PLEIVMODTERestartCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERestartCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTEPacketSequencing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTEPacketSequencing(int action, u_char *var_val, u_char var_val_type,
				    size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTEPacketSequencing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTEPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTEPacketSequencing;
		StorageTmp->x25PLEIVMODTEPacketSequencing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTEPacketSequencing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERegistrationTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERegistrationTime(int action, u_char *var_val, u_char var_val_type,
				    size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERegistrationTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERegistrationTime;
		StorageTmp->x25PLEIVMODTERegistrationTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERegistrationCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERegistrationCount(int action, u_char *var_val, u_char var_val_type,
				     size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PLEIVMODTERegistrationCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERegistrationCount;
		StorageTmp->x25PLEIVMODTERegistrationCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERegistrationPermitted(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PLEIVMODTERegistrationPermitted(int action, u_char *var_val, u_char var_val_type,
					 size_t var_val_len, u_char *statP, oid * name,
					 size_t name_len)
{
	static long old_value;
	struct x25PLEIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25PLEIVMODTERegistrationPermitted entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25PLEIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationPermitted not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationPermitted: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PLEIVMODTERegistrationPermitted: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PLEIVMODTERegistrationPermitted;
		StorageTmp->x25PLEIVMODTERegistrationPermitted = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PLEIVMODTERegistrationPermitted = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25VCPacketSequencing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25VCPacketSequencing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25VCTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25VCPacketSequencing entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSequencing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSequencing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case X25VCPACKETSEQUENCING_DEFAULT:
		case X25VCPACKETSEQUENCING_MODULO8:
		case X25VCPACKETSEQUENCING_MODULO128:
		case X25VCPACKETSEQUENCING_MODULO32768:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSequencing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25VCPacketSequencing;
		StorageTmp->x25VCPacketSequencing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCPacketSequencing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25VCPacketSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25VCPacketSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25VCTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25VCPacketSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25VCPACKETSIZEINCOMING_DEFAULT:
		case X25VCPACKETSIZEINCOMING_PSIZE16:
		case X25VCPACKETSIZEINCOMING_PSIZE32:
		case X25VCPACKETSIZEINCOMING_PSIZE64:
		case X25VCPACKETSIZEINCOMING_PSIZE128:
		case X25VCPACKETSIZEINCOMING_PSIZE256:
		case X25VCPACKETSIZEINCOMING_PSIZE512:
		case X25VCPACKETSIZEINCOMING_PSIZE1024:
		case X25VCPACKETSIZEINCOMING_PSIZE2048:
		case X25VCPACKETSIZEINCOMING_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSizeIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25VCPacketSizeIncoming;
		StorageTmp->x25VCPacketSizeIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCPacketSizeIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25VCPacketSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25VCPacketSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25VCTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25VCPacketSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25VCPACKETSIZEOUTGOING_DEFAULT:
		case X25VCPACKETSIZEOUTGOING_PSIZE16:
		case X25VCPACKETSIZEOUTGOING_PSIZE32:
		case X25VCPACKETSIZEOUTGOING_PSIZE64:
		case X25VCPACKETSIZEOUTGOING_PSIZE128:
		case X25VCPACKETSIZEOUTGOING_PSIZE256:
		case X25VCPACKETSIZEOUTGOING_PSIZE512:
		case X25VCPACKETSIZEOUTGOING_PSIZE1024:
		case X25VCPACKETSIZEOUTGOING_PSIZE2048:
		case X25VCPACKETSIZEOUTGOING_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCPacketSizeOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25VCPacketSizeOutgoing;
		StorageTmp->x25VCPacketSizeOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCPacketSizeOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25VCWindowSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25VCWindowSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25VCTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25VCWindowSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCWindowSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..32768 */
		if ((1 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCWindowSizeIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25VCWindowSizeIncoming;
		StorageTmp->x25VCWindowSizeIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCWindowSizeIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25VCWindowSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25VCWindowSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25VCTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25VCWindowSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCWindowSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..32768 */
		if ((1 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCWindowSizeOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25VCWindowSizeOutgoing;
		StorageTmp->x25VCWindowSizeOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCWindowSizeOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25VCThroughputClassIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25VCThroughputClassIncoming(int action, u_char *var_val, u_char var_val_type,
				   size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25VCTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25VCThroughputClassIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCThroughputClassIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25VCTHROUGHPUTCLASSINCOMING_DEFAULT:
		case X25VCTHROUGHPUTCLASSINCOMING_B75:
		case X25VCTHROUGHPUTCLASSINCOMING_B150:
		case X25VCTHROUGHPUTCLASSINCOMING_B300:
		case X25VCTHROUGHPUTCLASSINCOMING_B600:
		case X25VCTHROUGHPUTCLASSINCOMING_B1200:
		case X25VCTHROUGHPUTCLASSINCOMING_B2400:
		case X25VCTHROUGHPUTCLASSINCOMING_B4800:
		case X25VCTHROUGHPUTCLASSINCOMING_B9600:
		case X25VCTHROUGHPUTCLASSINCOMING_B19200:
		case X25VCTHROUGHPUTCLASSINCOMING_B48000:
		case X25VCTHROUGHPUTCLASSINCOMING_B64000:
		case X25VCTHROUGHPUTCLASSINCOMING_B128000:
		case X25VCTHROUGHPUTCLASSINCOMING_B192000:
		case X25VCTHROUGHPUTCLASSINCOMING_B256000:
		case X25VCTHROUGHPUTCLASSINCOMING_B320000:
		case X25VCTHROUGHPUTCLASSINCOMING_B384000:
		case X25VCTHROUGHPUTCLASSINCOMING_B448000:
		case X25VCTHROUGHPUTCLASSINCOMING_B512000:
		case X25VCTHROUGHPUTCLASSINCOMING_B576000:
		case X25VCTHROUGHPUTCLASSINCOMING_B640000:
		case X25VCTHROUGHPUTCLASSINCOMING_B704000:
		case X25VCTHROUGHPUTCLASSINCOMING_B768000:
		case X25VCTHROUGHPUTCLASSINCOMING_B832000:
		case X25VCTHROUGHPUTCLASSINCOMING_B896000:
		case X25VCTHROUGHPUTCLASSINCOMING_B960000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1024000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1088000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1792000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1152000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1216000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1280000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1344000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1408000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1472000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1536000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1600000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1664000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1728000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1856000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1920000:
		case X25VCTHROUGHPUTCLASSINCOMING_B1984000:
		case X25VCTHROUGHPUTCLASSINCOMING_B2048000:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCThroughputClassIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25VCThroughputClassIncoming;
		StorageTmp->x25VCThroughputClassIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCThroughputClassIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25VCThroughputClassOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25VCThroughputClassOutgoing(int action, u_char *var_val, u_char var_val_type,
				   size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25VCTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25VCThroughputClassOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25VCTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCThroughputClassOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25VCTHROUGHPUTCLASSOUTGOING_DEFAULT:
		case X25VCTHROUGHPUTCLASSOUTGOING_B75:
		case X25VCTHROUGHPUTCLASSOUTGOING_B150:
		case X25VCTHROUGHPUTCLASSOUTGOING_B300:
		case X25VCTHROUGHPUTCLASSOUTGOING_B600:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1200:
		case X25VCTHROUGHPUTCLASSOUTGOING_B2400:
		case X25VCTHROUGHPUTCLASSOUTGOING_B4800:
		case X25VCTHROUGHPUTCLASSOUTGOING_B9600:
		case X25VCTHROUGHPUTCLASSOUTGOING_B19200:
		case X25VCTHROUGHPUTCLASSOUTGOING_B48000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B64000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B128000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B192000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B256000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B320000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B384000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B448000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B512000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B576000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B640000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B704000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B768000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B832000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B896000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B960000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1024000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1088000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1792000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1152000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1216000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1280000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1344000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1408000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1472000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1536000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1600000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1664000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1728000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1856000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1920000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B1984000:
		case X25VCTHROUGHPUTCLASSOUTGOING_B2048000:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25VCThroughputClassOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25VCThroughputClassOutgoing;
		StorageTmp->x25VCThroughputClassOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25VCThroughputClassOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PVCDTELogicalChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PVCDTELogicalChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PVCDTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDTELogicalChannel entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PVCDTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PVCDTELogicalChannel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDTELogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDTELogicalChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDTELogicalChannel: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PVCDTELogicalChannel;
		StorageTmp->x25PVCDTELogicalChannel = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDTELogicalChannel = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PVCDCELogicalChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PVCDCELogicalChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PVCDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDCELogicalChannel entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PVCDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PVCDCELogicalChannel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCELogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCELogicalChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCELogicalChannel: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PVCDCELogicalChannel;
		StorageTmp->x25PVCDCELogicalChannel = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDCELogicalChannel = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PVCDCEChargingDirection(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PVCDCEChargingDirection(int action, u_char *var_val, u_char var_val_type,
				 size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PVCDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDCEChargingDirection entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PVCDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PVCDCEChargingDirection: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCEChargingDirection not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCEChargingDirection: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCEChargingDirection: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PVCDCEChargingDirection;
		StorageTmp->x25PVCDCEChargingDirection = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDCEChargingDirection = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PVCDCERemoteDTEAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PVCDCERemoteDTEAddress(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct x25PVCDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDCERemoteDTEAddress entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PVCDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PVCDCERemoteDTEAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCERemoteDTEAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..18 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN
		    || ((0 > var_val_len || var_val_len > 18))) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCERemoteDTEAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PVCDCERemoteDTEAddress;
		old_length = StorageTmp->x25PVCDCERemoteDTEAddressLen;
		StorageTmp->x25PVCDCERemoteDTEAddress = string;
		StorageTmp->x25PVCDCERemoteDTEAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDCERemoteDTEAddress = old_value;
		StorageTmp->x25PVCDCERemoteDTEAddressLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PVCDCERemoteLogicalChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PVCDCERemoteLogicalChannel(int action, u_char *var_val, u_char var_val_type,
				    size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PVCDCETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDCERemoteLogicalChannel entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDCETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PVCDCERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PVCDCERemoteLogicalChannel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCERemoteLogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCERemoteLogicalChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDCERemoteLogicalChannel: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PVCDCERemoteLogicalChannel;
		StorageTmp->x25PVCDCERemoteLogicalChannel = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDCERemoteLogicalChannel = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PVCDXELogicalChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25PVCDXELogicalChannel(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25PVCDXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25PVCDXELogicalChannel entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25PVCDXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25PVCDXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25PVCDXELogicalChannel: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDXELogicalChannel not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDXELogicalChannel: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..4095 */
		if ((0 > set_value || set_value > 4095)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25PVCDXELogicalChannel: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25PVCDXELogicalChannel;
		StorageTmp->x25PVCDXELogicalChannel = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25PVCDXELogicalChannel = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		   u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOId entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25SVCIVMOId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOId;
		old_length = StorageTmp->x25SVCIVMOIdLen;
		StorageTmp->x25SVCIVMOId = string;
		StorageTmp->x25SVCIVMOIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOId = old_value;
		StorageTmp->x25SVCIVMOIdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOFastSelect(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOFastSelect(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			   u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOFastSelect entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOFastSelect: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOFastSelect not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOFastSelect: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25SVCIVMOFASTSELECT_NOTSPECIFIED:
		case X25SVCIVMOFASTSELECT_FASTSELECT:
		case X25SVCIVMOFASTSELECT_FASTSELECTWITHRESTRICTEDRESPONSE:
		case X25SVCIVMOFASTSELECT_NOFASTSELECT:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOFastSelect: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOFastSelect;
		StorageTmp->x25SVCIVMOFastSelect = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOFastSelect = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOPacketSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOPacketSizeIncoming(int action, u_char *var_val, u_char var_val_type,
				   size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOPacketSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOPacketSizeIncoming: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOPacketSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOPacketSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25SVCIVMOPACKETSIZEINCOMING_DEFAULT:
		case X25SVCIVMOPACKETSIZEINCOMING_PSIZE16:
		case X25SVCIVMOPACKETSIZEINCOMING_PSIZE32:
		case X25SVCIVMOPACKETSIZEINCOMING_PSIZE64:
		case X25SVCIVMOPACKETSIZEINCOMING_PSIZE128:
		case X25SVCIVMOPACKETSIZEINCOMING_PSIZE256:
		case X25SVCIVMOPACKETSIZEINCOMING_PSIZE512:
		case X25SVCIVMOPACKETSIZEINCOMING_PSIZE1024:
		case X25SVCIVMOPACKETSIZEINCOMING_PSIZE2048:
		case X25SVCIVMOPACKETSIZEINCOMING_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOPacketSizeIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOPacketSizeIncoming;
		StorageTmp->x25SVCIVMOPacketSizeIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOPacketSizeIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOPacketSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOPacketSizeOutgoing(int action, u_char *var_val, u_char var_val_type,
				   size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOPacketSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOPacketSizeOutgoing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOPacketSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOPacketSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25SVCIVMOPACKETSIZEOUTGOING_DEFAULT:
		case X25SVCIVMOPACKETSIZEOUTGOING_PSIZE16:
		case X25SVCIVMOPACKETSIZEOUTGOING_PSIZE32:
		case X25SVCIVMOPACKETSIZEOUTGOING_PSIZE64:
		case X25SVCIVMOPACKETSIZEOUTGOING_PSIZE128:
		case X25SVCIVMOPACKETSIZEOUTGOING_PSIZE256:
		case X25SVCIVMOPACKETSIZEOUTGOING_PSIZE512:
		case X25SVCIVMOPACKETSIZEOUTGOING_PSIZE1024:
		case X25SVCIVMOPACKETSIZEOUTGOING_PSIZE2048:
		case X25SVCIVMOPACKETSIZEOUTGOING_PSIZE4096:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOPacketSizeOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOPacketSizeOutgoing;
		StorageTmp->x25SVCIVMOPacketSizeOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOPacketSizeOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOReverseCharging(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOReverseCharging(int action, u_char *var_val, u_char var_val_type,
				size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOReverseCharging entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOReverseCharging: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOReverseCharging not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOReverseCharging: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case TV_TRUE:
		case TV_FALSE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOReverseCharging: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOReverseCharging;
		StorageTmp->x25SVCIVMOReverseCharging = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOReverseCharging = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOThroughputClassIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOThroughputClassIncoming(int action, u_char *var_val, u_char var_val_type,
					size_t var_val_len, u_char *statP, oid * name,
					size_t name_len)
{
	static long old_value;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25SVCIVMOThroughputClassIncoming entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOThroughputClassIncoming: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOThroughputClassIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOThroughputClassIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_DEFAULT:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B75:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B150:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B300:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B600:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1200:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B2400:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B4800:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B9600:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B19200:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B48000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B64000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B128000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B192000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B256000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B320000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B384000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B448000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B512000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B576000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B640000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B704000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B768000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B832000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B896000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B960000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1024000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1088000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1792000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1152000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1216000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1280000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1344000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1408000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1472000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1536000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1600000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1664000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1728000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1856000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1920000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B1984000:
		case X25SVCIVMOTHROUGHPUTCLASSINCOMING_B2048000:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOThroughputClassIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOThroughputClassIncoming;
		StorageTmp->x25SVCIVMOThroughputClassIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOThroughputClassIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOThroughputClassOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOThroughputClassOutgoing(int action, u_char *var_val, u_char var_val_type,
					size_t var_val_len, u_char *statP, oid * name,
					size_t name_len)
{
	static long old_value;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB",
		    "write_x25SVCIVMOThroughputClassOutgoing entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOThroughputClassOutgoing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOThroughputClassOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOThroughputClassOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_DEFAULT:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B75:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B150:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B300:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B600:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1200:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B2400:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B4800:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B9600:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B19200:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B48000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B64000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B128000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B192000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B256000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B320000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B384000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B448000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B512000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B576000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B640000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B704000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B768000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B832000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B896000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B960000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1024000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1088000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1792000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1152000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1216000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1280000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1344000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1408000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1472000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1536000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1600000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1664000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1728000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1856000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1920000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B1984000:
		case X25SVCIVMOTHROUGHPUTCLASSOUTGOING_B2048000:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOThroughputClassOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOThroughputClassOutgoing;
		StorageTmp->x25SVCIVMOThroughputClassOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOThroughputClassOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOWindowSizeIncoming(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOWindowSizeIncoming(int action, u_char *var_val, u_char var_val_type,
				   size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOWindowSizeIncoming entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOWindowSizeIncoming: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOWindowSizeIncoming not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOWindowSizeIncoming: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..32768 */
		if ((1 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOWindowSizeIncoming: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOWindowSizeIncoming;
		StorageTmp->x25SVCIVMOWindowSizeIncoming = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOWindowSizeIncoming = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOWindowSizeOutgoing(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOWindowSizeOutgoing(int action, u_char *var_val, u_char var_val_type,
				   size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOWindowSizeOutgoing entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMOTableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMORowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOWindowSizeOutgoing: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOWindowSizeOutgoing not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOWindowSizeOutgoing: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 1..32768 */
		if ((1 > set_value || set_value > 32768)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOWindowSizeOutgoing: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOWindowSizeOutgoing;
		StorageTmp->x25SVCIVMOWindowSizeOutgoing = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOWindowSizeOutgoing = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		   u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOId entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25SVCIVMOId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOId;
		old_length = StorageTmp->x25SVCIVMOIdLen;
		StorageTmp->x25SVCIVMOId = string;
		StorageTmp->x25SVCIVMOIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOId = old_value;
		StorageTmp->x25SVCIVMOIdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTECallTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTECallTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTECallTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTECallTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTECallTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTECallTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTECallTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTECallTime;
		StorageTmp->x25SVCIVMODTECallTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTECallTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTEResetTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTEResetTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEResetTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTEResetTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEResetTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEResetTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 18000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEResetTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTEResetTime;
		StorageTmp->x25SVCIVMODTEResetTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEResetTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTEResetCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTEResetCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEResetCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTEResetCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEResetCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTEResetCount;
		StorageTmp->x25SVCIVMODTEResetCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEResetCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTEInterruptTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTEInterruptTime(int action, u_char *var_val, u_char var_val_type,
				 size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEInterruptTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTEInterruptTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEInterruptTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEInterruptTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 18000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEInterruptTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTEInterruptTime;
		StorageTmp->x25SVCIVMODTEInterruptTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEInterruptTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTEClearTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTEClearTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEClearTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTEClearTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEClearTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEClearTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 18000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEClearTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTEClearTime;
		StorageTmp->x25SVCIVMODTEClearTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEClearTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTEClearCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTEClearCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEClearCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTEClearCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEClearCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTEClearCount;
		StorageTmp->x25SVCIVMODTEClearCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEClearCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTEWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTEWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEWindowTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTEWindowTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEWindowTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEWindowTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTEWindowTime;
		StorageTmp->x25SVCIVMODTEWindowTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEWindowTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTEDataTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTEDataTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEDataTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTEDataTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEDataTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEDataTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEDataTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTEDataTime;
		StorageTmp->x25SVCIVMODTEDataTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEDataTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTEDataCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTEDataCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTEDataCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTEDataCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEDataCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTEDataCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTEDataCount;
		StorageTmp->x25SVCIVMODTEDataCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTEDataCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTERejectTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTERejectTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTERejectTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTERejectTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTERejectTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTERejectTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTERejectTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTERejectTime;
		StorageTmp->x25SVCIVMODTERejectTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTERejectTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTERejectCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODTERejectCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODTERejectCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODTETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODTERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODTERejectCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTERejectCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODTERejectCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODTERejectCount;
		StorageTmp->x25SVCIVMODTERejectCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODTERejectCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMOId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMOId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
		   u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMOId entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMOId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMOId not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25SVCIVMOId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMOId;
		old_length = StorageTmp->x25SVCIVMOIdLen;
		StorageTmp->x25SVCIVMOId = string;
		StorageTmp->x25SVCIVMOIdLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMOId = old_value;
		StorageTmp->x25SVCIVMOIdLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXECallTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXECallTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXECallTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXECallTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXECallTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXECallTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXECallTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXECallTime;
		StorageTmp->x25SVCIVMODXECallTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXECallTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXEResetTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXEResetTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEResetTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXEResetTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEResetTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEResetTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEResetTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXEResetTime;
		StorageTmp->x25SVCIVMODXEResetTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEResetTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXEClearTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXEClearTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEClearTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXEClearTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEClearTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEClearTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEClearTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXEClearTime;
		StorageTmp->x25SVCIVMODXEClearTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEClearTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXEInterruptTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXEInterruptTime(int action, u_char *var_val, u_char var_val_type,
				 size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEInterruptTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXEInterruptTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEInterruptTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEInterruptTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEInterruptTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXEInterruptTime;
		StorageTmp->x25SVCIVMODXEInterruptTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEInterruptTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXEResetCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXEResetCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEResetCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXEResetCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEResetCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEResetCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXEResetCount;
		StorageTmp->x25SVCIVMODXEResetCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEResetCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXEClearCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXEClearCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEClearCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXEClearCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEClearCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEClearCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXEClearCount;
		StorageTmp->x25SVCIVMODXEClearCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEClearCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXEWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXEWindowTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEWindowTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXEWindowTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEWindowTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEWindowTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEWindowTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXEWindowTime;
		StorageTmp->x25SVCIVMODXEWindowTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEWindowTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXEDataTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXEDataTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			    u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEDataTime entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXEDataTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEDataTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEDataTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEDataTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXEDataTime;
		StorageTmp->x25SVCIVMODXEDataTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEDataTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXEDataCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXEDataCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXEDataCount entering action=%d...  \n", action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXEDataCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEDataCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXEDataCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXEDataCount;
		StorageTmp->x25SVCIVMODXEDataCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXEDataCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXERejectTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXERejectTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			      u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXERejectTime entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXERejectTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXERejectTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXERejectTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXERejectTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXERejectTime;
		StorageTmp->x25SVCIVMODXERejectTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXERejectTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXERejectCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_x25SVCIVMODXERejectCount(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			       u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("x25PLPMIB", "write_x25SVCIVMODXERejectCount entering action=%d...  \n",
		    action));
	if ((StorageTmp =
	     header_complex(x25SVCIVMODXETableStorage, NULL,
			    &name[sizeof(x25PLPMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen,
			    1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->x25SVCIVMODXERowStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE),
					 "write to x25SVCIVMODXERejectCount: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXERejectCount not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE),
				 "write to x25SVCIVMODXERejectCount: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->x25SVCIVMODXERejectCount;
		StorageTmp->x25SVCIVMODXERejectCount = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->x25SVCIVMODXERejectCount = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEDTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			 u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEDTETable_data *StorageTmp = NULL;
	static struct x25PLEDTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEDTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25PLEDTETableStorage, NULL,
			   &name[sizeof(x25PLEDTETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDTERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEDTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEDTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEDTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25PLEDTETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PLEDTETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEDTETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEDTETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEDTERowStatus;
			StorageTmp->x25PLEDTERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEDTETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PLEDTETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEDTERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEDTETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEDTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEDTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEDTETable_destroy(&StorageDel);
			/* x25PLEDTETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEDCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			 u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEDCETable_data *StorageTmp = NULL;
	static struct x25PLEDCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEDCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25PLEDCETableStorage, NULL,
			   &name[sizeof(x25PLEDCETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDCERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEDCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEDCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEDCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25PLEDCETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PLEDCETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEDCETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEDCETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEDCERowStatus;
			StorageTmp->x25PLEDCERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEDCETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PLEDCETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEDCERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEDCETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEDCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEDCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEDCETable_destroy(&StorageDel);
			/* x25PLEDCETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEDXERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEDXERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			 u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEDXETable_data *StorageTmp = NULL;
	static struct x25PLEDXETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEDXETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25PLEDXETableStorage, NULL,
			   &name[sizeof(x25PLEDXETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDXERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEDXERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEDXERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEDXETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEDXETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25PLEDXETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PLEDXETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEDXETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEDXETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEDXERowStatus;
			StorageTmp->x25PLEDXERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEDXETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PLEDXETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEDXERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEDXETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEDXERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEDXERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEDXETable_destroy(&StorageDel);
			/* x25PLEDXETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEIVMODTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMODTETable_data *StorageTmp = NULL;
	static struct x25PLEIVMODTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEIVMODTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25PLEIVMODTETableStorage, NULL,
			   &name[sizeof(x25PLEIVMODTETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE),
			 "write to x25PLEIVMODTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMODTERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMODTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMODTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMODTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* x25PLEIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25PLEIVMODTETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PLEIVMODTETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEIVMODTETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEIVMODTETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMODTERowStatus;
			StorageTmp->x25PLEIVMODTERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEIVMODTETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PLEIVMODTETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMODTERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEIVMODTETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMODTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMODTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMODTETable_destroy(&StorageDel);
			/* x25PLEIVMODTETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PLEIVMODCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PLEIVMODCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	struct x25PLEIVMODCETable_data *StorageTmp = NULL;
	static struct x25PLEIVMODCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PLEIVMODCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25PLEIVMODCETableStorage, NULL,
			   &name[sizeof(x25PLEIVMODCETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE),
			 "write to x25PLEIVMODCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PLEIVMODCERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PLEIVMODCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PLEIVMODCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PLEIVMODCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* x25PLEIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25PLEIVMODCETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PLEIVMODCETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25PLEIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PLEIVMODCETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PLEIVMODCETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PLEIVMODCERowStatus;
			StorageTmp->x25PLEIVMODCERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PLEIVMODCETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PLEIVMODCETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PLEIVMODCERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PLEIVMODCETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMODCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PLEIVMODCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PLEIVMODCETable_destroy(&StorageDel);
			/* x25PLEIVMODCETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PVCDTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PVCDTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			 u_char *statP, oid * name, size_t name_len)
{
	struct x25PVCDTETable_data *StorageTmp = NULL;
	static struct x25PVCDTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PVCDTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25PVCDTETableStorage, NULL,
			   &name[sizeof(x25PVCDTETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PVCDTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PVCDTERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PVCDTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PVCDTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PVCDTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* x25VCId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25PVCDTETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PVCDTETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25VCId, vp->val.string, vp->val_len);
			StorageNew->x25VCIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PVCDTETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PVCDTETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PVCDTERowStatus;
			StorageTmp->x25PVCDTERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PVCDTETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PVCDTETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PVCDTERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PVCDTETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PVCDTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PVCDTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PVCDTETable_destroy(&StorageDel);
			/* x25PVCDTETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PVCDCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PVCDCERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			 u_char *statP, oid * name, size_t name_len)
{
	struct x25PVCDCETable_data *StorageTmp = NULL;
	static struct x25PVCDCETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PVCDCETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25PVCDCETableStorage, NULL,
			   &name[sizeof(x25PVCDCETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PVCDCERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PVCDCERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PVCDCERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PVCDCETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PVCDCETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* x25VCId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25PVCDCETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PVCDCETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25VCId, vp->val.string, vp->val_len);
			StorageNew->x25VCIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PVCDCETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PVCDCETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PVCDCERowStatus;
			StorageTmp->x25PVCDCERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PVCDCETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PVCDCETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PVCDCERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PVCDCETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PVCDCERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PVCDCERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PVCDCETable_destroy(&StorageDel);
			/* x25PVCDCETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25PVCDXERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25PVCDXERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			 u_char *statP, oid * name, size_t name_len)
{
	struct x25PVCDXETable_data *StorageTmp = NULL;
	static struct x25PVCDXETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25PVCDXETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25PVCDXETableStorage, NULL,
			   &name[sizeof(x25PVCDXETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PVCDXERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25PVCDXERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25PVCDXERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25PVCDXETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25PVCDXETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* x25VCId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25PVCDXETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25PVCDXETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25VCId, vp->val.string, vp->val_len);
			StorageNew->x25VCIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25PVCDXETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25PVCDXETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25PVCDXERowStatus;
			StorageTmp->x25PVCDXERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25PVCDXETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25PVCDXETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25PVCDXERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25PVCDXETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PVCDXERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25PVCDXERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25PVCDXETable_destroy(&StorageDel);
			/* x25PVCDXETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25SVCIVMORowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			  u_char *statP, oid * name, size_t name_len)
{
	struct x25SVCIVMOTable_data *StorageTmp = NULL;
	static struct x25SVCIVMOTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25SVCIVMOTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25SVCIVMOTableStorage, NULL,
			   &name[sizeof(x25SVCIVMOTable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25SVCIVMORowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25SVCIVMORowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25SVCIVMORowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25SVCIVMOTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25SVCIVMOTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* x25SVCIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25SVCIVMOTable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25SVCIVMOTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25SVCIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25SVCIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25SVCIVMOTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25SVCIVMOTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25SVCIVMORowStatus;
			StorageTmp->x25SVCIVMORowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25SVCIVMOTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25SVCIVMOTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25SVCIVMORowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25SVCIVMOTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25SVCIVMORowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25SVCIVMORowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25SVCIVMOTable_destroy(&StorageDel);
			/* x25SVCIVMOTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25SVCIVMODTERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	struct x25SVCIVMODTETable_data *StorageTmp = NULL;
	static struct x25SVCIVMODTETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25SVCIVMODTETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25SVCIVMODTETableStorage, NULL,
			   &name[sizeof(x25SVCIVMODTETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE),
			 "write to x25SVCIVMODTERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25SVCIVMODTERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25SVCIVMODTERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25SVCIVMODTETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25SVCIVMODTETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* x25SVCIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25SVCIVMODTETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25SVCIVMODTETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25SVCIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25SVCIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25SVCIVMODTETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25SVCIVMODTETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25SVCIVMODTERowStatus;
			StorageTmp->x25SVCIVMODTERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25SVCIVMODTETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25SVCIVMODTETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25SVCIVMODTERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25SVCIVMODTETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25SVCIVMODTERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25SVCIVMODTERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25SVCIVMODTETable_destroy(&StorageDel);
			/* x25SVCIVMODTETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_x25SVCIVMODXERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_x25SVCIVMODXERowStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len,
			     u_char *statP, oid * name, size_t name_len)
{
	struct x25SVCIVMODXETable_data *StorageTmp = NULL;
	static struct x25SVCIVMODXETable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(x25SVCIVMODXETable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp =
	    header_complex(x25SVCIVMODXETableStorage, NULL,
			   &name[sizeof(x25SVCIVMODXETable_variables_oid) / sizeof(oid) + 3 - 1],
			   &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE),
			 "write to x25SVCIVMODXERowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to x25SVCIVMODXERowStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->x25SVCIVMODXERowStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->x25SVCIVMODXETable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->x25SVCIVMODXETable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* x25PLEId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			/* x25SVCIVMOId */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);
			if (header_complex_parse_oid
			    (&(name[sizeof(x25SVCIVMODXETable_variables_oid) / sizeof(oid) + 2]),
			     newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = x25SVCIVMODXETable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			memdup((void *) &StorageNew->x25PLEId, vp->val.string, vp->val_len);
			StorageNew->x25PLEIdLen = vp->val_len;
			vp = vp->next_variable;
			memdup((void *) &StorageNew->x25SVCIVMOId, vp->val.string, vp->val_len);
			StorageNew->x25SVCIVMOIdLen = vp->val_len;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			x25SVCIVMODXETable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			x25SVCIVMODXETable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->x25SVCIVMODXERowStatus;
			StorageTmp->x25SVCIVMODXERowStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				x25SVCIVMODXETable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			x25SVCIVMODXETable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->x25SVCIVMODXERowStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			x25SVCIVMODXETable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25SVCIVMODXERowStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->x25SVCIVMODXERowStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			x25SVCIVMODXETable_destroy(&StorageDel);
			/* x25SVCIVMODXETable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
