#!/usr/bin/perl
# =============================================================================
# 
# @(#) $RCSfile$ $Name$($Revision$) $Date$
#
# -----------------------------------------------------------------------------
#
# Copyright (c) 2001-2007  OpenSS7 Corporation <http://www.openss7.com/>
# Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>
#
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>, or write to the
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# -----------------------------------------------------------------------------
#
# U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
# behalf of the U.S. Government ("Government"), the following provisions apply
# to you.  If the Software is supplied by the Department of Defense ("DoD"), it
# is classified as "Commercial Computer Software" under paragraph 252.227-7014
# of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
# successor regulations) and the Government is acquiring only the license rights
# granted herein (the license rights customarily provided to non-Government
# users).  If the Software is supplied to any unit or agency of the Government
# other than DoD, it is classified as "Restricted Computer Software" and the
# Government's rights in the Software are defined in paragraph 52.227-19 of the
# Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
# the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
# (or any successor regulations).
#
# -----------------------------------------------------------------------------
#
# Commercial licensing and support of this software is available from OpenSS7
# Corporation at a fee.  See http://www.openss7.com/
#
# -----------------------------------------------------------------------------
#
# Last Modified $Date$ by $Author$
#
# -----------------------------------------------------------------------------
#
# $Log$
# =============================================================================

eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
	if $running_under_some_shell;

$progname = $0;

$debug	    = 0;
$trace	    = 0;
$verbose    = 0;
$crossref   = 0;
@infiles    = ();

while ($ARGV[0]=~/^-/) {
	$_ = shift;
	last if /^--/;
	if (/^-n/) { $nflag++; next; }
	if (/^-d/) { $debug	= 1; next; }
	if (/^-t/) { $trace	= 1; next; }
	if (/^-v/) { $verbose	= 1; next; }
	if (/^-x/) { $crossref	= 1; next; }
	if (/^-f(.*)/) { if ($1) { push @infiles, $1; } else { push @infiles, shift; } next; }
	if (/^-o(.*)/) { if ($1) { $outfile = $1; } else { $outfile = shift; } next; }
	usage();
	die "I don't recognize this switch: $_\\n";
}

foreach $infile (@ARGV) {
	push @infiles, $infile;
}

sub usage {
	print STDERR "I: $0 Usage:\n";
	print STDERR "I:   $0 ".'[-d] [-t] [-v] [ [-f] infile [ [-o] outfile ] ]'."\n";
	print STDERR "I: 	-d - turn on debug mode\n";
	print STDERR "I: 	-t - turn on trace mode (lots of info)\n";
	print STDERR "I: 	-v - turn on verbose mode (lots of info)\n";
	print STDERR "I: 	-x - report crossreferences in output\n";
	print STDERR "I: 	[-f] infile  -  input file (default stdin)\n";
	print STDERR "I: 	[-o] outfile - output file (default stdout)\n";
}

$printit++ unless $nflag;

$\ = "\n";	# add new-line to print
$* = 0;		# do signleline matching
undef $/;	# read entire file

$file = '';

sub readfile {
	my $fh = shift;
	my $file = <$ifh>; # read entire file
	chomp $file;
	# strip leading whitespace
	$file=~s/^(?:\s|\n)*//s;
	# strip trailing whitespace
	$file=~s/(?:\s|\n)*$//s;
	# put an EOL on end in case file ends with comment
	$file .= "\n";
	return $file;
}

@filesread = ();

if (scalar @infiles > 0) {
	foreach $infile (@infiles) {
		open (INFILEH,"<$infile") || die "can't open $infile for input";
		$ifh = \*INFILEH;
		$file .= readfile($ifh);
		push @filesread, $infile;
	}
} else {
	$ifh = \*STDIN;
	$file .= readfile($ifh);
}

if ($outfile) {
	open (OUTFILEH,">$outfile") || die "can't open $outfile for output";
	select OUTFILEH;
} else {
	select STDOUT;
}

sub getchunk {
	# Get a chunk from the current or next file.  We try to look ahead 
}

# -------------------------------------
package Parser;
use strict;
# -------------------------------------

sub parse {
	my $type = shift;
	my $self = {};
	#print STDERR "Type is $type.";
	bless $self, $type;
	$self->{id} = ++$::oid;
	if ($::debug) {
		unless ($type=~/^Comment/) {
			$::depth++;
			if ($type=~/Template$/) {
				# $self->indent($::depth);
				# printf "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n";
			}
			$self->indent($::depth);
			printf "<$type> ... ";
			printf "\`".substr($_[0],0,index($_[0],"\n"))."'\n";
		}
	}
#	$self->{line} = $_[0];
#	$self->{success} = $::success;
	$::success = '';
	my $ret = $self->read(@_);
	if ($ret) {
#		unless ($::success) {
#			$::success = $self->{line};
#		}
#		if ($#::objects) {
#			$ret->{previous} = $::objects[-1];
#		}
		push @::objects, $ret;
#		my $n = $::root->{alloc}->{ref $ret}->{refs}++;
#		$::root->{alloc}->{total}->{refs}++;
		#print STDERR "Allocated ".$n." ".ref($ret).".";
	} else {
#		unless ($::success) {
#			$::success = $self->{success};
#		}
	}
	if ($::debug) {
		unless ($type=~/^Comment/) {
			if ($ret) {
				$self->indent($::depth);
				print "<$type> FOUND ";
				$self->gdmo();
				print "";
			} else {
				#$self->indent($::depth);
				#print "<$type> not found";
			}
			if ($type=~/Template$/) {
				# $self->indent($::depth);
				# printf "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n";
			}
			$::depth--;
		}
	}
	return $ret;
}

sub indent {
	my $self = shift;
	my $depth = shift;
	my $i; for ($i=0;$i<$depth;$i++) {
		printf '|';
	}
	return;
}

sub read {
	my $self = shift;
	return ($self->error(@_));
}

sub error {
	my $self = shift;
	unless ($::error) {
		# $::error = $_[0];
		$::errob = ref $self; }
	return undef;
}

# -------------------------------------
package Generator;
use strict;
# -------------------------------------

sub generate {
	my $self = shift;
	my $sub = shift;
	#print STDERR "//generating ".ref($self)."(".$sub.")";
	#print STDERR $self;
	return $self->$sub(@_);
}

sub call {
	my $self = shift;
	if ($::trace) { printf "--!!".ref($self)."!!--"; }
	#print STDERR "// calling ".ref($self)."(".$_[0].")";
	#print STDERR $self;
	push @::backtrack, $self;
	my $s; foreach $s (@{$self->{children}}) {
		#print STDERR "// calling ".ref($self)."(".$_[0].",".ref($s).")";
		if (defined $s) { $s->generate(@_); }
	}
	pop @::backtrack;
}

sub xref {
	my $self = shift;
	#print STDERR "// xref'ing ".ref($self)."(xref).";
	#print STDERR $self;
	return $self->call('xref',@_);
}
sub gdmo {
	my $self = shift;
	#print STDERR "// gdmo'ing ".ref($self)."(gdmo).";
	return $self->call('gdmo',@_);
}
sub head {
	my $self = shift;
	#print STDERR "// head'ing ".ref($self)."(head).";
	return $self->call('head',@_);
}
sub stub {
	my $self = shift;
	return $self->call('stub',@_);
}
sub code {
	my $self = shift;
	#print STDERR "// code'ing ".ref($self)."(code).";
	return $self->call('code',@_);
}

sub xform {
	my $self = shift;
	my $prefix = shift;
	my $label = shift;
	my $suffix = shift;
	$label=~s/-/_/g;
	$label=~s/\./_/g;
	$label=~s/\//_/g;
	#$label=~s/$suffix$//;
	#$label.=$suffix;
	#$label=$prefix.$label;
	#if (length($label) > 20) {
	#	$label=~s/[aeiouy]//g;
	#}
	return $label;
}

sub decclass {
	my $self = shift;
	my $parent = shift;
	printf "\n$::indent"."class $self->{name}";
}

sub begclass {
	my $self = shift;
	my $parent = shift;
	$self->decclass($parent);
	printf " : public $parent {";
	$::indent.="\t";
	printf "\n$::indent"."private:";
	$::indent.="\t";
}

sub endclass {
	my $self = shift;
	my $parent = shift;
	my $name = $self->{name};
	my ($a,$e);
	$::indent=~s/^.//s;
	printf "\n$::indent"."public:";
	$::indent.="\t";
	printf "\n$::indent"."$name"."(";
	if (defined $self->{constructorrefs}) {
		foreach $a (@{$self->{constructorrefs}}) {
			if ($e) { printf ", "; } else { $e++; }
			printf "$a->{name}&";
		}
	}
	if (defined $self->{constructorptrs}) {
		foreach $a (@{$self->{constructorptrs}}) {
			if ($e) { printf ", "; } else { $e++; }
			printf "$a->{name} *";
		}
	}
	printf ");";
	printf "\n$::indent"."virtual ~$name"."();";
	$::indent=~s/^.//s;
	$::indent=~s/^.//s;
	printf "\n$::indent}";
	if ($::indent=~/^$/) {
		printf ";\t// class $name";
	} else {
		printf " $name;";
	}
	print '';
}

sub genclass {
	my $self = shift;
	my $parent = shift;
	$self->begclass($parent);
	$self->call('head',@_);
	$self->endclass($parent);
}

sub cdtors {
	my $self = shift;
	my @inits = shift;
	my $parent = shift;
	my ($a,$e);
	printf "\n$::indent"."$self->{scopedname}"."::$self->{name}"."(";
	if (defined $self->{constructorrefs}) {
		foreach $a (@{$self->{constructorrefs}}) {
			if ($e) { printf ", "; } else { $e++; }
			printf "$a->{scopedname}& $a->{name}_R";
		}
	}
	if (defined $self->{constructorptrs}) {
		foreach $a (@{$self->{constructorptrs}}) {
			if ($e) { printf ", "; } else { $e++; }
			printf "$a->{scopedname} *$a->{name}_P";
		}
	}
	printf ")";
	if (scalar @inits) {
		printf "\n$::indent".": "; undef $e;
		foreach $a (@inits) {
			if ($e) { printf ", "; } else { $e++; }
			printf "$a";
		}
	}
	printf "\n$::indent"."{";
	printf "\n$::indent"."}";
	printf "\n$::indent"."$self->{scopedname}"."::~$self->{name}"."(";
	printf ")";
	printf "\n$::indent"."{";
	printf "\n$::indent"."}";
}


# -------------------------------------
package ParserGenerator;
use strict;
use vars qw(@ISA);
@ISA = qw(Parser Generator);
# -------------------------------------

# -------------------------------------
package ParserGeneratorMajor;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub call {
	my $self = shift;
	#print STDERR "// calling ".ref($self)."(".$_[0].")";
	push @::backtrack, ref $self;
	my $c; foreach $c (@{$self->{children}}) {
		#print STDERR "// calling ".ref($self)."(".$_[0].",".ref($c).")";
		$c->generate(@_,$self);
	}
	pop @::backtrack;
}

# -------------------------------------
package CommaList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readitem {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless (($s = $type->parse($line,@_[1,-1])));
		push @{$self->{items}}, $s;
		push @{$self->{children}}, $s;
		while ($line=~s/^,//s) {
			$s->{commentplus} = Comments->parse($line,@_[1,-1]);
			last TEST unless (($s = $type->parse($line,@_[1,-1])));
			push @{$self->{items}}, $s;
			push @{$self->{children}}, $s;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/List$//) {
		$type.='Item';
	}
	$type=~s/Comma$//;
	return $self->readitem($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			if ($i) {
				printf ','; $::first = 0;
				if ($c) { $c->gdmo(@_); }
			} else { $i = 1; }
			$s->gdmo(@_);
			$c = $s->{commentplus};
		}
		$::indent=~s/^.//s;
	}
}

# -------------------------------------
package CommaListUnindented;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		#$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			if ($i) {
				printf ','; $::first = 0;
				if ($c) { $c->gdmo(@_); }
			} else { $i = 1; }
			$s->gdmo(@_);
			$c = $s->{commentplus};
		}
		#$::indent=~s/^.//s;
	}
}

# -------------------------------------
package SimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readitem {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless (($s = $type->parse($line,@_[1,-1])));
		push @{$self->{items}}, $s;
		push @{$self->{children}}, $s;
		while (($s = $type->parse($line,@_[1,-1]))) {
			push @{$self->{items}}, $s;
			push @{$self->{children}}, $s;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/List$//) {
		$type.='Item';
	}
	$type=~s/Simple$//;
	return $self->readitem($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		#$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			$s->gdmo();
		}
		#$::indent=~s/^.//s;
	}
}

# -------------------------------------
package SimpleListIndented;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			$s->gdmo();
		}
		$::indent=~s/^.//s;
	}
}

# -------------------------------------
package MandatoryBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub readinterior {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^{//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{interior} = $type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{interior};
		last TEST unless ($line=~s/^}//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/Braced$//) {
		$type.='Lists';
	}
	return $self->readinterior($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '{'; $::first = 0;
		{
			#$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{interior}->gdmo();
			#$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf '}'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package MandatoryParens;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub readinterior {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\(//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{interior} = $type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{interior};
		last TEST unless ($line=~s/^\)//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/Parens$//) {
		$type.='Lists';
	}
	return $self->readinterior($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '('; $::first = 0;
		{
			#$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{interior}->gdmo();
			#$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf ')'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package OptionalBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub readinterior {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^{//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		if (($self->{interior} = $type->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{interior};
		}
		last TEST unless ($line=~s/^}//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#print STDERR "Reading type $type.";
	unless ($type=~s/Braced$//) {
		$type.='Lists';
	}
	return $self->readinterior($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '{'; $::first = 0;
		{
			#$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (($s = $self->{interior})) { $s->gdmo(); }
			#$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf '}'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SimpleToken;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readtoken {
	my $self = shift;
	my $token = shift;
	my $line = $_[0];
	TEST: {
		my $substitute;
		$self->{token} = $token;
		$substitute = $token;
		$substitute=~s/[ \t]+/\\s\*/g;
		#print STDERR "Substituting '$substitute'.";
		last TEST unless ($line=~s/^$substitute//s);
		# $self->{token} = $&;
		#print STDERR "Got '$self->{token}'.";
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Token$//;
	return $self->readtoken($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{token}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DashedToken;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readtoken {
	my $self = shift;
	my $token = shift;
	my $line = $_[0];
	TEST: {
		my $substitute;
		$self->{token} = $token;
		$substitute = $token;
		$substitute=~s/-/ /g;
		$substitute=~s/[ \t]+/\\s\*-?\\s\*/g;
		#print STDERR "Substituting '$substitute'.";
		last TEST unless ($line=~s/^$substitute//s);
		# $self->{token} = $&;
		#print STDERR "Got '$self->{token}'.";
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Token$//;
	return $self->readtoken($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{token}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DashedTokenIndented;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{token}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# =====================================
package Gdmo;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# =====================================

sub printem {
	my $self = shift;
	my $line = shift;
	my @lines = ( split(/\n/,$line,$::context) );
	my $l; my $i = 0; foreach $l (@lines) {
		if ($i < $::context - 1) {
			print $l;
		}
		$i++;
	}
	return;
}

sub read {
	my $self = shift;
	my $line = $_[0];
	my $s;
	$::error = '';
	if (($self->{modules} = GdmoModuleList->parse($line,@_[1,-1]))) {
		push @{$self->{children}}, $self->{modules};
	}
	if (length($line)) {
		print '<'.$::errob.">:\nSYNTAX ERROR (LINE $::lineno, LENGTH ".length($line).") NEAR(LENGTH ".length($::error)."):\n";
		$self->printem($::error);
		print '<'.$::errob.">:\nSYNTAX ERROR (LINE $::lineno, LENGTH ".length($line).") SUCCESS(LENGTH ".length($::success)."):\n";
		$self->printem($::success);
		print '<'.$::errob.">:\nSYNTAX ERROR LAST 10 SUCCESSFUL OBJECTS:";
		my $i; for ($i=-10;$i<0;$i++) {
			my $s = $::objects[$i];
			if ($s) {
				printf '<'.ref($s).">:\n'";
				$s->gdmo();
				print "'";
			}
		}
		return 0;
	}
	$_[0] = $line;
	return $self;
}

sub head {
	my $self = shift;
	my @names = ( 'relations', 'bindings', 'subordinates', 'objects', 'objects', 'packages', 'actions', 'notifications', 'groups', 'constraints', 'attributes', 'parameters', 'mappings', 'behaviours' );
	my @headers = ( 'Name Binding', 'Subordination Rule', 'Managed Object Class Factory', 'Managed Object Class', 'Package', 'Action', 'Notification', 'Attribute Group', 'Constraint Rule', 'Attribute', 'Parameter', 'Behaviour' );
	my @suffixes = ( '', '', 'Factory', '', '', '', '', '', '', '', '', '' );
	if (0) {
		my ($x,$d,$i,$e);
		for ($i=0;$i<scalar @names;$i++) {
			# Generate declarations for all classes
			printf "\n// $headers[$i] declarations\n";
			foreach $x (sort keys %{$::root->{$names[$i]}}) {
				if (($d = $::root->{$names[$i]}->{$x}->{defn})) {
					printf "\nclass $d->{scopedname}"."$suffixes[$i];";
					$e++;
				}
			}
			if ($e) { $e = 0; } else { printf "\n// No items\n"; }
			printf "\n";
		}
	}
	$self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	print '--@@ GDMOCHECK $Revision$';
	print '--@@ Copyright (c), 2001-2007 OpenSS7 Corporation  <http://www.openss7.com/>';
	print '--@@ Copyright (c), 1999-2000 Brian F. G. Bidulock <bidulock@openss7.org>';
	print '--@@ ';
	my $file = $::infile;
	$file = "(standard input)" unless ($file);
	my $date = `date`;
	$date=~s/(?:\s|\n)*$//s;
	print "--@@ Input File: <$file>";
	print "--@@ Special File: <$file\.specials>";
	print "--@@ Date: ".$date;
	print '--@@ ';
	my ($s,$i);
	$::first = 1;
	if (($s = $self->{modules})) { $s->gdmo(); }
	if (!$::first) { printf "\n"; $::first = 1; }
	print '--@@ ';
	print '--@@ end of gdmos';
	print '--@@ ';
	my ($id,$n,$s);
	if (1) {
		$i = 0;
		foreach $id (sort keys %{$::root->{gdmos}}) {
			unless (($s = $::root->{gdmos}->{$id}->{defn})) {
				if (defined $::root->{gdmos}->{$id}->{refs}) {
					$n = scalar @{$::root->{gdmos}->{$id}->{refs}};
					unless ($i) { print "--@@"; }
					printf "--@@ These modules reference \"$id\" $n times.\n";
					$i++;
				}
			}
		}
		if ($i) { print "--@@"; }
	}
	if ($i) {
		$i = 0;
		foreach $id (sort keys %{$::root->{gdmos}}) {
			if (($s = $::root->{gdmos}->{$id}->{defn})) {
				unless ($i) { print "--@@"; }
				printf "--@@ These modules define \"$id\"\n";
				$i++;
			}
		}
		if ($i) { print "--@@"; }
	}
	if (1) {
		my ($g,$l);
		foreach $g (@{$::root->{modules}}) {
			$i = 0;
			foreach $l (sort keys %{$g->{objects}}) {
				if ($g->{objects}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines MANAGED OBJECT CLASS $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no MANAGED OBJECT CLASS."; }
			$i = 0;
			foreach $l (sort keys %{$g->{objects}}) {
				if (!$g->{objects}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{objects}->{$l}->{docs}}) {
						print "--@@ This module references MANAGED OBJECT CLASS $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no MANAGED OBJECT CLASS."; }
			$i = 0;
			foreach $l (sort keys %{$g->{packages}}) {
				if ($g->{packages}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines PACKAGE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no PACKAGE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{packages}}) {
				if (!$g->{packages}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{packages}->{$l}->{docs}}) {
						print "--@@ This module references PACKAGE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no PACKAGE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{parameters}}) {
				if ($g->{parameters}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines PARAMETER $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no PARAMETER."; }
			$i = 0;
			foreach $l (sort keys %{$g->{parameters}}) {
				if (!$g->{parameters}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{parameters}->{$l}->{docs}}) {
						print "--@@ This module references PARAMETER $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no PARAMETER."; }
			$i = 0;
			foreach $l (sort keys %{$g->{relations}}) {
				if ($g->{relations}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines RELATIONSHIP CLASS $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no RELATIONSHIP CLASS."; }
			$i = 0;
			foreach $l (sort keys %{$g->{relations}}) {
				if (!$g->{relations}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{relations}->{$l}->{docs}}) {
						print "--@@ This module references RELATIONSHIP CLASS $l in module \"$id\".";
					}
					$i++;
				}
			}
			$i = 0;
			foreach $l (sort keys %{$g->{bindings}}) {
				if ($g->{bindings}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines NAME BINDING $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no NAME BINDING."; }
			$i = 0;
			foreach $l (sort keys %{$g->{bindings}}) {
				if (!$g->{bindings}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{bindings}->{$l}->{docs}}) {
						print "--@@ This module references NAME BINDING $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no NAME BINDING."; }
			$i = 0;
			foreach $l (sort keys %{$g->{attributes}}) {
				if ($g->{attributes}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines ATTRIBUTE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no ATTRIBUTE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{attributes}}) {
				if (!$g->{attributes}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{attributes}->{$l}->{docs}}) {
						print "--@@ This module references ATTRIBUTE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no ATTRIBUTE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{groups}}) {
				if ($g->{groups}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines ATTRIBUTE GROUP $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no ATTRIBUTE GROUP."; }
			$i = 0;
			foreach $l (sort keys %{$g->{groups}}) {
				if (!$g->{groups}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{groups}->{$l}->{docs}}) {
						print "--@@ This module references ATTRIBUTE GROUP $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no ATTRIBUTE GROUP."; }
			$i = 0;
			foreach $l (sort keys %{$g->{behaviours}}) {
				if ($g->{behaviours}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines BEHAVIOUR $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no BEHAVIOUR."; }
			$i = 0;
			foreach $l (sort keys %{$g->{behaviours}}) {
				if (!$g->{behaviours}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{behaviours}->{$l}->{docs}}) {
						print "--@@ This module references BEHAVIOUR $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no BEHAVIOUR."; }
			$i = 0;
			foreach $l (sort keys %{$g->{actions}}) {
				if ($g->{actions}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines ACTION $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no ACTION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{actions}}) {
				if (!$g->{actions}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{actions}->{$l}->{docs}}) {
						print "--@@ This module references ACTION $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no ACTION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{notifications}}) {
				if ($g->{notifications}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines NOTIFICATION $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no NOTIFICATION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{notifications}}) {
				if (!$g->{notifications}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{notifications}->{$l}->{docs}}) {
						print "--@@ This module references NOTIFICATION $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no NOTIFICATION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{constraints}}) {
				if ($g->{constraints}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines CONSTRAINT RULE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no CONSTRAINT RULE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{constraints}}) {
				if (!$g->{constraints}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{constraints}->{$l}->{docs}}) {
						print "--@@ This module references CONSTRAINT RULE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no CONSTRAINT RULE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{subordinates}}) {
				if ($g->{subordinates}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines SUBORDINATION RULE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no SUBORDINATION RULE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{subordinates}}) {
				if (!$g->{subordinates}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{subordinates}->{$l}->{docs}}) {
						print "--@@ This module references SUBORDINATION RULE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no SUBORDINATION RULE."; }
		}
	}
	if (1) {
		my ($g,$l);
		$g = $::root;
		if (1) {
			$i = 0;
			foreach $l (sort keys %{$g->{objects}}) {
				if (!$g->{objects}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{objects}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference MANAGED OBJECT CLASS $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no MANAGED OBJECT CLASS."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{objects}}) {
					if ($g->{objects}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define MANAGED OBJECT CLASS $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no MANAGED OBJECT CLASS."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{packages}}) {
				if (!$g->{packages}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{packages}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference PACKAGE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no PACKAGE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{packages}}) {
					if ($g->{packages}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define PACKAGE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no PACKAGE."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{parameters}}) {
				if (!$g->{parameters}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{parameters}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference PARAMETER $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no PARAMETER."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{parameters}}) {
					if ($g->{parameters}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define PARAMETER $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no PARAMETER."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{relations}}) {
				if (!$g->{relations}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{relations}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference RELATIONSHIP CLASS $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no NAME BINDING."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{relations}}) {
					if ($g->{relations}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define RELATIONSHIP CLASS $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no NAME BINDING."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{bindings}}) {
				if (!$g->{bindings}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{bindings}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference NAME BINDING $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no NAME BINDING."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{bindings}}) {
					if ($g->{bindings}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define NAME BINDING $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no NAME BINDING."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{attributes}}) {
				if (!$g->{attributes}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{attributes}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference ATTRIBUTE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no ATTRIBUTE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{attributes}}) {
					if ($g->{attributes}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define ATTRIBUTE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no ATTRIBUTE."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{groups}}) {
				if (!$g->{groups}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{groups}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference ATTRIBUTE GROUP $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no ATTRIBUTE GROUP."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{groups}}) {
					if ($g->{groups}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define ATTRIBUTE GROUP $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no ATTRIBUTE GROUP."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{behaviours}}) {
				if (!$g->{behaviours}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{behaviours}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference BEHAVIOUR $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no BEHAVIOUR."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{behaviours}}) {
					if ($g->{behaviours}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define BEHAVIOUR $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no BEHAVIOUR."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{actions}}) {
				if (!$g->{actions}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{actions}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference ACTION $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no ACTION."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{actions}}) {
					if ($g->{actions}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define ACTION $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no ACTION."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{notifications}}) {
				if (!$g->{notifications}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{notifications}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference NOTIFICATION $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no NOTIFICATION."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{notifications}}) {
					if ($g->{notifications}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define NOTIFICATION $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no NOTIFICATION."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{constraints}}) {
				if (!$g->{constraints}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{constraints}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference CONSTRAINT RULE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no CONSTRAINT RULE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{constraints}}) {
					if ($g->{constraints}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define CONSTRAINT RULE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no CONSTRAINT RULE."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{subordinates}}) {
				if (!$g->{subordinates}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{subordinates}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference SUBORDINATION RULE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no SUBORDINATION RULE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{subordinates}}) {
					if ($g->{subordinates}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define SUBORDINATION RULE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no SUBORDINATION RULE."; }
			}
		}
	}
	print '--@@ ';
	if ($::crossref) {
		print "--@@ ****************************************";
		my $e;
		my $i = 0;
		foreach $e (keys %::refs) {
			$i++;
			unless ($::defs{$e}->{count}) {
				unless (${%{$::spec->{vars}}}{$e}) {
					print "--@@ UNDEFINED REFERENCE: $e";
				}
			}
		}
		print "--@@ THERE ARE $i REFERENCES.";
		$i = 0;
		foreach $e (keys %::defs) {
			$i++;
			if ($::defs{$e}->{count} > 1) {
				print "--@@ DEFINITION $e DEFINED $::defs{$e}->{count} TIMES!";
			}
			unless ($::refs{$e}) {
				print "--@@ UNREFERENCED DEFINITION: $e";
			}
		}
		print "--@@ THERE ARE $i DEFINITIONS.";
	}
#	print STDERR ref($::root->{alloc});
#	my ($k); foreach $k (sort keys %{$::root->{alloc}}) {
#		print STDERR "Allocated ".$::root->{alloc}->{$k}->{refs}." $k.";
#	}
	my ($l); foreach $l ('objects', 'packages', 'parameters', 'attributes', 'groups', 'behaviours', 'actions', 'notifications', 'constraints', 'subordinates') {
		my ($k); foreach $k (sort keys %{$::root->{$l}}) {
			if ($::root->{$l}->{$k}->{defn}) {
				if (!defined $::root->{$l}->{$k}->{refs}) {
					#print STDERR "W: $l $k defined but never referenced!";
				}
			} elsif (defined $::root->{$l}->{$k}->{refs}) {
				print "--@@ $l $k referenced but never defined!";
				print STDERR "E: $l $k referenced but never defined!";
				my $r; foreach $r (@{$::root->{$l}->{$k}->{refs}}) {
					print "--@@ ".ref($r)." references undefined \"$r->{documentid}\":$k";
				}
			}
		}
	}
	# print a derivation tree
	my ($d); if ($d = $::root->{objects}->{top}->{defn}) {
		printf "\n--@@";
		printf "\n--@@ Derivation Tree:";
		printf "\n--@@";
		$d->showderived();
		printf "\n--@@\n";
	}
	# print a containment tree
	my ($d); if ($d = $::root->{objects}->{top}->{defn}) {
		printf "\n--@@";
		printf "\n--@@ Containment Tree:";
		printf "\n--@@";
		$d->showcontained();
		printf "\n--@@\n";
	}
	print "--@@ vim: comments=\\b\\:--";
	print "--@@ vim: formatoptions+=tcqlornw tw=120 nocin nosi";
}



# -------------------------------------
package GdmoModuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------
#
# -------------------------------------
package GdmoModule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# -------------------------------------
# A GDMO module consists of zero or more template specifiers.  GDMO Templates are only valid outside
# of ASN.1 modules.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$e);
		$e = 0;
		if (($s = GdmoPreambleDirectives->parse($line,$self))) {
			$self->{preamble} = $s;
			push @{$self->{children}}, $s;
			$e++;
		}
		if (($s = Module->parse($line,$self))) {
			$self->{module} = $s;
			push @{$self->{children}}, $s;
			$e++;
		}
		if (($s = TemplateList->parse($line,$self))) {
			$self->{templates} = $s;
			push @{$self->{children}}, $s;
			$e++;
		}
		if (($s = Asn1ModuleList->parse($line,$self))) {
			$self->{asn1modules} = $s;
			push @{$self->{children}}, $s;
			$e++;
		}
		last TEST unless (
			!$self->{module} ||
			($self->{end} = End->parse($line,$self))
		);
		if ($self->{end}) {
			push @{$self->{children}}, $self->{end};
		}
		if (($s = GdmoPostambleDirectives->parse($line,$self))) {
			$self->{postamble} = $s;
			push @{$self->{children}}, $s;
			$e++;
		}
		last TEST unless ($e != 0);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my @names = ( 'bindings', 'subordinates', 'objects', 'objects', 'packages', 'actions', 'notifications', 'groups', 'constraints', 'attributes', 'parameters', 'behaviours' );
	my @headers = ( 'Name Binding', 'Subordination Rule', 'Managed Object Class Factory', 'Managed Object Class', 'Package', 'Action', 'Notification', 'Attribute Group', 'Constraint Rule', 'Attribute', 'Parameter', 'Behaviour' );
	my @suffixes = ( '', '', 'Factory', '', '', '', '', '', '', '', '', '' );
	my ($x,$d,$i,$e);
	for ($i=0;$i<scalar @names;$i++) {
		# Generate declarations for all classes
		printf "\n// $headers[$i] declarations\n";
		foreach $x (sort keys %{$self->{$names[$i]}}) {
			if (($d = $self->{$names[$i]}->{$x}->{defn})) {
				printf "\nclass $d->{scopedname}"."$suffixes[$i];";
				$e++;
			}
		}
		if ($e) { $e = 0; } else { printf "\n// No items\n"; }
		printf "\n";
	}
	$self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{preamble})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		if (($s = $self->{module})) { $s->gdmo(); }
		if (($s = $self->{templates})) { $s->gdmo(); }
		if (($s = $self->{asn1modules})) { $s->gdmo(); }
		if (($s = $self->{end})) { $s->gdmo(); }
		if (($s = $self->{postamble})) { $s->gdmo(); }
		if (0) {
			my ($d,$i);
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			foreach $d (sort keys %{$self->{aliases}}) {
				unless ($i) { print "--@@"; }
				print "--@@ This module defines \"$d\".";
				$i++;
			}
			if ($i) { print "--@@"; }
		}
	}
}

# -------------------------------------
package Module;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MODULE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if ($self->{documentstring} = DocumentIdentifier->parse($line,@_[1,-1])) {
			push @{$self->{children}}, $self->{documentstring};
		}
		if ($self->{documentoid} = ObjectIdentifierValue->parse($line,@_[1,-1])) {
			push @{$self->{children}}, $self->{documentoid};
		}
		last TEST unless ($self->{documentstring} || $self->{documentoid});
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; };
		printf 'MODULE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{documentstring})) { $s->gdmo(); }
		if (($s = $self->{documentoid})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoPreambleDirectives;
use strict;
use vars qw(@ISA);
@ISA = qw(Directives);
# -------------------------------------

# -------------------------------------
package GdmoPostambleDirectives;
use strict;
use vars qw(@ISA);
@ISA = qw(Directives);
# -------------------------------------

# -------------------------------------
package GdmoPreambleDirectivesChoice;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GDMO\s*\.\s*(\w*)\s*//s);
		$self->{directive} = $1;
		if ($self->{directive}=~/^Version$/) {
		} elsif ($self->{directive}=~/^Copyright$/) {
		} elsif ($self->{directive}=~/^Document$/) {
		} elsif ($self->{directive}=~/^Alias$/) {
		} elsif ($self->{directive}=~/^Include$/) {
		} else {
			last TEST;
		}
		$self->{type} = 'Gdmo'.$self->{directive}.'Directive';
		last TEST unless (($self->{item} = "$self->{type}"->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{item};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'GDMO.'.$self->{directive}; $::first = 0;
		$self->{item}->gdmo();
	}
}

# -------------------------------------
package GdmoPostambleDirectivesChoice;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GDMO\s*\.\s*(\w*)\s*//s);
		$self->{directive} = $1;
		if ($self->{directive}=~/^ChangeLog$/) {
		} elsif ($self->{directive}=~/^EndDocument$/) {
		} else {
			last TEST;
		}
		$self->{type} = 'Gdmo'.$self->{directive}.'Directive';
		last TEST unless (($self->{item} = "$self->{type}"->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{item};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'GDMO.'.$self->{directive}; $::first = 0;
		$self->{item}->gdmo();
	}
}

# -------------------------------------
package Asn1ModuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package Asn1Module;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# -------------------------------------
# ASN.1 modules are distingushed by
#
# ModuleIdentifier ObjectIdentifier DEFINITIONS ::= BEGIN ... END

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if ($self->{directives} = Asn1Directives->parse($line,@_[1,-1],$self)) {
			push @{$self->{children}}, $self->{directives};
		}
		last TEST unless (($self->{name} = ModuleIdentifier->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{name};
		last TEST unless (($self->{oid} = ObjectIdentifierValue->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{oid};
		last TEST unless (($self->{definitions} = Asn1Definitions->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{definitions};
		if ($self->{tagdefault} = TagDefault->parse($line,@_[1,-1],$self)) {
			push @{$self->{children}}, $self->{tagdefault};
		}
		if ($self->{extdefault} = ExtensionDefault->parse($line,@_[1,-1],$self)) {
			push @{$self->{children}}, $self->{extdefault};
		}
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{begin} = Begin->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{begin};
		if ($self->{body} = ModuleBody->parse($line,@_[1,-1],$self)) {
			push @{$self->{children}}, $self->{body};
		}
		last TEST unless (($self->{end} = End->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{end};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{preamble})) { $s->gdmo(); }
		foreach $s (@{$self->{comments}}) { $s->gdmo(); }
		$self->{name}->gdmo();
		$self->{oid}->gdmo();
		$self->{definitions}->gdmo();
		if (($s = $self->{tagdefault})) { $s->gdmo(); }
		if (($s = $self->{extdefault})) { $s->gdmo(); }
		$self->{assign}->gdmo();
		$self->{begin}->gdmo();
		if (($s = $self->{body})) { $s->gdmo(); }
		$self->{end}->gdmo();
	}
}

# -------------------------------------
package Asn1Definitions;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('DEFINITIONS',@_);
}

# -------------------------------------
package TagDefault;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{tags} = ExplicitTags->parse($line,@_[1,-1])) ||
			($self->{tags} = ImplicitTags->parse($line,@_[1,-1])) ||
			($self->{tags} = AutomaticTags->parse($line,@_[1,-1]))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{tags}->gdmo();
	}
}

# -------------------------------------
package ExplicitTags;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EXPLICIT TAGS',@_);
}

# -------------------------------------
package ImplicitTags;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('IMPLICIT TAGS',@_);
}

# -------------------------------------
package AutomaticTags;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('AUTOMATIC TAGS',@_);
}

# -------------------------------------
package ExtensionDefault;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EXTENSIBILITY IMPLIED',@_);
}

# -------------------------------------
package Assign;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('::=',@_);
}

# -------------------------------------
package Begin;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('BEGIN',@_);
}

# -------------------------------------
package End;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('END',@_);
}

# -------------------------------------
package ModuleBody;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if ($self->{exports} = Exports->parse($line,@_[1,-1])) {
			push @{$self->{children}}, $self->{exports};
		}
		if ($self->{imports} = Imports->parse($line,@_[1,-1])) {
			push @{$self->{children}}, $self->{imports};
		}
		if ($self->{assignmentlist} = AssignmentList->parse($line,@_[1,-1])) {
			push @{$self->{children}}, $self->{assignmentlist};
		}
		last TEST unless ($line=~s/^\s*((?:.|\n)*?)\s*(?=END)//s);
		$self->{text} = $1;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{exports})) { $s->gdmo(); }
		if (($s = $self->{imports})) { $s->gdmo(); }
		if (($s = $self->{assignmentlist})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{text}"; $::first = 0;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
package Exports;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^EXPORTS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (
			($self->{exports} = ExportsAll->parse($line,@_[1,-1])) ||
			($self->{exports} = ExportedSymbols->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{exports};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'EXPORTS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{exports}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExportsAll;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ALL',@_);
}

# -------------------------------------
package ExportedSymbols;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readitem('TypeReference',@_);
}

# -------------------------------------
package Imports;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless ($line=~s/^IMPORTS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		if (($self->{imports} = SymbolsFromModuleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{imports};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'IMPORTS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (($s = $self->{imports})) { $s->gdmo(); }
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SymbolsFromModuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package SymbolsFromModule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless (($self->{symbols} = ImportedSymbols->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{symbols};
		last TEST unless ($line=~s/^FROM//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (
			($self->{module} = GlobalModuleReference->parse($line,@_[1,-1])) ||
			($self->{module} = ModuleReference->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{module};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	# note the order, imported symbols are called with the associated
	# module on the stack
	$self->{module}->xref(@_);
	$self->{symbols}->xref(@_,$self->{module});
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{symbols}->gdmo();
		if (!$::first) { printf "\n$::indent\t"; } else { printf "\t"; $::first = 0; }
		printf 'FROM'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{module}->gdmo();
	}
}

# -------------------------------------
package ImportedSymbols;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readitem('TypeReference',@_);
}

# -------------------------------------
package GlobalModuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{module} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{module};
		last TEST unless (($self->{object} = ObjectIdentifierValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{object};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{module}->xref(@_);
	$self->{object}->xref(@_,$self->{module});
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{module}->gdmo();
		$self->{object}->gdmo();
	}
}

# -------------------------------------
package AssignmentList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package Assignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{assignment} = TypeAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ValueAssignment->parse($line,@_[1,-1])) ||
#			($self->{assignment} = XMLValueAssignment->parse($line,@_[1,-1])) ||
			($self->{assignment} = ValueSetTypeAssignment->parse($line,@_[1,-1]))
#			|| ($self->{assignment} = ObjectClassAssignment->parse($line,@_[1,-1]))
#			|| ($self->{assignment} = ObjectAssignment->parse($line,@_[1,-1]))
#			|| ($self->{assignment} = ObjectSetAssignment->parse($line,@_[1,-1]))
#			|| ($self->{assignment} = ParameterizedAssignment->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{assignment};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{assignment}->gdmo();
	}
}

# -------------------------------------
package TypeAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = TypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{reference}->gdmo();
		$self->{assign}->gdmo();
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package ValueAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = ValueReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{reference}->gdmo();
		$self->{type}->gdmo();
		$self->{assign}->gdmo();
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package Value;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = BuiltinValue->parse($line,@_[1,-1])) ||
			($self->{value} = ReferencedValue->parse($line,@_[1,-1])) ||
			($self->{value} = ObjectClassFieldName->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package BuiltinValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = BitStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = BooleanValue->parse($line,@_[1,-1])) ||
			($self->{value} = CharacterStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = ChoiceValue->parse($line,@_[1,-1])) ||
			($self->{value} = EmbeddedPDVValue->parse($line,@_[1,-1])) ||
			($self->{value} = EnumeratedValue->parse($line,@_[1,-1])) ||
			($self->{value} = ExternalValue->parse($line,@_[1,-1])) ||
#			($self->{value} = InstanceOfValue->parse($line,@_[1,-1])) ||
			($self->{value} = IntegerValue->parse($line,@_[1,-1])) ||
			($self->{value} = NullValue->parse($line,@_[1,-1])) ||
			($self->{value} = ObjectIdentifierValue->parse($line,@_[1,-1])) ||
			($self->{value} = OctetStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = RealValue->parse($line,@_[1,-1])) ||
			($self->{value} = RelativeOIDValue->parse($line,@_[1,-1])) ||
			($self->{value} = SequenceValue->parse($line,@_[1,-1])) ||
			($self->{value} = SequenceOfValue->parse($line,@_[1,-1])) ||
			($self->{value} = SetValue->parse($line,@_[1,-1])) ||
			($self->{value} = SetOfValue->parse($line,@_[1,-1])) ||
			($self->{value} = TaggedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package ReferencedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = DefinedValue->parse($line,@_[1,-1])) ||
			($self->{value} = ValueFromObject->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package NamedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package Identifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-)//s);
		$self->{identifier} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{identifier}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ValueSetTypeAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = TypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
		last TEST unless (($self->{assign} = Assign->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{assign};
		last TEST unless (($self->{valueset} = ValueSet->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{valueset};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{reference}->gdmo();
		$self->{assign}->gdmo();
		$self->{valueset}->gdmo();
	}
}

# -------------------------------------
package ValueSet;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ElementSetSpecs',@_); }

# -------------------------------------
package Type;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = BuiltinType->parse($line,@_[1,-1])) ||
			($self->{type} = ReferencedType->parse($line,@_[1,-1])) ||
			($self->{type} = ConstrainedType->parse($line,@_[1,-1]))

		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package BuiltinType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = BitStringType->parse($line,@_[1,-1])) ||
			($self->{type} = BooleanType->parse($line,@_[1,-1])) ||
			($self->{type} = CharacterStringType->parse($line,@_[1,-1])) ||
			($self->{type} = ChoiceType->parse($line,@_[1,-1])) ||
			($self->{type} = EmbeddedPDVType->parse($line,@_[1,-1])) ||
			($self->{type} = EnumeratedType->parse($line,@_[1,-1])) ||
			($self->{type} = ExternalType->parse($line,@_[1,-1])) ||
#			($self->{type} = InstanceOfType->parse($line,@_[1,-1])) ||
			($self->{type} = IntegerType->parse($line,@_[1,-1])) ||
			($self->{type} = NullType->parse($line,@_[1,-1])) ||
#			($self->{type} = ObjectClassFieldType->parse($line,@_[1,-1])) ||
			($self->{type} = ObjectIdentifierType->parse($line,@_[1,-1])) ||
			($self->{type} = OctetStringType->parse($line,@_[1,-1])) ||
			($self->{type} = RealType->parse($line,@_[1,-1])) ||
			($self->{type} = RelativeOIDType->parse($line,@_[1,-1])) ||
			($self->{type} = SequenceType->parse($line,@_[1,-1])) ||
			($self->{type} = SequenceOfType->parse($line,@_[1,-1])) ||
			($self->{type} = SetType->parse($line,@_[1,-1])) ||
			($self->{type} = SetOfType->parse($line,@_[1,-1])) ||
			($self->{type} = TaggedType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package BooleanType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('BOOLEAN',@_);
}

# -------------------------------------
package BooleanValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($line=~s/^(TRUE|FALSE)//s));
		$self->{value} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{value}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package IntegerType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^INTEGER//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{list} = NamedNumberListBraced->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{list};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf 'INTEGER'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{list})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamedNumberListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package NamedNumberList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package NamedNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless ($line=~s/^\(//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (
			($self->{number} = SignedNumber->($line)) ||
			($self->{number} = DefinedValue->($line))
		);
		push @{$self->{children}}, $self->{number};
		last TEST unless ($line=~s/^\)//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{identifier}->gdmo();
		printf '('; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{number}->gdmo();
		printf ')'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SignedNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(0|-?[1-9][0-9]*)//s);
		$self->{number} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{number}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gmdo(); }
	}
}

# -------------------------------------
package Number;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(0|[1-9][0-9]*)//s);
		$self->{number} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{number}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package IntegerValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (
			($s = SignedNumber->parse($line,@_[1,-1])) ||
			($s = Identifier->parse($line,@_[1,-1]))
			# FIXME: the identifier here must ne one of the identifiers in the
			# IntegerType with which the value is associated, and shall represent the
			# corresponding number.  See X.608 Clause 18.10.
		);
		$self->{value} = $s;
		push @{$self->{children}}, $s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package EnumeratedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ENUMERATED//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($line=~s/^{//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{enumerations} = Enumerations->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{enumerations};
		last TEST unless ($line=~s/^}//s);
		$self->{comments3} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'ENUMERATE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		printf '{'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments2})) { $s->gdmo(); }
			$self->{enumerations}->gdmo();
			$::indent=~s/^.//s;
		}
		printf '}'; $::first = 0;
		if (($s = $self->{comments3})) { $s->gdmo(); }

	}
}

# -------------------------------------
package Enumerations;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{root} = RootEnumeration->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{root};
		if ($line=~s/^\,//s) {
			$self->{comments1} = Comments->parse($line,@_[1,-1]);
			last TEST unless ($line=~s/^\.\.\.//s);
			$self->{comments2} = Comments->parse($line,@_[1,-1]);
			last TEST unless (($self->{exceptionspec} = ExceptionSpec->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{exceptionspec};
			if ($line=~s/^\,//s) {
				$self->{comments3} = Comments->parse($line,@_[1,-1]);
				last TEST unless (($self->{additional} = AdditionalEnumeration->parse($line,@_[1,-1])));
				push @{$self->{children}}, $self->{additional};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{root}->gdmo();
		if (($s = $self->{exceptionspec})) {
			printf ','; $::first = 0;
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			printf '...'; $::first = 0;
			if (($s = $self->{comments2})) { $s->gdmo(); }
			$s->gdmo();
			if (($s = $self->{additional})) {
				printf ','; $::first = 0;
				if (($s = $self->{comments3})) { $s->gdmo(); }
				if (!$::first) { printf "\n$::indent"; $::first = 1; }
				$s->gdmo();

			}
		}
	}
}

# -------------------------------------
package RootEnumeration;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{enumeration} = Enumeration->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{enumeration};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{enumeration}->gdmo();
	}
}

# -------------------------------------
package AdditionalEnumeration;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{enumeration} = Enumeration->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{enumeration};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{enumeration}->gdmo();
	}
}

# -------------------------------------
package Enumeration;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package EnumerationItem;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{item} = Identifier->parse($line,@_[1,-1])) ||
			($self->{item} = NamedNumber->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{item};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{item}->gdmo();
	}
}

# -------------------------------------
package EnumeratedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		# FIXME: identifier must be in enumerated type
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package RealType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('REAL',@_);
}

# -------------------------------------
package RealValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = NumericRealValue->parse($line,@_[1,-1])) ||
			($self->{value} = SpecialRealValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package NumericRealValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = SignedRealNumber->parse($line,@_[1,-1])) ||
			($self->{value} = SequenceValue->parse($line,@_[1,-1]))
			# FIXME; where the sequence must contain mantisa base and exponent
			# named numbers (exponent may only be 2 or 10).
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package SignedRealNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^-?(?:0|[1-9][0-9]*)(?:\.[0-9][0-9]*)?//s);
		$self->{number} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{number}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}


# -------------------------------------
package SpecialRealValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(?:PLUS|MINUS)-INFINITY//s);
		$self->{value} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{value}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BitStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^BIT\s*STRING//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{list} = NamedBitListBraced->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{list};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'BIT STRING';
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{list})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamedBitListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package NamedBitList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package NamedBit;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless ($line=~s/^\(//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (
			($self->{number} = Number->($line)) ||
			($self->{number} = DefinedValue->($line))
		);
		push @{$self->{children}}, $self->{number};
		last TEST unless ($line=~s/^\)//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{identifier}->gdmo();
		printf '('; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{number}->gdmo();
		printf ')'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BitStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = Bstring->parse($line,@_[1,-1])) ||
			($self->{value} = Hstring->parse($line,@_[1,-1])) ||
			($self->{value} = BitStringValueList->parse($line,@_[1,-1])) ||
			($self->{value} = ContainingValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package Bstring;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^'([01]*)'[Bb]//s);
		$self->{value} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "'$self->{value}'B"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Hstring;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^'([0-9A-Fa-f]*)'[Hh]//s);
		$self->{value} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "'$self->{value}'H"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BitStringValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('IdentifierList',@_); }

# -------------------------------------
package IdentifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ContainingValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CONTAINING//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'CONTAINING'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package OctetStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('OCTET STRING',@_);
}

# -------------------------------------
package OctetStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = Bstring->parse($line,@_[1,-1])) ||
			($self->{value} = Hstring->parse($line,@_[1,-1])) ||
			($self->{value} = ContainingValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package NullType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('NULL',@_);
}

# -------------------------------------
package NullValue;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('NULL',@_);
}

# -------------------------------------
package SequenceType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SEQUENCE(?!\s*OF)//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{list} = ExtensionOrComponentTypeListBraced->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{list};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'SEQUENCE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{list})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExtensionOrComponentTypeListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

# -------------------------------------
package ExtensionOrComponentTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{exception} = ExtensionAndExceptionList->parse($line,@_[1,-1])) ||
			($self->{component} = ComponentTypeLists->parse($line,@_[1,-1]))
		);
		if ($self->{exception}) {
			push @{$self->{children}}, $self->{exception};
		}
		if ($self->{component}) {
			push @{$self->{children}}, $self->{component};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{exception})) { $s->gdmo(); }
		if (($s = $self->{component})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExtensionAndExceptionList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{exception} = ExtensionAndException->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{exception};
			if (($self->{extension} = ExtensionMarker->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{extension};
			}
		} else { last TEST; }
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{exception}->gdmo();
		if (($s = $self->{extension})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExtensionAndException;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\.\.\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{exception} = ExceptionSpec->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{exception};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '...'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{exception})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExtensionMarker;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^,//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($line=~s/^\.\.\.//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf ','; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf '...'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ComponentTypeLists;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{root} = RootComponentTypeList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{root};
			goto DONE unless ($line=~s/^\,//s);
			$self->{comments1} = Comments->parse($line,@_[1,-1]);
		}
		push @{$self->{children}}, $self->{root};
		last TEST unless (($self->{exception} = ExtensionAndException->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{exception};
		last TEST unless (($self->{addition} = ExtensionAdditions->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{addition};
		if (($self->{endmarker} = ExtensionMarker->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{endmarker};
			last TEST unless ($line=~s/^,//s);
			$self->{comments2} = Comments->parse($line,@_[1,-1]);
			last TEST unless (($self->{list} = RootComponentTypeList->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{list};
		} else {
			if (($self->{extension} = ExtensionMarker->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{extension};
			}
		}
	DONE:
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{root}->gdmo();
		if (($s = $self->{exception})) {
			printf ','; $::first = 0;
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{exception}->gdmo();
			if (($s = $self->{addition})) { $s->gdmo(); }
			if (($s = $self->{endmarker})) {
				$s->gdmo();
				printf ','; $::first = 0;
				if (($s = $self->{comments2})) { $s->gdmo(); }
				$self->{list}->gdmo();
			} else {
				if (($s = $self->{extension})) { $s->gdmo(); }
			}
		}
	}
}

# -------------------------------------
package RootComponentTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{list} = ComponentTypeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{list}->gdmo();
	}
}

# -------------------------------------
package ExtensionAdditions;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^,//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{list} = ExtensionAdditionList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		printf ','; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{list}->gdmo();
	}
}

# -------------------------------------
package ExtensionAdditionList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ExtensionAddition;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{addition} = ComponentType->parse($line,@_[1,-1])) ||
			($self->{addition} = ExtensionAdditionGroup->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{addition};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{addition}->gdmo();
	}
}

# -------------------------------------
package ExtensionAddtionGroup;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\[\[//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		if (($self->{version} = VersionNumber->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{version};
		}
		last TEST unless (($self->{list} = ComponentTypeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless ($line=~s/^\]\]//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '[['; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (($s = $self->{version})) { $s->gdmo(); }
		$self->{list}->gdmo();
		if (!$::first) { printf ' '; }
		printf ']]'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package VersionNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{number} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{number};
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{number}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ComponentTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ComponentType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{namedtype} = NamedType->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{namedtype};
			if ($line=~s/^OPTIONAL//s) {
				$self->{optional} = 'OPTIONAL';
				$self->{comments} = Comments->parse($line,@_[1,-1]);
			} elsif ($line=~s/^DEFAULT//s) {
				$self->{default} = 'DEFAULT';
				$self->{comments} = Comments->parse($line,@_[1,-1]);
				last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
				push @{$self->{children}}, $self->{value};
			}
		} elsif ($line=~s/^COMPONENTS\s*OF//s) {
			$self->{comments} = Comments->parse($line,@_[1,-1]);
			last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{type};
		} else {
			last TEST;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{namedtype})) {
			$s->gdmo();
			if ($self->{optional}) {
				if (!$::first) { printf ' '; }
				printf 'OPTIONAL'; $::first = 0;
			}
			if ($self->{default}) {
				if (!$::first) { printf ' '; }
				printf 'DEFAULT'; $::first = 0;
				$self->{value}->gdmo();
			}

		} else {
			if (!$::first) { printf ' '; }
			printf 'COMPONENTS OF'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{type}->gdmo();
		}
	}
}

# -------------------------------------
package SequenceValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ComponentValueList',@_); }

# -------------------------------------
package ComponentValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readitem('NamedValue',@_);
}

# -------------------------------------
package SequenceOfType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SEQUENCE\s*OF//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (
			($self->{type} = Type->parse($line,@_[1,-1])) ||
			($self->{type} = NamedType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'SEQUENCE OF'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package SequenceOfValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ValueListOrNameValueList',@_); }

# -------------------------------------
package ValueListOrNameValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{list} = ValueList->parse($line,@_[1,-1])) ||
			($self->{list} = NamedValueList->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{list}->gdmo();
	}
}

# -------------------------------------
package ValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package NamedValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package SetType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET(?!\s*OF)//s);
		$self->{comments} = Comments->pcase($line);
		$self->{list} = ExtensionOrComponentTypeListBraced->parse($line,@_[1,-1]);
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'SET'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{list})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SetValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('ComponentValueList',@_);
}

# -------------------------------------
package SetOfType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET\s*OF//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (
			($self->{type} = Type->parse($line,@_[1,-1])) ||
			($self->{type} = NamedType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'SET OF'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package SetOfValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('ValueListOrNamedValueList',@_);
}

# -------------------------------------
package ChoiceType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHOICE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{alternatives} = AlternativeTypeListsBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{alternatives};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'CHOICE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{alternatives}->gdmo();
	}
}

# -------------------------------------
package AlternativeTypeListsBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package AlternativeTypeLists;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{root} = RootAlternativeTypeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{root};
		if ($line=~s/^,//s) {
			$self->{comments} = Comments->parse($line,@_[1,-1]);
			last TEST unless (($self->{exception} = ExtensionAndException->parse($line,@_[1,-1])));
			push @{$self->{children}}, $self->{exception};
			if (($self->{addition} = ExtensionAdditionAlternatives->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{addition};
			}
			if (($self->{marker} = ExtensionMarker->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{marker};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{root}->gdmo();
		if (($s = $self->{exception})) {
			printf ','; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{exception}->gdmo();
			if (($s = $self->{addition})) { $s->gdmo(); }
			if (($s = $self->{marker})) { $s->gdmo(); }
		}
	}
}

# -------------------------------------
package RootAlternativeTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{list} = AlternativeTypeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{list}->gdmo();
	}
}

# -------------------------------------
package ExtensionAdditionAlternatives;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^,//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{list} = ExtensionAdditionAlternativesList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf ','; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{list}->gdmo();
	}
}


# -------------------------------------
package ExtensionAdditionAlternativesList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ExtensionAdditionAlternative',@_); }

# -------------------------------------
package ExtensionAdditionAlternative;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{alternative} = ExtensionAdditionAlternativesGroup->parse($line,@_[1,-1])) ||
			($self->{alternative} = NamedType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{alternative};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{alternative}->gdmo();
	}
}

# -------------------------------------
package ExtensionAdditionAlternativesGroup;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\[\[//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		if (($self->{version} = VersionNumber->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{version};
		}
		last TEST unless (($self->{list} = AlternativeTypeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless ($line=~s/^\]\]//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '[['; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (($s = $self->{version})) { $s->gdmo(); }
		$self->{list}->gdmo();
		if (!$::first) { printf ' '; }
		printf ']]'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AlternativeTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('NamedType',@_); }

# -------------------------------------
package ChoiceValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{value} = Value->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
		print ':'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package SelectionType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless ($line=~s/^\<//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
		printf '<'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package TaggedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{tag} = Tag->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{tag};
		if ($line=~s/^IMPLICIT//s) {
			$self->{implicit} = 'IMPLICIT';
			$self->{comments} = Comments->parse($line,@_[1,-1]);
		} elsif ($line=~s/^EXPLICIT//s) {
			$self->{explicit} = 'EXPLICIT';
			$self->{comments} = Comments->parse($line,@_[1,-1]);
		}
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{tag}->gdmo();
		if (($s = $self->{implicit})) {
			if (!$::first) { printf ' '; }
			printf 'IMPLICIT'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
		}
		if (($s = $self->{explicit})) {
			if (!$::first) { printf ' '; }
			printf 'EXPLICIT'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
		}
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package Tag;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\[//);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		if (($self->{class} = Class->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{class};
		}
		last TEST unless (($self->{number} = ClassNumber->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{number};
		last TEST unless ($line=~s/^\]//);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '['; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1;
		if (($s = $self->{class})) {
			$s->gdmo();
			$self->{number}->gdmo();
		} else {
			$::first = 1;
			$self->{number}->gdmo();
		}
		printf ']'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Class;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{class} = ClassUniversal->parse($line,@_[1,-1])) ||
			($self->{class} = ClassApplication->parse($line,@_[1,-1])) ||
			($self->{class} = ClassPrivate->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{class};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{class}->gdmo();
	}
}

# -------------------------------------
package ClassUniversal;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('UNIVERSAL',@_);
}

# -------------------------------------
package ClassApplication;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('APPLICATION',@_);
}

# -------------------------------------
package ClassPrivate;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('PRIVATE',@_);
}

# -------------------------------------
package ClassNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = Number->parse($line,@_[1,-1])) ||
			($self->{value} = DefinedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package ObjectIdentifierType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('OBJECT IDENTIFIER',@_);
}

# -------------------------------------
package ObjectIdentifierValue;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('ObjIdComponentsList',@_);
}

# -------------------------------------
package ObjIdComponentsList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package ObjIdComponents;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{component} = NameAndNumberForm->parse($line,@_[1,-1])) ||
			($self->{component} = NumberForm->parse($line,@_[1,-1])) ||
			($self->{component} = NameForm->parse($line,@_[1,-1])) ||
			($self->{component} = DefinedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{component};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{component}->gdmo();
	}
}

# -------------------------------------
package NameForm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
	}
}

# -------------------------------------
package NumberForm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{number} = Number->parse($line,@_[1,-1])) ||
			($self->{number} = DefinedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{number};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{number}->gdmo();
	}
}

# -------------------------------------
package NameAndNumberForm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless ($line=~s/^\(//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{number}  = NumberForm->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{number};
		last TEST unless ($line=~s/^\)//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{identifier}->gdmo();
		printf '('; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1;
		$self->{number}->gdmo();
		printf ')'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RelativeOIDType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('RELATIVE-OID',@_);
}

# -------------------------------------
package RelativeOIDValue;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('RelativeOIDComponentsList');
}

# -------------------------------------
package RelativeOIDComponentsList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package RelativeOIDComponents;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{component} = NameAndNumberForm->parse($line,@_[1,-1])) ||
			($self->{component} = NumberForm->parse($line,@_[1,-1])) ||
			($self->{component} = DefinedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{component};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{component}->gdmo();
	}
}

# -------------------------------------
package EmbeddedPDVType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EMBEDDED PDV',@_);
}

# -------------------------------------
package EmbeddedPDVValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = SequenceValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package ExternalType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EXTERNAL',@_);
}

# -------------------------------------
package ExternalValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = SequenceValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package CharacterStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = RestrictedCharacterStringType->parse($line,@_[1,-1])) ||
			($self->{type} = UnrestrictedCharacterStringType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package CharacterStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = RestrictedCharacterStringValue->parse($line,@_[1,-1])) ||
			($self->{value} = UnrestrictedCharacterStringValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package RestrictedCharacterStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = BMPStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = GeneralStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = GraphicStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = IA5StringToken->parse($line,@_[1,-1])) ||
			($self->{type} = ISO646StringToken->parse($line,@_[1,-1])) ||
			($self->{type} = NumericStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = PrintableStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = TeletexStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = T61StringToken->parse($line,@_[1,-1])) ||
			($self->{type} = UniversalStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = UTF8StringToken->parse($line,@_[1,-1])) ||
			($self->{type} = VideotexStringToken->parse($line,@_[1,-1])) ||
			($self->{type} = VisibleStringToken->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package BMPStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package GeneralStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package GraphicStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package IA5StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package ISO646StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package NumericStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package PrintableStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package TeletexStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package T61StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package UniversalStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package UTF8StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package VideotexStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package VisibleStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package RestrictedCharacterStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = CString->parse($line,@_[1,-1])) ||
			($self->{value} = CharacterStringList->parse($line,@_[1,-1])) ||
			($self->{value} = Quadruple->parse($line,@_[1,-1])) ||
			($self->{value} = Tuple->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package CharacterStringList;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('CharSyms',@_); }

# -------------------------------------
package CharSyms;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('CharsDefn',@_); }

# -------------------------------------
package CharsDefn;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = CString->parse($line,@_[1,-1])) ||
			($self->{value} = CharacterStringList->parse($line,@_[1,-1])) ||
			($self->{value} = Quadruple->parse($line,@_[1,-1])) ||
			($self->{value} = Tuple->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package Quadruple;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('QuadrupleList',@_); }

# -------------------------------------
package QuadrupleList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{group} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{group};
		last TEST unless ($line=~s/^,//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{plane} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{plane};
		last TEST unless ($line=~s/^,//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{row} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{row};
		last TEST unless ($line=~s/^,//s);
		$self->{comments3} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{cell} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{cell};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{group}->gdmo();
		printf ','; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{plane}->gdmo();
		printf ','; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{row}->gdmo();
		printf ','; $::first = 0;
		if (($s = $self->{comments3})) { $s->gdmo(); }
		$self->{cell}->gdmo();
	}
}

# -------------------------------------
package Tuple;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('TupleList',@_); }

# -------------------------------------
package TupleList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{column} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{column};
		last TEST unless ($line=~s/^,//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{row} = Number->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{row};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{column}->gdmo();
		printf ','; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{row}->gdmo();
	}
}

# -------------------------------------
package CString;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $string;
		last TEST unless ($line=~s/^\"((?:[^"]|\"\s*\")*)\"//s);
		$string = $1;
		$string=~s/\"\s+\"//gs;
		$string=~s/\"\"/\"/gs;
		$self->{string} = $string;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($string,$s);
		$string = $self->{string};
		$string=~s/\"/\"\"/g;
		if (!$::first) { printf ' '; }
		printf "\"$string\""; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UnrestrictedCharacterStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read { my $self = shift; return $self->readtoken('CHARACTER STRING',@_); }

# -------------------------------------
package UnrestrictedCharacterStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = SequenceValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package UsefulType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = GeneralizedTimeToken->parse($line,@_[1,-1])) ||
			($self->{type} = UTCTimeToken->parse($line,@_[1,-1])) ||
			($self->{type} = ObjectDescriptorToken->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package GeneralizedTimeToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package UTCTimeToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package ObjectDescriptorToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package ReferencedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (
			($s = DefinedType->parse($line,@_[1,-1])) ||
			($s = UsefulType->parse($line,@_[1,-1])) ||
			($s = SelectionType->parse($line,@_[1,-1])) ||
			($s = TypeFromObject->parse($line,@_[1,-1])) ||
			($s = ValueSetFromObjects->parse($line,@_[1,-1]))
		);
		$self->{type} = $s;
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package NamedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{identifier};
		last TEST unless (($self->{type} = Type->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package ObjectClassAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package ObjectAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package ObjectSetAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package ParameterizedAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package DefinedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = ExternalTypeReference->parse($line,@_[1,-1])) ||
			($self->{type} = TypeReference->parse($line,@_[1,-1])) ||
			($self->{type} = ParameterizedType->parse($line,@_[1,-1])) ||
			($self->{type} = ParameterizedValueSetType->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package DefinedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = ExternalValueReference->parse($line,@_[1,-1])) ||
			($self->{value} = ValueReference->parse($line,@_[1,-1])) ||
			($self->{value} = ParameterizedValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package ParameterizedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package ParameterizedValueSetType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package ParameterizedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package AAA;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package GdmoAliasDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (($self->{documentId} = DocumentSpecifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{documentId};
		last TEST unless (($s = DocumentIdentifier->parse($line,@_[1,-1])));
		push @{$self->{documentAliases}}, $s;
		push @{$self->{children}}, $s;
		while ($line=~s/^,(?:\s|\n)*//s) {
			last TEST unless (($s = DocumentIdentifier->parse($line,@_[1,-1])));
			push @{$self->{documentAliases}}, $s;
			push @{$self->{children}}, $s;
		}
		$_[0] = $line; return $self;
	}
	$self->{errors} = "must consist of GDMO.Alias <directive>";
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if ($::first) { printf '-- '; $::first = 0; }
		$self->{documentId}->gdmo();
		my $i = 0;
		foreach $s (@{$self->{documentAliases}}) {
			if ($i) { printf ",\n-- "; $::first = 0; }
			$s->gdmo();
			$i++;
		}
	}
}

# -------------------------------------
package DocumentSpecifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{specifier} = DocumentReference->parse($line,@_[1,-1])) ||
			($self->{specifier} = ObjectIdentifierValue->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{specifier};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{specifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoDocumentDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{documentstring} = DocumentIdentifier->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentstring};
		}
		if (($self->{documentoid} = ObjectIdentifierValue->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentoid};
		}
		last TEST unless ($self->{documentstring} || $self->{documentoid});
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{documentstring})) { $s->gdmo(); }
		if (($s = $self->{documentoid})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoEndDocumentDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{documentstring} = DocumentIdentifier->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentstring};
		}
		if (($self->{documentoid} = ObjectIdentifierValue->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentoid};
		}
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if ($::first) { printf '-- '; $::first = 0; }
		if (($s = $self->{documentstring})) { $s->gdmo(); }
		if (($s = $self->{documentoid})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoVersionDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{version} = Version->parse($line,@_[1,-1]);
		push @{$self->{children}}, $self->{version};
		if (($self->{documentstring} = DocumentIdentifier->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentstring};
		}
		if (($self->{documentoid} = ObjectIdentifierValue->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentoid};
		}
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if ($::first) { printf '-- '; $::first = 0; }
		if (($s = $self->{version})) { $s->gdmo(); }
		if ($::first) { printf '-- '; $::first = 0; }
		if (($s = $self->{documentstring})) { $s->gdmo(); }
		if ($::first) { printf '-- '; $::first = 0; }
		if (($s = $self->{documentoid})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoCopyrightDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{copyright} = $line;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$l);
		if ($::first) { printf '-- '; $::first = 0; }
		foreach $l (split(/\n/,$self->{copyright})) {
			printf "\n--  ".$l; $::first = 0;
		}
		printf "\n-- "; $::first = 0;
	}
}

# -------------------------------------
package GdmoChangeLogDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{changelog} = $line;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$l);
		if ($::first) { printf '-- '; $::first = 0; }
		foreach $l (split(/\n/,$self->{changelog})) {
			printf "\n--  ".$l; $::first = 0;
		}
		printf "\n-- "; $::first = 0;
	}
}

# -------------------------------------
package GdmoIncludeDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\s*"([^"]*)"\s*//s);
		$self->{filename} = $1;
		#print STDERR "Checking $self->{filename}...";
		my $f; foreach $f (@::filesread) {
			if ($f eq $self->{filename}) {
				#print STDERR "$self->{filename} is equal to $f";
				goto DONE;
			} else {
				#print STDERR "$self->{filename} is not equal to $f";
			}
		}
		{
			push @::filesread, $self->{filename};
			print STDERR "I: Reading $self->{filename}...";
			open (MYFILEH,"<$self->{filename}") || die "can't open $self->{filename} for input";
			my $ifh = \*MYFILEH;
			my $file = <$ifh>;
			chomp $file;
			# strip leading whitespace
			$file=~s/^(?:\s|\n)*//s;
			# strip trailing whitespace
			$file=~s/(?:\s|\n)*$//s;
			# put an EOL on end in case file ends with comment
			$file .= "\n";
			close (MYFILEH);
			#print STDERR "Included file $self->{filename} is:";
			#print STDERR $file;
			die "could not parse $self->{filename}"
				unless (($self->{module} = GdmoModule->parse($file)));
			push @{$self->{children}}, $self->{module};
		}
	DONE:
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $name = $self->{filename};
	$name=~s/\.gdmo$/.hh/;
	$name=~s/(\.hh)?$/.hh/;
	printf "\n$::indent"."#include <$name>"; $::first = 0;
}

sub stub {
	my $self = shift;
	my $name = $self->{filename};
	$name=~s/\.gdmo$/.hh/;
	$name=~s/(\.hh)?$/.hh/;
	printf "\n$::indent"."#include <$name>"; $::first = 0;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$l);
		if ($::first) { printf '-- '; $::first = 0; } else { printf ' '; }
		printf "\"$self->{filename}\""; $::first = 0;
	}
}


# -------------------------------------
package Asn1VersionDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{version} = Version->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{version};
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{version}->gdmo();
	}
}

# -------------------------------------
package Version;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[0-9]+(?:\.[0-9]+)*//s);
		$self->{version} = $&;
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{version}"; $::first = 0;
	}
}

# -------------------------------------
package Directives;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readdirective {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$directive,$e);
		do {
			if ($line=~s/^(?:\s|\n)*--<((?:.|\n)*?)>--(?:\s|\n)*//s) {
				$directive = $1;
				# strip all the continuation markers
				$directive=~s/\n[ \t]*(?:--[ \t]*)?/\n/sg;
				# strip leading and trailing whitespace
				$directive=~s/^(?:\s|\n)*//s;
				$directive=~s/(?:\s|\n)*$//s;
				if (($s = $type->parse($directive,@_[1,-1]))) {
					push @{$self->{directives}}, $s;
					push @{$self->{children}}, $s;
				}
				$e++;
			} elsif (($s = Comments->parse($line,@_[1,-1]))) {
				push @{$self->{comments}}, $s;
				$e++;
			}
		} while ($s);
		last TEST unless ($e);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref($self).'Choice';
	return $self->readdirective($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		foreach $s (@{$self->{directives}}) {
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			printf '--<'; $::first = 0;
			$s->gdmo();
			if (!$::first) { printf ' '; } else { printf '-- '; $::first = 0; }
			printf '>--'; $::first = 0;
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
		}
		foreach $s (@{$self->{comments}}) { $s->gdmo(); }
	}
}

# -------------------------------------
package Asn1Directives;
use strict;
use vars qw(@ISA);
@ISA = qw(Directives);
# -------------------------------------

# -------------------------------------
package Asn1DirectivesChoice;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ASN1\s*\.\s*(\w*)\s*//s);
		$self->{directive} = $1;
		if ($self->{directive}=~/^Version$/) {
		} elsif ($self->{directive}=~/^FileNameExtension$/) {
		} elsif ($self->{directive}=~/^FileNamePrefixe$/) {
		} elsif ($self->{directive}=~/^FileNameSuffix$/) {
		} elsif ($self->{directive}=~/^Nickname$/) {
		} elsif ($self->{directive}=~/^Remove$/) {
		} elsif ($self->{directive}=~/^WorkingSet1$/) {
		} else {
			last TEST;
		}
		$self->{type} = 'Asn1'.$self->{directive}.'Directive';
		last TEST unless (($self->{item} = "$self->{type}"->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{item};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'ASN1.'.$self->{directive}; $::first = 0;
		$self->{item}->gdmo();
	}
}


# ----------------------------------------
package Comments;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		if (($s = Comment->parse($line,@_[1,-1]))) {
			push @{$self->{comments}}, $s;
			while (($s = Comment->parse($line,@_[1,-1]))) {
				push @{$self->{comments}}, $s;
			}
			$line=~s/^(\s|\n)*//s;
			$_[0] = $line; return $self;
		} else {
			$line=~s/^(\s|\n)*//s;
			$_[0] = $line;
		}
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		foreach $s (@{$self->{comments}}) {
			$s->gdmo();
		}
	}
}

# ----------------------------------------
package Comment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------
# Comments can either be -- folowed by an end of line or a -- followed by a ---.  There is a special
# construct in the Ammendment 3 for X.722 which provides for the following:


sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^((?:\s|\n)*)--(?!<)([^\n]*)(\n|--)(?:\s|\n)*//s);
		$self->{beginning} = $1;
		$self->{comment} = $2;
		$self->{ending} = $3;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		# do not print our own compiler generated comments
		unless ($self->{comment}=~/^@@/s) {
			if ($self->{beginning}=~/\n/) {
				if (!$::first) {
					printf "\n$::indent--"; $::first = 0;
				} else {
					printf '--'; $::first = 0;
				}
			} else {
				printf '--'; $::first = 0;
			}
			printf "$self->{comment}"; $::first = 0;
			if ($self->{ending}=~/^--/) {
				printf '--'; $::first = 0;
			} else {
				printf "\n$::indent"; $::first = 1;
			}
		}
	}
}

# ----------------------------------------
package TemplateList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# ----------------------------------------

# ----------------------------------------
package Template;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$::noref++;
		last TEST unless (
			($self->{template} = ClassTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = PackageTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = ParameterTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = NameBindingTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = AttributeTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = AttributeGroupTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = BehaviourTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = ActionTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = NotificationTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = SubordinationRuleTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = ConstraintRuleTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = RelationshipClassTemplate->parse($line,@_[1,-1])) ||
			($self->{template} = RelationshipMappingTemplate->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{template};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "\n$::indent";
		if (($s = $self->{template})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "\n$::indent";
	}
}

# ----------------------------------------
package ObjectTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# ----------------------------------------

sub xreftyped {
	my $self = shift;
	my $type = shift;
	my $gdmo = $_[0];

#	if (defined $::root{$type}->{$self->{label}}->{defn}) {
#		print STDERR "E: object ".ref($self)."($self->{label}) already defined.";
#		print STDERR "E: attempted redefinition from \"$gdmo->{documentid}\".";
#		print STDERR "E: original definition in \"$::root->{$type}->{$self->{label}}->{modl}->{documentid}\".";
#		die "multiple definitions";
#	}
#	print STDERR "Assigning document id \"$gdmo->{documentid}\" from ".ref($gdmo)." to ".ref($self)." from xreftyped";
#	$self->{documentid} = $gdmo->{documentid};
#	$gdmo->{$type}->{$self->{label}}->{defn} = $self;
#	$::root->{$type}->{$self->{label}}->{defn} = $self;
#	$::root->{$type}->{$self->{label}}->{modl} = $gdmo;
	if ($type=~/bindings|subordinates/) {
		if (defined $self->{superior}) {
			my $s = $self->{superior}->{class};
			if (defined $::root->{objects}->{$s->{label}}->{defn}) {
				$::root->{objects}->{$s->{label}}->{defn}->{subordinate} = $self;
				push @{$::root->{objects}->{$s->{label}}->{defn}->{subordinates}}, $self;
			}
			push @{$self->{constructorrefs}}, $s;
		}
		if (defined $self->{subordinate}) {
			my $s = $self->{subordinate}->{class};
			if (defined $::root->{objects}->{$s->{label}}->{defn}) {
				$::root->{objects}->{$s->{label}}->{defn}->{superior} = $self;
				push @{$::root->{objects}->{$s->{label}}->{defn}->{superiors}}, $self;
			}
			push @{$self->{constructorrefs}}, $s;
		}
		if (defined $self->{subordinates}) {
			my $s; foreach $s (@{$self->{subordinates}->{items}}) {
				if (defined $::root->{objects}->{$s->{label}}->{defn}) {
					$::root->{objects}->{$s->{label}}->{defn}->{superior} = $self;
					push @{$::root->{objects}->{$s->{label}}->{defn}->{superiors}}, $self;
				}
				push @{$self->{constructorrefs}}, $s;
			}
		}
	}
	$self->call('xref',@_);
}

sub pushscope {
	my $self = shift;
	my $label = shift;
	my $suffix = ref $self;
	$suffix=~s/Template//;
	$suffix=~s/Class/ManagedObject/;
	$suffix=~s/SubordinationRule/Subordinate/;
	$suffix=~s/ConstraintRule/Constraint/;
	$self->{label} = $label;
	$self->{name} = $self->xform('',$label,$suffix);
	$self->{scope} = $::scope;
	if (length $::scope > 0) {
		$::scope.='::'.$self->{name};
	} else {
		$::scope = $self->{name};
	}
	$self->{scopedname} = $::scope;
}
sub popscope {
	my $self = shift;
	$::scope = $self->{scope};
}
sub definition {
	my $self = shift;
	my $gdmo = $_[1];

	#print STDERR "I: Stack from: ".ref($self);
	#my $s; foreach $s (@_) {
	#	print STDERR "I: Stack is: ".ref($s);
	#}

	my $type = ref $self;
	$type=~s/Template//;
	$type=lc $type;
	$type.='s';
	$type=~s/classs/objects/;
	$type=~s/namebindings/bindings/;
	$type=~s/attributegroups/groups/;
	$type=~s/subordinationrules/subordinates/;
	$type=~s/constraintrules/constraints/;
	$type=~s/relationshipclass/relations/;
	$type=~s/relationshipmapping/mapping/;

	if (defined $::root{$type}->{$self->{label}}->{defn}) {
		print STDERR "E: object ".ref($self)."($self->{label}) already defined.";
		print STDERR "E: attempted redefinition from \"$gdmo->{documentid}\".";
		print STDERR "E: original definition in \"$::root->{$type}->{$self->{label}}->{modl}->{documentid}\".";
		die "multiple definitions";
	}
	#print STDERR "Assigning document id \"$gdmo->{documentid}\" from ".ref($gdmo)." to ".ref($self)." $self->{label} from definition";
	$self->{documentid} = $gdmo->{documentid};
	$gdmo->{$type}->{$self->{label}}->{defn} = $self;
	$::root->{$type}->{$self->{label}}->{defn} = $self;
	$::root->{$type}->{$self->{label}}->{modl} = $gdmo;
}

sub xref {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Template//;
	$type=lc $type;
	$type.='s';
	$type=~s/classs/objects/;
	$type=~s/namebindings/bindings/;
	$type=~s/attributegroups/groups/;
	$type=~s/subordinationrules/subordinates/;
	$type=~s/constraintrules/constraints/;
	$type=~s/relationshipclass/relations/;
	$type=~s/relationshipmapping/mapping/;
	return $self->xreftyped($type,@_);
}

sub gdmolabel {
	my $self = shift;
	my $title = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my ($s,$r);
		printf "$self->{label} $title"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$r = 0;
			foreach $s (@{$self->{children}}) {
				if (ref $s eq 'RegisteredAs') {
					if (!$r) { $::indent=~s/^.//s; $r = 1; }
				}
				$s->gdmo();
			}
			if (!$r) { $::indent=~s/^.//s; $r = 1; }
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ClassTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*MANAGED(?:\s|\n)*((-)?)(?:\s|\n)*OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{derivedfrom} = DerivedFromClasses->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{derivedfrom};
		}
		if (($self->{characterization} = Characterization->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{characterization};
		}
		if (($self->{conditionalpackages} = ConditionalPackages->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{conditionalpackages};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if ($::root->{objects}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{objects}->{$self->{label}}->{intf} = $self;
		printf "\n$::indent"."class $self->{name}"."Factory : public ManagedObjectFactory {";
		$::indent.="\t";
		printf "\n$::indent"."public:";
		$::indent.="\t";
		printf "\n$::indent"."$self->{scopedname}& create(";
		#if (defined $self->{superior}) {
		#	printf "\n$::indent"."\t$self->{superior}->{scopedname}& nameBinding,";
		#	printf "\n$::indent"."\t$self->{superior}->{superior}->{class}->{scopedname}& superiorObject,";
		#} else {
			printf "\n$::indent"."\tNameBinding& nameBinding,";
			printf "\n$::indent"."\tManagedObject& superiorObject,";
		#}
		printf "\n$::indent"."\tconst char **name";
		my ($d,@derived,@list,$l,$s);
		@list = ( $self );
		while ($d = shift @list) {
			if ($d->{derivedfrom}) {
				my @superiors = ();
				foreach $l (@{$d->{derivedfrom}->{classes}->{items}}) {
					if (($s = $::root->{objects}->{$l->{label}}->{defn})) {
						unshift @superiors, $s;
					}
				}
				push @list, @superiors;
			}
			push @derived, $d;
		}
		while ($d = pop @derived) {
			my ($p,$e,$a);
			#if (!defined $self->{head}->{$d->{label}}->{refs}) {
			#	$self->{head}->{$d->{label}}->{refs}++;
				if (defined $d->{constructorrefs}) {
					foreach $p (@{$d->{constructorrefs}}) {
						#printf ",\n$::indent"."\t$p->{scopedname}& $p->{name}Reference";
						if ($p = $::root->{packages}->{$p->{label}}->{defn}) {
							if (defined $p->{constructorrefs}) {
								foreach $a (@{$p->{constructorrefs}}) {
									printf ",\n$::indent"."\t$a->{scopedname}& $a->{name}Reference";
								}
							}
							if (defined $p->{constructorptrs}) {
								foreach $a (@{$p->{constructorptrs}}) {
									printf ",\n$::indent"."\t$a->{scopedname} *$a->{name}Pointer";
								}
							}
						}
					}
				}
				if (defined $d->{constructorptrs}) {
					foreach $p (@{$d->{constructorptrs}}) {
						#printf ",\n$::indent"."\t$p->{scopedname} *$p->{name}Pointer";
						if ($p = $::root->{packages}->{$p->{label}}->{defn}) {
							if (defined $p->{constructorrefs}) {
								foreach $a (@{$p->{constructorrefs}}) {
									printf ",\n$::indent"."\t$a->{scopedname} *$a->{name}Pointer";
								}
							}
							if (defined $p->{constructorptrs}) {
								foreach $a (@{$p->{constructorptrs}}) {
									printf ",\n$::indent"."\t$a->{scopedname} *$a->{name}Pointer";
								}
							}
						}
					}
				}
			#}
		}
		printf "\n$::indent".");";
		printf "\n$::indent"."$self->{name}"."Factory();";
		printf "\n$::indent"."virtual ~$self->{name}"."Factory();";
		$::indent=~s/^.//s;
		$::indent=~s/^.//s;
		printf "\n$::indent"."}; // class $self->{name}"."Factory";
		printf "\n$::indent";
		if ($self->{derivedfrom}) {
			$self->decclass('ManagedObject');
		} else {
			$self->begclass('ManagedObject');
		}
		my $x;
		if (($x = $self->{derivedfrom})) { $x->generate('head',@_,$self); }
		printf "\n$::indent"."static const char name"."[];";
		printf "\n$::indent"."static bool subclassOf(typename type);";
		printf "\n$::indent"."static $self->{name}& Create();";
		printf "\n$::indent"."virtual Delete();";
		if (defined $self->{superiors}) {
			printf "\n$::indent"."// NAMED BY SUPERIOR OBJECT CLASS:";
			foreach $x (@{$self->{superiors}}) {
				printf "\n$::indent"."$x->{scopedname}& $x->{superior}->{class}->{name};";
			}
		} elsif (defined $self->{superior}) {
			printf "\n$::indent"."// NAMED BY SUPERIOR OBJECT CLASS:";
			printf "\n$::indent"."$self->{superior}->{scopedname}& $self->{superior}->{superior}->{class}->{name};"
		}
		if (defined $self->{subordinates}) {
			printf "\n$::indent"."// SUBORDINATE OBJECT CLASS:";
			foreach $x (@{$self->{subordinates}}) {
				printf "\n$::indent"."list <"."$x->{scopedname}&> $x->{subordinate}->{class}->{name};"
			}
		} elsif (defined $self->{subordinate}) {
			printf "\n$::indent"."// SUBORDINATE OBJECT CLASS:";
			printf "\n$::indent"."list <"."$self->{subordinate}->{scopedname}&> $self->{subordinate}->{subordinate}->{class}->{name};"
		}
		if (($x = $self->{characterization})) { $x->generate('head',@_,$self); }
		if (($x = $self->{conditionalpackages})) { $x->generate('head',@_,$self); }
		if (($x = $self->{registration})) { $x->generate('head',@_,$self); }
		$self->endclass('ManagedObject');
	}
}

# subclassOf() is used by the managed object Create() operation to create an instance
sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// MANAGED OBJECT CLASS: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		printf "\n$::indent"."bool $name"."::subclassOf(typename type)";
		printf "\n$::indent"."{";
		printf "\n$::indent"."\t// Quite simply the current class is subclass of the specified class,";
		printf "\n$::indent"."\t// 'type', if the specified class is the parent class, or the parent";
		printf "\n$::indent"."\t// class is a subclass of the specified class.";
		printf "\n$::indent"."\t";
		printf "\n$::indent"."\treturn ( false";
		my $p; foreach $p (@{$self->{derivedfrom}->{classes}->{items}}) {
			printf "\n$::indent"."\t\t|| (type == $p->{name}) || $p->{scopedname}"."::subclassOf(type)";
		}
		printf "\n$::indent"."\t);";
		printf "\n$::indent"."\t";
		printf "\n$::indent"."}";
		printf "\n$::indent"."bool $name& $name"."::Create()";
		printf "\n$::indent"."{";
		printf "\n$::indent"."}";
		printf "\n$::indent"."$name"."::Delete()";
		printf "\n$::indent"."{";
		printf "\n$::indent"."}";
		$self->call('stub',@_);
		$self->cdtors((),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('MANAGED OBJECT CLASS',@_); }

sub showderived {
	my $self = shift;
	printf "\n--@@ $::indent";
	if (defined $self->{documentid}) {
		printf "\"$self->{documentid}\":$self->{name}";
	} else {
		printf "$self->{name}";
	}
	if ($::indent eq '') { $::indent='+- '; } else { $::indent='|  '.$::indent; }
	if (defined $self->{derivations}) {
		my ($d); foreach $d (@{$self->{derivations}}) {
			$d->showderived();
		}
	}
	$::indent=~s/^...//;
}

sub walkcontained {
	my $self = shift;
	printf "\n--@@ $::indent";
	if (defined $self->{documentid}) {
		printf "\"$self->{documentid}\":$self->{name}";
	} else {
		printf "$self->{name}";
	}
#	if (defined $self->{derivations}) {
#		if ($::indent eq '') { $::indent='>- '; } else { $::indent='|  '.$::indent; }
#		$::indent=~s/>/+/;
#		my ($d); foreach $d (@{$self->{derivations}}) {
#			$d->showderived();
#		}
#		$::indent=~s/\+/>/;
#		$::indent=~s/^...//;
#	}
	if ($::indent eq '') { $::indent='>- '; } else { $::indent='|  '.$::indent; }
	if (defined $self->{contains}) {
		if (!defined $self->{beenthere}) {
			$self->{beenthere} = 1;
			my ($d); foreach $d (@{$self->{contains}}) {
				if ($d->{label} eq $self->{label}) {
					printf "\n--@@ $::indent";
					if (defined $self->{documentid}) {
						printf "\"$self->{documentid}\":$self->{name}";
					} else {
						printf "$self->{name}";
					}
				} else {
					$d->walkcontained();
				}
			}
		} else {
			printf ' +++';
		}
	}
	$::indent=~s/^...//;
}

sub showcontained {
	my $self = shift;
	if (!defined $self->{container} && defined $self->{contains}) {
		$self->walkcontained();
	}
	if (defined $self->{derivations}) {
		my ($d); foreach $d (@{$self->{derivations}}) {
			$d->showcontained();
		}
	}
}

# ----------------------------------------
package PackageTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*PACKAGE//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{attributes} = Attributes->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{attributes};
		}
		if (($self->{attributegroups} = AttributeGroups->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{attributegroups};
		}
		if (($self->{actions} = Actions->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{actions};
		}
		if (($self->{notifications} = Notifications->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{notifications};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if ($::root->{packages}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{packages}->{$self->{label}}->{intf} = $self;
		$self->begclass('Package');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Package');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// PACKAGE: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::"."name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('Package(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('PACKAGE',@_); }

# ----------------------------------------
package ParameterTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*PARAMETER//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		last TEST unless ($self->{context} = Context->parse($line,@_[1,-1],$self));
		push @{$self->{children}}, $self->{context};
		last TEST unless (
			($self->{syntax} = WithSyntax->parse($line,@_[1,-1],$self)) ||
			($self->{syntax} = Attribute->parse($line,@_[1,-1],$self))
		);
		push @{$self->{children}}, $self->{syntax};
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if ($::root->{parameters}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{parameters}->{$self->{label}}->{intf} = $self;
		$self->begclass('Parameter');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Parameter');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// PARAMETER: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('Parameter(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('PARAMETER',@_); }

# ----------------------------------------
package NameBindingTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------
# This template allows alternative naming structures to be defined for managed objects of a given
# managed object class by means of name bindings.  A name binding allows an attribtue to be selected
# as the naming attribute that shall be used when a subordinate object which is an instnance of the
# specified managed object class is named by a superior object which is an instance of the specified
# managed object class or other object class, such as a Directory obejct class.
#
# If a given name binding is used, the attribute identified as the naming attribute shall be present
# in the subordinate object.  The naming attribute is used to construct the relative distinguished
# name (RDN) of subordinate objects of that class.  An RDN is constructued from the object identifier
# assigned ot that attribute type and the avlaue of the instance of the attribute.  The Distinguished
# Name of the subordinate object is obtained by appending the RDN to the Distinguished Name of its
# superior object.
#
# Name bindings are not considered to be part of the definition of either of the classes that they
# reference.  A given subordinate managed object class may have more than one name binding associated
# with it.  The set of name bindings defines the set of possible naming relationships with superior
# objects and the set of managed object classes from which subordinate objects may be instantiated.
#
# A name binding may also be defined to apply to all subclasses of the specified superior object class
# or all subclasses of the sepcified subordinate object class, or both.
#
#   NOTE -- Name binding may be specified for a managed object class subsequent to the specification
#   of the managed object class itself.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*NAME(?:\s|\n)*((-)?)(?:\s|\n)*BINDING//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		last TEST unless ($self->{subordinate} = SubordinateObjectClass->parse($line,@_[1,-1],$self));
		push @{$self->{children}}, $self->{subordinate};
		last TEST unless ($self->{superior} = NamedBySuperior->parse($line,@_[1,-1],$self));
		push @{$self->{children}}, $self->{superior};
		last TEST unless ($self->{attribute} = WithAttribute->parse($line,@_[1,-1],$self));
		push @{$self->{children}}, $self->{attribute};
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{createit} = Create->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{createit};
		}
		if (($self->{deleteit} = Delete->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{deleteit};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my ($sup,$sub);
	if (
		($sup = $::root->{objects}->{$self->{superior}->{class}->{label}}->{defn}) &&
		($sub = $::root->{objects}->{$self->{subordinate}->{class}->{label}}->{defn})
	) {
		push @{$sup->{contains}}, $sub;
		push @{$sub->{container}}, $sup;
	}
	$self->call('xref',@_);
}

sub head {
	my $self = shift;
	if ($::root->{bindings}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{bindings}->{$self->{label}}->{intf} = $self;
		$self->begclass('NameBinding');
		printf "\n$::indent"."static const char name"."[];";
		printf "\n$::indent"."static const typename superiorClassType;";
		printf "\n$::indent"."static const bool superiorSubclassesAllowed;";
		printf "\n$::indent"."static const typename subordinateClassType;";
		printf "\n$::indent"."static const bool subordinateSubclassesAllowed;";
		printf "\n$::indent"."static const bool managersMayCreate;";
		printf "\n$::indent"."static const NameBinding::deletePolicy deletePolicy;";
		printf "\n$::indent"."$self->{superior}->{class}->{scopedname}& superiorClass;";
		printf "\n$::indent"."$self->{subordinate}->{class}->{scopedname}& subordinateClass;";
		$self->call('head',@_);
		$self->endclass('NameBinding');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// NAME BINDING: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		printf "\n$::indent"."const typename $name"."::superiorClassType = $self->{superior}->{class}->{scopedname};";
		printf "\n$::indent"."const bool $name"."::superiorSubclassesAllowed = ";
		if (defined $self->{superior}->{subclasses}) { printf 'true;'; } else { printf 'false;'; }
		printf "\n$::indent"."const typename $name"."::subordinateClassType = $self->{subordinate}->{class}->{scopedname};";
		printf "\n$::indent"."const bool $name"."::subordinateSubclassesAllowed = ";
		if (defined $self->{subordinate}->{subclasses}) { printf 'true;'; } else { printf 'false;'; }
		printf "\n$::indent"."const bool $name"."::managersMayCreate = ";
		if (defined $self->{createit}) { printf "true;"; } else { printf "false;"; }
		printf "\n$::indent"."const NameBinding::deletePolicy $name"."::deletePolicy = NameBinding::";
		if (defined $self->{deleteit}) { printf "$self->{deleteit}->{policy};"; } else { printf "notDeletable;"; }
		$self->cdtors(('NameBinding(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('NAME BINDING',@_); }

# ----------------------------------------
package AttributeTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*ATTRIBUTE//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		last TEST unless (
			($self->{syntax} = DerivedFromAttribute->parse($line,@_[1,-1],$self)) ||
			($self->{syntax} = WithAttributeSyntax->parse($line,@_[1,-1],$self))
		);
		push @{$self->{children}}, $self->{syntax};
		if (($self->{matches} = MatchesFor->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{matches};
		}
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{parameters} = Parameters->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if ($::root->{attributes}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{attributes}->{$self->{label}}->{intf} = $self;
		my $x;
		$self->decclass('Attribute');
		$::indent.="\t";
		$self->{syntax}->generate('head',@_,$self);
		printf "\n$::indent"."static const char name"."[];";
		printf "\n$::indent"."static const bool equality;";
		printf "\n$::indent"."static const bool ordering;";
		printf "\n$::indent"."static const bool substrings;";
		printf "\n$::indent"."static const bool setComparison;";
		printf "\n$::indent"."static const bool setInteraction;";
		if (($x = $self->{behaviour}))	    { $x->generate('head',@_,$self); }
		if (($x = $self->{parameters}))	    { $x->generate('head',@_,$self); }
		if (($x = $self->{registration}))   { $x->generate('head',@_,$self); }
		$::indent=~s/^.//s;
		$self->endclass('Attribute');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// ATTTRIBUTE: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->{syntax}->generate('stub',@_,$self);
		printf "\n$::indent"."const bool $name"."::"."equality = ";
		if ($self->{equality}) { printf "true;"; } else { printf "false;"; }
		printf "\n$::indent"."const bool $name"."::"."ordering = ";
		if ($self->{ordering}) { printf "true;"; } else { printf "false;"; }
		printf "\n$::indent"."const bool $name"."::"."substrings = ";
		if ($self->{substrings}) { printf "true;"; } else { printf "false;"; }
		printf "\n$::indent"."const bool $name"."::"."setComparison = ";
		if ($self->{setcomparison}) { printf "true;"; } else { printf "false;"; }
		printf "\n$::indent"."const bool $name"."::"."setIntersection = ";
		if ($self->{setintersection}) { printf "true;"; } else { printf "false;"; }
		my $x;
		if (($x = $self->{behaviour}))	    { $x->generate('stub',@_,$self); }
		if (($x = $self->{parameters}))	    { $x->generate('stub',@_,$self); }
		if (($x = $self->{registration}))   { $x->generate('stub',@_,$self); }
		$self->cdtors(('Attribute(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('ATTRIBUTE',@_); }

# ----------------------------------------
package AttributeGroupTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*GROUP//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{groupelements} = GroupElements->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{groupelements};
		}
		if (($self->{fixed} = Fixed->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{fixed};
		}
		if (($self->{description} = Description->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{description};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if ($::root->{groups}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{groups}->{$self->{label}}->{intf} = $self;
		$self->begclass('AttributeGroup');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_,$self);
		$self->endclass('AttributeGroup');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// ATTTRIBUTE GROUP: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('AttributeGroup(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('ATTRIBUTE GROUP',@_); }

# ----------------------------------------
package BehaviourTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*BEHAVIOUR//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{definedas} = DefinedAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{definedas};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if ($::root->{behaviours}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{behaviours}->{$self->{label}}->{intf} = $self;
		$self->begclass('Behaviour');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_,$self);
		$self->endclass('Behaviour');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// BEHAVIOUR: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('Behaviour(name,definedas)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('BEHAVIOUR',@_); }

# ----------------------------------------
package ActionTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*ACTION//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{mode} = Mode->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{mode};
		}
		if (($self->{parameters} = Parameters->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		if (($self->{infosyntax} = WithInformationSyntax->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{infosyntax};
		}
		if (($self->{replysyntax} = WithReplySyntax->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{replysyntax};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if ($::root->{actions}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{actions}->{$self->{label}}->{intf} = $self;
		$self->begclass('Action');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Action');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// ACTION: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('Action(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('ACTION',@_); }

# ----------------------------------------
package NotificationTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*NOTIFICATION//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{behaviour};
		}
		if (($self->{parameters} = Parameters->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		if (($self->{infosyntax} = WithInformationSyntaxAndAttributeIds->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{infosyntax};
		}
		if (($self->{replysyntax} = WithReplySyntax->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{replysyntax};
		}
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if ($::root->{notifications}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{notifications}->{$self->{label}}->{intf} = $self;
		$self->begclass('Notification');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Notification');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// NOTIFICATION: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('Notification(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('NOTIFICATION',@_); }

# -------------------------------------
package SubordinationRuleTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*SUBORDINATION(?:\s|\n)*((-)?)(?:\s|\n)*RULE//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		last TEST unless (($self->{superior} = SuperiorObjectClass->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{superior};
		last TEST unless (($self->{subordinates} = NamesSubordinates->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{subordinates};
		last TEST unless (($self->{accordingto} = AccordingToRule->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{accordingto};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if ($::root->{subordinates}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{subordinates}->{$self->{label}}->{intf} = $self;
		$self->begclass('Subordination');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Subordination');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		printf "\n$::indent"."//";
		printf "\n$::indent"."// SUBORDINATION RULE: $name";
		printf "\n$::indent"."//";
		$self->call('stub',@_);
		$self->cdtors(('SubordinationRule(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('SUBORDINATION RULE',@_); }

# -------------------------------------
package ConstraintRuleTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*CONSTRAINT(?:\s|\n)*((-)?)(?:\s|\n)*RULE//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		last TEST unless (($self->{objectclass} = ObjectClass->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{objectclass};
		last TEST unless (($self->{isrelatedto} = IsRelatedTo->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{isrelatedto};
		last TEST unless (($self->{usingattribute} = UsingAttribute->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{usingattribute};
		last TEST unless (($self->{ruleset} = ConstraintRuleSet->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{ruleset};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub head {
	my $self = shift;
	if ($::root->{constraints}->{$self->{label}}->{intf}) {
		printf "\n$::indent"."$self->{name} $self->{name};";
	} else {
		$::root->{constraints}->{$self->{label}}->{intf} = $self;
		$self->begclass('Constraint');
		printf "\n$::indent"."static const char name"."[];";
		$self->call('head',@_);
		$self->endclass('Constraint');
	}
}

sub stub {
	my $self = shift;
	my $label = $self->{label};
	my $name = $self->{scopedname};
	if (!defined $::root->{objects}->{$label}->{impl}) {
		$::root->{objects}->{$label}->{impl} = $self;
		printf "\n$::indent"."//";
		printf "\n$::indent"."// CONSTRAINT RULE: $name";
		printf "\n$::indent"."//";
		printf "\n$::indent"."const char $name"."::name[] = \"$label\";";
		$self->call('stub',@_);
		$self->cdtors(('ConstraintRule(name)'),@_);
	}
}

sub gdmo { my $self = shift; return $self->gdmolabel('CONSTRAINT RULE',@_); }

# -------------------------------------
package RelationshipClassTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*RELATIONSHIP(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{derivedfrom} = DerivedFromRelationshipClasses->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{derivedfrom};
		}
		last TEST unless (($self->{behaviour} = Behaviour->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{behaviour};
		if (($self->{supports} = Supports->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{supports};
		}
		if (($self->{qualifiedby} = QualifiedBy->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{qualifiedby};
		}
		last TEST unless (($self->{rolespecifiers} = RoleSpecifiers->parse($line,@_[1,-1],$self)));
		push @{$self->{children}}, $self->{rolespecifiers};
		if (($self->{registration} = RegisteredAs->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{registration};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	$self->popscope();
	return $self->error($line);
}

sub gdmo { my $self = shift; return $self->gdmolabel('RELATIONSHIP CLASS',@_); }

# -------------------------------------
package RelationshipMappingTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectTemplate);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{scope} = $::scope;
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*RELATIONSHIP(?:\s|\n)*((-)?)(?:\s|\n)*MAPPING//s);
		$self->pushscope($1);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = RelationshipClass->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		last TEST unless (($self->{behavior} = Behaviour->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{behavior};
		if (($self->{object} = RelationshipObject->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{object};
		}
		last TEST unless (($self->{roles} = RoleMappingSpecifications->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{roles};
		if (($self->{operations} = OperationsMapping->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operations};
		}
		if (($self->{registered} = RegisteredAs->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{registered};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$self->definition(@_);
		$self->popscope();
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo { my $self = shift; return $self->gdmolabel('RELATIONSHIP MAPPING',@_); }

# -------------------------------------
package RelationshipClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^RELATIONSHIP\s*-?\s*CLASS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = RelationshipClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'RELATIONSHIP CLASS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{class}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}


# -------------------------------------
package AccordingToRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{accordingto} = AccordingToRuleToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{accordingto};
		last TEST unless (($self->{rule} = SubordinationRule->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rule};
		last TEST unless ($line=~s/^;//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$::indent.="\t";
		$self->{accordingto}->gdmo();
		{
			$self->{rule}->gdmo();
			$::indent=~s/^.//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SuperiorObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SUPERIOR\s*-?\s*OBJECT\s*-?\s*CLASS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{subclasses};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "SUPERIOR OBJECT CLASS"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{subclasses};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "OBJECT CLASS"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamesSubordinates;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAMES\s*-?\s*SUBORDINATES//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{list} = ClassReferenceCommaList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "NAMES SUBORDINATES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{list}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package IsRelatedTo;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^IS(?:\s|\n)*((-)?)(?:\s|\n)*RELATED(?:\s|\n)*((-)?)(?:\s|\n)*TO//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{list} = ClassSpecList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "IS RELATED TO"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{list}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ClassSpecList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ClassSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{reference};
		if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{subclasses};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{reference}->gdmo();
		if (($s = $self->{subclasses})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UsingAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^USING(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'USING ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ConstraintRuleSet;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{ruleset} = SingleConstraintRule->parse($line,@_[1,-1])) ||
			($self->{ruleset} = NamedTypeConstraintRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{ruleset};
		last TEST unless ($line=~s/^;//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{ruleset}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SingleConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACCORDING\s*-?\s*TO\s*-?\s*RULE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rule} = ConstraintRule->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rule};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ACCORDING TO RULE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package NamedTypeConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CASE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rules} = NamedTypeConstraintRuleListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'CASE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package NamedTypeConstraintRuleListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package NamedTypeConstraintRuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('NamedTypeConstraintRuleItem',@_); }

# -------------------------------------
package NamedTypeConstraintRuleItem;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{type} = Identifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless (($self->{accordingto} = AccordingToRuleToken->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{accordingto};
		last TEST unless (($self->{rule} = ConstraintRule->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rule};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{type}->gdmo();
		$self->{accordingto}->gdmo();
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package AccordingToRuleToken;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read { my $self = shift; return $self->readtoken('ACCORDING TO RULE',@_); }

# -------------------------------------
package SubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{rule} = SetSubordinationRule->parse($line,@_[1,-1])) ||
			($self->{rule} = ChoiceSubordinationRule->parse($line,@_[1,-1])) ||
			($self->{rule} = SetSizeSubordinationRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{rule};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package ConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{rule} = SetConstraintRule->parse($line,@_[1,-1])) ||
			($self->{rule} = SequenceConstraintRule->parse($line,@_[1,-1])) ||
			($self->{rule} = ChoiceConstraintRule->parse($line,@_[1,-1])) ||
			($self->{rule} = SetSizeConstraintRule->parse($line,@_[1,-1])) ||
			($self->{rule} = SequenceSizeConstraintRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{rule};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package SetSubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rules} = SubordinationTermListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SET'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package SetConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rules} = ConstraintTermListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SET'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package SequenceConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SEQUENCE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rules} = ConstraintTermListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SEQUENCE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package ChoiceSubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHOICE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rules} = SubordinationTermListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CHOICE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package ChoiceConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHOICE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rules} = ConstraintTermListBraced->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rules};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CHOICE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package SetSizeSubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET\s*-?\s*SIZE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{ordinality} = OrdinalityParens->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{ordinality};
		last TEST unless ($line=~s/^OF//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{constraint} = SubordinationTerm->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SET SIZE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		if (!$::first) { printf ' '; }
		printf 'OF'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{constraint}->gdmo();
	}
}

# -------------------------------------
package SetSizeConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET\s*-?\s*SIZE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{ordinality} = OrdinalityParens->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{ordinality};
		last TEST unless ($line=~s/^OF//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{constraint} = ConstraintTerm->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SET SIZE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		if (!$::first) { printf ' '; }
		printf 'OF'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{constraint}->gdmo();
	}
}

# -------------------------------------
package SequenceSizeConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SEQUENCE\s*-?\s*SIZE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{ordinality} = OrdinalityParens->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{ordinality};
		last TEST unless ($line=~s/^OF//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{constraint} = ConstraintTerm->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{constraint};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SEQUENCE SIZE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		if (!$::first) { printf ' '; }
		printf 'OF'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{constraint}->gdmo();
	}
}

# -------------------------------------
package OrdinalityParens;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryParens);
# -------------------------------------

# -------------------------------------
package Ordinality;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{ordinality} = ValueRange->parse($line,@_[1,-1])) ||
			($self->{ordinality} = ValueList->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{ordinality};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		$::first = 1; # fool it
	}
}

# -------------------------------------
package ValueRange;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{lower} = IntegerValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{lower};
		last TEST unless ($line=~s/^\.\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (
			$line=~s/^N//s ||
			($self->{upper} = IntegerValue->parse($line,@_[1,-1]))
		);
		if ($self->{upper}) {
			push @{$self->{children}}, $self->{upper};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$::first = 1; # fool it
		$self->{lower}->gdmo();
		printf '..'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{upper})) { $s->gdmo(); } else {
			printf 'N'; $::first = 0;
		}
		$::first = 1; # fool it
	}
}

# -------------------------------------
package SubordinationTermListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package SubordinationTermList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package SubordinationTerm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{term} = ClassReference->parse($line,@_[1,-1])) ||
			($self->{term} = SubordinationRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{term};
		my $ref = ref $self->{term};
		if ($ref=~/ClassReference/) {
			if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{subclasses};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{term}->gdmo();
		my $s; if (($s = $self->{subclasses})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ConstraintTermListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package ConstraintTermList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ConstraintTerm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{term} = ClassReference->parse($line,@_[1,-1])) ||
			($self->{term} = ConstraintRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{term};
		my $ref = ref $self->{term};
		if ($ref=~/ClassReference/) {
			if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
				push @{$self->{children}}, $self->{subclasses};
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{term}->gdmo();
		my $s; if (($s = $self->{subclasses})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DerivedFromRelationshipClasses;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# This construct shall be used to specify the superclass(es) from which the managed relationsihp
# class inherits its characteristics including any which may, in turn, have been inherited from
# other managed relationship class(es).  The managed relationship calss is a specialization of the
# inherited characteristics and those specified in the balance of the completed template; the
# specialization is such that the subclass is consistent with its superclass(es). If this construct
# is absent, the managed relationship class is not specialized from other relationship classes.
#
# Specification of characteristics that are inherited from other managed relationship classes shall
# not be repeated in the specification of the subclass unless on eof the techniques described in
# CCITT Rec. X.722 | ISO/IEC 10165-4 for extending a specification inherited from a superclass is
# being used.
#
# The rules for specifying managed relationship subclasses to ensure consistency are as follows:
#
# a) SUPPORTS: The specialized relationship management operation shall be the union of the
#    relationship management operations of the superclass and those specified in the subclass;
#    inheritance and specialization shall not introduce additional relationship management
#    notificiations into a subclass.
#
# b) QUALIFIED BY: Permitted and required value-sets of atrribute ranges shall not be changed in a
#    subclass behaviour.
#
# c) BEHAVIOUR: The behaviour of a subclass shall be:
#
#    - the disjunctive combination of the pre-conditions inherited from its superclass(es) and those
#      specified in the sublcass;
#
#    - the conjunctive combination of the post-conditions inherited from its superclass(es) and
#      those specified in the subclass;
#
#    - the conjunctive combination of the invariants inherited from its superclass(es) and those
#      specified in the subclass; if the invariants are mutually contradictory, a subclass cannot be
#      specified.
#
# d) ROLE:
#
#    - Additional role specifications may be included in the subclass definition.
#
#    - A managed objects class introduced by the COMPATIBLE WITH clause in the subclass shall be
#      compatible to those referenced in similar clauses in the superclass(es).
#
#    - The inherited PERMITTED-ROLE-CARDINALITY-CONSTRAINT value of a role inherited from more than
#      one superclass shall be the set intersection of the values specified for that role in the
#      superclasses; any permitted role cardinality constraint value specified in the subclass shall
#      be a subset of, or equal to, the inherited permitted role cardinality constraint value; the
#      specialized permitted role cardinality constraint value shall be the set intersection of the
#      inherited values and that specified in the subclass.
#
#    - The inherited REQUIRED-ROLE-CARDINALITY-CONSTRAINT value of a rule inherited from more than
#      one superclass hsall be the set union of the values specified for the role in the
#      superclasses set-intersected with the inherited permitted role cardinality constraint value;
#      any required role cardinality constraint value specified in the subclass shall be a superset
#      of, or equal to, the inherited required role cardinality constraint value; the specialized
#      required role cardinality constraint value shall be the set union of the inherited value and
#      that specified in the subclass set-intersected with the value of the specialized permitted
#      rold cardinality constraint.
#
#    - BIND-SUPPORT may be added in the subclass specification.
#
#    - UNBIND-SUPPORT may be added in the subclass specification.
#
#    - The inherited PERMITTED-RELATIONSHIP-CARDINALITY-CONSTRAINT value of a rule inherited from
#      more than one superclass shall be the set intersection of the values sepecified for the role
#      in the superclasses; any permitted relationship cardinality constraint value specified in the
#      subclass shall be a subset of, or equal to, the inherited permitted relationship cardinality
#      constraint value; the specialized permitted relationship cardinality constraint value shall
#      be the set intersection of the inherited value and that specified in the subclass.
#
# e) REGISTERED AS: The subclass registration shall replace any registration inherited from other
#    definiitons.
#

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s|\n)*FROM//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{classes} = ClassReferenceCommaList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{classes};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	my $gdmo = $_[-2];
	my ($i,$d);
	foreach $i (@{$self->{classes}->{items}}) {
		if (defined $::root->{objects}->{$i->{label}}) {
			if ($d = $::root->{objects}->{$i->{label}}->{defn}) {
				my ($t);
				if (defined $tmpl->{backtrace}) {
					print STDERR "E: multiple markings of $tmpl->{label}";
					print STDERR "E: backtrace is:";
					my $b; foreach $b (@::backtrack) {
						print STDERR "E: B: ".ref($b);
					}
					print STDERR "E: original backtrace was:";
					my $b; foreach $b (@{$tmpl->{backtrace}}) {
						print STDERR "E: B: ".ref($b);
					}
					#die "multiple markings";
				} else {
					my $b; foreach $b (@::backtrace) {
						push @{$tmpl->{backtrace}}, $b;
					}
					my ($t,$e); foreach $t (@{$d->{derivations}}) {
						if ($t->{label} eq $tmpl->{label}) {
							print STDERR "E: multiple markings with same label $t->{label}";
							print STDERR "E: template 1 is ".ref($t).".$t->{id}";
							print STDERR "E: template 2 is ".ref($tmpl).".$t->{id}";
							$e++;
						}
					}
					unless ($e) {
						#print "--@@ $tmpl->{label} is derived from $d->{label}.";
						push @{$d->{derivations}}, $tmpl;
					}
				}
			}
		}
	}
	$self->call('xref',@_);
}

sub head {
	my $self = shift;
	my ($i,$e);
	printf ' : public ';
	foreach $i (@{$self->{classes}->{items}}) {
		if ($e) { printf ', '; } else { $e++; }
		printf "$i->{name}";
	}
	printf ' {';
	$::indent.="\t";
	printf "\n$::indent"."private:";
	$::indent.="\t";
	return $self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "DERIVED FROM"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{classes}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Supports;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# A.1.3.3  SUPPORTS supported [, supported]*
#
# This construct shall be used to define the relationship management operaitons and notifications
# that a managed relationship supports.  The 'supported' production shall be used to specifiy the
# prototypical operation or notification on which the relationship mangement operation or
# notification is based, namely:
#
# - ESTABLISH [operation-name];
# - TERMINATE [operation-name];
# - QUERY [operation-name];
# - NOTIFY [notification-name];
# - USER DEFINED [operation-name];
#

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SUPPORTS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{supported} = SupportedList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{supported};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "SUPPORTS"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{supported}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SupportedList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package Supported;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{supported} = EstablishSupport->parse($line,@_[1,-1])) ||
			($self->{supported} = TerminateSupport->parse($line,@_[1,-1])) ||
			($self->{supported} = QuerySupport->parse($line,@_[1,-1])) ||
			($self->{supported} = NotifySupport->parse($line,@_[1,-1])) ||
			($self->{supported} = UserDefinedSupport->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{supported};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package EstablishSupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ESTABLISH//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'ESTABLISH'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package TerminateSupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^TERMINATE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'TERMINATE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package QuerySupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^QUERY//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'QUERY'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NotifySupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFY//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{notification} = NotificationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{notification};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'NOTIFY'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{notification})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UserDefinedSupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^USER\s*-?\s*DEFINED//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'USER DEFINED'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RoleSpecifiers;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{list} = RoleSpecifierList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{list};
		last TEST unless ($line=~s/^;//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{list}->gdmo();
		printf ';'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RoleSpecifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package RoleSpecifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# A.1.3.5 ROLE role-name
#
# This construct shall be used to specify the roles associated with the managed relationship calss;
# the label 'role-name' shll be used as a reference name o the role.
#
#

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ROLE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rolename} = RoleName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rolename};
		if (($self->{compatiblewith} = CompatibleWith->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{compatiblewith};
		}
		if (($self->{permittedrole} = PermittedRoleCardinalityConstraint->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{permittedrole};
		}
		if (($self->{requiredrole} = RequiredRoleCardinalityConstraint->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{requiredrole};
		}
		if (($self->{bindsupport} = BindSupport->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{bindsupport};
		}
		if (($self->{unbindsupport} = UnbindSupport->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{unbindsupport};
		}
		if (($self->{permittedrel} = PermittedRelationshipCardinalityConstraint->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{permittedrel};
		}
		if (($self->{registeredas} = RegisteredAs->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{registeredas};
		}
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ROLE'; $::first = 0;
		my $s;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{rolename}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{compatiblewith})) { $s->gdmo(); }
			if (($s = $self->{permittedrole} )) { $s->gdmo(); }
			if (($s = $self->{requiredrole}  )) { $s->gdmo(); }
			if (($s = $self->{bindsupport}   )) { $s->gdmo(); }
			if (($s = $self->{unbindsupport} )) { $s->gdmo(); }
			if (($s = $self->{permittedrel}  )) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
		if (($s = $self->{registeredas})) { $s->gdmo(); }
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package CompatibleWith;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^COMPATIBLE\s*-?\s*WITH//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'COMPATIBLE-WITH'; $::first = 0;
		my $s;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{class}->gdmo();
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package PermittedRoleCardinalityConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PERMITTED\s*-?\s*ROLE\s*-?\s*CARDINALITY\s*-?\s*CONSTRAINT//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{type} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PERMITTED-ROLE-CARDINALITY-CONSTRAINT'; $::first = 0;
		my $s;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{type}->gdmo();
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RequiredRoleCardinalityConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REQUIRED\s*-?\s*ROLE\s*-?\s*CARDINALITY\s*-?\s*CONSTRAINT//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{type} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'REQUIRED-ROLE-CARDINALITY-CONSTRAINT'; $::first = 0;
		my $s;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{type}->gdmo();
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BindSupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^BIND\s*-?\s*SUPPORT//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'BIND-SUPPORT'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UnbindSupport;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^UNBIND\s*-?\s*SUPPORT//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'UNBIND-SUPPORT'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package PermittedRelationshipCardinalityConstraint;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PERMITTED\s*-?\s*RELATIONSHIP\s*-?\s*CARDINALITY\s*-?\s*CONSTRAINT//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{type} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PERMITTED-RELATIONSHIP-CARDINALITY-CONSTRAINT'; $::first = 0;
		my $s;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{type}->gdmo();
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package QualifiedBy;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# This construct shall be used to specify attributes that are associated with the managed
# relationship as a whole.  Qualifying attributes shall be made available in all implementations of
# the managed relationship irrespective of the representation method used.  The relationship mapping
# template shall be used to specify how these attributes are made available by a paticular
# representation.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RelationshipObject;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^RELATIONSHIP\s*-?\s*OBJECT//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{qualifies} = QualifiesComma->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{qualifies};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'RELATIONSHIP OBJECT'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (!$::first) { printf ' '; $::first = 1; }
			$self->{class}->gdmo();
			if (($s = $self->{qualifies})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package QualifiesComma;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		last TEST unless ($line=~s/^QUALIFIES//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attributes} = AttributeReferenceCommaList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attributes};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'QUALIFIES'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{attributes}->gdmo();
	}
}

# -------------------------------------
package RoleMappingSpecifications;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{roles} = RoleMappingSpecificationList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{roles};
		last TEST unless ($line=~s/^;//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{roles}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RoleMappingSpecificationList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaListUnindented);
# -------------------------------------

# -------------------------------------
package RoleMappingSpecification;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{role} = Role->parse($line, @_[1,-1])));
		push @{$self->{children}}, $self->{role};
		last TEST unless (($self->{classes} = RelatedClasses->parse($line, @_[1,-1])));
		push @{$self->{children}}, $self->{classes};
		if (($self->{representedby} = RepresentedBy->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{representedby};
		}
		if (($self->{qualifies} = QualifiesSimple->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{qualifies};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		$self->{role}->gdmo();
		{
			$::indent.="\t";
			$self->{classes}->gdmo();
			if (($s = $self->{representedby})) { $s->gdmo(); }
			if (($s = $self->{qualifies})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
	}
}

# -------------------------------------
package Role;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ROLE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{rolename} = RoleName->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{rolename};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "ROLE"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{rolename}->gdmo();
	}
}

# -------------------------------------
package RelatedClasses;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^RELATED\s*-?\s*CLASSES//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{classes} = ClassReferenceSimpleList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{classes};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "RELATED-CLASSES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{classes}->gdmo();
	}
}

# -------------------------------------
package RepresentedBy;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REPRESENTED\s*-?\s*BY//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{representation} = Representation->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{representation};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'REPRESENTED-BY'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{representation}->gdmo();
	}
}

# -------------------------------------
package Representation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{representation} = Naming->parse($line,@_[1,-1])) ||
			($self->{representation} = AttributeRepresentation->parse($line,@_[1,-1])) ||
			($self->{representation} = RelationshipObjectUsingPointer->parse($line,@_[1,-1])) ||
			($self->{representation} = Operation->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{representation};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package AttributeRepresentation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		#if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments})) { $s->gdmo(); }
			if (!$::first) { printf ' '; $::first = 1; }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package Naming;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAMING//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{binding} = NameBindingReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{binding};
		last TEST unless (($self->{using} = Using->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{using};
		last TEST unless (
			($self->{suporsub} = Superior->parse($line,@_[1,-1])) ||
			($self->{suporsub} = Subordinate->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{suporsub};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NAMING'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{binding}->gdmo();
		$self->{using}->gdmo();
		$self->{suporsub}->gdmo();
	}
}

# -------------------------------------
package Using;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read { my $self = shift; return $self->readtoken('USING',@_); }

# -------------------------------------
package Superior;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read { my $self = shift; return $self->readtoken('SUPERIOR',@_); }

# -------------------------------------
package Subordinate;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read { my $self = shift; return $self->readtoken('SUBORDINATE',@_); }

# -------------------------------------
package ClassReferenceSimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package RelationshipObjectUsingPointer;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^RELATIONSHIP\s*-?\s*OBJECT\s*-?\s*USING\s*-?\s*POINTER\s*-?\s*//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		#last TEST unless ($line=~s/^;//s);
		#$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'RELATIONSHIP-OBJECT-USING-POINTER'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		#printf ';'; $::first = 0;
		#if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Operation;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read { my $self = shift; return $self->readtoken('OPERATION',@_); }

# -------------------------------------
package QualifiesSimple;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^QUALIFIES//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attributes} = AttributeReferenceSimpleList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attributes};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'QUALIFIES'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{attributes}->gdmo();
	}
}

# -------------------------------------
package AttributeReferenceSimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package OperationsMapping;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^OPERATIONS\s*-?\s*MAPPING//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{operationmaps} = RelationshipOperationsMapList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{operationmaps};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'OPERATIONS MAPPING'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{operationmaps}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RelationshipOperationsMapList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package RelationshipOperationsMap;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{operation} = RelationshipOperation->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{operation};
		last TEST unless (($self->{mapsto} = MapsTo->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{mapsto};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->call('gdmo',@_);
	}
}

# -------------------------------------
package RelationshipOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{operation} = EstablishOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = TerminateOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = BindOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = UnbindOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = QueryOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = NotifyOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = UserDefinedOperation->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{operation};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package EstablishOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ESTABLISH//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'ESTABLISH'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package TerminateOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^TERMINATE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'TERMINATE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BindOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^BIND//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		if (($self->{role} = RoleName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{role};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'BIND'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
		if (($s = $self->{role})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UnbindOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^UNBIND//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		if (($self->{role} = RoleName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{role};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'UNBIND'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
		if (($s = $self->{role})) { $s->gdmo(); }
	}
}

# -------------------------------------
package QueryOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^QUERY//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		if (($self->{role} = RoleName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{role};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'QUERY'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
		if (($s = $self->{role})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NotifyOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFY//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{notification} = NotificationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'NOTIFY'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		if (($s = $self->{notification})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UserDefinedOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^USER\s*-?\s*DEFINED//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{operation} = OperationName->parse($line, @_[1,-1]))) {
			push @{$self->{children}}, $self->{operation};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'USER DEFINED'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{operation})) { $s->gdmo(); }
	}
}

# -------------------------------------
package OperationName;
use strict;
use vars qw(@ISA);
@ISA = qw(Identifier);
# -------------------------------------
# The operation-name and notification-name shall be used, where necessary, to:
#
# - provide a link to an optional specificaiton, in behaviour templates referenced  by the BEHAVIOUR
#   construct, of behaviour additional to the  referenced prototypical operation;
#
# - disambiguate relationship management operations or notifications that are based on the same
#   prototypical operation or notification respectively;
#
# - provide a link to the related systems management operations and notifications specified in the
#   relationship mapping template.

# -------------------------------------
package RoleName;
use strict;
use vars qw(@ISA);
@ISA = qw(Identifier);
# -------------------------------------

# -------------------------------------
package NotificationName;
use strict;
use vars qw(@ISA);
@ISA = qw(Identifier);
# -------------------------------------

# -------------------------------------
package MapsTo;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MAPS\s*-?\s*TO\s*-?\s*OPERATION\s*-?\s*//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{operations} = SystemManagementOperationRoleList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{operations};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'MAPS-TO-OPERATION'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{operations}->gdmo();
	}
}

# -------------------------------------
package SystemManagementOperationRoleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleListIndented);
# -------------------------------------

# -------------------------------------
package SystemManagementOperationRole;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{operation} = SystemManagementOperation->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{operation};
		last TEST unless ($line=~s/^OF//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{roleorobj} = RoleOrRelationshipObject->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{roleorobj};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{operation}->gdmo();
		if (!$::first) { printf ' '; }
		printf "OF"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{roleorobj}->gdmo();
	}
}

# -------------------------------------
package SystemManagementOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{operation} = GetOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = ReplaceOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = AddOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = RemoveOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = CreateOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = DeleteOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = ActionOperation->parse($line,@_[1,-1])) ||
			($self->{operation} = NotificationOperation->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{operation};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# -------------------------------------
package GetOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GET//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'GET'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{attribute}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ReplaceOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REPLACE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'REPLACE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{attribute}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AddOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ADD//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'ADD'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{attribute}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RemoveOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REMOVE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'REMOVE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{attribute}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package CreateOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CREATE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{class} = ClassReference->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{class};
		}
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'CREATE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		if (($s = $self->{class})) { $s->gdmo(); }
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DeleteOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DELETE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'DELETE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ActionOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACTION//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{action} = ActionReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{action};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'CREATE'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{action}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NotificationOperation;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFICATION//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{notification} = NotificationReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{notification};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'NOTIFICATION'; $::first = 0;
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf ' '; $::first = 1; }
		$self->{notification}->gdmo();
		if (($s = $self->{parameters})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RoleOrRelationshipObject;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			$line=~s/^RELATIONSHIP\s*-?\s*OBJECT//s ||
			($self->{rolename} = RoleName->parse($line,@_[1,-1]))
		);
		if ($self->{rolename}) {
			push @{$self->{children}}, $self->{rolename};
		} else {
			$self->{comments} = Comments->parse($line,@_[1,-1]);
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{rolename})) {
			$s->gdmo();
		} else {
			if (!$::first) { printf ' '; }
			printf 'RELATIONSHIP OBJECT'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
		}
	}
}

# -------------------------------------
package DocumentIdentifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	my $gdmo = $_[-1];
	TEST: {
		last TEST unless ($line=~s/^(?:"([^"]*)")//s);
		$self->{documentid} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		#print STDERR "Assigning document id \"$self->{documentid}\" to ".ref($gdmo)." from DocumentIdentifier";
		$gdmo->{documentid} = $self->{documentid};
		$gdmo->{aliases}->{$self->{documentid}}++;
		$::root->{gdmos}->{$self->{documentid}}->{defn} = $gdmo;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	# last TEST if ($::root->{gdmos}->{$self->{documentid}}->{defn});
	#print STDERR "Assigning document id to ".ref($gdmo);
	#$gdmo->{documentid} = $self->{documentid};
	#$gdmo->{aliases}->{$self->{documentid}}++;
	#$::root->{gdmos}->{$self->{documentid}}->{defn} = $gdmo;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "\"$self->{documentid}\""; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DocumentReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	my $gdmo = $_[1];
	TEST: {
		last TEST unless ($line=~s/^(?:"([^"]*)")//s);
		$self->{documentid} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		push @{$gdmo->{docrefs}->{$self->{documentid}}->{refs}}, $self;
		push @{$::root->{gdmos}->{$self->{documentid}}->{refs}}, $self;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	#push @{$gdmo->{docrefs}->{$self->{documentid}}->{refs}}, $self;
	#push @{$::root->{gdmos}->{$self->{documentid}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "\"$self->{documentid}\""; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Label;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		# ok, you can have a period or slash in a label
		last TEST unless ($line=~s/^[a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-)//s);
		$self->{label} = $&;
		$self->{name} = $self->xform('',$self->{label},'');
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf "$self->{label}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}


# ----------------------------------------
package Reference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{documentid} = DocumentReference->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{documentid};
			last TEST unless ($line=~s/^://s);
			$self->{comments} = Comments->parse($line,@_[1,-1]);
		}
		last TEST unless (($self->{label} = Label->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{label};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		if (($s = $self->{documentid})) {
			$s->gdmo();
			printf ':'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
		}
		if (($s = $self->{label})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ObjectReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub readreference {
	my $self = shift;
	my $tmpl = shift;
	my $line = $_[0];
	my $gdmo = $_[1];
	TEST: {
		if (($self->{reference} = $tmpl->parse($line,@_[1,-1]))) {
			$self->{label} = $self->{reference}->{label};
			$self->{name} = $self->{reference}->{name};
			$self->{scope} = $self->{reference}->{scope};
			$self->{scopedname} = $self->{reference}->{scopedname};
		} elsif (($self->{reference} = Reference->parse($line,@_[1,-1]))) {
			if ($self->{reference}->{documentid}) {
				$self->{documentid} = $self->{reference}->{documentid}->{documentid};
			}
			if ($self->{reference}->{label}) {
				$self->{label} = $self->{reference}->{label}->{label};
				$self->{name} = $self->{reference}->{label}->{name};
				$self->{scope} = '';
				$self->{scopedname} = $self->{name};
			}
		} else {
			last TEST;
		}
		push @{$self->{children}}, $self->{reference};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $tmpl = ref $self;
	$tmpl=~s/Reference/Template/;
	return $self->readreference($tmpl,@_);
}

sub xreftyped {
	my $self = shift;
	my $type = shift;
	my $gdmo = $_[0];
	my ($l,$d);

	$l = $self->{label};
	push @{$gdmo->{$type}->{$l}->{refs}}, $self;
	push @{$::root->{$type}->{$l}->{refs}}, $self;
	if ($d = $self->{documentid}) {
		push @{$gdmo->{$type}->{$l}->{docs}->{$d}->{refs}}, $self;
		push @{$::root->{$type}->{$l}->{docs}->{$d}->{refs}}, $self;
	}
	if ($d = $::root->{$type}->{$l}->{defn}) {
		$self->{scope} = $d->{scope};
		$self->{scopedname} = $d->{scopedname};
	}
	$self->call('xref',@_);
}

sub xref {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Reference//;
	$type=lc $type;
	$type.='s';
	$type=~s/classs/objects/;
	$type=~s/namebindings/bindings/;
	$type=~s/attributegroups/groups/;
	$type=~s/subordinationrules/subordinates/;
	$type=~s/constraintrules/constraints/;
	$type=~s/relationshipclass/relations/;
	$type=~s/relationshipmapping/mapping/;
	return $self->xreftyped($type,@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{reference}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ClassReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package PackageReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package ParameterReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package NameBindingReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package AttributeReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package AttributeGroupReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package BehaviourReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package ActionReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package NotificationReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package SubordinationRuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package ConstraintRuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package RelationshipClassReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# ----------------------------------------
package RelationshipMappingReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ObjectReference);
# ----------------------------------------

# -------------------------------------
package DerivedFromClasses;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s|\n)*FROM//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{classes} = ClassReferenceCommaList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{classes};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	my $gdmo = $_[-2];
	my ($i,$d);
	foreach $i (@{$self->{classes}->{items}}) {
		if (defined $::root->{objects}->{$i->{label}}) {
			if ($d = $::root->{objects}->{$i->{label}}->{defn}) {
				my ($t);
				if (defined $tmpl->{backtrace}) {
					print STDERR "E: multiple markings of $tmpl->{label}";
					print STDERR "E: backtrace is:";
					my $b; foreach $b (@::backtrack) {
						print STDERR "E: B: ".ref($b);
					}
					print STDERR "E: original backtrace was:";
					my $b; foreach $b (@{$tmpl->{backtrace}}) {
						print STDERR "E: B: ".ref($b);
					}
					#die "multiple markings";
				} else {
					my $b; foreach $b (@::backtrace) {
						push @{$tmpl->{backtrace}}, $b;
					}
					my ($t,$e); foreach $t (@{$d->{derivations}}) {
						if ($t->{label} eq $tmpl->{label}) {
							print STDERR "E: multiple markings with same label $t->{label}";
							print STDERR "E: template 1 is ".ref($t).".$t->{id}";
							print STDERR "E: template 2 is ".ref($tmpl).".$t->{id}";
							$e++;
						}
					}
					unless ($e) {
						#print "--@@ $tmpl->{label} is derived from $d->{label}.";
						push @{$d->{derivations}}, $tmpl;
					}
				}
			}
		}
	}
	$self->call('xref',@_);
}

sub head {
	my $self = shift;
	my ($i,$e);
	printf ' : public ';
	foreach $i (@{$self->{classes}->{items}}) {
		if ($e) { printf ', '; } else { $e++; }
		printf "$i->{name}";
	}
	printf ' {';
	$::indent.="\t";
	printf "\n$::indent"."private:";
	$::indent.="\t";
	return $self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "DERIVED FROM"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{classes}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ClassReferenceCommaList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package Characterization;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHARACTERIZED(?:\s|\n)*((-)?)(?:\s|\n)*BY//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{packages} = PackageReferenceList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{packages};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1]; # PackageTemplate
	$self->call('xref',@_);
	my $p; foreach $p (@{$self->{packages}->{items}}) {
		#print STDERR "Pushing $p->{name} on ".ref($tmpl)." constructor references";
		push @{$tmpl->{constructorrefs}}, $p;
	}
}

sub head {
	my $self = shift;
	my $tmpl = $_[-1]; # PackageTemplate
	print "\n\n$::indent"."// CHARACTERIZED BY: (mandatory packages)";
	$self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "CHARACTERIZED BY"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{packages}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package PackageReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ConditionalPackages;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CONDITIONAL(?:\s|\n)*((-)?)(?:\s|\n)*PACKAGES//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{conditions} = PackageConditionList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{conditions};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// CONDITIONAL PACKAGES::\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "CONDITIONAL PACKAGES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{conditions}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package PackageConditionList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package PackageCondition;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{package} = PackageReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{package};
		last TEST unless (
			($self->{condition} = PresentIf->parse($line,@_[1,-1])) ||
			($self->{condition} = PresentOnlyIf->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{condition};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1]; # PackageTemplate
	#print STDERR "Pushing $self->{package}->{name} on ".ref($tmpl)." constructor pointers";
	push @{$tmpl->{constructorptrs}}, $self->{package};
	$self->call('xref',@_);
}

sub head {
	my $self = shift;
	my $tmpl = $_[-1]; # PackageTemplate
	if (ref($self->{package}->{reference})=~/PackageTemplate/) {
		if (!$::root->{packages}->{$self->{package}->{label}}->{intf}) {
			$::root->{packages}->{$self->{package}->{label}}->{intf} = $self->{package}->{reference};
			$self->{package}->generate('head',@_);
		} 
	}
	$self->{condition}->generate('head',@_,$self->{package});
	printf "\n$::indent"."$self->{package}->{scopedname} *$self->{package}->{name};";
	printf "\n$::indent";
}

sub stub {
	my $self = shift;
	$self->{package}->generate('stub',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{package}->gdmo();
		$::indent.="\t";
		$self->{condition}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package PresentIf;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PRESENT(?:\s|\n)*((-)?)(?:\s|\n)*IF//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,',;',@_[1,-1])));
		push @{$self->{children}}, $self->{delimited};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// PRESENT-IF:\n$::indent// "; $::first = 1;
	# dig right down to the string inside the delimited string object
	my ($s, $col, $spc, $len, $line, $d, $e);
	$line = $self->{delimited}->{string};
	$d = $self->{delimited}->{delimiter};
	$d = '\\'.$d if ($d=~/[\$\*\?\\]/);
	$line=~s/$d$d/$d/gs;
	$col = 0;
	my @paras = ( split(/\n\n/s,$line) );
	my $p; foreach $p (@paras) {
		if ($e) {
			if (!$::first) { printf "\n\n$::indent// "; $col = 0; $::first = 1; }
		} else { $e++; }
		my @lines = ( split(/\n/s,$p) );
		my $l; foreach $l (@lines) {
			$l=~s/^\t+//s;
			if ($l=~/^[^ ]/) {
				my @words = ( split(/\s+/s,$l) );
				my $w; foreach $w (@words) {
					if ($col == 0) { $spc = 0; } else { $spc = 1; }
					$len = length($w);
					if ($len) {
						if ($col + $spc + $len < $::colwidth) {
							if ($spc) { printf ' '; }
							$col += $spc + $len;
						} else {
							printf "\n$::indent// ";
							$col = $len;
						}
						printf "$w";
					}
				}
			} else {
				if (!$::first) { printf "\n$::indent// "; $::first = 1; }
				printf "$l"; $::first = 0;
				if (!$::first) { printf "\n$::indent// "; $::first = 1; }
			}
		}
	}

	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "PRESENT IF"; $::first = 0;
		$::indent.="\t";
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{delimited})) { $s->gdmo(); }
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package PresentOnlyIf;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PRESENT(?:\s|\n)*((-)?)(?:\s|\n)*ONLY(?:\s|\n)*((-)?)(?:\s|\n)*IF//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,',;',@_[1,-1])));
		push @{$self->{children}}, $self->{delimited};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// PRESENT-ONLY-IF:\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "PRESENT ONLY IF"; $::first = 0;
		my $s;
		$::indent.="\t";
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{delimited})) { $s->gdmo(); }
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package DelimitedString;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	my $term = $_[1];
	TEST: {
		my $pattern;
		if ($line=~s/^[!"#\$%^&\*'`~\?@\\]//s) {
			my $d = $&;
			$self->{delimiter} = $d;
			$d = '\\'.$d if ($d=~/[\$\*\?\\]/);
			$pattern="((?:[^".$d."]|[".$d."](?=[".$d."]))*)[".$d."]";
		} else {
			$pattern="([^".$term."]*)";
		}
		last TEST unless ($line=~s/^$pattern//s);
		$self->{string} = $1;
		$self->{comments} = Comments->parse($line,@_[2,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub stub {
	my $self = shift;
	my ($s, $col, $spc, $len, $line, $d, $e);
	$line = $self->{string};
	$d = $self->{delimiter};
	$d = '\\'.$d if ($d=~/[\$\*\?\\]/);
	$line=~s/$d$d/$d/gs;
	$line=~s/"/\"/gs;
	$col = 0;
	my @paras = ( split(/\n\n/s,$line) );
	my $p; foreach $p (@paras) {
		if ($e) {
			if (!$::first) { printf "\\n\\\n\\n\\\n"; $col = 0; $::first = 1; }
		} else { $e++; }
		my @lines = ( split(/\n/s,$p) );
		my $l; foreach $l (@lines) {
			$l=~s/^\t+//s;
			if ($l=~/^[^ ]/) {
				my @words = ( split(/\s+/s,$l) );
				my $w; foreach $w (@words) {
					if ($col == 0) { $spc = 0; } else { $spc = 1; }
					$len = length($w);
					if ($len) {
						if ($col + $spc + $len < $::colwidth) {
							if ($spc) { printf ' '; }
							$col += $spc + $len;
						} else {
							printf "\\n\\\n";
							$col = $len;
						}
						printf "$w";
					}
				}
			} else {
				if (!$::first) { printf "\\n\\\n"; $::first = 1; }
				printf "$l"; $::first = 0;
				if (!$::first) { printf "\\n\\\n"; $::first = 1; }
			}
		}
	}
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$col,$e,$tws,$lws,$sep);
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{delimiter}";
		$col = 0;
		# any line with trailing whitespace is a continutation line
		if ($self->{string}=~s/[ \t]+\n[ \t]*/ /sg) {
			$tws = 1;
		}
		# anything separated by a double line break is a paragraph
		my @paras = ( split(/\n\n/s,$self->{string}) );
		if ($tws || scalar @paras <= 1) {
			# this treats lines as paragraphs but doesn't doublespace them unless they
			# were already double spaced
			if (scalar @paras > 1) { $sep = "\n"; } else { $sep = ''; }
			# if there was trailing whitespace, all single line breaks are paragraphs
			@paras = ( split(/\n/s,join("\n",@paras)) );
		} else {
			# if there are lines in pagarages separated by double linefeeeds, separate
			# them again by double linefeeds
			$sep = "\n";
		}
		my $p; foreach $p (@paras) {
			if ($e) { printf "$sep\n$::indent"; $col = 0; $::first = 1; } else { $e++; }
			my @lines = ( split(/\n/s,$p) );
			my $l; foreach $l (@lines) {
				$l=~s/^\t+//s;
				$l=~s/\s+$//s;
				$l=~s/\t/ /sg;
				$l=~s/^(\s+|\s*(?:-|\xB7)\s+|\s*[\(\[\{]?[a-zA-Z1-9][ivxIVX0-9]*[\.:]??[\.:\)\]\}]\s*)//;
				$lws = $1;
				my @words = ( split(/\s+/s,$l) );
				my $w; foreach $w (@words) {
					if (!$::first) {
						printf ' ';  $col++;
						if ($col + length($w) > $::colwidth) {
							printf "\n$::indent"; $::first = 1;
						}
					}
					if ($::first) {
						printf "$lws"; $col = length($lws); $::first = 0; $lws=~s/[^ ]/ /sg;
					}
					printf "$w"; $::first = 0; $col += length($w);
				}
			}
		}
		printf "$self->{delimiter}";
		#for now: flow it later
		#printf "$self->{delimiter}$self->{string}$self->{delimiter}";
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::first = 0;
	}
}

# -------------------------------------
package Attributes;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTES//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attributes} = AttributePropertyList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attributes};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// ATTRIBUTES:\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "ATTRIBUTES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{attributes}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributePropertyList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package AttributeProperty;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1],$self)));
		if (($self->{properties} = PropertyList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{properties};
		}
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (ref($self->{attribute}->{reference})=~/AttributeTemplate/) {
		$self->call('head',@_);
	} else {
		my $x;
		printf "\n$::indent"."$self->{attribute}->{scopedname} $self->{attribute}->{name};";
		if (($x = $self->{properties})) { $x->generate('head',@_,$self); }
		if (($x = $self->{parameters})) { $x->generate('head',@_,$self); }
	}
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{attribute})) { $s->gdmo(); }
		{
			$::indent.="\t";
			if (($s = $self->{properties})) { $s->gdmo(); }
			if (($s = $self->{parameters})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
	}
}

# -------------------------------------
package PropertyList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package Property;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{property} = ReplaceWithDefault->parse($line,@_[1,-1])) ||
			($self->{property} = DefaultValue->parse($line,@_[1,-1])) ||
			($self->{property} = InitialValue->parse($line,@_[1,-1])) ||
			($self->{property} = PermittedValues->parse($line,@_[1,-1])) ||
			($self->{property} = RequiredValues->parse($line,@_[1,-1])) ||
			($self->{property} = GetReplace->parse($line,@_[1,-1])) ||
			($self->{property} = Get->parse($line,@_[1,-1])) ||
			($self->{property} = Replace->parse($line,@_[1,-1])) ||
			($self->{property} = AddRemove->parse($line,@_[1,-1])) ||
			($self->{property} = Add->parse($line,@_[1,-1])) ||
			($self->{property} = Remove->parse($line,@_[1,-1])) ||
			($self->{property} = SetByCreate->parse($line,@_[1,-1])) ||
			($self->{property} = NoModify->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{property};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{property}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ReplaceWithDefault;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('REPLACE-WITH-DEFAULT',@_);
}

sub head {
	my $self = shift;
	my $tmpl = $_[-2];
	my $prop = $_[-1];
	printf "\n$::indent"."static bool ReplaceWithDefault = true;";
}

sub stub {
	my $self = shift;
	my $tmpl = $_[-2];
	my $prop = $_[-1];
	my $name = $tmpl->{scopedname};
	printf "\n$::indent"."bool $name"."::ReplaceWithDefault = true;";
}

# -------------------------------------
package DefaultValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DEFAULT(?:\s|\n)*((-)?)(?:\s|\n)*VALUE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{value} = ValueSpecifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."static const $attr& $name"."Default;";
	printf "\n$::indent"."$name"."SetDefault();";
	$self->{value}->generate('head',@_);
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$attr"."SetDefault()";
	printf "\n$::indent"."{";
	printf "\n$::indent"."}";
	$self->{value}->generate('stub',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DEFAULT VALUE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{value})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
package InitialValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^INITIAL(?:\s|\n)*((-)?)(?:\s|\n)*VALUE//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{value} = ValueSpecifier->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{value};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."static const $attr& $name"."Initial;";
	$self->{value}->generate('head',@_);
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."const $attr& $attr"."Initial = 0;";
	$self->{value}->generate('stub',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'INITIAL VALUE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
package PermittedValues;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PERMITTED(?:\s|\n)*((-)?)(?:\s|\n)*VALUES//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{typereference} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{typereference};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."static const $attr& $name"."Permitted;";
	$self->{typereference}->generate('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PERMITTED VALUES'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{typereference}->gdmo();
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
package RequiredValues;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REQUIRED(?:\s|\n)*((-)?)(?:\s|\n)*VALUES//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{typereference} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{typereference};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."static const $attr& $name"."Required;";
	$self->{typereference}->generate('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'REQUIRED VALUES'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{typereference}->gdmo();
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
package GetReplace;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: Inclusing of the GET-REPLACE peroperty is the notation for specifying that both
# the GET property and the REPLACE property are included.

sub read {
	my $self = shift;
	return $self->readtoken('GET-REPLACE',@_);
}

sub xref {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	#print STDERR "Pushing $prop->{attribute}->{name} on ".ref($tmpl)." constructor pointers";
	push @{$tmpl->{constructorptrs}}, $prop->{attribute};
	return $self->call('xref',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$attr& $name"."Get();";
	printf "\n$::indent"."$name"."Set($attr& val);";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$attr& $scop"."::$name"."Get() {";
	printf "\n$::indent"."\treturn $name;";
	printf "\n$::indent"."}";
	printf "\n$::indent"."$scop"."::$name"."Set($attr& val) {";
	printf "\n$::indent"."\t$name = val;";
	printf "\n$::indent"."}";
}

# -------------------------------------
package Get;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: The GET property is included if the value of the attributes may be retrieved
# with the Get attribute value operation.

sub read {
	my $self = shift;
	return $self->readtoken('GET',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$attr& $name"."Get();";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$attr& $scop"."::$name"."Get() {";
	printf "\n$::indent"."\treturn $name;";
	printf "\n$::indent"."}";
}

# -------------------------------------
package Replace;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: The REPLACE property is included if the attribute may be set with the Replace
# attribute value operation andw ith the Create operation.  Setting with the Create operation applies
# only if the Create operation is supported by the name binding of the managed object instance.

sub read {
	my $self = shift;
	return $self->readtoken('REPLACE',@_);
}

sub xref {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	#print STDERR "Pushing $prop->{attribute}->{name} on ".ref($tmpl)." constructor pointers";
	push @{$tmpl->{constructorptrs}}, $prop->{attribute};
	return $self->call('xref',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$name"."Set($attr& val);";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$scop"."::$name"."Set($attr& val) {";
	printf "\n$::indent"."\t$name = val;";
	printf "\n$::indent"."}";
}

# -------------------------------------
package AddRemove;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: Inclusinon of the ADD-REMOVE property is the notation for specifying that both
# the ADD property and the REMOVE property are included.

sub read {
	my $self = shift;
	return $self->readtoken('ADD-REMOVE',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$name"."Add($attr& val);";
	printf "\n$::indent"."$name"."Remove($attr& val);";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$scop"."::$name"."Add($attr& val) {";
	printf "\n$::indent"."\treturn; // FIXME";
	printf "\n$::indent"."}";
	printf "\n$::indent"."$scop"."::$name"."Remove($attr& val) {";
	printf "\n$::indent"."\treturn; // FIXME";
	printf "\n$::indent"."}";
}

# -------------------------------------
package Add;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: The ADD property is included if the attribut may be set with the Add member
# operation.

sub read {
	my $self = shift;
	return $self->readtoken('ADD',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$name"."Add($attr& val);";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$scop"."::$name"."Add($attr& val) {";
	printf "\n$::indent"."\treturn; // FIXME";
	printf "\n$::indent"."}";
}

# -------------------------------------
package Remove;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: The REMOVE property is included if the attribute may bse sset with the Remove
# member operation.

sub read {
	my $self = shift;
	return $self->readtoken('REMOVE',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$name"."Remove($attr& val);";
}

sub stub {
	my $self = shift;
	my $prop = $_[-1];
	my $tmpl = $_[-2];
	my $scop = $tmpl->{scopedname};
	my $attr = $prop->{attribute}->{scopedname};
	my $name = $prop->{attribute}->{name};
	printf "\n$::indent"."$scop"."::$name"."Remove($attr& val) {";
	printf "\n$::indent"."\treturn; // FIXME";
	printf "\n$::indent"."}";
}

# -------------------------------------
package SetByCreate;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 1: The SET-BY-CREATE property is included if the attribute may be set by means of
# the Create operation.  This property is only meaningful if the Create operation is supported by the
# name binding of the managed object instance.  Since the REPLACE poperty is included if the attribute
# may be set by means of the Replace operation or the Create operation, the SET-BY-CREATE property
# does not have to be included if the REPLACE property is present.  Similarly, teh SET-BY-CREATE
# property does nto have to be included if the ADD, REMOVE, or ADD-REMOVE property is present.  Even
# if SET-BY-CREATE is absent, the attempt to set a value with the Create operation may succeeed.

sub read {
	my $self = shift;
	return $self->readtoken('SET-BY-CREATE',@_);
}

sub xref {
	my $self = shift;
	my $prop = $_[-1]; # AttributeProperty
	my $tmpl = $_[-2]; # PackageTemplate
	#print STDERR "Pushing $prop->{attribute}->{name} on ".ref($tmpl)." constructor references";
	push @{$tmpl->{constructorrefs}}, $prop->{attribute};
	return $self->call('xref',@_);
}

sub head {
	my $self = shift;
	my $prop = $_[-1]; # AttributeProperty
	my $tmpl = $_[-2]; # PackageTemplate
	printf "\n$::indent"."// SET-BY-CREATE: $prop->{attribute}->{scopedname}";
}

# -------------------------------------
package NoModify;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# X.722 Ammendment 2: The absence of the REPLACE property may be used to specify that an attribute
# cannot be replaced for instances of a class but this absence does not preclude subclasses adding the
# REPLACE property.  The NO-MODIFY property is present to explicitly specify that an attribute cannot
# be modified (is read-only) in the class having this property and in all subclassess and in all
# compatible managed objects (i.e. managed objects behaving allomorphically to the class).  This
# property is inconsistent with and shall not be present in a managed object class definition hta thas
# any of the REPLACE, GET-REPLACE, ADD, REMOVE, or ADD-REMOVE properties of the same attribute.
#
#   NOTE 3 -- The NO-MODIFY property is not necessarily inconsistent wih the REPLACE-WITH-DEFAULT
#   property because this operation is often used with the meanning of "reset" that can be consistent
#   with a manager's inability to control the attribute's value.
#
#   NOTE 4 -- Before the NOT-MODIFY property was added to GDMO, the convention was to specify that
#   property in BEHAVIOUR templates or in documents referenced in BEHAVIOUR templates.
#
# If it is desired that part of the definition of an attriabute is that the attribute shall not be
# replaced in any class that specifies the attribute, then this constraint sha be specified in a
# BEHAVIOUR repmplate referenced by the ATTRIBUTE template.

sub read {
	my $self = shift;
	return $self->readtoken('NO-MODIFY',@_);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// FIXME: override default $_[-1]->{attribute}->{scopedname} ops with errors";
	#fixme provide error overrides for default operations
	#printf "\n$::indent"."static bool NoModify = true;";
}

# -------------------------------------
package ValueSpecifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = ExternalValueReference->parse($line,@_[1,-1])) ||
			($self->{value} = DerivationRule->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{value};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{value}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExternalTypeReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{modulereference} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{modulereference};
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{typename} = TypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{typename};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modulereference}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::first = 1; # fool typereference into concatenating
		$self->{typename}->gdmo();
	}
}

# -------------------------------------
package ExternalValueReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{modulereference} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{modulereference};
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{valuename} = ValueReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{valuename};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modulereference}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{valuename}->gdmo();
	}
}

sub oid {
	my $self = shift;
	my ($s,$name);
	if (($s = $self->{modulereference})) {
		$name = $self->{modulereference}.".".$self->{valuename};
	} else {
		$name = $self->{valuename};
	}
	# Just return the value of name for now
	return "$name";
}

# -------------------------------------
package AbsoluteReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$c);
		last TEST unless ($line=~s/^@//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{modulereference} = ModuleReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{modulereference};
		last TEST unless ($line=~s/^\.//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($s = TypeReference->parse($line,@_[1,-1])));
		push @{$self->{typereferences}}, $s;
		push @{$self->{children}}, $s;
		while ($line=~s/^\.//s) {
			if (($c = Comments->parse($line,@_[1,-1]))) {
				$s->{commentplus} = $c;
			}
			last TEST unless (($s = TypeReference->parse($line,@_[1,-1])));
			push @{$self->{typereferences}}, $s;
			push @{$self->{children}}, $s;
			# Fixme: the last element after the '.' is an identifier, a number, or a '*'
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		if (!$::first) { printf ' '; }
		printf '@'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{modulereference}->gdmo(); printf '.'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		foreach $s (@{$self->{typereferences}}) {
			if ($i) {
				printf '.'; $::first = 0;
				if ($c) { $c->gdmo(); }
			} else { $i = 1; }
			$s->gdmo();
			$c = $s->{commentplus};
		}
	}
}

# -------------------------------------
package DerivationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# Some ITU standareds use DERIVED RULES instead of DERIVATION RULE... go figure.
# It will be corrrected on output.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			$line=~s/^DERIVATION(?:\s|\n)*((-)?)(?:\s|\n)*RULE//s ||
			$line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s\|\n)*RULES//s
		);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($self->{behaviour} = BehaviourReference->parse($line,@_[1,-1]));
		push @{$self->{children}}, $self->{behaviour};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		my $s;
		printf 'DERIVATION RULE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{behaviour}->gdmo();
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package ModuleIdentifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{reference} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# ModuleIdentifier's occur only in the definition of an ASN module.  We keep track of which module
# identifiers are defined in all documents, the definiting GDMO document and the definining ASN
# module.

sub xref {
	my $self = shift;
	my $asn1 = $_[1]; # ASN1 module

	$asn1->{moduleid} = $self->{reference};
	$::root->{asnmodules}->{$self->{reference}}->{defn} = $asn1;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf "$self->{reference}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ModuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{reference} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# ModuleRference's occur on SymbolsFromModule (after FROM in ASN module IMPORTS statment), a global
# module reference of the form ModuleName and ObjectIdentifier (also after FROM in ASN module
# IMPORTS statement) an ExternalTypeReference or ExternalValueReference which can occur just about
# anywhere, including GDMO templates, which are proliferated with ExternalTypeRerferences and have a
# few ExternalValueReferences for Initial and Default values for attributes.
#
# When this function is called, we might or might not be within an ASN module (we might only be
# within a gdmo).  We must keep track of all external module references for the root, each gdmo
# document and each ASN1 module.

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{asnmodules}->{$self->{reference}}->{refs}}, $self; }
	push @{$gdmo->{asnmodules}->{$self->{reference}}->{refs}}, $self;
	push @{$::root->{asnmodules}->{$self->{reference}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{reference}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ValueReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[a-z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{vrefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{vrefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{vrefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package TypeReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$self->{name} = $&;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { push @{$asn1->{trefs}->{$self->{name}}->{refs}}, $self; }
	push @{$gdmo->{trefs}->{$self->{name}}->{refs}}, $self;
	push @{$::root->{trefs}->{$self->{name}}->{refs}}, $self;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeGroups;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*GROUPS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{groups} = AttributeGroupAttributesList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{groups};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE GROUPS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{groups}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeGroupAttributesList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package AttributeGroupAttributes;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{group} = AttributeGroupReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{groups};
		if (($self->{attributes} = AttributeReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{attributes};
		}
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// ATTRIBUTE GROUPS:\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{group}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{attributes})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeReferenceSimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('AttributeReference',@_); }

# -------------------------------------
package Actions;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACTIONS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{actions} = ActionParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{actions};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// ACTIONS:\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ACTIONS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{actions}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ActionParameterList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ActionParameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{action} = ActionReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{action};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	if (ref($self->{action}->{reference})=~/ActionTemplate/) {
		$self->call('head',@_);
	} else {
		printf "\n$::indent"."$self->{action}->{name}"."();";
	}
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{action}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{parameters})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package ParameterReferenceSimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('ParameterReference',@_); }

# -------------------------------------
package Notifications;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFICATIONS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{notifications} = NotificationParameterList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{notifications};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// NOTIFICATIONS:\n$::indent";
	$self->call('head',@_);
	printf "\n$::indent";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NOTIFICATIONS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{notifications}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NotificationParameterList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package NotificationParameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{notification} = NotificationReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{notification};
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{parameters};
		}
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{notification}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{parameters})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RegisteredAs;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless
		($line=~s/^REGISTERED(?:\s|\n)*((-)?)(?:\s|\n)*AS//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{objectid} = ObjectIdentifierValue->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{objectid};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'REGISTERED AS'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{objectid}->gdmo();
	}
}

# -------------------------------------
package WithSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Package;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PACKAGE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{package} = PackageReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{package};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PACKAGE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{package}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Parameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PARAMETER//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{parameter} = ParameterReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{parameter};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PARAMETER'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{parameter}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NameBinding;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAME(?:\s|\n)*((-)?)(?:\s|\n)*BINDING//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{namebinding} = NameBindingReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{namebinding};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NAME BINDING'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{namebinding}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Attribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeGroup;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*GROUP//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attributegroup} = AttributeGroupReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attributegroup};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE GROUP'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attributegroup}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Behaviour;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^BEHAVIOUR//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{behaviour} = BehaviourReferenceList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{behaviour};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'BEHAVIOUR'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{behaviour}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BehaviourReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package Action;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACTION//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{action} = ActionReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{action};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ACTION'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{action}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Notification;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFICATION//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{notification} = NotificationReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{notification};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NOTIFICATION'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{notification}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SubordinateObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# This defines a manged object class whose instances may be named by instances of the object class
# defined by the NAME BY SUPERIOR OBJECT CLASS constuct.  The name of an instance of this subordinate
# object class is constructed by concatentating the distinguished name of it's superior object with
# the relative disinguished name of the specified managed object class.  IF AND SUBCLASSES is
# specified, the name binding also applies to all subclasses of the specified managed object class.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SUBORDINATE(?:\s|\n)*((-)?)(?:\s|\n)*OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{subclasses};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SUBORDINATE OBJECT CLASS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (!$::first) { printf ' '; $::first = 1; }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamedBySuperior;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# This defines a managed object class or other object class, such as a Directory object class, whose
# instances may name instances of the managed object class defined by the SUBORDINATE OBJECT CLASS
# construct.  If AND SUBCLASSES is specified, the name binding also applies to all subclasses of the
# specified object class.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAMED(?:\s|\n)*((-)?)(?:\s|\n)*BY//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($line=~s/^SUPERIOR(?:\s|\n)*((-)?)(?:\s|\n)*OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{class} = ClassReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{class};
		if (($self->{subclasses} = AndSubclasses->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{subclasses};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments3} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NAMED BY'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		if (!$::first) { printf ' '; }
		printf 'SUPERIOR OBJECT CLASS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments2})) { $s->gdmo(); }
			if (!$::first) { printf ' '; $::first = 1; }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments3})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AndSubclasses;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('AND SUBCLASSES',@_);
}

# -------------------------------------
package WithAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# This defines the attribute that shall be used, in the context of this name binding, to construct the
# relative distinguisehed name for instances of the managed object class defined by the SUBORDINATE
# OBJECT CLASS construct.  Values of this attribute shall be repsrented by single-valued data types
# complying with the restrictions specified in CCITT Rec. X.720 | ISO/IEC 10165-1; if no suitable
# attribute is available for use as a naming attribute, managed object designers are encouraged to
# provide a naming attribute of type GraphicString.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Create;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# -------------------------------------
# Present if it is permitted to create new instances of the managed object class referenced by the
# SUBORDINATE OBJECT CLASS construct in the context of this name binding, by means of system
# management operation.  The create--modifier values specify the options available on creation.
#
# The behaviour definitions shall specify what course of action is taken when there is a choice of
# Name Bindings that may be applied to the new managed object.
#
# The sources of initial attribute values used at managed object creation time, and their associated
# precedence rules, are defined in CCITT Rec. X.720 | ISO/IEC 10165-1.
#
# If present, the parameter-labels identify the name binding specific error parameters associated with
# the Create operation.  These are reported as processing failures.  The syntax of the error
# parameters are defined in the referenced templates.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$c);
		last TEST unless ($line=~s/^CREATE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{modifiers} = CreateModifierList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{modifiers};
		}
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		last TEST unless ($line=~s/^;//s); 
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CREATE'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (($s = $self->{modifiers})) { $s->gdmo(); }
		if (($s = $self->{parameters})) { $s->gdmo(); }
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package CreateModifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package CreateModifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{modifier} = WithReferenceObject->parse($line,@_[1,-1])) ||
			($self->{modifier} = WithAutomaticInstanceNaming->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{modifier};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithReferenceObject;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# If present, a reference managed object may be specified on creation as a source of default values
# and to specify choice of conditional packages.

sub read {
	my $self = shift;
	return $self->readtoken('WITH-REFERENCE-OBJECT',@_);
}

# -------------------------------------
package WithAutomaticInstanceNaming;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# If present, the Create request may omit to specify the instance name of the new managed object.

sub read {
	my $self = shift;
	return $self->readtoken('WITH-AUTOMATIC-INSTANCE-NAMING',@_);
}

# -------------------------------------
package Delete;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGeneratorMajor);
# -------------------------------------
# Prsent if it is permitted to delete instances of the managed object class referenced by the
# SUBORDINATE OBJECT CLASS construct in the context of this name binding.  The delete-modifier, if
# present, indicates the behaviour of a managed object of that class if the managed object is deleted.
#
# Other rules which describe the behaviour with respect to delettion of contained manged objects may
# be specified in the BEHAVIOUR construct.
#
#   NOTE 2 -- Givent that the DELETES-CONTAINED-OBJECTS modifier permits the deletion of a manged
#   object regardless of whether it contains other managed objects, it is advisable to user the
#   ONLY-IF-NO-CONTAINED-OBJECTS modifier if there is any doubt as to which modifier is appropriate.
#
# If there are constraints on deletion relative to other relationships or conditions that are generic
# to the managed object class, these shall be specified as part of the behaviour of the managed object
# class.
#
# If present, the paraemter-labels identifier name binding specified error parameters associated with
# the Delete operation.  These are reported as processing failures.  The syntax of the error
# parameters are defined in the referenced templates.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$c);
		last TEST unless ($line=~s/^DELETE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1],$self);
		if (($self->{modifiers} = DeleteModifierList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{modifiers};
		}
		if (($self->{parameters} = ParameterReferenceSimpleList->parse($line,@_[1,-1],$self))) {
			push @{$self->{children}}, $self->{parameters};
		}
		last TEST unless ($line=~s/^;//s); 
		$self->{comments2} = Comments->parse($line,@_[1,-1],$self);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{policy} = 'deleteOnlyIfNoContained';
	$self->call('xref',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DELETE'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (($s = $self->{modifiers})) { $s->gdmo(); }
		if (($s = $self->{parameters})) { $s->gdmo(); }
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DeleteModifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package DeleteModifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{modifier} = OnlyIfNoContainedObjects->parse($line,@_[1,-1])) ||
			($self->{modifier} = DeletesContainedObjects->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{modifier};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package OnlyIfNoContainedObjects;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# If specified, any contained managed objects shall be explicitly deleted by management operations
# prior to deletion of the containing managed object, i.e, a Delete request will cause an error if
# there are contained managed objects.

sub read {
	my $self = shift;
	return $self->readtoken('ONLY-IF-NO-CONTAINED-OBJECTS',@_);
}

sub xref {
	my $self = shift;
	my $dele = $_[-1];
	$dele->{policy} = 'deleteOnlyIfNoContained';
}

# -------------------------------------
package DeletesContainedObjects;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------
# If a Delete request is applied to a managed object for which the DELETES-CONTAINED-OBJECTS modifier
# is specified, the Delete request will faile if any directly or indirectly contained managed object
# has the ONLY-IF-NO-CONTAINED-OBJECTS modifier specified and also has a contained manged object;
# otherwise, a successful Delete request will aso have the effect of deleting contained managed
# objects.

sub read {
	my $self = shift;
	return $self->readtoken('DELETES-CONTAINED-OBJECTS',@_);
}

sub xref {
	my $self = shift;
	my $dele = $_[-1];
	$dele->{policy} = 'deletesContainedObjects';
}

# -------------------------------------
package DerivedFromAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s|\n)*FROM//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf " : public $self->{attribute}->{name} {";
	$::indent.="\t";
	printf "\n$::indent"."private:";
	$::indent.="\t";
	$self->{attribute}->generate('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DERIVED FROM'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithAttributeSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf ' : public Attribute {';
	# could actually let the syntax fill out the parent class
	$self->{syntax}->generate('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH ATTRIBUTE SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package MatchesFor;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MATCHES(?:\s|\n)*((-)?)(?:\s|\n)*FOR//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{matches} = MatchQualifierList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{matches};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'MATCHES FOR'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{matches}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package MatchQualifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package MatchQualifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{qualifier} = Equality->parse($line,@_[1,-1])) ||
			($self->{qualifier} = Ordering->parse($line,@_[1,-1])) ||
			($self->{qualifier} = Substrings->parse($line,@_[1,-1])) ||
			($self->{qualifier} = SetComparison->parse($line,@_[1,-1])) ||
			($self->{qualifier} = SetIntersection->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{qualifier};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		#if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{qualifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Equality;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EQUALITY',@_);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	$tmpl->{equality} = $self;
}

# -------------------------------------
package Ordering;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ORDERING',@_);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	$tmpl->{ordering} = $self;
}

# -------------------------------------
package Substrings;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SUBSTRINGS',@_);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	$tmpl->{substrings} = $self;
}

# -------------------------------------
package SetComparison;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SET-COMPARISON',@_);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	$tmpl->{setcomparison} = $self;
}

# -------------------------------------
package SetIntersection;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SET-INTERSECTION',@_);
}

sub xref {
	my $self = shift;
	my $tmpl = $_[-1];
	$tmpl->{setintersection} = $self;
}

# -------------------------------------
package Parameters;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PARAMETERS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{parameters} = ParameterReferenceList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{parameters};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	printf "\n$::indent"."// PARAMETERS:\n$::indent";
	$self->call('head',@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PARAMETERS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{parameters}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ParameterReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package GroupElements;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GROUP(?:\s|\n)*((-)?)(?:\s|\n)*ELEMENTS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{elements} = AttributeReferenceCommaList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{elements};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'GROUP ELEMENTS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{elements}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeReferenceCommaList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package Fixed;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^FIXED//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'FIXED'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Description;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DESCRIPTION//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,';',@_[1,-1])));
		push @{$self->{children}}, $self->{delimited};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $name = $_[-1]->{name};
	printf "\n$::indent"."static const char description"."[];";
	$self->call('head',@_);
}

sub stub {
	my $self = shift;
	my $tmpl = $_[-1];
	my $name = $tmpl->{scopedname};
	printf "\n$::indent"."const char $name"."::description[] = \"\\\n";
	$self->call('stub',@_);
	printf "\";";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DESCRIPTION'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{delimited}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DefinedAs;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DEFINED(?:\s|\n)*((-)?)(?:\s|\n)*AS//s);
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,';',@_[1,-1])));
		push @{$self->{children}}, $self->{delimited};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub head {
	my $self = shift;
	my $tmpl = $_[-1];
	printf "\n$::indent"."static const char definedas[];";
	$self->call('head',@_);
}

sub stub {
	my $self = shift;
	my $tmpl = $_[-1];
	my $name = $tmpl->{scopedname};
	printf "\n$::indent"."const char $name"."::definedas[] = \"\\\n";
	$self->call('stub',@_);
	printf "\";";
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DEFINED AS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{delimited}->gdmo();
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package Mode;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MODE//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (
			($self->{mode} = Confirmed->parse($line,@_[1,-1])) ||
			($self->{mode} = Unconfirmed->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{mode};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'MODE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{mode}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Confirmed;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('CONFIRMED',@_);
}

# -------------------------------------
package Unconfirmed;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('UNCONFIRMED',@_);
}

# -------------------------------------
package WithInformationSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*INFORMATION(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH INFORMATION SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithReplySyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*REPLY(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH REPLY SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithInformationSyntaxAndAttributeIds;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*INFORMATION(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{syntax};
		if (($self->{attributeids} = AndAttributeIds->parse($line,@_[1,-1]))) {
			push @{$self->{children}}, $self->{attributeids};
		}
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH INFORMATION SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			if (($s = $self->{attributeids})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AndAttributeIds;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^AND(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*IDS//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{ids} = FieldAttributeList->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{ids};
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'AND ATTRIBUTE IDS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{ids}->gdmo();
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package FieldAttributeList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package FieldAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9]|-(?!-))*(?<!-))//s);
		$self->{fieldname} = $1;
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{attribute};
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{fieldname}"; $::first = 0;
		$::indent.="\t";
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{attribute}->gdmo();
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package Context;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless ($line=~s/^CONTEXT//s);
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{type} = ContextType->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{type};
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CONTEXT'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{type}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ContextType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = ContextKeyword->parse($line,@_[1,-1])) ||
			($self->{type} = ActionInfo->parse($line,@_[1,-1])) ||
			($self->{type} = ActionReply->parse($line,@_[1,-1])) ||
			($self->{type} = EventInfo->parse($line,@_[1,-1])) ||
			($self->{type} = EventReply->parse($line,@_[1,-1])) ||
			($self->{type} = SpecificError->parse($line,@_[1,-1]))
		);
		push @{$self->{children}}, $self->{type};
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{type}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ContextKeyword;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{typereference} = ExternalTypeReference->parse($line,@_[1,-1])));
		push @{$self->{children}}, $self->{typereference};
		$self->{comments1} = Comments->parse($line,@_[1,-1]);
		last TEST unless ($line=~s/^\.//s);
		$self->{comments2} = Comments->parse($line,@_[1,-1]);
		last TEST unless (($self->{identifier} = Identifier->parse($line,@_[1,-1])));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{typereference}->gdmo();
		if (($s = $self->{comments1})) { $s->gdmo(); }
		printf '.'; $::first = 1;
		$self->{identifier}->gdmo();
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ActionInfo;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ACTION-INFO',@_);
}

# -------------------------------------
package ActionReply;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ACTION-REPLY',@_);
}

# -------------------------------------
package EventInfo;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EVENT-INFO',@_);
}

# -------------------------------------
package EventReply;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EVENT-REPLY',@_);
}

# -------------------------------------
package SpecificError;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SPECIFIC-ERROR',@_);
}

# -------------------------------------
package XXX;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{comments} = Comments->parse($line,@_[1,-1]);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package main;
use strict;
# -------------------------------------

no strict;

$s = '\s';
$lineno = 0;
$endoffile = 0;
$done = 0;
$error = '';
$success = '';
$errob = '';
$indent = '';
$first = 0;
$noref = 0;
$depth = 0;
$colwidth = 80; # width of delimited string reflow
$context = 50; # number of lines to report on error
@objects = ();
$root = {}; # root object
$scope = '';
@backtrack = ();
$oid = 0;

$root->{gdmos} = {};
$root->{oids} = {};

undef $/; # suck entire file

#
# Several things that we want to do:
#
# gdmocheck:
#   - check syntax and crossreferences and emit pretty printed results to stdout
#
# gdmohead:
#   - read GDMO input files and generate C++ header files for each input file
#   - where the input file is named x.gdmo the output file is named x.gdmo.hh
#   - where the input file is named x.gdmo the associated ASN syntax is named x.asn
#   - GDMO include files are searched in the current directory and in any include directory paths
#
# gdmostub:
#   - read GDMO input files and generate C++ stub implementation files for each input
#   - where the intput file is named x.gdmo the output file is named x.gdmo.cpp
#   - where the input file is named x.gdmo the associated ASN syntax is named x.asn
#   - GDMO include files are searched in the current directory and in any include directory paths
#
# gdmodep:
#   - read GDMO input files and generate makefile dependencies for each input to stdout
#

if (($gdmo = Gdmo->parse($file))) {
	$gdmo->generate('xref');
	if ($progname=~/check$/) {
		$gdmo->generate('gdmo');
	} elsif ($progname=~/head$/) {
		$gdmo->generate('head');
	} elsif ($progname=~/stub$/) {
		$gdmo->generate('stub');
	}
} else {
	print STDERR "E: PARSE FAILED!";
}

# vim: ft=perl comments=b\:#,b\:##,b\:#\! formatoptions+=tcqlorn
