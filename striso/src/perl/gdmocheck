#!/usr/bin/perl
# =============================================================================
# 
# @(#) $RCSfile$ $Name$($Revision$) $Date$
#
# -----------------------------------------------------------------------------
#
# Copyright (c) 2001-2007  OpenSS7 Corporation <http://www.openss7.com/>
# Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>
#
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>, or write to the
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# -----------------------------------------------------------------------------
#
# U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
# behalf of the U.S. Government ("Government"), the following provisions apply
# to you.  If the Software is supplied by the Department of Defense ("DoD"), it
# is classified as "Commercial Computer Software" under paragraph 252.227-7014
# of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
# successor regulations) and the Government is acquiring only the license rights
# granted herein (the license rights customarily provided to non-Government
# users).  If the Software is supplied to any unit or agency of the Government
# other than DoD, it is classified as "Restricted Computer Software" and the
# Government's rights in the Software are defined in paragraph 52.227-19 of the
# Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
# the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
# (or any successor regulations).
#
# -----------------------------------------------------------------------------
#
# Commercial licensing and support of this software is available from OpenSS7
# Corporation at a fee.  See http://www.openss7.com/
#
# -----------------------------------------------------------------------------
#
# Last Modified $Date$ by $Author$
#
# -----------------------------------------------------------------------------
#
# $Log$
# =============================================================================

eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
	if $running_under_some_shell;

$progname = $0;

$debug	    = 0;
$trace	    = 0;
$verbose    = 0;
$crossref   = 0;
@infiles    = ();

while ($ARGV[0]=~/^-/) {
	$_ = shift;
	last if /^--/;
	if (/^-n/) { $nflag++; next; }
	if (/^-d/) { $debug	= 1; next; }
	if (/^-t/) { $trace	= 1; next; }
	if (/^-v/) { $verbose	= 1; next; }
	if (/^-x/) { $crossref	= 1; next; }
	if (/^-f(.*)/) { if ($1) { push @infiles, $1; } else { push @infiles, shift; } next; }
	if (/^-o(.*)/) { if ($1) { $outfile = $1; } else { $outfile = shift; } next; }
	usage();
	die "I don't recognize this switch: $_\\n";
}

foreach $infile (@ARGV) {
	push @infiles, $infile;
}

sub usage {
	print STDERR "$0 Usage:\n";
	print STDERR "  $0 ".'[-d] [-t] [-v] [ [-f] infile [ [-o] outfile ] ]'."\n";
	print STDERR "	-d - turn on debug mode\n";
	print STDERR "	-t - turn on trace mode (lots of info)\n";
	print STDERR "	-v - turn on verbose mode (lots of info)\n";
	print STDERR "	-x - report crossreferences in output\n";
	print STDERR "	[-f] infile  -  input file (default stdin)\n";
	print STDERR "	[-o] outfile - output file (default stdout)\n";
}

$printit++ unless $nflag;

$\ = "\n";	# add new-line to print
$* = 0;		# do signleline matching
undef $/;	# read entire file

$file = '';

sub readfile {
	my $fh = shift;
	$file .= <$ifh>; # read entire file
	chomp $file;
	# strip leading whitespace
	$file=~s/^(?:\s|\n)*//s;
	# strip trailing whitespace
	$file=~s/(?:\s|\n)*$//s;
	# put an EOL on end in case file ends with comment
	$file .= "\n";
}

if (scalar @infiles > 0) {
	foreach $infile (@infiles) {
		open (INFILEH,"<$infile") || die "can't open $infile for input";
		$ifh = \*INFILEH;
		readfile($ifh);
	}
} else {
	$ifh = \*STDIN;
	readfile($ifh);
}

if ($outfile) {
	open (OUTFILEH,">$outfile") || die "can't open $outfile for output";
	select OUTFILEH;
} else {
	select STDOUT;
}

sub getchunk {
	# Get a chunk from the current or next file.  We try to look ahead 
}

# -------------------------------------
package Parser;
use strict;
# -------------------------------------

sub parse {
	my $type = shift;
	my $self = {};
	# print STDERR "Type is $type.";
	bless $self, $type;
	if ($::debug) {
		unless ($type=~/^Comment/) {
			$::depth++;
			if ($type=~/Template$/) {
				# $self->indent($::depth);
				# printf "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n";
			}
			$self->indent($::depth);
			printf "<$type> ... ";
			printf "\`".substr($_[0],0,index($_[0],"\n"))."'\n";
		}
	}
#	$self->{line} = $_[0];
#	$self->{success} = $::success;
	$::success = '';
	my $ret = $self->read(@_);
	if ($ret) {
#		unless ($::success) {
#			$::success = $self->{line};
#		}
#		if ($#::objects) {
#			$ret->{previous} = $::objects[-1];
#		}
		push @::objects, $ret;
#		my $n = $::root->{alloc}->{ref $ret}->{refs}++;
#		$::root->{alloc}->{total}->{refs}++;
		# print STDERR "Allocated ".$n." ".ref($ret).".";
	} else {
#		unless ($::success) {
#			$::success = $self->{success};
#		}
	}
	if ($::debug) {
		unless ($type=~/^Comment/) {
			if ($ret) {
				$self->indent($::depth);
				print "<$type> FOUND ";
				$self->gdmo();
				print "";
			} else {
				#$self->indent($::depth);
				#print "<$type> not found";
			}
			if ($type=~/Template$/) {
				# $self->indent($::depth);
				# printf "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n";
			}
			$::depth--;
		}
	}
	return $ret;
}

sub indent {
	my $self = shift;
	my $depth = shift;
	my $i; for ($i=0;$i<$depth;$i++) {
		printf '|';
	}
	return;
}

sub read {
	my $self = shift;
	return ($self->error(@_));
}

sub error {
	my $self = shift;
	unless ($::error) {
		# $::error = $_[0];
		$::errob = ref $self; }
	undef $self;
	return undef;
}

# -------------------------------------
package Generator;
use strict;
# -------------------------------------

sub generate {
	my $self = shift;
	my $sub = shift;
	return $self->$sub(@_);
}

sub general {
	my $self = shift;
	if ($::trace) { printf "--!!".ref($self)."!!--"; }
	my $s; foreach $s (@{$self->{children}}) {
		$s->generate(@_);
	}
}

sub xref {
	my $self = shift;
	return;
}

sub gdmo {
	my $self = shift;
	return $self->general('gdmo',@_);
}

# -------------------------------------
package ParserGenerator;
use strict;
use vars qw(@ISA);
@ISA = qw(Parser Generator);
# -------------------------------------


# -------------------------------------
package CommaList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readitem {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless (($s = $type->parse($line)));
		push @{$self->{items}}, $s;
		while ($line=~s/^,//s) {
			$s->{commentplus} = Comments->parse($line);
			last TEST unless (($s = $type->parse($line)));
			push @{$self->{items}}, $s;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#printf STDERR "Reading type $type.";
	unless ($type=~s/List$//) {
		$type.='Item';
	}
	return $self->readitem($type,@_);
}

sub xref {
	my $self = shift;
	my ($x); foreach $x (@{$self->{items}}) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			if ($i) {
				printf ','; $::first = 0;
				if ($c) { $c->gdmo(@_); }
			} else { $i = 1; }
			$s->gdmo(@_);
			$c = $s->{commentplus};
		}
		$::indent=~s/^.//s;
	}
}

# -------------------------------------
package SimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readitem {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless (($s = $type->parse($line)));
		push @{$self->{items}}, $s;
		while (($s = $type->parse($line))) {
			push @{$self->{items}}, $s;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#printf STDERR "Reading type $type.";
	unless ($type=~s/List$//) {
		$type.='Item';
	}
	return $self->readitem($type,@_);
}

sub xref {
	my $self = shift;
	my ($x); foreach $x (@{$self->{items}}) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		#$::indent.="\t";
		foreach $s (@{$self->{items}}) {
			$s->gdmo();
		}
		#$::indent=~s/^.//s;
	}
}

# -------------------------------------
package MandatoryBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub readinterior {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^{//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{interior} = $type->parse($line)));
		last TEST unless ($line=~s/^}//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#printf STDERR "Reading type $type.";
	unless ($type=~s/Braced$//) {
		$type.='Lists';
	}
	return $self->readinterior($type,@_);
}

sub xref {
	my $self = shift;
	$self->{interior}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '{'; $::first = 0;
		{
			#$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{interior}->gdmo();
			#$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf '}'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package MandatoryParens;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub readinterior {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\(//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{interior} = $type->parse($line)));
		last TEST unless ($line=~s/^\)//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#printf STDERR "Reading type $type.";
	unless ($type=~s/Parens$//) {
		$type.='Lists';
	}
	return $self->readinterior($type,@_);
}

sub xref {
	my $self = shift;
	$self->{interior}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '('; $::first = 0;
		{
			#$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{interior}->gdmo();
			#$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf ')'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package OptionalBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub readinterior {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^{//s);
		$self->{comments1} = Comments->parse($line);
		$self->{interior} = $type->parse($line);
		last TEST unless ($line=~s/^}//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	#printf STDERR "Reading type $type.";
	unless ($type=~s/Braced$//) {
		$type.='Lists';
	}
	return $self->readinterior($type,@_);
}

sub xref {
	my $self = shift;
	$self->{interior}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf '{'; $::first = 0;
		{
			#$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (($s = $self->{interior})) { $s->gdmo(); }
			#$::indent=~s/^.//s;
		}
		if (!$::first) { printf ' '; }
		printf '}'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SimpleToken;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readtoken {
	my $self = shift;
	my $token = shift;
	my $line = $_[0];
	TEST: {
		my $substitute;
		$self->{token} = $token;
		$substitute = $token;
		$substitute=~s/[ \t]+/\\s\*/g;
		# print STDERR "Substituting '$substitute'.";
		last TEST unless ($line=~s/^$substitute//s);
		# $self->{token} = $&;
		# print STDERR "Got '$self->{token}'.";
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Token$//;
	return $self->readtoken($type,@_);
}

sub xref {
	my $self = shift;
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{token}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DashedToken;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readtoken {
	my $self = shift;
	my $token = shift;
	my $line = $_[0];
	TEST: {
		my $substitute;
		$self->{token} = $token;
		$substitute = $token;
		$substitute=~s/-/ /g;
		$substitute=~s/[ \t]+/\\s\*-?\\s\*/g;
		# print STDERR "Substituting '$substitute'.";
		last TEST unless ($line=~s/^$substitute//s);
		# $self->{token} = $&;
		# print STDERR "Got '$self->{token}'.";
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref $self;
	$type=~s/Token$//;
	return $self->readtoken($type,@_);
}

sub xref {
	my $self = shift;
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{token}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}


# =====================================
package Gdmo;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# =====================================

sub printem {
	my $self = shift;
	my $line = shift;
	my @lines = ( split(/\n/,$line,$::context) );
	my $l; my $i = 0; foreach $l (@lines) {
		if ($i < $::context - 1) {
			print $l;
		}
		$i++;
	}
	return;
}

sub read {
	my $self = shift;
	my $line = $_[0];
	my $s;
	$::error = '';
	$self->{modules} = GdmoModuleList->parse($line);
	if (length($line)) {
		print '<'.$::errob.">:\nSYNTAX ERROR (LINE $::lineno, LENGTH ".length($line).") NEAR(LENGTH ".length($::error)."):\n";
		$self->printem($::error);
		print '<'.$::errob.">:\nSYNTAX ERROR (LINE $::lineno, LENGTH ".length($line).") SUCCESS(LENGTH ".length($::success)."):\n";
		$self->printem($::success);
		print '<'.$::errob.">:\nSYNTAX ERROR LAST 10 SUCCESSFUL OBJECTS:";
		my $i; for ($i=-10;$i<0;$i++) {
			my $s = $::objects[$i];
			if ($s) {
				printf '<'.ref($s).">:\n'";
				$s->gdmo();
				print "'";
			}
		}
		return 0;
	}
	$_[0] = $line;
	return $self;
}

sub xref {
	my $self = shift;
	my $x; if (($x = $self->{modules})) { $x->xref($self); }
}

sub gdmo {
	my $self = shift;
	print '--@@ GDMOCHECK $Revision$';
	print '--@@ Copyright (c), 2001-2007 OpenSS7 Corporation  <http://www.openss7.com/>';
	print '--@@ Copyright (c), 1999-2000 Brian F. G. Bidulock <bidulock@openss7.org>';
	print '--@@ ';
	my $file = $::infile;
	$file = "(standard input)" unless ($file);
	my $date = `date`;
	$date=~s/(?:\s|\n)*$//s;
	print "--@@ Input File: <$file>";
	print "--@@ Special File: <$file\.specials>";
	print "--@@ Date: ".$date;
	print '--@@ ';
	my ($s,$i);
	$::first = 1;
	if (($s = $self->{modules})) { $s->gdmo(); }
	if (!$::first) { printf "\n"; $::first = 1; }
	print '--@@ ';
	print '--@@ end of gdmos';
	print '--@@ ';
	my ($id,$n,$s);
	if (1) {
		$i = 0;
		foreach $id (sort keys %{$::root->{gdmos}}) {
			unless (($s = $::root->{gdmos}->{$id}->{defn})) {
				if (($n = $::root->{gdmos}->{$id}->{refs}) > 0) {
					unless ($i) { print "--@@"; }
					printf "--@@ These modules reference \"$id\" $n times.\n";
					$i++;
				}
			}
		}
		if ($i) { print "--@@"; }
	}
	if ($i) {
		$i = 0;
		foreach $id (sort keys %{$::root->{gdmos}}) {
			if (($s = $::root->{gdmos}->{$id}->{defn})) {
				unless ($i) { print "--@@"; }
				printf "--@@ These modules define \"$id\"\n";
				$i++;
			}
		}
		if ($i) { print "--@@"; }
	}
	if (0) {
		my ($g,$l);
		foreach $g (@{$::root->{modules}}) {
			$i = 0;
			foreach $l (sort keys %{$g->{objects}}) {
				if ($g->{objects}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines MANAGED OBJECT CLASS $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no MANAGED OBJECT CLASS."; }
			$i = 0;
			foreach $l (sort keys %{$g->{objects}}) {
				if (!$g->{objects}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{objects}->{$l}->{docs}}) {
						print "--@@ This module references MANAGED OBJECT CLASS $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no MANAGED OBJECT CLASS."; }
			$i = 0;
			foreach $l (sort keys %{$g->{packages}}) {
				if ($g->{packages}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines PACKAGE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no PACKAGE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{packages}}) {
				if (!$g->{packages}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{packages}->{$l}->{docs}}) {
						print "--@@ This module references PACKAGE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no PACKAGE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{parameters}}) {
				if ($g->{parameters}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines PARAMETER $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no PARAMETER."; }
			$i = 0;
			foreach $l (sort keys %{$g->{parameters}}) {
				if (!$g->{parameters}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{parameters}->{$l}->{docs}}) {
						print "--@@ This module references PARAMETER $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no PARAMETER."; }
			$i = 0;
			foreach $l (sort keys %{$g->{bindings}}) {
				if ($g->{bindings}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines NAME BINDING $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no NAME BINDING."; }
			$i = 0;
			foreach $l (sort keys %{$g->{bindings}}) {
				if (!$g->{bindings}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{bindings}->{$l}->{docs}}) {
						print "--@@ This module references NAME BINDING $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no NAME BINDING."; }
			$i = 0;
			foreach $l (sort keys %{$g->{attributes}}) {
				if ($g->{attributes}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines ATTRIBUTE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no ATTRIBUTE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{attributes}}) {
				if (!$g->{attributes}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{attributes}->{$l}->{docs}}) {
						print "--@@ This module references ATTRIBUTE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no ATTRIBUTE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{groups}}) {
				if ($g->{groups}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines ATTRIBUTE GROUP $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no ATTRIBUTE GROUP."; }
			$i = 0;
			foreach $l (sort keys %{$g->{groups}}) {
				if (!$g->{groups}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{groups}->{$l}->{docs}}) {
						print "--@@ This module references ATTRIBUTE GROUP $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no ATTRIBUTE GROUP."; }
			$i = 0;
			foreach $l (sort keys %{$g->{behaviours}}) {
				if ($g->{behaviours}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines BEHAVIOUR $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no BEHAVIOUR."; }
			$i = 0;
			foreach $l (sort keys %{$g->{behaviours}}) {
				if (!$g->{behaviours}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{behaviours}->{$l}->{docs}}) {
						print "--@@ This module references BEHAVIOUR $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no BEHAVIOUR."; }
			$i = 0;
			foreach $l (sort keys %{$g->{actions}}) {
				if ($g->{actions}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines ACTION $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no ACTION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{actions}}) {
				if (!$g->{actions}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{actions}->{$l}->{docs}}) {
						print "--@@ This module references ACTION $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no ACTION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{notifications}}) {
				if ($g->{notifications}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines NOTIFICATION $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no NOTIFICATION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{notifications}}) {
				if (!$g->{notifications}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{notifications}->{$l}->{docs}}) {
						print "--@@ This module references NOTIFICATION $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no NOTIFICATION."; }
			$i = 0;
			foreach $l (sort keys %{$g->{constraints}}) {
				if ($g->{constraints}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines CONSTRAINT RULE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no CONSTRAINT RULE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{constraints}}) {
				if (!$g->{constraints}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{constraints}->{$l}->{docs}}) {
						print "--@@ This module references CONSTRAINT RULE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no CONSTRAINT RULE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{subordinates}}) {
				if ($g->{subordinates}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					print "--@@ This module defines SUBORDINATION RULE $l.";
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module defines no SUBORDINATION RULE."; }
			$i = 0;
			foreach $l (sort keys %{$g->{subordinates}}) {
				if (!$g->{subordinates}->{$l}->{defn}) {
					unless ($i) { print "--@@"; }
					foreach $id (sort keys %{$g->{subordinates}->{$l}->{docs}}) {
						print "--@@ This module references SUBORDINATION RULE $l in module \"$id\".";
					}
					$i++;
				}
			}
			unless ($i) { print "--@@\n--@@ This module references no SUBORDINATION RULE."; }
		}
	}
	if (1) {
		my ($g,$l);
		$g = $::root;
		if (1) {
			$i = 0;
			foreach $l (sort keys %{$g->{objects}}) {
				if (!$g->{objects}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{objects}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference MANAGED OBJECT CLASS $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no MANAGED OBJECT CLASS."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{objects}}) {
					if ($g->{objects}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define MANAGED OBJECT CLASS $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no MANAGED OBJECT CLASS."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{packages}}) {
				if (!$g->{packages}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{packages}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference PACKAGE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no PACKAGE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{packages}}) {
					if ($g->{packages}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define PACKAGE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no PACKAGE."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{parameters}}) {
				if (!$g->{parameters}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{parameters}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference PARAMETER $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no PARAMETER."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{parameters}}) {
					if ($g->{parameters}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define PARAMETER $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no PARAMETER."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{bindings}}) {
				if (!$g->{bindings}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{bindings}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference NAME BINDING $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no NAME BINDING."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{bindings}}) {
					if ($g->{bindings}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define NAME BINDING $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no NAME BINDING."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{attributes}}) {
				if (!$g->{attributes}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{attributes}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference ATTRIBUTE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no ATTRIBUTE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{attributes}}) {
					if ($g->{attributes}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define ATTRIBUTE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no ATTRIBUTE."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{groups}}) {
				if (!$g->{groups}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{groups}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference ATTRIBUTE GROUP $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no ATTRIBUTE GROUP."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{groups}}) {
					if ($g->{groups}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define ATTRIBUTE GROUP $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no ATTRIBUTE GROUP."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{behaviours}}) {
				if (!$g->{behaviours}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{behaviours}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference BEHAVIOUR $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no BEHAVIOUR."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{behaviours}}) {
					if ($g->{behaviours}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define BEHAVIOUR $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no BEHAVIOUR."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{actions}}) {
				if (!$g->{actions}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{actions}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference ACTION $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no ACTION."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{actions}}) {
					if ($g->{actions}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define ACTION $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no ACTION."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{notifications}}) {
				if (!$g->{notifications}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{notifications}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference NOTIFICATION $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no NOTIFICATION."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{notifications}}) {
					if ($g->{notifications}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define NOTIFICATION $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no NOTIFICATION."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{constraints}}) {
				if (!$g->{constraints}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{constraints}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference CONSTRAINT RULE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no CONSTRAINT RULE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{constraints}}) {
					if ($g->{constraints}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define CONSTRAINT RULE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no CONSTRAINT RULE."; }
			}
			$i = 0;
			foreach $l (sort keys %{$g->{subordinates}}) {
				if (!$g->{subordinates}->{$l}->{defn}) {
					foreach $id (sort keys %{$g->{subordinates}->{$l}->{docs}}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules reference SUBORDINATION RULE $l in module \"$id\".";
						$i++;
					}
				}
			}
			# unless ($i) { print "--@@\n--@@ These modules reference no SUBORDINATION RULE."; }
			if ($i) {
				$i = 0;
				foreach $l (sort keys %{$g->{subordinates}}) {
					if ($g->{subordinates}->{$l}->{defn}) {
						unless ($i) { print "--@@"; }
						print "--@@ These modules define SUBORDINATION RULE $l.";
						$i++;
					}
				}
				unless ($i) { print "--@@\n--@@ These modules define no SUBORDINATION RULE."; }
			}
		}
	}
	print '--@@ ';
	if ($::crossref) {
		print "--@@ ****************************************";
		my $e;
		my $i = 0;
		foreach $e (keys %::refs) {
			$i++;
			unless ($::defs{$e}->{count}) {
				unless (${%{$::spec->{vars}}}{$e}) {
					print "--@@ UNDEFINED REFERENCE: $e";
				}
			}
		}
		print "--@@ THERE ARE $i REFERENCES.";
		$i = 0;
		foreach $e (keys %::defs) {
			$i++;
			if ($::defs{$e}->{count} > 1) {
				print "--@@ DEFINITION $e DEFINED $::defs{$e}->{count} TIMES!";
			}
			unless ($::refs{$e}) {
				print "--@@ UNREFERENCED DEFINITION: $e";
			}
		}
		print "--@@ THERE ARE $i DEFINITIONS.";
	}
	print STDERR ref($::root->{alloc});
#	my ($k); foreach $k (sort keys %{$::root->{alloc}}) {
#		print STDERR "Allocated ".$::root->{alloc}->{$k}->{refs}." $k.";
#	}
	my ($l); foreach $l ('objects', 'packages', 'parameters', 'attributes', 'groups', 'behaviours', 'actions', 'notifications', 'constraints', 'subordinates') {
		my ($k); foreach $k (sort keys %{$::root->{$l}}) {
			if ($::root->{$l}->{$k}->{defn}) {
				if (!$::root->{$l}->{$k}->{refs}) {
					#print STDERR "W: $l $k defined but never referenced!";
				}
			} elsif ($::root->{$l}->{$k}->{refs}) {
				print STDERR "E: $l $k referenced never defined!";
			}
		}
	}
}

# -------------------------------------
package GdmoModuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------
#
# -------------------------------------
package GdmoModule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# A GDMO module consists of zero or more template specifiers.  GDMO Templates are only valid outside
# of ASN.1 modules.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$e);
		$e = 0;
		if (($s = GdmoPreambleDirectives->parse($line))) {
			$self->{preamble} = $s;
			$e++;
		}
		if (($s = Module->parse($line))) {
			$self->{module} = $s;
			$e++;
		}
		if (($s = TemplateList->parse($line))) {
			$self->{templates} = $s;
			$e++;
		}
		if (($s = Asn1ModuleList->parse($line))) {
			$self->{asn1modules} = $s;
			$e++;
		}
		last TEST unless (
			!$self->{module} ||
			($self->{end} = End->parse($line))
		);
		if (($s = GdmoPostambleDirectives->parse($line))) {
			$self->{postamble} = $s;
			$e++;
		}
		last TEST unless ($e != 0);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;

	push @{$::root->{modules}}, $self;

	my $x;
	if (($x = $self->{preamble})) { $x->xref(@_,$self); }
	if (($x = $self->{module})) { $x->xref(@_,$self); }
	if (($x = $self->{templates})) { $x->xref(@_,$self); }
	if (($x = $self->{asn1modules})) { $x->xref(@_,$self); }
	if (($x = $self->{end})) { $x->xref(@_,$self); }
	if (($x = $self->{postamble})) { $x->xref(@_,$self); }
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{preamble})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		if (($s = $self->{module})) { $s->gdmo(); }
		if (($s = $self->{templates})) { $s->gdmo(); }
		if (($s = $self->{asn1modules})) { $s->gdmo(); }
		if (($s = $self->{end})) { $s->gdmo(); }
		if (($s = $self->{postamble})) { $s->gdmo(); }
		if (0) {
			my ($d,$i);
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			foreach $d (sort keys %{$self->{aliases}}) {
				unless ($i) { print "--@@"; }
				print "--@@ This module defines \"$d\".";
				$i++;
			}
			if ($i) { print "--@@"; }
		}
	}
}

# -------------------------------------
package Module;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MODULE//s);
		$self->{comments} = Comments->parse($line);
		$self->{documentstring} = DocumentIdentifier->parse($line);
		$self->{documentoid} = ObjectIdentifierValue->parse($line);
		last TEST unless ($self->{documentstring} || $self->{documentoid});
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{documentstring})) { $x->xref(@_); }
	if (($x = $self->{documentoid})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; };
		printf 'MODULE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{documentstring})) { $s->gdmo(); }
		if (($s = $self->{documentoid})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoPreambleDirectives;
use strict;
use vars qw(@ISA);
@ISA = qw(Directives);
# -------------------------------------

# -------------------------------------
package GdmoPostambleDirectives;
use strict;
use vars qw(@ISA);
@ISA = qw(Directives);
# -------------------------------------

# -------------------------------------
package GdmoPreambleDirectivesChoice;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GDMO\s*\.\s*(\w*)\s*//s);
		$self->{directive} = $1;
		if ($self->{directive}=~/^Version$/) {
		} elsif ($self->{directive}=~/^Copyright$/) {
		} elsif ($self->{directive}=~/^Document$/) {
		} elsif ($self->{directive}=~/^Alias$/) {
		} else {
			last TEST;
		}
		$self->{type} = 'Gdmo'.$self->{directive}.'Directive';
		last TEST unless (($self->{item} = "$self->{type}"->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{item}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'GDMO.'.$self->{directive}; $::first = 0;
		$self->{item}->gdmo();
	}
}

# -------------------------------------
package GdmoPostambleDirectivesChoice;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GDMO\s*\.\s*(\w*)\s*//s);
		$self->{directive} = $1;
		if ($self->{directive}=~/^ChangeLog$/) {
		} elsif ($self->{directive}=~/^EndDocument$/) {
		} else {
			last TEST;
		}
		$self->{type} = 'Gdmo'.$self->{directive}.'Directive';
		last TEST unless (($self->{item} = "$self->{type}"->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{item}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'GDMO.'.$self->{directive}; $::first = 0;
		$self->{item}->gdmo();
	}
}

# -------------------------------------
package Asn1ModuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package Asn1Module;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# ASN.1 modules are distingushed by
#
# ModuleIdentifier ObjectIdentifier DEFINITIONS ::= BEGIN ... END

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{directives} = Asn1Directives->parse($line);
		last TEST unless (($self->{name} = ModuleIdentifier->parse($line)));
		last TEST unless (($self->{oid} = ObjectIdentifierValue->parse($line)));
		last TEST unless (($self->{definitions} = Asn1Definitions->parse($line)));
		$self->{tagdefault} = TagDefault->parse($line);
		$self->{extdefault} = ExtensionDefault->parse($line);
		last TEST unless (($self->{assign} = Assign->parse($line)));
		last TEST unless (($self->{begin} = Begin->parse($line)));
		$self->{body} = ModuleBody->parse($line);
		last TEST unless (($self->{end} = End->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;

	if (($x = $self->{directives})) { $x->xref(@_,$self); }
	$self->{name}->xref(@_,$self);
	$self->{oid}->xref(@_,$self);
	# $self->{definitions}->xref(@_,$self);
	if (($x = $self->{tagdefault})) { $x->xref(@_,$self); }
	if (($x = $self->{extdefault})) { $x->xref(@_,$self); }
	# $self->{assign}->xref(@_,$self);
	# $self->{begin}->xref(@_,$self);
	if (($x = $self->{body})) { $x->xref(@_,$self); }
	# $self->{end}->xref(@_,$self);
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{preamble})) { $s->gdmo(); }
		foreach $s (@{$self->{comments}}) { $s->gdmo(); }
		$self->{name}->gdmo();
		$self->{oid}->gdmo();
		$self->{definitions}->gdmo();
		if (($s = $self->{tagdefault})) { $s->gdmo(); }
		if (($s = $self->{extdefault})) { $s->gdmo(); }
		$self->{assign}->gdmo();
		$self->{begin}->gdmo();
		if (($s = $self->{body})) { $s->gdmo(); }
		$self->{end}->gdmo();
	}
}

# -------------------------------------
package Asn1Definitions;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('DEFINITIONS',@_);
}

# -------------------------------------
package TagDefault;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{tags} = ExplicitTags->parse($line)) ||
			($self->{tags} = ImplicitTags->parse($line)) ||
			($self->{tags} = AutomaticTags->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{tags}->gdmo();
	}
}

# -------------------------------------
package ExplicitTags;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EXPLICIT TAGS',@_);
}

# -------------------------------------
package ImplicitTags;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('IMPLICIT TAGS',@_);
}

# -------------------------------------
package AutomaticTags;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('AUTOMATIC TAGS',@_);
}

# -------------------------------------
package ExtensionDefault;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EXTENSIBILITY IMPLIED',@_);
}

# -------------------------------------
package Assign;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('::=',@_);
}

# -------------------------------------
package Begin;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('BEGIN',@_);
}

# -------------------------------------
package End;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('END',@_);
}

# -------------------------------------
package ModuleBody;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{exports} = Exports->parse($line);
		$self->{imports} = Imports->parse($line);
		$self->{assignmentlist} = AssignmentList->parse($line);
		last TEST unless ($line=~s/^\s*((?:.|\n)*?)\s*(?=END)//s);
		$self->{text} = $1;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{exports})) { $x->xref(@_); }
	if (($x = $self->{imports})) { $x->xref(@_); }
	if (($x = $self->{assignmentlist})) { $x->xref(@_); }
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{exports})) { $s->gdmo(); }
		if (($s = $self->{imports})) { $s->gdmo(); }
		if (($s = $self->{assignmentlist})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{text}"; $::first = 0;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
	}
}

# -------------------------------------
package Exports;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^EXPORTS//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (
			($self->{exports} = ExportsAll->parse($line)) ||
			($self->{exports} = ExportedSymbols->parse($line))
		);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{exports}->xref(@_);
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'EXPORTS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{exports}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExportsAll;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ALL',@_);
}

sub xref {
	my $self = shift;
	# FIXME mark fact that all symbols are (explicitly) exported.
	return;
}

# -------------------------------------
package ExportedSymbols;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readitem('TypeReference',@_);
}

# -------------------------------------
package Imports;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless ($line=~s/^IMPORTS//s);
		$self->{comments1} = Comments->parse($line);
		$self->{imports} = SymbolsFromModuleList->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{imports})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'IMPORTS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (($s = $self->{imports})) { $s->gdmo(); }
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SymbolsFromModuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package SymbolsFromModule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s);
		last TEST unless (($self->{symbols} = ImportedSymbols->parse($line)));
		last TEST unless ($line=~s/^FROM//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (
			($self->{module} = GlobalModuleReference->parse($line)) ||
			($self->{module} = ModuleReference->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	# note the order, imported symbols are called with the associated
	# module on the stack
	$self->{module}->xref(@_);
	$self->{symbols}->xref(@_,$self->{module});
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{symbols}->gdmo();
		if (!$::first) { printf "\n$::indent\t"; } else { printf "\t"; $::first = 0; }
		printf 'FROM'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{module}->gdmo();
	}
}

# -------------------------------------
package ImportedSymbols;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readitem('TypeReference',@_);
}

# -------------------------------------
package GlobalModuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{module} = ModuleReference->parse($line)));
		last TEST unless (($self->{object} = ObjectIdentifierValue->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{module}->xref(@_);
	$self->{object}->xref(@_,$self->{module});
	return;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{module}->gdmo();
		$self->{object}->gdmo();
	}
}

# -------------------------------------
package AssignmentList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package Assignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{assignment} = TypeAssignment->parse($line)) ||
			($self->{assignment} = ValueAssignment->parse($line)) ||
#			($self->{assignment} = XMLValueAssignment->parse($line)) ||
			($self->{assignment} = ValueSetTypeAssignment->parse($line))
#			|| ($self->{assignment} = ObjectClassAssignment->parse($line))
#			|| ($self->{assignment} = ObjectAssignment->parse($line))
#			|| ($self->{assignment} = ObjectSetAssignment->parse($line))
#			|| ($self->{assignment} = ParameterizedAssignment->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{assignment}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{assignment}->gdmo();
	}
}

# -------------------------------------
package TypeAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = TypeReference->parse($line)));
		last TEST unless (($self->{assign} = Assign->parse($line)));
		last TEST unless (($self->{type} = Type->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{reference}->xref(@_);
	# $self->{assign}->xref(@_);
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{reference}->gdmo();
		$self->{assign}->gdmo();
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package ValueAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = ValueReference->parse($line)));
		last TEST unless (($self->{type} = Type->parse($line)));
		last TEST unless (($self->{assign} = Assign->parse($line)));
		last TEST unless (($self->{value} = Value->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{reference}->xref(@_);
	$self->{type}->xref(@_);
	# $self->{assign}->xref();
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{reference}->gdmo();
		$self->{type}->gdmo();
		$self->{assign}->gdmo();
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package Value;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = BuiltinValue->parse($line)) ||
			($self->{value} = ReferencedValue->parse($line)) ||
			($self->{value} = ObjectClassFieldName->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package BuiltinValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = BitStringValue->parse($line)) ||
			($self->{value} = BooleanValue->parse($line)) ||
			($self->{value} = CharacterStringValue->parse($line)) ||
			($self->{value} = ChoiceValue->parse($line)) ||
			($self->{value} = EmbeddedPDVValue->parse($line)) ||
			($self->{value} = EnumeratedValue->parse($line)) ||
			($self->{value} = ExternalValue->parse($line)) ||
#			($self->{value} = InstanceOfValue->parse($line)) ||
			($self->{value} = IntegerValue->parse($line)) ||
			($self->{value} = NullValue->parse($line)) ||
			($self->{value} = ObjectIdentifierValue->parse($line)) ||
			($self->{value} = OctetStringValue->parse($line)) ||
			($self->{value} = RealValue->parse($line)) ||
			($self->{value} = RelativeOIDValue->parse($line)) ||
			($self->{value} = SequenceValue->parse($line)) ||
			($self->{value} = SequenceOfValue->parse($line)) ||
			($self->{value} = SetValue->parse($line)) ||
			($self->{value} = SetOfValue->parse($line)) ||
			($self->{value} = TaggedValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package ReferencedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = DefinedValue->parse($line)) ||
			($self->{value} = ValueFromObject->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package NamedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line)));
		last TEST unless (($self->{value} = Value->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{identifier}->xref(@_);
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package Identifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-)//s);
		$self->{identifier} = $&;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{identifier}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ValueSetTypeAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = TypeReference->parse($line)));
		last TEST unless (($self->{assign} = Assign->parse($line)));
		last TEST unless (($self->{valueset} = ValueSet->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{reference}->xref(@_);
	# $self->{assign}->xref(@_);
	$self->{valueset}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{reference}->gdmo();
		$self->{assign}->gdmo();
		$self->{valueset}->gdmo();
	}
}

# -------------------------------------
package ValueSet;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ElementSetSpecs',@_); }

# -------------------------------------
package Type;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = BuiltinType->parse($line)) ||
			($self->{type} = ReferencedType->parse($line)) ||
			($self->{type} = ConstrainedType->parse($line))

		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package BuiltinType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = BitStringType->parse($line)) ||
			($self->{type} = BooleanType->parse($line)) ||
			($self->{type} = CharacterStringType->parse($line)) ||
			($self->{type} = ChoiceType->parse($line)) ||
			($self->{type} = EmbeddedPDVType->parse($line)) ||
			($self->{type} = EnumeratedType->parse($line)) ||
			($self->{type} = ExternalType->parse($line)) ||
#			($self->{type} = InstanceOfType->parse($line)) ||
			($self->{type} = IntegerType->parse($line)) ||
			($self->{type} = NullType->parse($line)) ||
#			($self->{type} = ObjectClassFieldType->parse($line)) ||
			($self->{type} = ObjectIdentifierType->parse($line)) ||
			($self->{type} = OctetStringType->parse($line)) ||
			($self->{type} = RealType->parse($line)) ||
			($self->{type} = RelativeOIDType->parse($line)) ||
			($self->{type} = SequenceType->parse($line)) ||
			($self->{type} = SequenceOfType->parse($line)) ||
			($self->{type} = SetType->parse($line)) ||
			($self->{type} = SetOfType->parse($line)) ||
			($self->{type} = TaggedType->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package BooleanType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('BOOLEAN',@_);
}

# -------------------------------------
package BooleanValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($line=~s/^(TRUE|FALSE)//s));
		$self->{value} = $1;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{value}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package IntegerType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^INTEGER//s);
		$self->{comments} = Comments->parse($line);
		$self->{list} = NamedNumberListBraced->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x; if (($x = $self->{list})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s);
		if (!$::first) { printf ' '; }
		printf 'INTEGER'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{list})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamedNumberListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package NamedNumberList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package NamedNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line)));
		last TEST unless ($line=~s/^\(//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (
			($self->{number} = SignedNumber->($line)) ||
			($self->{number} = DefinedValue->($line))
		);
		last TEST unless ($line=~s/^\)//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{identifier}->xref(@_);
	$self->{number}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{identifier}->gdmo();
		printf '('; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{number}->gdmo();
		printf ')'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SignedNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(0|-?[1-9][0-9]*)//s);
		$self->{number} = $1;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{number}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gmdo(); }
	}
}

# -------------------------------------
package Number;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(0|[1-9][0-9]*)//s);
		$self->{number} = $1;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{number}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package IntegerValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (
			($s = SignedNumber->parse($line)) ||
			($s = Identifier->parse($line))
			# FIXME: the identifier here must ne one of the identifiers in the
			# IntegerType with which the value is associated, and shall represent the
			# corresponding number.  See X.608 Clause 18.10.
		);
		$self->{value} = $s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package EnumeratedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ENUMERATED//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless ($line=~s/^{//s);
		$self->{comments2} = Comments->parse($line);
		last TEST unless (($self->{enumerations} = Enumerations->parse($line)));
		last TEST unless ($line=~s/^}//s);
		$self->{comments3} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{enumerations}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'ENUMERATE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		printf '{'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments2})) { $s->gdmo(); }
			$self->{enumerations}->gdmo();
			$::indent=~s/^.//s;
		}
		printf '}'; $::first = 0;
		if (($s = $self->{comments3})) { $s->gdmo(); }

	}
}

# -------------------------------------
package Enumerations;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{root} = RootEnumeration->parse($line)));
		if ($line=~s/^\,//s) {
			$self->{comments1} = Comments->parse($line);
			last TEST unless ($line=~s/^\.\.\.//s);
			$self->{comments2} = Comments->parse($line);
			last TEST unless (($self->{exceptionspec} = ExceptionSpec->parse($line)));
			if ($line=~s/^\,//s) {
				$self->{comments3} = Comments->parse($line);
				last TEST unless (($self->{additional} = AdditionalEnumeration->parse($line)));
			}
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	$self->{root}->xref(@_);
	if (($x = $self->{exceptionspec})) {
		$x->xref(@_);
		if (($x = $self->{additional})) {
			$x->xref(@_);
		}
	}
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{root}->gdmo();
		if (($s = $self->{exceptionspec})) {
			printf ','; $::first = 0;
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			printf '...'; $::first = 0;
			if (($s = $self->{comments2})) { $s->gdmo(); }
			$s->gdmo();
			if (($s = $self->{additional})) {
				printf ','; $::first = 0;
				if (($s = $self->{comments3})) { $s->gdmo(); }
				if (!$::first) { printf "\n$::indent"; $::first = 1; }
				$s->gdmo();

			}
		}
	}
}

# -------------------------------------
package RootEnumeration;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{enumeration} = Enumeration->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{enumeration}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{enumeration}->gdmo();
	}
}

# -------------------------------------
package AdditionalEnumeration;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{enumeration} = Enumeration->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{enumeration}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{enumeration}->gdmo();
	}
}

# -------------------------------------
package Enumeration;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package EnumerationItem;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{item} = Identifier->parse($line)) ||
			($self->{item} = NamedNumber->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{item}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{item}->gdmo();
	}
}

# -------------------------------------
package EnumeratedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = Identifier->parse($line)));
		# FIXME: identifier must be in enumerated type
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package RealType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('REAL',@_);
}

# -------------------------------------
package RealValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = NumericRealValue->parse($line)) ||
			($self->{value} = SpecialRealValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package NumericRealValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = SignedRealNumber->parse($line)) ||
			($self->{value} = SequenceValue->parse($line))
			# FIXME; where the sequence must contain mantisa base and exponent
			# named numbers (exponent may only be 2 or 10).
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package SignedRealNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^-?(?:0|[1-9][0-9]*)(?:\.[0-9][0-9]*)?//s);
		$self->{number} = $&;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{number}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}


# -------------------------------------
package SpecialRealValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(?:PLUS|MINUS)-INFINITY//s);
		$self->{value} = $&;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "$self->{value}"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BitStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^BIT\s*STRING//s);
		$self->{comments} = Comments->parse($line);
		$self->{list} = NamedBitListBraced->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{list}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'BIT STRING';
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{list})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamedBitListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package NamedBitList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package NamedBit;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line)));
		last TEST unless ($line=~s/^\(//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (
			($self->{number} = Number->($line)) ||
			($self->{number} = DefinedValue->($line))
		);
		last TEST unless ($line=~s/^\)//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{identifier}->xref(@_);
	$self->{number}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{identifier}->gdmo();
		printf '('; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{number}->gdmo();
		printf ')'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BitStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = Bstring->parse($line)) ||
			($self->{value} = Hstring->parse($line)) ||
			($self->{value} = BitStringValueList->parse($line)) ||
			($self->{value} = ContainingValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package Bstring;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^'([01]*)'[Bb]//s);
		$self->{value} = $1;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "'$self->{value}'B"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Hstring;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^'([0-9A-Fa-f]*)'[Hh]//s);
		$self->{value} = $1;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf "'$self->{value}'H"; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BitStringValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('IdentifierList',@_); }

# -------------------------------------
package IdentifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ContainingValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CONTAINING//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{value} = Value->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'CONTAINING'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package OctetStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('OCTET STRING',@_);
}

# -------------------------------------
package OctetStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = Bstring->parse($line)) ||
			($self->{value} = Hstring->parse($line)) ||
			($self->{value} = ContainingValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package NullType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('NULL',@_);
}

# -------------------------------------
package NullValue;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('NULL',@_);
}

# -------------------------------------
package SequenceType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SEQUENCE(?!\s*OF)//s);
		$self->{comments} = Comments->parse($line);
		$self->{list} = ExtensionOrComponentTypeListBraced->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x; if (($x = $self->{list})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'SEQUENCE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{list})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExtensionOrComponentTypeListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

# -------------------------------------
package ExtensionOrComponentTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{exception} = ExtensionAndExceptionList->parse($line)) ||
			($self->{component} = ComponentTypeLists->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{exception})) { $x->xref(@_); }
	if (($x = $self->{component})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{exception})) { $s->gdmo(); }
		if (($s = $self->{component})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExtensionAndExceptionList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{exception} = ExtensionAndException->parse($line))) {
			$self->{extension} = ExtensionMarker->parse($line);
		} else { last TEST; }
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	$self->{exception}->xref(@_);
	if (($x = $self->{extension})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{exception}->gdmo();
		if (($s = $self->{extension})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExtensionAndException;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\.\.\.//s);
		$self->{comments} = Comments->parse($line);
		$self->{exception} = ExceptionSpec->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{exception})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '...'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{exception})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExtensionMarker;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^,//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless ($line=~s/^\.\.\.//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf ','; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf '...'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ComponentTypeLists;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{root} = RootComponentTypeList->parse($line))) {
			goto DONE unless ($line=~s/^\,//s);
			$self->{comments1} = Comments->parse($line);
		}
		last TEST unless (($self->{exception} = ExtensionAndException->parse($line)));
		last TEST unless (($self->{addition} = ExtensionAdditions->parse($line)));
		if (($self->{endmarker} = ExtensionMarker->parse($line))) {
			last TEST unless ($line=~s/^,//s);
			$self->{comments2} = Comments->parse($line);
			last TEST unless (($self->{list} = RootComponentTypeList->parse($line)));
		} else {
			$self->{extension} = ExtensionMarker->parse($line);
		}
	DONE:
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	$self->{root}->xref(@_);
	if (($x = $self->{exception})) { $x->xref(@_); }
	if (($x = $self->{addition})) { $x->xref(@_); }
	# if (($x = $self->{endmarker})) { $x->xref(@_); }
	if (($x = $self->{list})) { $x->xref(@_); }
	if (($x = $self->{extension})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{root}->gdmo();
		if (($s = $self->{exception})) {
			printf ','; $::first = 0;
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{exception}->gdmo();
			if (($s = $self->{addition})) { $s->gdmo(); }
			if (($s = $self->{endmarker})) {
				$s->gdmo();
				printf ','; $::first = 0;
				if (($s = $self->{comments2})) { $s->gdmo(); }
				$self->{list}->gdmo();
			} else {
				if (($s = $self->{extension})) { $s->gdmo(); }
			}
		}
	}
}

# -------------------------------------
package RootComponentTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{list} = ComponentTypeList->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{list}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{list}->gdmo();
	}
}

# -------------------------------------
package ExtensionAdditions;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^,//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{list} = ExtensionAdditionList->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{list}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		printf ','; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{list}->gdmo();
	}
}

# -------------------------------------
package ExtensionAdditionList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ExtensionAddition;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{addition} = ComponentType->parse($line)) ||
			($self->{addition} = ExtensionAdditionGroup->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{addition}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{addition}->gdmo();
	}
}

# -------------------------------------
package ExtensionAddtionGroup;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\[\[//s);
		$self->{comments1} = Comments->parse($line);
		$self->{version} = VersionNumber->parse($line);
		last TEST unless (($self->{list} = ComponentTypeList->parse($line)));
		last TEST unless ($line=~s/^\]\]//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{version})) { $x->xref(@_); }
	$self->{list}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '[['; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (($s = $self->{version})) { $s->gdmo(); }
		$self->{list}->gdmo();
		if (!$::first) { printf ' '; }
		printf ']]'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package VersionNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{number} = Number->parse($line)));
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{number}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{number}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ComponentTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ComponentType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{namedtype} = NamedType->parse($line))) {
			if ($line=~s/^OPTIONAL//s) {
				$self->{optional} = 'OPTIONAL';
				$self->{comments} = Comments->parse($line);
			} elsif ($line=~s/^DEFAULT//s) {
				$self->{default} = 'DEFAULT';
				$self->{comments} = Comments->parse($line);
				last TEST unless (($self->{value} = Value->parse($line)));
			}
		} elsif ($line=~s/^COMPONENTS\s*OF//s) {
			$self->{comments} = Comments->parse($line);
			last TEST unless (($self->{type} = Type->parse($line)));
		} else {
			last TEST;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{namedtype})) { $x->xref(@_); }
	if (($x = $self->{value})) { $x->xref(@_); }
	if (($x = $self->{type})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{namedtype})) {
			$s->gdmo();
			if ($self->{optional}) {
				if (!$::first) { printf ' '; }
				printf 'OPTIONAL'; $::first = 0;
			}
			if ($self->{default}) {
				if (!$::first) { printf ' '; }
				printf 'DEFAULT'; $::first = 0;
				$self->{value}->gdmo();
			}

		} else {
			if (!$::first) { printf ' '; }
			printf 'COMPONENTS OF'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{type}->gdmo();
		}
	}
}

# -------------------------------------
package SequenceValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ComponentValueList',@_); }

# -------------------------------------
package ComponentValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readitem('NamedValue',@_);
}

# -------------------------------------
package SequenceOfType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SEQUENCE\s*OF//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (
			($self->{type} = Type->parse($line)) ||
			($self->{type} = NamedType->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'SEQUENCE OF'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package SequenceOfValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ValueListOrNameValueList',@_); }

# -------------------------------------
package ValueListOrNameValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{list} = ValueList->parse($line)) ||
			($self->{list} = NamedValueList->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{list}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{list}->gdmo();
	}
}

# -------------------------------------
package ValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package NamedValueList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package SetType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET(?!\s*OF)//s);
		$self->{comments} = Comments->pcase($line);
		$self->{list} = ExtensionOrComponentTypeListBraced->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x; if (($x = $self->{list})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'SET'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{list})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SetValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('ComponentValueList',@_);
}

# -------------------------------------
package SetOfType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET\s*OF//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (
			($self->{type} = Type->parse($line)) ||
			($self->{type} = NamedType->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'SET OF'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package SetOfValue;
use strict;
use vars qw(@ISA);
@ISA = qw(OptionalBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('ValueListOrNamedValueList',@_);
}

# -------------------------------------
package ChoiceType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHOICE//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{alternatives} = AlternativeTypeListsBraced->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{alternatives}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'CHOICE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{alternatives}->gdmo();
	}
}

# -------------------------------------
package AlternativeTypeListsBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package AlternativeTypeLists;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{root} = RootAlternativeTypeList->parse($line)));
		if ($line=~s/^,//s) {
			$self->{comments} = Comments->parse($line);
			last TEST unless (($self->{exception} = ExtensionAndException->parse($line)));
			$self->{addition} = ExtensionAdditionAlternatives->parse($line);
			$self->{marker} = ExtensionMarker->parse($line);
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	$self->{exception}->xref(@_);
	if (($x = $self->{addition})) { $x->xref(@_); }
	if (($x = $self->{marker})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{root}->gdmo();
		if (($s = $self->{exception})) {
			printf ','; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{exception}->gdmo();
			if (($s = $self->{addition})) { $s->gdmo(); }
			if (($s = $self->{marker})) { $s->gdmo(); }
		}
	}
}

# -------------------------------------
package RootAlternativeTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{list} = AlternativeTypeList->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{list}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{list}->gdmo();
	}
}

# -------------------------------------
package ExtensionAdditionAlternatives;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^,//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{list} = ExtensionAdditionAlternativesList->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{list}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf ','; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{list}->gdmo();
	}
}


# -------------------------------------
package ExtensionAdditionAlternativesList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('ExtensionAdditionAlternative',@_); }

# -------------------------------------
package ExtensionAdditionAlternative;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{alternative} = ExtensionAdditionAlternativesGroup->parse($line)) ||
			($self->{alternative} = NamedType->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{alternative}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{alternative}->gdmo();
	}
}

# -------------------------------------
package ExtensionAdditionAlternativesGroup;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\[\[//s);
		$self->{comments1} = Comments->parse($line);
		$self->{version} = VersionNumber->parse($line);
		last TEST unless (($self->{list} = AlternativeTypeList->parse($line)));
		last TEST unless ($line=~s/^\]\]//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x; if (($x = $self->{version})) { $x->xref(@_); }
	$self->{list}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '[['; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (($s = $self->{version})) { $s->gdmo(); }
		$self->{list}->gdmo();
		if (!$::first) { printf ' '; }
		printf ']]'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AlternativeTypeList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('NamedType',@_); }

# -------------------------------------
package ChoiceValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line)));
		last TEST unless ($line=~s/^://s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{value} = Value->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{identifier}->xref(@_);
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
		print ':'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package SelectionType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line)));
		last TEST unless ($line=~s/^\<//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{type} = Type->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{identifier}->xref(@_);
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
		printf '<'; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package TaggedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{tag} = Tag->parse($line)));
		if ($line=~s/^IMPLICIT//s) {
			$self->{implicit} = 'IMPLICIT';
			$self->{comments} = Comments->parse($line);
		} elsif ($line=~s/^EXPLICIT//s) {
			$self->{explicit} = 'EXPLICIT';
			$self->{comments} = Comments->parse($line);
		}
		last TEST unless (($self->{type} = Type->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{tag}->xref(@_);
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{tag}->gdmo();
		if (($s = $self->{implicit})) {
			if (!$::first) { printf ' '; }
			printf 'IMPLICIT'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
		}
		if (($s = $self->{explicit})) {
			if (!$::first) { printf ' '; }
			printf 'EXPLICIT'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
		}
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package Tag;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\[//);
		$self->{comments1} = Comments->parse($line);
		$self->{class} = Class->parse($line);
		last TEST unless (($self->{number} = ClassNumber->parse($line)));
		last TEST unless ($line=~s/^\]//);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x; if (($x = $self->{class})) { $x->xref(@_); }
	$self->{number}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf '['; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1;
		if (($s = $self->{class})) {
			$s->gdmo();
			$self->{number}->gdmo();
		} else {
			$::first = 1;
			$self->{number}->gdmo();
		}
		printf ']'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Class;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{class} = ClassUniversal->parse($line)) ||
			($self->{class} = ClassApplication->parse($line)) ||
			($self->{class} = ClassPrivate->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{class}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{class}->gdmo();
	}
}

# -------------------------------------
package ClassUniversal;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('UNIVERSAL',@_);
}

# -------------------------------------
package ClassApplication;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('APPLICATION',@_);
}

# -------------------------------------
package ClassPrivate;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('PRIVATE',@_);
}

# -------------------------------------
package ClassNumber;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = Number->parse($line)) ||
			($self->{value} = DefinedValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package ObjectIdentifierType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('OBJECT IDENTIFIER',@_);
}

# -------------------------------------
package ObjectIdentifierValue;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('ObjIdComponentsList',@_);
}

# -------------------------------------
package ObjIdComponentsList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package ObjIdComponents;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{component} = NameAndNumberForm->parse($line)) ||
			($self->{component} = NumberForm->parse($line)) ||
			($self->{component} = NameForm->parse($line)) ||
			($self->{component} = DefinedValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{component}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{component}->gdmo();
	}
}

# -------------------------------------
package NameForm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{identifier}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
	}
}

# -------------------------------------
package NumberForm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{number} = Number->parse($line)) ||
			($self->{number} = DefinedValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{number}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{number}->gdmo();
	}
}

# -------------------------------------
package NameAndNumberForm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line)));
		last TEST unless ($line=~s/^\(//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{number}  = NumberForm->parse($line)));
		last TEST unless ($line=~s/^\)//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{identifier}->xref(@_);
	$self->{number}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{identifier}->gdmo();
		printf '('; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1;
		$self->{number}->gdmo();
		printf ')'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RelativeOIDType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('RELATIVE-OID',@_);
}

# -------------------------------------
package RelativeOIDValue;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readinterior('RelativeOIDComponentsList');
}

# -------------------------------------
package RelativeOIDComponentsList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package RelativeOIDComponents;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{component} = NameAndNumberForm->parse($line)) ||
			($self->{component} = NumberForm->parse($line)) ||
			($self->{component} = DefinedValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{component}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{component}->gdmo();
	}
}

# -------------------------------------
package EmbeddedPDVType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EMBEDDED PDV',@_);
}

# -------------------------------------
package EmbeddedPDVValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = SequenceValue->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package ExternalType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EXTERNAL',@_);
}

# -------------------------------------
package ExternalValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = SequenceValue->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package CharacterStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = RestrictedCharacterStringType->parse($line)) ||
			($self->{type} = UnrestrictedCharacterStringType->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package CharacterStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = RestrictedCharacterStringValue->parse($line)) ||
			($self->{value} = UnrestrictedCharacterStringValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package RestrictedCharacterStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = BMPStringToken->parse($line)) ||
			($self->{type} = GeneralStringToken->parse($line)) ||
			($self->{type} = GraphicStringToken->parse($line)) ||
			($self->{type} = IA5StringToken->parse($line)) ||
			($self->{type} = ISO646StringToken->parse($line)) ||
			($self->{type} = NumericStringToken->parse($line)) ||
			($self->{type} = PrintableStringToken->parse($line)) ||
			($self->{type} = TeletexStringToken->parse($line)) ||
			($self->{type} = T61StringToken->parse($line)) ||
			($self->{type} = UniversalStringToken->parse($line)) ||
			($self->{type} = UTF8StringToken->parse($line)) ||
			($self->{type} = VideotexStringToken->parse($line)) ||
			($self->{type} = VisibleStringToken->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package BMPStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package GeneralStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package GraphicStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package IA5StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package ISO646StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package NumericStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package PrintableStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package TeletexStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package T61StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package UniversalStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package UTF8StringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package VideotexStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package VisibleStringToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package RestrictedCharacterStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = CString->parse($line)) ||
			($self->{value} = CharacterStringList->parse($line)) ||
			($self->{value} = Quadruple->parse($line)) ||
			($self->{value} = Tuple->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package CharacterStringList;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('CharSyms',@_); }

# -------------------------------------
package CharSyms;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('CharsDefn',@_); }

# -------------------------------------
package CharsDefn;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = CString->parse($line)) ||
			($self->{value} = CharacterStringList->parse($line)) ||
			($self->{value} = Quadruple->parse($line)) ||
			($self->{value} = Tuple->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package Quadruple;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('QuadrupleList',@_); }

# -------------------------------------
package QuadrupleList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{group} = Number->parse($line)));
		last TEST unless ($line=~s/^,//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{plane} = Number->parse($line)));
		last TEST unless ($line=~s/^,//s);
		$self->{comments2} = Comments->parse($line);
		last TEST unless (($self->{row} = Number->parse($line)));
		last TEST unless ($line=~s/^,//s);
		$self->{comments3} = Comments->parse($line);
		last TEST unless (($self->{cell} = Number->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{group}->xref(@_);
	$self->{plane}->xref(@_);
	$self->{row}->xref(@_);
	$self->{cell}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{group}->gdmo();
		printf ','; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{plane}->gdmo();
		printf ','; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{row}->gdmo();
		printf ','; $::first = 0;
		if (($s = $self->{comments3})) { $s->gdmo(); }
		$self->{cell}->gdmo();
	}
}

# -------------------------------------
package Tuple;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

sub read { my $self = shift; return $self->readinterior('TupleList',@_); }

# -------------------------------------
package TupleList;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{column} = Number->parse($line)));
		last TEST unless ($line=~s/^,//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{row} = Number->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{column}->xref(@_);
	$self->{row}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{column}->gdmo();
		printf ','; $::first = 0;
		my $s; if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{row}->gdmo();
	}
}

# -------------------------------------
package CString;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $string;
		last TEST unless ($line=~s/^\"((?:[^"]|\"\s*\")*)\"//s);
		$string = $1;
		$string=~s/\"\s+\"//gs;
		$string=~s/\"\"/\"/gs;
		$self->{string} = $string;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($string,$s);
		$string = $self->{string};
		$string=~s/\"/\"\"/g;
		if (!$::first) { printf ' '; }
		printf "\"$string\""; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UnrestrictedCharacterStringType;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

sub read { my $self = shift; return $self->readtoken('CHARACTER STRING',@_); }

# -------------------------------------
package UnrestrictedCharacterStringValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{value} = SequenceValue->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package UsefulType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = GeneralizedTimeToken->parse($line)) ||
			($self->{type} = UTCTimeToken->parse($line)) ||
			($self->{type} = ObjectDescriptorToken->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package GeneralizedTimeToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package UTCTimeToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package ObjectDescriptorToken;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleToken);
# -------------------------------------

# -------------------------------------
package ReferencedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (
			($s = DefinedType->parse($line)) ||
			($s = UsefulType->parse($line)) ||
			($s = SelectionType->parse($line)) ||
			($s = TypeFromObject->parse($line)) ||
			($s = ValueSetFromObjects->parse($line))
		);
		$self->{type} = $s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package NamedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{identifier} = Identifier->parse($line)));
		last TEST unless (($self->{type} = Type->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{identifier}->xref(@_);
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{identifier}->gdmo();
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package ObjectClassAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package ObjectAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package ObjectSetAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package ParameterizedAssignment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package DefinedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = ExternalTypeReference->parse($line)) ||
			($self->{type} = TypeReference->parse($line)) ||
			($self->{type} = ParameterizedType->parse($line)) ||
			($self->{type} = ParameterizedValueSetType->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{type}->gdmo();
	}
}

# -------------------------------------
package DefinedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = ExternalValueReference->parse($line)) ||
			($self->{value} = ValueReference->parse($line)) ||
			($self->{value} = ParameterizedValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package ParameterizedType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package ParameterizedValueSetType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package ParameterizedValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package AAA;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
}

sub gdmo {
	my $self = shift;
	PRINT: {
	}
}

# -------------------------------------
package GdmoAliasDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless (($self->{documentId} = DocumentSpecifier->parse($line)));
		last TEST unless (($s = DocumentIdentifier->parse($line)));
		push @{$self->{documentAliases}}, $s;
		while ($line=~s/^,(?:\s|\n)*//s) {
			last TEST unless (($s = DocumentIdentifier->parse($line)));
			push @{$self->{documentAliases}}, $s;
		}
		$_[0] = $line; return $self;
	}
	$self->{errors} = "must consist of GDMO.Alias <directive>";
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{documentId}->xref(@_);
	my $x; foreach $x (@{$self->{documentAliases}}) {
		$x->xref(@_);
	}
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; } else { printf '-- '; $::first = 0; }
		$self->{documentId}->gdmo();
		my $i = 0;
		foreach $s (@{$self->{documentAliases}}) {
			if ($i) { printf ",\n-- "; $::first = 0; }
			$s->gdmo();
			$i++;
		}
	}
}

# -------------------------------------
package DocumentSpecifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{specifier} = DocumentReference->parse($line)) ||
			($self->{specifier} = ObjectIdentifierValue->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{specifier}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{specifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoDocumentDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{documentstring} = DocumentIdentifier->parse($line);
		$self->{documentoid} = ObjectIdentifierValue->parse($line);
		last TEST unless ($self->{documentstring} || $self->{documentoid});
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{documentstring})) { $x->xref(@_); }
	if (($x = $self->{documentoid})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; } else { printf '-- '; $::first = 0; }
		if (($s = $self->{documentstring})) { $s->gdmo(); }
		if (($s = $self->{documentoid})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoEndDocumentDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{documentstring} = DocumentReference->parse($line);
		$self->{documentoid} = ObjectIdentifierValue->parse($line);
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{documentstring})) { $x->xref(@_); }
	if (($x = $self->{documentoid})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; } else { printf '-- '; $::first = 0; }
		if (($s = $self->{documentstring})) { $s->gdmo(); }
		if (($s = $self->{documentoid})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoVersionDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{version} = Version->parse($line);
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x; if (($x = $self->{version})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; } else { printf '-- '; $::first = 0; }
		if (($s = $self->{version})) { $s->gdmo(); }
	}
}

# -------------------------------------
package GdmoCopyrightDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{copyright} = $line;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$l);
		if (!$::first) { printf ' '; } else { printf '-- '; $::first = 0; }
		foreach $l (split(/\n/,$self->{copyright})) {
			printf "\n--  ".$l; $::first = 0;
		}
		printf "\n-- "; $::first = 0;
	}
}

# -------------------------------------
package GdmoChangeLogDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{changelog} = $line;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$l);
		if (!$::first) { printf ' '; } else { printf '-- '; $::first = 0; }
		foreach $l (split(/\n/,$self->{changelog})) {
			printf "\n--  ".$l; $::first = 0;
		}
		printf "\n-- "; $::first = 0;
	}
}

# -------------------------------------
package GdmoIncludeDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^\s*"([^"]*)"\s*//s);
		$self->{filename} = $1;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$l);
		if (!$::first) { printf ' '; } else { printf '-- '; $::first = 0; }
		foreach $l (split(/\n/,$self->{changelog})) {
			printf "\n--  ".$l; $::first = 0;
		}
		printf "\n-- "; $::first = 0;
	}
}


# -------------------------------------
package Asn1VersionDirective;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{version} = Version->parse($line)));
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{version}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{version}->gdmo();
	}
}

# -------------------------------------
package Version;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[0-9]+(?:\.[0-9]+)*//s);
		$self->{version} = $&;
		$line=~s/^(?:\s|\n)*//s;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{version}"; $::first = 0;
	}
}

# -------------------------------------
package Directives;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub readdirective {
	my $self = shift;
	my $type = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$directive,$e);
		do {
			if ($line=~s/^(?:\s|\n)*--<((?:.|\n)*?)>--(?:\s|\n)*//s) {
				$directive = $1;
				# strip all the continuation markers
				$directive=~s/\n[ \t]*(?:--[ \t]*)?/\n/sg;
				# strip leading and trailing whitespace
				$directive=~s/^(?:\s|\n)*//s;
				$directive=~s/(?:\s|\n)*$//s;
				if (($s = $type->parse($directive))) {
					push @{$self->{directives}}, $s;
				}
				$e++;
			} elsif (($s = Comments->parse($line))) {
				push @{$self->{comments}}, $s;
				$e++;
			}
		} while ($s);
		last TEST unless ($e);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub read {
	my $self = shift;
	my $type = ref($self).'Choice';
	return $self->readdirective($type,@_);
}

sub xref {
	my $self = shift;
	my $x;
	foreach $x (@{$self->{directives}}) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		foreach $s (@{$self->{directives}}) {
			if (!$::first) { printf "\n$::indent"; $::first = 1; }
			printf '--<'; $::first = 0;
			$s->gdmo();
			if (!$::first) { printf ' '; } else { printf '-- '; $::first = 0; }
			printf '>--'; $::first = 0;
		}
		foreach $s (@{$self->{comments}}) { $s->gdmo(); }
	}
}

# -------------------------------------
package Asn1Directives;
use strict;
use vars qw(@ISA);
@ISA = qw(Directives);
# -------------------------------------

# -------------------------------------
package Asn1DirectivesChoice;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ASN1\s*\.\s*(\w*)\s*//s);
		$self->{directive} = $1;
		if ($self->{directive}=~/^Version$/) {
		} elsif ($self->{directive}=~/^FileNameExtension$/) {
		} elsif ($self->{directive}=~/^FileNamePrefixe$/) {
		} elsif ($self->{directive}=~/^FileNameSuffix$/) {
		} elsif ($self->{directive}=~/^Nickname$/) {
		} elsif ($self->{directive}=~/^Remove$/) {
		} elsif ($self->{directive}=~/^WorkingSet1$/) {
		} else {
			last TEST;
		}
		$self->{type} = 'Asn1'.$self->{directive}.'Directive';
		last TEST unless (($self->{item} = "$self->{type}"->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{item}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		printf 'ASN1.'.$self->{directive}; $::first = 0;
		$self->{item}->gdmo();
	}
}


# ----------------------------------------
package Comments;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	my $test = $_[2];
	TEST: {
		my $s;
		if (($s = Comment->parse($line,$test))) {
			push @{$self->{comments}}, $s;
			while (($s = Comment->parse($line,$test))) {
				push @{$self->{comments}}, $s;
			}
			$line=~s/^(\s|\n)*//s;
			$_[0] = $line; return $self;
		} else {
			$line=~s/^(\s|\n)*//s;
			$_[0] = $line;
		}
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		foreach $s (@{$self->{comments}}) {
			$s->gdmo();
		}
	}
}

# ----------------------------------------
package Comment;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------
# Comments can either be -- folowed by an end of line or a -- followed by a ---.  There is a special
# construct in the Ammendment 3 for X.722 which provides for the following:


sub read {
	my $self = shift;
	my $line = $_[0];
	my $test = $_[2];
	TEST: {
		if (defined $_[2] && $test) {
			last TEST unless ($line=~s/^((?:\s|\n)*)--([^\n]*)(\n|--)(?:\s|\n)*//s);
			$self->{beginning} = $1;
			$self->{comment} = $2;
			$self->{ending} = $3;
		} else {
			last TEST unless ($line=~s/^((?:\s|\n)*)--(?!<)([^\n]*)(\n|--)(?:\s|\n)*//s);
			$self->{beginning} = $1;
			$self->{comment} = $2;
			$self->{ending} = $3;
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		# do not print our own compiler generated comments
		unless ($self->{comment}=~/^@@/s) {
			if ($self->{beginning}=~/\n/) {
				if (!$::first) {
					printf "\n$::indent--"; $::first = 0;
				} else {
					printf '--'; $::first = 0;
				}
			} else {
				printf '--'; $::first = 0;
			}
			printf "$self->{comment}"; $::first = 0;
			if ($self->{ending}=~/^--/) {
				printf '--'; $::first = 0;
			} else {
				printf "\n$::indent"; $::first = 1;
			}
		}
	}
}

# ----------------------------------------
package TemplateList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# ----------------------------------------

# ----------------------------------------
package Template;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$::noref++;
		last TEST unless (
			($self->{template} = ClassTemplate->parse($line)) ||
			($self->{template} = PackageTemplate->parse($line)) ||
			($self->{template} = ParameterTemplate->parse($line)) ||
			($self->{template} = NameBindingTemplate->parse($line)) ||
			($self->{template} = AttributeTemplate->parse($line)) ||
			($self->{template} = AttributeGroupTemplate->parse($line)) ||
			($self->{template} = BehaviourTemplate->parse($line)) ||
			($self->{template} = ActionTemplate->parse($line)) ||
			($self->{template} = NotificationTemplate->parse($line)) ||
			($self->{template} = SubordinationRuleTemplate->parse($line)) ||
			($self->{template} = ConstraintRuleTemplate->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{template}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "\n$::indent";
		if (($s = $self->{template})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "\n$::indent";
	}
}

# ----------------------------------------
package ClassTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*MANAGED(?:\s|\n)*((-)?)(?:\s|\n)*OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		$self->{derivedfrom} = DerivedFromClasses->parse($line);
		$self->{characterization} = Characterization->parse($line);
		$self->{conditionalpackages} = ConditionalPackages->parse($line);
		$self->{registration} = RegisteredAs->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{objects}->{$self->{label}}->{defn} = $self;
	$::root->{objects}->{$self->{label}}->{defn} = $self;
	$::root->{objects}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	if (($x = $self->{derivedfrom})) { $x->xref(@_); }
	if (($x = $self->{characterization})) { $x->xref(@_); }
	if (($x = $self->{conditionalpackages})) { $x->xref(@_); }
	if (($x = $self->{registration})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} MANAGED OBJECT CLASS"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1}          )) { $s->gdmo(); }
			if (($s = $self->{derivedfrom}        )) { $s->gdmo(); }
			if (($s = $self->{characterization}   )) { $s->gdmo(); }
			if (($s = $self->{conditionalpackages})) { $s->gdmo(); }
			$::indent=~s/^.//s;
			if (($s = $self->{registration}       )) { $s->gdmo(); }
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package PackageTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*PACKAGE//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		$self->{behaviour} = Behaviour->parse($line);
		$self->{attributes} = Attributes->parse($line);
		$self->{attributegroups} = AttributeGroups->parse($line);
		$self->{actions} = Actions->parse($line);
		$self->{notifications} = Notifications->parse($line);
		$self->{registration} = RegisteredAs->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{packages}->{$self->{label}}->{defn} = $self;
	$::root->{packages}->{$self->{label}}->{defn} = $self;
	$::root->{packages}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	if (($x = $self->{behaviour})) { $x->xref(@_); }
	if (($x = $self->{attributes})) { $x->xref(@_); }
	if (($x = $self->{attributegroups})) { $x->xref(@_); }
	if (($x = $self->{actions})) { $x->xref(@_); }
	if (($x = $self->{notifications})) { $x->xref(@_); }
	if (($x = $self->{registration})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} PACKAGE"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (($s = $self->{behaviour}      )) { $s->gdmo(); }
			if (($s = $self->{attributes}     )) { $s->gdmo(); }
			if (($s = $self->{attributegroups})) { $s->gdmo(); }
			if (($s = $self->{actions}        )) { $s->gdmo(); }
			if (($s = $self->{notifications}  )) { $s->gdmo(); }
			$::indent=~s/.$//s;
			if (($s = $self->{registration}   )) { $s->gdmo(); }
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ParameterTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*PARAMETER//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		last TEST unless ($self->{context} = Context->parse($line));
		last TEST unless (
			($self->{syntax} = WithSyntax->parse($line)) ||
			($self->{syntax} = Attribute->parse($line))
		);
		$self->{behaviour} = Behaviour->parse($line);
		$self->{registration} = RegisteredAs->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{parameters}->{$self->{label}}->{defn} = $self;
	$::root->{parameters}->{$self->{label}}->{defn} = $self;
	$::root->{parameters}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	$self->{context}->xref(@_);
	$self->{syntax}->xref(@_);
	if (($x = $self->{behaviour})) { $x->xref(@_); }
	if (($x = $self->{registration})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} PARAMETER"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{context}->gdmo();
			$self->{syntax}->gdmo();
			if (($s = $self->{behaviour}   )) { $s->gdmo(); }
			$::indent=~s/.$//s;
			if (($s = $self->{registration})) { $s->gdmo(); }
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package NameBindingTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*NAME(?:\s|\n)*((-)?)(?:\s|\n)*BINDING//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		last TEST unless ($self->{subordinate} = Subordinate->parse($line));
		last TEST unless ($self->{superior} = NamedBySuperior->parse($line));
		last TEST unless ($self->{attribute} = WithAttribute->parse($line));
		$self->{behaviour} = Behaviour->parse($line);
		$self->{createit} = Create->parse($line);
		$self->{deleteit} = Delete->parse($line);
		$self->{registration} = RegisteredAs->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{bindings}->{$self->{label}}->{defn} = $self;
	$::root->{bindings}->{$self->{label}}->{defn} = $self;
	$::root->{bindings}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	$self->{subordinate}->xref(@_);
	$self->{superior}->xref(@_);
	$self->{attribute}->xref(@_);
	if (($x = $self->{behaviour})) { $x->xref(@_); }
	if (($x = $self->{createit})) { $x->xref(@_); }
	if (($x = $self->{deleteit})) { $x->xref(@_); }
	if (($x = $self->{registration})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} NAME BINDING"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{subordinate}->gdmo();
			$self->{superior}->gdmo();
			$self->{attribute}->gdmo();
			if (($s = $self->{behaviour}   )) { $s->gdmo(); }
			if (($s = $self->{createit}    )) { $s->gdmo(); }
			if (($s = $self->{deleteit}    )) { $s->gdmo(); }
			$::indent=~s/.$//s;
			if (($s = $self->{registration})) { $s->gdmo(); }
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package AttributeTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*ATTRIBUTE//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		last TEST unless (
			($self->{syntax} = DerivedFromAttribute->parse($line)) ||
			($self->{syntax} = WithAttributeSyntax->parse($line))
		);
		$self->{matches} = Matches->parse($line);
		$self->{behaviour} = Behaviour->parse($line);
		$self->{parameters} = Parameters->parse($line);
		$self->{registration} = RegisteredAs->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{attributes}->{$self->{label}}->{defn} = $self;
	$::root->{attributes}->{$self->{label}}->{defn} = $self;
	$::root->{attributes}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	$self->{syntax}->xref(@_);
	if (($x = $self->{matches})) { $x->xref(@_); }
	if (($x = $self->{behaviour})) { $x->xref(@_); }
	if (($x = $self->{parameters})) { $x->xref(@_); }
	if (($x = $self->{registration})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} ATTRIBUTE"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			if (($s = $self->{matches})     ) { $s->gdmo(); }
			if (($s = $self->{behaviour})   ) { $s->gdmo(); }
			if (($s = $self->{parameters})  ) { $s->gdmo(); }
			$::indent=~s/.$//s;
			if (($s = $self->{registration})) { $s->gdmo(); }
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package AttributeGroupTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*GROUP//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		$self->{groupelements} = GroupElements->parse($line);
		$self->{fixed} = Fixed->parse($line);
		$self->{description} = Description->parse($line);
		$self->{registration} = RegisteredAs->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{groups}->{$self->{label}}->{defn} = $self;
	$::root->{groups}->{$self->{label}}->{defn} = $self;
	$::root->{groups}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	if (($x = $self->{groupelements})) { $x->xref(@_); }
	if (($x = $self->{fixed})) { $x->xref(@_); }
	if (($x = $self->{description})) { $x->xref(@_); }
	if (($x = $self->{registration})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} ATTRIBUTE GROUP"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1}) ) { $s->gdmo(); }
			if (($s = $self->{groupelements})) { $s->gdmo(); }
			if (($s = $self->{fixed})        ) { $s->gdmo(); }
			if (($s = $self->{description})  ) { $s->gdmo(); }
			$::indent=~s/.$//s;
			if (($s = $self->{registration}) ) { $s->gdmo(); }
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2}) ) { $s->gdmo(); }
	}
}

# ----------------------------------------
package BehaviourTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*BEHAVIOUR//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		$self->{definedas} = DefinedAs->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{behaviours}->{$self->{label}}->{defn} = $self;
	$::root->{behaviours}->{$self->{label}}->{defn} = $self;
	$::root->{behaviours}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	if (($x = $self->{definedas})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} BEHAVIOUR"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (($s = $self->{definedas})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ActionTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*ACTION//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		$self->{behaviour} = Behaviour->parse($line);
		$self->{mode} = Mode->parse($line);
		$self->{parameters} = Parameters->parse($line);
		$self->{infosyntax} = WithInformationSyntax->parse($line);
		$self->{replysyntax} = WithReplySyntax->parse($line);
		$self->{registration} = RegisteredAs->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{actions}->{$self->{label}}->{defn} = $self;
	$::root->{actions}->{$self->{label}}->{defn} = $self;
	$::root->{actions}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	if (($x = $self->{behaviour})) { $x->xref(@_); }
	if (($x = $self->{mode})) { $x->xref(@_); }
	if (($x = $self->{parameters})) { $x->xref(@_); }
	if (($x = $self->{infosyntax})) { $x->xref(@_); }
	if (($x = $self->{replysyntax})) { $x->xref(@_); }
	if (($x = $self->{registeredas})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} ACTION"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (($s = $self->{behaviour})   ) { $s->gdmo(); }
			if (($s = $self->{mode})        ) { $s->gdmo(); }
			if (($s = $self->{parameters})  ) { $s->gdmo(); }
			if (($s = $self->{infosyntax})  ) { $s->gdmo(); }
			if (($s = $self->{replysyntax}) ) { $s->gdmo(); }
			$::indent=~s/.$//s;
			if (($s = $self->{registration})) { $s->gdmo(); }
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package NotificationTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*NOTIFICATION//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		$self->{behaviour} = Behaviour->parse($line);
		$self->{parameters} = Parameters->parse($line);
		$self->{infosyntax} = WithInformationSyntaxAndAttributeIds->parse($line);
		$self->{replysyntax} = WithReplySyntax->parse($line);
		$self->{registration} = RegisteredAs->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{notifications}->{$self->{label}}->{defn} = $self;
	$::root->{notifications}->{$self->{label}}->{defn} = $self;
	$::root->{notifications}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	if (($x = $self->{behaviour})) { $x->xref(@_); }
	if (($x = $self->{parameters})) { $x->xref(@_); }
	if (($x = $self->{infosyntax})) { $x->xref(@_); }
	if (($x = $self->{replysyntax})) { $x->xref(@_); }
	if (($x = $self->{registeredas})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} NOTIFICATION"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			if (($s = $self->{behaviour})   ) { $s->gdmo(); }
			if (($s = $self->{parameters})  ) { $s->gdmo(); }
			if (($s = $self->{infosyntax})  ) { $s->gdmo(); }
			if (($s = $self->{replysyntax}) ) { $s->gdmo(); }
			$::indent=~s/.$//s;
			if (($s = $self->{registration})) { $s->gdmo(); }
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SubordinationRuleTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*SUBORDINATION(?:\s|\n)*((-)?)(?:\s|\n)*RULE//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{superiorclass} = SuperiorObjectClass->parse($line)));
		last TEST unless (($self->{namessubs} = NamesSubordinates->parse($line)));
		last TEST unless (($self->{accordingto} = AccordingToRule->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{subordinates}->{$self->{label}}->{defn} = $self;
	$::root->{subordinates}->{$self->{label}}->{defn} = $self;
	$::root->{subordinates}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	$self->{superiorclass}->xref(@_);
	$self->{namessubs}->xref(@_);
	$self->{accordingto}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} SUBORDINATION RULE"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{superiorclass}->gdmo();
			$self->{namessubs}->gdmo();
			$self->{accordingto}->gdmo();
			$::indent=~s/.$//s;
		}
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AccordingToRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{accordingto} = AccordingToRuleToken->parse($line)));
		last TEST unless (($self->{rule} = SubordinationRule->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{accordingto}->xref(@_);
	$self->{rule}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$::indent.="\t";
		$self->{accordingto}->gdmo();
		{
			$self->{rule}->gdmo();
			$::indent=~s/^.//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ConstraintRuleTemplate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-))(?:\s|\n)*CONSTRAINT(?:\s|\n)*((-)?)(?:\s|\n)*RULE//s);
		$self->{label} = $1;
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{objectclass} = ObjectClass->parse($line)));
		last TEST unless (($self->{isrelatedto} = IsRelatedTo->parse($line)));
		last TEST unless (($self->{usingattribute} = UsingAttribute->parse($line)));
		last TEST unless (($self->{ruleset} = ConstraintRuleSet->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{constraints}->{$self->{label}}->{defn} = $self;
	$::root->{constraints}->{$self->{label}}->{defn} = $self;
	$::root->{constraints}->{$self->{label}}->{modl} = $gdmo;

	my $x;
	$self->{objectclass}->xref(@_);
	$self->{isrelatedto}->xref(@_);
	$self->{usingattribute}->xref(@_);
	$self->{ruleset}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "$self->{label} CONSTRAINT RULE"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{objectclass}->gdmo();
			$self->{isrelatedto}->gdmo();
			$self->{usingattribute}->gdmo();
			$self->{ruleset}->gdmo();
			$::indent=~s/.$//s;
		}
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SuperiorObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SUPERIOR\s*-?\s*OBJECT\s*-?\s*CLASS//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{class} = ClassReference->parse($line)));
		$self->{subclasses} = AndSubclasses->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{class}->xref(@_);
	my $x; if (($x = $self->{subclasses})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "SUPERIOR OBJECT CLASS"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ObjectClass;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{class} = ClassReference->parse($line)));
		$self->{subclasses} = AndSubclasses->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{class}->xref(@_);
	my $x; if (($x = $self->{subclasses})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "OBJECT CLASS"; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamesSubordinates;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAMES\s*-?\s*SUBORDINATES//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{list} = ClassReferenceList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{list}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "NAMES SUBORDINATES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{list}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package IsRelatedTo;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^IS(?:\s|\n)*((-)?)(?:\s|\n)*RELATED(?:\s|\n)*((-)?)(?:\s|\n)*TO//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{list} = ClassSpecList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{list}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "IS RELATED TO"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{list}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ClassSpecList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ClassSpec;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{reference} = ClassReference->parse($line)));
		$self->{subclasses} = AndSubclasses->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{reference}->xref(@_);
	my $x; if (($x = $self->{subclasses})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{reference}->gdmo();
		if (($s = $self->{subclasses})) { $s->gdmo(); }
	}
}

# -------------------------------------
package UsingAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^USING(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{attribute}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'USING ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ConstraintRuleSet;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
#
sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{ruleset} = SingleConstraintRule->parse($line)) ||
			($self->{ruleset} = NamedTypeConstraintRule->parse($line))
		);
		last TEST unless ($line=~s/^;//s);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{ruleset}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{ruleset}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package SingleConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACCORDING\s*-?\s*TO\s*-?\s*RULE//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{rule} = ConstraintRule->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{rule}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ACCORDING TO RULE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package NamedTypeConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CASE//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{rules} = NamedTypeConstraintRuleListBraced->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{rules}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf 'CASE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package NamedTypeConstraintRuleListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package NamedTypeConstraintRuleList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('NamedTypeConstraintRuleItem',@_); }

# -------------------------------------
package NamedTypeConstraintRuleItem;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{type} = Identifier->parse($line)));
		last TEST unless (($self->{accordingto} = AccordingToRuleToken->parse($line)));
		last TEST unless (($self->{rule} = ConstraintRule->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
	$self->{accordingto}->xref(@_);
	$self->{rule}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{type}->gdmo();
		$self->{accordingto}->gdmo();
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package AccordingToRuleToken;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read { my $self = shift; return $self->readtoken('ACCORDING TO RULE',@_); }

# -------------------------------------
package SubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{rule} = SetSubordinationRule->parse($line)) ||
			($self->{rule} = ChoiceSubordinationRule->parse($line)) ||
			($self->{rule} = SetSizeSubordinationRule->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{rule}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package ConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{rule} = SetConstraintRule->parse($line)) ||
			($self->{rule} = SequenceConstraintRule->parse($line)) ||
			($self->{rule} = ChoiceConstraintRule->parse($line)) ||
			($self->{rule} = SetSizeConstraintRule->parse($line)) ||
			($self->{rule} = SequenceSizeConstraintRule->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{rule}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{rule}->gdmo();
	}
}

# -------------------------------------
package SetSubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{rules} = SubordinationTermListBraced->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{rules}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SET'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package SetConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{rules} = ConstraintTermListBraced->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{rules}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SET'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package SequenceConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SEQUENCE//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{rules} = ConstraintTermListBraced->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{rules}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SEQUENCE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package ChoiceSubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHOICE//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{rules} = SubordinationTermListBraced->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{rules}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CHOICE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package ChoiceConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHOICE//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{rules} = ConstraintTermListBraced->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{rules}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CHOICE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{rules}->gdmo();
	}
}

# -------------------------------------
package SetSizeSubordinationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET\s*-?\s*SIZE//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{ordinality} = OrdinalityParens->parse($line)));
		last TEST unless ($line=~s/^OF//s);
		$self->{comments2} = Comments->parse($line);
		last TEST unless (($self->{constraint} = SubordinationTerm->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{ordinality}->xref(@_);
	$self->{constraint}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SET SIZE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		if (!$::first) { printf ' '; }
		printf 'OF'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{constraint}->gdmo();
	}
}

# -------------------------------------
package SetSizeConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SET\s*-?\s*SIZE//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{ordinality} = OrdinalityParens->parse($line)));
		last TEST unless ($line=~s/^OF//s);
		$self->{comments2} = Comments->parse($line);
		last TEST unless (($self->{constraint} = ConstraintTerm->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{ordinality}->xref(@_);
	$self->{constraint}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SET SIZE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		if (!$::first) { printf ' '; }
		printf 'OF'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{constraint}->gdmo();
	}
}

# -------------------------------------
package SequenceSizeConstraintRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SEQUENCE\s*-?\s*SIZE//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{ordinality} = OrdinalityParens->parse($line)));
		last TEST unless ($line=~s/^OF//s);
		$self->{comments2} = Comments->parse($line);
		last TEST unless (($self->{constraint} = ConstraintTerm->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{ordinality}->xref(@_);
	$self->{constraint}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SEQUENCE SIZE'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		if (!$::first) { printf ' '; }
		printf 'OF'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		$self->{constraint}->gdmo();
	}
}

# -------------------------------------
package OrdinalityParens;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryParens);
# -------------------------------------

# -------------------------------------
package Ordinality;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{ordinality} = ValueRange->parse($line)) ||
			($self->{ordinality} = ValueList->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{ordinality}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$::first = 1; # fool it
		$self->{ordinality}->gdmo();
		$::first = 1; # fool it
	}
}

# -------------------------------------
package ValueRange;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{lower} = IntegerValue->parse($line)));
		last TEST unless ($line=~s/^\.\.//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (
			$line=~s/^N//s ||
			($self->{upper} = IntegerValue->parse($line))
		);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{lower}->xref(@_);
	my $x; if (($x = $self->{upper})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$::first = 1; # fool it
		$self->{lower}->gdmo();
		printf '..'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{upper})) { $s->gdmo(); } else {
			printf 'N'; $::first = 0;
		}
		$::first = 1; # fool it
	}
}

# -------------------------------------
package SubordinationTermListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package SubordinationTermList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package SubordinationTerm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{term} = ClassReference->parse($line)) ||
			($self->{term} = SubordinationRule->parse($line))
		);
		my $ref = ref $self->{term};
		if ($ref=~/ClassReference/) {
			$self->{subclasses} = AndSubclasses->parse($line);
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{term}->xref(@_);
	my $x; if (($x = $self->{subclasses})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{term}->gdmo();
		my $s; if (($s = $self->{subclasses})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ConstraintTermListBraced;
use strict;
use vars qw(@ISA);
@ISA = qw(MandatoryBraced);
# -------------------------------------

# -------------------------------------
package ConstraintTermList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ConstraintTerm;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{term} = ClassReference->parse($line)) ||
			($self->{term} = ConstraintRule->parse($line))
		);
		my $ref = ref $self->{term};
		if ($ref=~/ClassReference/) {
			$self->{subclasses} = AndSubclasses->parse($line);
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{term}->xref(@_);
	my $x; if (($x = $self->{subclasses})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		$self->{term}->gdmo();
		my $s; if (($s = $self->{subclasses})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DocumentIdentifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(?:"([^"]*)")//s);
		$self->{documentid} = $1;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	# last TEST if ($::root->{gdmos}->{$self->{documentid}}->{defn});
	$gdmo->{documentid} = $self->{documentid};
	$gdmo->{aliases}->{$self->{documentid}}++;
	$::root->{gdmos}->{$self->{documentid}}->{defn} = $gdmo;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "\"$self->{documentid}\""; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DocumentReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^(?:"([^"]*)")//s);
		$self->{documentid} = $1;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	$gdmo->{docrefs}->{$self->{documentid}}->{refs}++;
	$::root->{gdmos}->{$self->{documentid}}->{refs}++;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "\"$self->{documentid}\""; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Label;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		# ok, you can have a period or slash in a label
		last TEST unless ($line=~s/^[a-z](?:[a-zA-Z0-9\.\/]|-(?!-))*(?<!-)//s);
		$self->{label} = $&;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf "$self->{label}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}


# ----------------------------------------
package Reference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		if (($self->{documentid} = DocumentReference->parse($line))) {
			last TEST unless ($line=~s/^://s);
			$self->{comments} = Comments->parse($line);
		}
		last TEST unless (($self->{label} = Label->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x; if (($x = $self->{documentid})) { $x->xref(@_); }
	# might want to also pass documentid
	$self->{label}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		if (($s = $self->{documentid})) {
			$s->gdmo();
			printf ':'; $::first = 0;
			if (($s = $self->{comments})) { $s->gdmo(); }
		}
		if (($s = $self->{label})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ClassReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	my $gdmo = $_[1];
	TEST: {
		last TEST
		unless (
			($self->{template} = ClassTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{objects}->{$l}->{refs}++;
		$::root->{objects}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{objects}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{objects}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package PackageReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST
		unless (
			($self->{template} = PackageTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{packages}->{$l}->{refs}++;
		$::root->{packages}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{packages}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{packages}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ParameterReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST
		unless (
			($self->{template} = ParameterTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{parameters}->{$l}->{refs}++;
		$::root->{parameters}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{parameters}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{parameters}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package NameBindingReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST
		unless (
			($self->{template} = NameBindingTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{bindings}->{$l}->{refs}++;
		$::root->{bindings}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{bindings}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{bindings}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package AttributeReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST
		unless (
			($self->{template} = AttributeTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{attributes}->{$l}->{refs}++;
		$::root->{attributes}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{attributes}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{attributes}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package AttributeGroupReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST
		unless (
			($self->{template} = AttributeGroupTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{groups}->{$l}->{refs}++;
		$::root->{groups}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{groups}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{groups}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package BehaviourReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST
		unless (
			($self->{template} = BehaviourTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{behaviours}->{$l}->{refs}++;
		$::root->{behaviours}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{behaviours}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{behaviours}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ActionReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST
		unless (
			($self->{template} = ActionTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{actions}->{$l}->{refs}++;
		$::root->{actions}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{actions}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{actions}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package NotificationReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST
		unless (
			($self->{template} = NotificationTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{notifications}->{$l}->{refs}++;
		$::root->{notifications}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{notifications}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{notifications}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package SubordinationRuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST
		unless (
			($self->{template} = SubordinationRuleTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{subordinates}->{$l}->{refs}++;
		$::root->{subordinates}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{subordinates}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{subordinates}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# ----------------------------------------
package ConstraintRuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# ----------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST
		unless (
			($self->{template} = ConstraintRuleTemplate->parse($line)) ||
			($self->{reference} = Reference->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];

	my ($r,$d,$l);
	if (($r = $self->{reference})) {
		$l = $r->{label}->{label};
		$gdmo->{constraints}->{$l}->{refs}++;
		$::root->{constraints}->{$l}->{refs}++;
		if (($d = $r->{documentid})) {
			$gdmo->{constraints}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
			$::root->{constraints}->{$l}->{docs}->{$d->{documentid}}->{refs}++;
		}
	}

	my $x;
	if (($x = $self->{template}) ) { $x->xref(@_); }
	if (($x = $self->{reference})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{template}) ) { $s->gdmo(); }
		if (($s = $self->{reference})) { $s->gdmo(); }
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DerivedFromClasses;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s|\n)*FROM//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{classes} = ClassReferenceList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{classes}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "DERIVED FROM"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{classes}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ClassReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package Characterization;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CHARACTERIZED(?:\s|\n)*((-)?)(?:\s|\n)*BY//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{packages} = PackageReferenceList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{packages}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "CHARACTERIZED BY"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{packages}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package PackageReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ConditionalPackages;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^CONDITIONAL(?:\s|\n)*((-)?)(?:\s|\n)*PACKAGES//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{conditions} = PackageConditionList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{conditions}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "CONDITIONAL PACKAGES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{conditions}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package PackageConditionList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package PackageCondition;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{package} = PackageReference->parse($line)));
		last TEST unless (
			($self->{condition} = PresentIf->parse($line)) ||
			($self->{condition} = PresentOnlyIf->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{package}->xref(@_);
	$self->{condition}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{package}->gdmo();
		$::indent.="\t";
		$self->{condition}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package PresentIf;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PRESENT(?:\s|\n)*((-)?)(?:\s|\n)*IF//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,',;')));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{delimited}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "PRESENT IF"; $::first = 0;
		$::indent.="\t";
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{delimited})) { $s->gdmo(); }
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package PresentOnlyIf;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PRESENT(?:\s|\n)*((-)?)(?:\s|\n)*ONLY(?:\s|\n)*((-)?)(?:\s|\n)*IF//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,',;')));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{delimited}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "PRESENT ONLY IF"; $::first = 0;
		my $s;
		$::indent.="\t";
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{delimited})) { $s->gdmo(); }
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package DelimitedString;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	my $term = $_[1];
	TEST: {
		my $pattern;
		if ($line=~s/^[!"#\$%^&\*'`~\?@\\]//s) {
			my $d = $&;
			$self->{delimiter} = $d;
			$d = '\\'.$d if ($d=~/[\$\*\?\\]/);
			$pattern="((?:[^".$d."]|[".$d."](?=[".$d."]))*)[".$d."]";
		} else {
			$pattern="([^".$term."]*)";
		}
		last TEST unless ($line=~s/^$pattern//s);
		$self->{string} = $1;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$col,$spc,$len);
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{delimiter}";
		$col = 0;
		my @paras = ( split(/\n\n/s,$self->{string}) );
		my $p; foreach $p (@paras) {
			my @lines = ( split(/\n/s,$p) );
			my $l; foreach $l (@lines) {
				my @words = ( split(/\s+/s,$l) );
				my $w; foreach $w (@words) {
					if ($col == 0) { $spc = 0; } else { $spc = 1; }
					$len = length($w);
					if ($len) {
						if ($col + $spc + $len < $::colwidth) {
							if ($spc) { printf ' '; }
							$col += $spc + $len;
						} else {
							printf "\n$::indent";
							$col = $len;
						}
						printf "$w";
					}
				}
			}
		}
		printf "$self->{delimiter}";
		#for now: flow it later
		#printf "$self->{delimiter}$self->{string}$self->{delimiter}";
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::first = 0;
	}
}

# -------------------------------------
package Attributes;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTES//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{attributes} = AttributePropertyList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{attributes}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		my $s;
		printf "ATTRIBUTES"; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{attributes}->gdmo();
		printf ";"; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributePropertyList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package AttributeProperty;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{attribute} = AttributeReference->parse($line)));
		$self->{properties} = PropertyList->parse($line);
		$self->{parameters} = ParameterReferenceSimpleList->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{properties})) { $x->xref(@_); }
	if (($x = $self->{parameters})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{attribute})) { $s->gdmo(); }
		{
			$::indent.="\t";
			if (($s = $self->{properties})) { $s->gdmo(); }
			if (($s = $self->{parameters})) { $s->gdmo(); }
			$::indent=~s/^.//s;
		}
	}
}

# -------------------------------------
package PropertyList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

# -------------------------------------
package Property;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{property} = ReplaceWithDefault->parse($line)) ||
			($self->{property} = DefaultValue->parse($line)) ||
			($self->{property} = InitialValue->parse($line)) ||
			($self->{property} = PermittedValues->parse($line)) ||
			($self->{property} = RequiredValues->parse($line)) ||
			($self->{property} = GetReplace->parse($line)) ||
			($self->{property} = Get->parse($line)) ||
			($self->{property} = Replace->parse($line)) ||
			($self->{property} = AddRemove->parse($line)) ||
			($self->{property} = Add->parse($line)) ||
			($self->{property} = Remove->parse($line)) ||
			($self->{property} = SetByCreate->parse($line)) ||
			($self->{property} = NoModify->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{property}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{property}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ReplaceWithDefault;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('REPLACE-WITH-DEFAULT',@_);
}

# -------------------------------------
package DefaultValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DEFAULT(?:\s|\n)*((-)?)(?:\s|\n)*VALUE//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{value} = ValueSpecifier->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DEFAULT VALUE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		if (($s = $self->{value})) { $s->gdmo(); }
	}
}

# -------------------------------------
package InitialValue;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^INITIAL(?:\s|\n)*((-)?)(?:\s|\n)*VALUE//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{value} = ValueSpecifier->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'INITIAL VALUE'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{value}->gdmo();
	}
}

# -------------------------------------
package PermittedValues;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PERMITTED(?:\s|\n)*((-)?)(?:\s|\n)*VALUES//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{typereference} = ExternalTypeReference->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{typereference}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PERMITTED VALUES'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{typereference}->gdmo();
	}
}

# -------------------------------------
package RequiredValues;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^REQUIRED(?:\s|\n)*((-)?)(?:\s|\n)*VALUES//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{typereference} = ExternalTypeReference->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{typereference}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'REQUIRED VALUES'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{typereference}->gdmo();
	}
}

# -------------------------------------
package GetReplace;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('GET-REPLACE',@_);
}

# -------------------------------------
package Get;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('GET',@_);
}

# -------------------------------------
package Replace;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('REPLACE',@_);
}

# -------------------------------------
package AddRemove;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ADD-REMOVE',@_);
}

# -------------------------------------
package Add;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ADD',@_);
}

# -------------------------------------
package Remove;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('REMOVE',@_);
}

# -------------------------------------
package SetByCreate;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SET-BY-CREATE',@_);
}

# -------------------------------------
package NoModify;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('NO-MODIFY',@_);
}

# -------------------------------------
package ValueSpecifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{value} = ExternalValueReference->parse($line)) ||
			($self->{value} = DerivationRule->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{value}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ExternalTypeReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{modulereference} = ModuleReference->parse($line)));
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{typename} = TypeReference->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{value}->xref(@_);
}

sub xref {
	my $self = shift;
	$self->{modulereference}->xref(@_);
	# FIXME: might want to pass modulereference to typename
	$self->{typename}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modulereference}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::first = 1; # fool typereference into concatenating
		$self->{typename}->gdmo();
	}
}

# -------------------------------------
package ExternalValueReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{modulereference} = ModuleReference->parse($line)));
		last TEST unless ($line=~s/^\.//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{valuename} = ValueReference->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{modulereference}->xref(@_);
	# FIXME: might want to pass modulereference to valuename
	$self->{valuename}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modulereference}->gdmo();
		printf '.'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$::first = 1; # fool it
		$self->{valuename}->gdmo();
	}
}

sub oid {
	my $self = shift;
	my ($s,$name);
	if (($s = $self->{modulereference})) {
		$name = $self->{modulereference}.".".$self->{valuename};
	} else {
		$name = $self->{valuename};
	}
	# Just return the value of name for now
	return "$name";
}

# -------------------------------------
package AbsoluteReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$c);
		last TEST unless ($line=~s/^@//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{modulereference} = ModuleReference->parse($line)));
		last TEST unless ($line=~s/^\.//s);
		$self->{comments2} = Comments->parse($line);
		last TEST unless (($s = TypeReference->parse($line)));
		push @{$self->{typereferences}}, $s;
		while ($line=~s/^\.//s) {
			if (($c = Comments->parse($line))) {
				$s->{commentplus} = $c;
			}
			last TEST unless (($s = TypeReference->parse($line)));
			push @{$self->{typereferences}}, $s;
			# Fixme: the last element after the '.' is an identifier, a number, or a '*'
		}
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{modulereference}->xref(@_);
	# FIXME: might want to pass modulereference to typereferences
	my $x; foreach $x (@{$self->{typereferences}}) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my ($s,$c,$i);
		if (!$::first) { printf ' '; }
		printf '@'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		$self->{modulereference}->gdmo(); printf '.'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
		foreach $s (@{$self->{typereferences}}) {
			if ($i) {
				printf '.'; $::first = 0;
				if ($c) { $c->gdmo(); }
			} else { $i = 1; }
			$s->gdmo();
			$c = $s->{commentplus};
		}
	}
}

# -------------------------------------
package DerivationRule;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------
# Some ITU standareds use DERIVED RULES instead of DERIVATION RULE... go figure.
# It will be corrrected on output.

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			$line=~s/^DERIVATION(?:\s|\n)*((-)?)(?:\s|\n)*RULE//s ||
			$line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s\|\n)*RULES//s
		);
		$self->{comments} = Comments->parse($line);
		last TEST unless ($self->{behaviour} = BehaviourReference->parse($line));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{behaviour}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		if (!$::first) { printf ' '; }
		my $s;
		printf 'DERIVATION RULE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{behaviour}->gdmo();
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package ModuleIdentifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{reference} = $&;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# ModuleIdentifier's occur only in the definition of an ASN module.  We keep track of which module
# identifiers are defined in all documents, the definiting GDMO document and the definining ASN
# module.

sub xref {
	my $self = shift;
	my $asn1 = $_[1]; # ASN1 module

	$asn1->{moduleid} = $self->{reference};
	$::root->{asnmodules}->{$self->{reference}}->{defn} = $asn1;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		printf "$self->{reference}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ModuleReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{reference} = $&;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

# ModuleRference's occur on SymbolsFromModule (after FROM in ASN module IMPORTS statment), a global
# module reference of the form ModuleName and ObjectIdentifier (also after FROM in ASN module
# IMPORTS statement) an ExternalTypeReference or ExternalValueReference which can occur just about
# anywhere, including GDMO templates, which are proliferated with ExternalTypeRerferences and have a
# few ExternalValueReferences for Initial and Default values for attributes.
#
# When this function is called, we might or might not be within an ASN module (we might only be
# within a gdmo).  We must keep track of all external module references for the root, each gdmo
# document and each ASN1 module.

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { $asn1->{asnmodules}->{$self->{reference}}->{refs}++; }
	$gdmo->{asnmodules}->{$self->{reference}}->{refs}++;
	$::root->{asnmodules}->{$self->{reference}}->{refs}++;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{reference}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ValueReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[a-z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{name} = $&;
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { $asn1->{vrefs}->{$self->{name}}->{refs}++; }
	$gdmo->{vrefs}->{$self->{name}}->{refs}++;
	$::root->{vrefs}->{$self->{name}}->{refs}++;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package TypeReference;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^[A-Z](?:[a-zA-Z0-9]|-(?!-))*(?<!-)//s);
		$self->{comments} = Comments->parse($line);
		$self->{name} = $&;
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $gdmo = $_[0];
	my $asn1 = $_[1];

	if ($asn1) { $asn1->{trefs}->{$self->{name}}->{refs}++; }
	$gdmo->{trefs}->{$self->{name}}->{refs}++;
	$::root->{trefs}->{$self->{name}}->{refs}++;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf ' '; }
		printf "$self->{name}"; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeGroups;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*GROUPS//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{groups} = AttributeGroupAttributesList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{groups}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE GROUPS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{groups}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeGroupAttributesList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package AttributeGroupAttributes;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{group} = AttributeGroupReference->parse($line)));
		$self->{attributes} = AttributeReferenceSimpleList->parse($line);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{group}->xref(@_);
	my $x; if (($x = $self->{attributes})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{group}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{attributes})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeReferenceSimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('AttributeReference',@_); }

# -------------------------------------
package Actions;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACTIONS//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{actions} = ActionParameterList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{actions}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ACTIONS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{actions}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ActionParameterList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package ActionParameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{action} = ActionReference->parse($line)));
		$self->{parameters} = ParameterReferenceSimpleList->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{action}->xref(@_);
	my $x; if (($x = $self->{parameters})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{action}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{parameters})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package ParameterReferenceSimpleList;
use strict;
use vars qw(@ISA);
@ISA = qw(SimpleList);
# -------------------------------------

sub read { my $self = shift; return $self->readitem('ParameterReference',@_); }

# -------------------------------------
package Notifications;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFICATIONS//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{notifications} = NotificationParameterList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{notifications}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NOTIFICATIONS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{notifications}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NotificationParameterList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package NotificationParameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{notification} = NotificationReference->parse($line)));
		$self->{parameters} = ParameterReferenceSimpleList->parse($line);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{notification}->xref(@_);
	my $x; if (($x = $self->{parameters})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{notification}->gdmo();
		{
			$::indent.="\t";
			if (($s = $self->{parameters})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package RegisteredAs;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless
		($line=~s/^REGISTERED(?:\s|\n)*((-)?)(?:\s|\n)*AS//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{objectid} = ObjectIdentifierValue->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{objectid}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'REGISTERED AS'; $::first = 0;
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{objectid}->gdmo();
	}
}

# -------------------------------------
package WithSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{syntax}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Package;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PACKAGE//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{package} = PackageReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{package}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PACKAGE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{package}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Parameter;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PARAMETER//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{parameter} = ParameterReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{parameter}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PARAMETER'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{parameter}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NameBinding;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAME(?:\s|\n)*((-)?)(?:\s|\n)*BINDING//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{namebinding} = NameBindingReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}
sub xref {
	my $self = shift;
	$self->{namebinding}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NAME BINDING'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{namebinding}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Attribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{attribute}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeGroup;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*GROUP//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{attributegroup} = AttributeGroupReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{attributegroup}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ATTRIBUTE GROUP'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attributegroup}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Behaviour;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^BEHAVIOUR//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{behaviour} = BehaviourReferenceList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{behaviour}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'BEHAVIOUR'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{behaviour}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package BehaviourReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package Action;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^ACTION//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{action} = ActionReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{action}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'ACTION'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{action}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Notification;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NOTIFICATION//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{notification} = NotificationReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{notification}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NOTIFICATION'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{notification}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Subordinate;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^SUBORDINATE(?:\s|\n)*((-)?)(?:\s|\n)*OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{class} = ClassReference->parse($line)));
		$self->{subclasses} = AndSubclasses->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{class}->xref(@_);
	my $x; if (($x = $self->{subclasses})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SUBORDINATE OBJECT CLASS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package NamedBySuperior;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^NAMED(?:\s|\n)*((-)?)(?:\s|\n)*BY//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless ($line=~s/^SUPERIOR(?:\s|\n)*((-)?)(?:\s|\n)*OBJECT(?:\s|\n)*((-)?)(?:\s|\n)*CLASS//s);
		$self->{comments2} = Comments->parse($line);
		last TEST unless (($self->{class} = ClassReference->parse($line)));
		$self->{subclasses} = AndSubclasses->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments3} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{class}->xref(@_);
	my $x; if (($x = $self->{subclasses})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'NAMED BY'; $::first = 0;
		if (($s = $self->{comments1})) { $s->gdmo(); }
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'SUPERIOR OBJECT CLASS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments2})) { $s->gdmo(); }
			$self->{class}->gdmo();
			if (($s = $self->{subclasses})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments3})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AndSubclasses;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('AND SUBCLASSES',@_);
}

# -------------------------------------
package WithAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{attribute}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH ATTRIBUTE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Create;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$c);
		last TEST unless ($line=~s/^CREATE//s);
		$self->{comments1} = Comments->parse($line);
		$self->{modifiers} = CreateModifierList->parse($line);
		$self->{parameters} = ParameterReferenceSimpleList->parse($line);
		last TEST unless ($line=~s/^;//s); 
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{modifiers})) { $x->xref(@_); }
	if (($x = $self->{parameters})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CREATE'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (($s = $self->{modifiers})) { $s->gdmo(); }
		if (($s = $self->{parameters})) { $s->gdmo(); }
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package CreateModifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package CreateModifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{modifier} = WithReferenceObject->parse($line)) ||
			($self->{modifier} = WithAutomaticInstanceNaming->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{modifier}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithReferenceObject;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('WITH-REFERENCE-OBJECT',@_);
}

# -------------------------------------
package WithAutomaticInstanceNaming;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('WITH-AUTOMATIC-INSTANCE-NAMING',@_);
}

# -------------------------------------
package Delete;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my ($s,$c);
		last TEST unless ($line=~s/^DELETE//s);
		$self->{comments1} = Comments->parse($line);
		$self->{modifiers} = DeleteModifierList->parse($line);
		$self->{parameters} = ParameterReferenceSimpleList->parse($line);
		last TEST unless ($line=~s/^;//s); 
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	my $x;
	if (($x = $self->{modifiers})) { $x->xref(@_); }
	if (($x = $self->{parameters})) { $x->xref(@_); }
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DELETE'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		if (($s = $self->{modifiers})) { $s->gdmo(); }
		if (($s = $self->{parameters})) { $s->gdmo(); }
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DeleteModifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package DeleteModifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{modifier} = OnlyIfNoContainedObjects->parse($line)) ||
			($self->{modifier} = DeletesContainedObjects->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{modifier}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{modifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package OnlyIfNoContainedObjects;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ONLY-IF-NO-CONTAINED-OBJECTS',@_);
}

# -------------------------------------
package DeletesContainedObjects;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('DELETES-CONTAINED-OBJECTS',@_);
}

# -------------------------------------
package DerivedFromAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DERIVED(?:\s|\n)*((-)?)(?:\s|\n)*FROM//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{attribute}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DERIVED FROM'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{attribute}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithAttributeSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{syntax}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH ATTRIBUTE SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Matches;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MATCHES(?:\s|\n)*((-)?)(?:\s|\n)*FOR//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{matches} = MatchQualifierList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{matches}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'MATCHES FOR'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{matches}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package MatchQualifierList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package MatchQualifier;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{qualifier} = Equality->parse($line)) ||
			($self->{qualifier} = Ordering->parse($line)) ||
			($self->{qualifier} = Substrings->parse($line)) ||
			($self->{qualifier} = SetComparison->parse($line)) ||
			($self->{qualifier} = SetIntersection->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{qualifier}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		$self->{qualifier}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Equality;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EQUALITY',@_);
}

# -------------------------------------
package Ordering;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ORDERING',@_);
}

# -------------------------------------
package Substrings;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SUBSTRINGS',@_);
}

# -------------------------------------
package SetComparison;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SET-COMPARISON',@_);
}

# -------------------------------------
package SetIntersection;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SET-INTERSECTION',@_);
}

# -------------------------------------
package Parameters;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^PARAMETERS//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{parameters} = ParameterReferenceList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{parameters}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'PARAMETERS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{parameters}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ParameterReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package GroupElements;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^GROUP(?:\s|\n)*((-)?)(?:\s|\n)*ELEMENTS//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{elements} = AttributeReferenceList->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{elements}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'GROUP ELEMENTS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{elements}->gdmo();
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AttributeReferenceList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package Fixed;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^FIXED//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'FIXED'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Description;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DESCRIPTION//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,';')));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{delimited}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DESCRIPTION'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{delimited}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package DefinedAs;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^DEFINED(?:\s|\n)*((-)?)(?:\s|\n)*AS//s);
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{delimited} = DelimitedString->parse($line,';')));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{delimited}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'DEFINED AS'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments})) { $s->gdmo(); }
			$self->{delimited}->gdmo();
			$::indent=~s/.$//s;
		}
	}
}

# -------------------------------------
package Mode;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^MODE//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (
			($self->{mode} = Confirmed->parse($line)) ||
			($self->{mode} = Unconfirmed->parse($line))
		);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{mode}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'MODE'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{mode}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package Confirmed;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('CONFIRMED',@_);
}

# -------------------------------------
package Unconfirmed;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('UNCONFIRMED',@_);
}

# -------------------------------------
package WithInformationSyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*INFORMATION(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{syntax}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH INFORMATION SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithReplySyntax;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*REPLY(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{syntax}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH REPLY SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package WithInformationSyntaxAndAttributeIds;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^WITH(?:\s|\n)*((-)?)(?:\s|\n)*INFORMATION(?:\s|\n)*((-)?)(?:\s|\n)*SYNTAX//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{syntax} = ExternalTypeReference->parse($line)));
		$self->{attributeids} = AndAttributeIds->parse($line);
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{syntax}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'WITH INFORMATION SYNTAX'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{syntax}->gdmo();
			if (($s = $self->{attributeids})) { $s->gdmo(); }
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package AndAttributeIds;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^AND(?:\s|\n)*((-)?)(?:\s|\n)*ATTRIBUTE(?:\s|\n)*((-)?)(?:\s|\n)*IDS//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{ids} = FieldAttributeList->parse($line)));
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{ids}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'AND ATTRIBUTE IDS'; $::first = 0;
		$::indent.="\t"; if (($s = $self->{comments1})) { $s->gdmo(); } $::indent=~s/^.//s;
		$self->{ids}->gdmo();
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package FieldAttributeList;
use strict;
use vars qw(@ISA);
@ISA = qw(CommaList);
# -------------------------------------

# -------------------------------------
package FieldAttribute;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless ($line=~s/^([a-z](?:[a-zA-Z0-9]|-(?!-))*(?<!-))//s);
		$self->{fieldname} = $1;
		$self->{comments} = Comments->parse($line);
		last TEST unless (($self->{attribute} = AttributeReference->parse($line)));
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{attribute}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf "$self->{fieldname}"; $::first = 0;
		$::indent.="\t";
		if (($s = $self->{comments})) { $s->gdmo(); }
		$self->{attribute}->gdmo();
		$::indent=~s/.$//s;
	}
}

# -------------------------------------
package Context;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		my $s;
		last TEST unless ($line=~s/^CONTEXT//s);
		$self->{comments1} = Comments->parse($line);
		last TEST unless (($self->{type} = ContextType->parse($line)));
		last TEST unless ($line=~s/^;//s);
		$self->{comments2} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (!$::first) { printf "\n$::indent"; $::first = 1; }
		printf 'CONTEXT'; $::first = 0;
		{
			$::indent.="\t";
			if (($s = $self->{comments1})) { $s->gdmo(); }
			$self->{type}->gdmo();
			$::indent=~s/.$//s;
		}
		printf ';'; $::first = 0;
		if (($s = $self->{comments2})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ContextType;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (
			($self->{type} = ContextKeyword->parse($line)) ||
			($self->{type} = ActionInfo->parse($line)) ||
			($self->{type} = ActionReply->parse($line)) ||
			($self->{type} = EventInfo->parse($line)) ||
			($self->{type} = EventReply->parse($line)) ||
			($self->{type} = SpecificError->parse($line))
		);
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{type}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{type}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ContextKeyword;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		last TEST unless (($self->{typereference} = ExternalTypeReference->parse($line)));
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
	$self->{typereference}->xref(@_);
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		$self->{typereference}->gdmo();
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package ActionInfo;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ACTION-INFO',@_);
}

# -------------------------------------
package ActionReply;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('ACTION-REPLY',@_);
}

# -------------------------------------
package EventInfo;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EVENT-INFO',@_);
}

# -------------------------------------
package EventReply;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('EVENT-REPLY',@_);
}

# -------------------------------------
package SpecificError;
use strict;
use vars qw(@ISA);
@ISA = qw(DashedToken);
# -------------------------------------

sub read {
	my $self = shift;
	return $self->readtoken('SPECIFIC-ERROR',@_);
}

# -------------------------------------
package XXX;
use strict;
use vars qw(@ISA);
@ISA = qw(ParserGenerator);
# -------------------------------------

sub read {
	my $self = shift;
	my $line = $_[0];
	TEST: {
		$self->{comments} = Comments->parse($line);
		$_[0] = $line; return $self;
	}
	return $self->error($line);
}

sub xref {
	my $self = shift;
}

sub gdmo {
	my $self = shift;
	PRINT: {
		my $s;
		if (($s = $self->{comments})) { $s->gdmo(); }
	}
}

# -------------------------------------
package main;
use strict;
# -------------------------------------

no strict;

$s = '\s';
$lineno = 0;
$endoffile = 0;
$done = 0;
$error = '';
$success = '';
$errob = '';
$indent = '';
$first = 0;
$noref = 0;
$depth = 0;
$colwidth = 100; # width of delimited string reflow
$context = 50; # number of lines to report on error
@objects = ();
$root = {}; # root object

$root->{gdmos} = {};
$root->{oids} = {};

undef $/; # suck entire file

if (($gdmo = Gdmo->parse($file))) {
	$gdmo->generate('xref');
	$gdmo->generate('gdmo');
} else {
	print STDERR "PARSE FAILED!";
}

# vim: ft=perl comments=b\:#,b\:##,b\:#\! formatoptions+=tcqlorn
