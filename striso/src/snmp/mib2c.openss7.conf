# mib2c.storage.conf:
#
#  This is a special mib2c.conf file that assumes that you want to do
#  all storage of information locally rather than pulling the
#  information from another source outside the agent (EG, the
#  kernel).  To accomplish this, it defines a structure for the
#  storage of tables and assumes you want to use the header_complex
#  functions for retrieving and storing that data in a local data
#  store.  It even writes a .conf file parser for you and sets you up
#  for being able to do persistant storage fairly simply.
#
#  In short:  it trys to do almost all of the work for you...  Almost...

#
# Define types of data by mib type, and translate into needed C code.
#

# We need to get some extra stuff into the variable declarations
# before sourcing the main mib2c.vartypes.conf file below.
type:		OCTETSTR
storage:	uint8_t *${name};
storage:	size_t ${name}Len;
tmpsize:	StorageTmp->${name}Len
varlencheck:	2 > var_val_len || var_val_len > SPRINT_MAX_LEN
vartest:	if (StorageTmp->${name} == NULL) {
vartest:		config_perror(\"invalid specification for ${name}\");
vartest:		return;
vartest:	}
vartest:	
reserve2:	if ((string = malloc(var_val_len)) == NULL)
reserve2:		return SNMP_ERR_RESOURCEUNAVAILABLE;
reserve2:	memcpy((void *)string, (void *)var_val, var_val_len);
free:		SNMP_FREE(string);
action:		old_value = StorageTmp->$name;
action:		old_length = StorageTmp->${name}Len;
action:		StorageTmp->$name = string;
action:		StorageTmp->${name}Len = var_val_len;
undo:		StorageTmp->${name} = old_value;
undo:		StorageTmp->${name}Len = old_length;
commit:		SNMP_FREE(old_value);
commit:		old_length = 0;
commit:		string = NULL;
deletevar:	SNMP_FREE(StorageDel->${name});
deletevar:	StorageDel->${name}Len = 0;
sizeofstart:	
sizeofend:	Len
tmpvar:		uint8_t *
varname:	string
varinit:	static size_t old_length = 0;
varinit:	static uint8_t *string = NULL;
casttmp:	strdup((uint8_t *) old_value);
action2:	memdup((void *) &StorageNew->$name, vp->val.string, vp->val_len);
action2:	StorageNew->${name}Len = vp->val_len;
action3:	StorageNew->${name} = strdup(\"$mib->{defaultValue}\");
action3:	StorageNew->${name}Len = strlen(\"$mib->{defaultValue}\");\n
#
type:		INTEGER
storage:	long $name;
tmpsize:	tmpsize
varlencheck:	var_val_len > sizeof(int32_t)
storageret:	&
sizeofstart:	sizeof(
sizeofend:	)
tmpvar:		long
varname:	set_value
varinit:	long set_value = *((long *) var_val);
action:		old_value = StorageTmp->$name;
action:		StorageTmp->${name} = set_value;
undo:		StorageTmp->${name} = old_value;
casttmp:	old_value;
action2:	StorageNew->$name = *vp->val.integer;
action3:	StorageNew->${name} = $mib->{defaultValue};\n
#
type:		UNSIGNED32
storage:	ulong $name;
tmpsize:	tmpsize
varlencheck:	var_val_len > sizeof(uint32_t)
storageret:	&
sizeofstart:	sizeof(
sizeofend:	)
tmpvar:		ulong
varname:	set_value
varinit:	ulong set_value = *((ulong *) var_val);
action:		old_value = StorageTmp->$name;
action:		StorageTmp->${name} = set_value;
undo:		StorageTmp->${name} = old_value;
casttmp:	old_value;
action2:	StorageNew->$name = *vp->val.integer;
action3:	StorageNew->${name} = $mib->{defaultValue};\n
#
type:		OBJECTID
storage:	oid *$name;
storage:	size_t ${name}Len;
tmpsize:	StorageTmp->${name}Len
varsize:	* sizeof(oid)
varlencheck:	MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)
vartest:	if (StorageTmp->${name} == NULL) {
vartest:		config_perror(\"invalid specification for ${name}\");
vartest:		return;
vartest:	}
vartest:	
reserve2:	if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
reserve2:		return SNMP_ERR_RESOURCEUNAVAILABLE;
free:		SNMP_FREE(objid);
action:		old_value = StorageTmp->$name;
action:		old_length = StorageTmp->${name}Len;
action:		StorageTmp->$name = objid;
action:		StorageTmp->${name}Len = var_val_len/sizeof(oid);
undo:		StorageTmp->${name} = old_value;
undo:		StorageTmp->${name}Len = old_length;
commit:		SNMP_FREE(old_value);
commit:		old_length = 0;
commit:		objid = NULL;
deletevar:	SNMP_FREE(StorageDel->${name});
deletevar:	StorageDel->${name}Len = 0;
sizeofstart:	
sizeofend:	Len
tmpvar:		oid *
varname:	objid
varinit:	static size_t old_length = 0;
varinit:	static oid *objid = NULL;
casttmp:	(oid *) old_value;
freetmp:	SNMP_FREE(old_value);
action2:	memdup((void *) &StorageNew->$name, (uint8_t *)vp->val.oid, vp->val_len);
action2:	StorageNew->${name}Len = vp->val_len/sizeof(oid);
action3:	 /* StorageNew->${name} = $mib->{defaultValue}; */\n
#
type:		COUNTER64
storage:	struct counter64 $name;
tmpsize:	tmpsize
varlencheck:	var_val_len > sizeof(uint64_t)
storageret:	&
sizeofstart:	sizeof(
sizeofend:	)
tmpvar:		struct counter64
varname:	c64
varinit:	struct counter64 c64 = *((struct counter64 *) var_val);
action:		old_value = StorageTmp->$name;
action:		StorageTmp->${name} = c64;
undo:		StorageTmp->${name} = old_value;
casttmp:	old_value;
action2:	StorageNew->$name = *vp->val.counter64;
action3:	StorageNew->${name} = 0;\n

############################################################################
# source variable typing information:
include: mib2c.vartypes.conf

# Begin code template section
############################################################################
# variable statemnts used in a couple of places below
############################################################################
type:	code-varInits
code:	 /* variables we may use later */
code:	static long long_ret;
code:	static ulong ulong_ret;
code:	static uint8_t string[SPRINT_MAX_LEN];
code:	static oid objid[MAX_OID_LEN];
code:	static struct counter64 c64;

############################################################################
# The .h file
############################################################################
type:	code-dot-h
code:	/*****************************************************************************
code:	
code:	 \@(#) \$Id\$
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 Copyright (c) 2008-2009  Monavacom Limited <http://www.monavacom.com/>
code:	 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
code:	 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock\@openss7.org>
code:	
code:	 All Rights Reserved.
code:	
code:	 This program is free software; you can redistribute it and/or modify it under
code:	 the terms of the GNU Affero General Public License as published by the Free
code:	 Software Foundation; version 3 of the License.
code:	
code:	 This program is distributed in the hope that it will be useful, but WITHOUT
code:	 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
code:	 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
code:	 details.
code:	
code:	 You should have received a copy of the GNU Affero General Public License
code:	 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
code:	 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
code:	 02139, USA.
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
code:	 behalf of the U.S. Government (\"Government\"), the following provisions apply
code:	 to you.  If the Software is supplied by the Department of Defense (\"DoD\"), it
code:	 is classified as \"Commercial Computer Software\" under paragraph 252.227-7014
code:	 of the DoD Supplement to the Federal Acquisition Regulations (\"DFARS\") (or any
code:	 successor regulations) and the Government is acquiring only the license rights
code:	 granted herein (the license rights customarily provided to non-Government
code:	 users).  If the Software is supplied to any unit or agency of the Government
code:	 other than DoD, it is classified as \"Restricted Computer Software\" and the
code:	 Government's rights in the Software are defined in paragraph 52.227-19 of the
code:	 Federal Acquisition Regulations (\"FAR\") (or any successor regulations) or, in
code:	 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
code:	 (or any successor regulations).
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 Commercial licensing and support of this software is available from OpenSS7
code:	 Corporation at a fee.  See http://www.openss7.com/
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 Last Modified \$Date\$ by \$Author\$
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 \$Log\$
code:	 *****************************************************************************/
code:	
code:	#ifndef __LOCAL_${MIBNAME}_H__
code:	#define __LOCAL_${MIBNAME}_H__
code:	
code:	#ident \"\@(#) \$RCSfile\$ \$Name\$(\$Revision\$) Copyright (c) 2008-2009 Monavacom Limited.\"
code:	
code:	/*
code:	 * This file was generated by mib2c and is intended for use as a mib module
code:	 * for the ucd-snmp snmpd agent.
code:	 */
code:	/* our storage structure(s) */
code:	struct ${mibName}_data { uint ${mibName}_request; $variables{'code-structure-mib'}{'processed'} };
code:	$variables{'code-structure-per-table'}{'processed'}
code:	/* storage declarations */
code:	extern struct ${mibName}_data *${mibName}Storage;
code:	$variables{'code-structure-storage-declaration'}{'processed'}
code:	/* enum definitions from the covered mib sections */
code:	$variables{'code-enums'}{'processed'}
code:	/* notifications */
code:	$variables{'code-declarations-notifications'}{'processed'}
code:	/* scalars accessible only for notify */
code:	$variables{'code-declarations-parameters'}{'processed'}
code:	/* object id definitions */
code:	$variables{'code-declarations-oids'}{'processed'}
code:	/* function prototypes */
code:	void   init_$mibName(void);
code:	void   deinit_$mibName(void);
code:	int term_$mibName(int majorID, int minorID, void *serverarg, void *clientarg);
code:	FindVarMethod var_$mibName;
code:	void parse_$mibName(const char *, char *);
code:	SNMPCallback store_$mibName;
code:	void refresh_$mibName(void);
code:	$variables{'code-var-table-decl'}{'processed'}
code:	$variables{'code-write-func-decl'}{'processed'}
code:	#endif /* __LOCAL_${MIBNAME}_H__ */

#
# Table refresh variable declarations.
#
type:		code-refresh-decl
processtable:	code-refresh-decl
code:	volatile int ${vtable}_refresh = 1;
#
# Structure definition line.
#
type:		code-structure-mib
process:	code-structure-mib
skipif:		$vroutine ne $mibName || $mib->{'access'} =~ /NoAccess|Notify/
code:	" . eval ("\"$variables{$mib->{'type'}}{'storage'}\"") . "

#
# Structure definition, one per table
#
type:		code-structure-per-table
processtable:	code-structure-per-table
code:	struct ${vtable}_data { uint ${vtable}_request; uint ${vtable}_refs; $variables{$vtable}{'code-structure'}{'processed'} };

#
# Structure storage arrays, one per table
#
type:		code-structure-storage
processtable:	code-structure-storage
code:	struct header_complex_index *${vtable}Storage = NULL;

#
# Strucutre storage declarations, one per table
#
type:		code-structure-storage-declaration
processtable:	code-structure-storage-declaration
code:	extern struct header_complex_index *${vtable}Storage;

#
# Structure definition line.
#
type:		code-structure
process:	code-structure
code:	" . eval ("\"$variables{$mib->{'type'}}{'storage'}\"") . "
#
# ENUM definitions
#
type:		code-enums
process:	code-enums
skipif:		$mib->{'textualConvention'} eq "RowStatus" || $mib->{'textualConvention'} eq "StorageType"
code:	" . eval{ my ($i, $x); foreach $i (sort {$mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}} keys(%{$mib->{'enums'}})) { $x .= sprintf("#define %-40s %d\n","${NAME}_" . uc($i),$mib->{'enums'}{$i}); } $x =~ s/-/_/g; $x; } . "\n
#
# OID definitions
#
type:		code-declarations-oids
processoid:	code-declarations-oids
skipif:		$name eq $mibName || $mib->{type} eq "NOTIF"
code:	extern oid ${name}_oid[" .( countsubs $mib->{'objectID'} ). "];
#
# OID definitions
#
type:		code-declarations-notifications
processoid:	code-declarations-notifications
skipif:		$mib->{type} ne "NOTIF"
code:	extern oid ${name}_oid[" .( countsubs $mib->{'objectID'} ). "];
#
# OID definitions
#
type:		code-declarations-parameters
process:	code-declarations-parameters
skipif:		$vroutine ne $mibName || $mib->{'access'} ne "Notify" || $variables{$vroutine}{$i}{'isanindex'} == 1
code:	extern oid ${name}_oid[" .( countsubs $mib->{'objectID'} ). "];

############################################################################
# The .c file, top
############################################################################
type:	code-main-part
code:	/*****************************************************************************
code:	
code:	 \@(#) \$RCSfile\$ \$Name\$(\$Revision\$) \$Date\$
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 Copyright (c) 2008-2009  Monavacom Limited <http://www.monavacom.com/>
code:	 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
code:	 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock\@openss7.org>
code:	
code:	 All Rights Reserved.
code:	
code:	 This program is free software: you can redistribute it and/or modify it under
code:	 the terms of the GNU Affero General Public License as published by the Free
code:	 Software Foundation, version 3 of the license.
code:	
code:	 This program is distributed in the hope that it will be useful, but WITHOUT
code:	 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
code:	 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
code:	 details.
code:	
code:	 You should have received a copy of the GNU Affero General Public License
code:	 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
code:	 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
code:	 02139, USA.
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
code:	 behalf of the U.S. Government (\"Government\"), the following provisions apply
code:	 to you.  If the Software is supplied by the Department of Defense (\"DoD\"), it
code:	 is classified as \"Commercial Computer Software\" under paragraph 252.227-7014
code:	 of the DoD Supplement to the Federal Acquisition Regulations (\"DFARS\") (or any
code:	 successor regulations) and the Government is acquiring only the license rights
code:	 granted herein (the license rights customarily provided to non-Government
code:	 users).  If the Software is supplied to any unit or agency of the Government
code:	 other than DoD, it is classified as \"Restricted Computer Software\" and the
code:	 Government's rights in the Software are defined in paragraph 52.227-19 of the
code:	 Federal Acquisition Regulations (\"FAR\") (or any successor regulations) or, in
code:	 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
code:	 (or any successor regulations).
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 Commercial licensing and support of this software is available from OpenSS7
code:	 Corporation at a fee.  See http://www.openss7.com/
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 Last Modified \$Date\$ by \$Author\$
code:	
code:	 -----------------------------------------------------------------------------
code:	
code:	 \$Log\$
code:	 *****************************************************************************/
code:	
code:	#ident \"\@(#) \$RCSfile\$ \$Name\$(\$Revision\$) \$Date\$\"
code:	
code:	static char const ident[] = \"\$RCSfile\$ \$Name\$(\$Revision\$) \$Date\$\";
code:	
code:	/* This file was generated by mib2c and is intended for use as
code:	   a mib module for the ucd-snmp snmpd agent. */
code:	#include <ucd-snmp/ucd-snmp-config.h>
code:	#include <ucd-snmp/ucd-snmp-includes.h>
code:	#include <ucd-snmp/ucd-snmp-agent-includes.h>
code:	#include <ucd-snmp/callback.h>
code:	#include <ucd-snmp/snmp-tc.h>
code:	#include <ucd-snmp/default_store.h>
code:	#include <ucd-snmp/snmp_alarm.h>
code:	/* The following header files are mangled in most recent net-snmp releases so
code:	 * the versions from UCD-SNMP 4.2.5 are included here.  */
code:	#if defined HAVE_LIBNETSNMP
code:	#else  /* defined HAVE_LIBNETSNMP */
code:	#endif /* defined HAVE_LIBNETSNMP */
code:	/* These are messed up on both. */
code:	#include \"ds_agent.h\"
code:	#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
code:	#include <ucd-snmp/util_funcs.h>
code:	/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
code:	int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
code:	#else  /* HAVE_UCD_SNMP_UTIL_FUNCS_H */
code:	#include \"util_funcs.h\"
code:	#endif /* HAVE_UCD_SNMP_UTIL_FUNCS_H */
code:	#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
code:	#include <ucd-snmp/header_complex.h>
code:	#else  /* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
code:	#include \"header_complex.h\"
code:	#endif /* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
code:	/* This one is the other way around: it is just fine for net-snmp, but
code:	 * ucd-snmp does not provide the header file at all.  */
code:	#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
code:	#include <ucd-snmp/mib_modules.h>
code:	#else  /* HAVE_UCD_SNMP_MIB_MODULES_H */
code:	#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
code:	#include <net-snmp/agent/mib_modules.h>
code:	#else  /* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
code:	#include \"mib_modules.h\"
code:	#endif /* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
code:	#endif /* HAVE_UCD_SNMP_MIB_MODULES_H */
code:	#include <stdint.h>
code:	#include <signal.h>
code:	#include <sys/stat.h>		/* for struct stat, fstat() */
code:	#include <sys/types.h>
code:	#include <unistd.h>
code:	#include <stdlib.h>
code:	#include <pwd.h>		/* for getpwuid() getpwnam() */
code:	#include <grp.h>		/* for getgrgid() getgrnam() */
code:	#include <libgen.h>		/* for basename() */
code:	#include <fcntl.h>		/* for O_CREAT */
code:	#include <sys/sysctl.h>		/* for sysctl */
code:	#include <errno.h>
code:	#include <string.h>
code:	#ifdef _GNU_SOURCE
code:	#include <getopt.h>
code:	#endif
code:	#include \"$outputName.h\"
code:	const char sa_program[] = \"$mibname\";
code:	#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
code:	#if !defined MODULE
code:	int sa_dump = 0;		/* default packet dump */
code:	int sa_debug = 0;		/* default no debug */
code:	int sa_nomead = 1;		/* default daemon mode */
code:	int sa_output = 1;		/* default normal output */
code:	int sa_agentx = 1;		/* default agentx mode */
code:	int sa_alarms = 1;		/* default application alarms */
code:	int sa_fclose = 1;		/* default close files between requests */
code:	int sa_logaddr = 0;		/* log addresses */
code:	int sa_logfillog = 0;		/* log to sa_logfile */
code:	int sa_logstderr = 0;		/* log to standard error */
code:	int sa_logstdout = 0;		/* log to standard output */
code:	int sa_logsyslog = 0;		/* log to system logs */
code:	int sa_logcallog = 0;		/* log to callback logs */
code:	int sa_appendlog = 0;		/* append to log file without truncating */
code:	char sa_logfile[256] = \"/var/log/$mibname.log\";
code:	char sa_pidfile[256] = \"/var/run/$mibname.pid\";
code:	char sa_sysctlf[256] = \"/etc/$mibname.conf\";
code:	int allow_severity = LOG_ERR;
code:	int deny_severity = LOG_ERR;
code:	/* file stream for log file */
code:	FILE *stdlog = NULL;
code:	/* file descriptor for MIB use */
code:	int sa_fd = 0;
code:	/* indication to reread MIB configuration */
code:	int sa_changed = 1;
code:	/* indications that statistics, the mib or its tables need to be refreshed */
code:	int sa_stats_refresh = 1;
code:	#endif /* !defined MODULE */
code:	/* request number for per-request actions */
code:	int sa_request = 1;
code:	volatile int ${mibName}_refresh = 1;
code:	$variables{'code-refresh-decl'}{'processed'}
code:	/*
code:	 * ${mibName}_variables_oid: object identifier for $mibName
code:	 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
code:	 * suffix appearing in the variable below.
code:	 */
code:	oid ${mibName}_variables_oid[] = { $commaoid };
code:	$variables{'code-write-rowstatus-oid'}{'processed'}
code:	/*
code:	 * Oids for use in notifications defined in this MIB.
code:	 */
code:	$variables{'code-definitions-notifications'}{'processed'}
code:	/*
code:	 * Oids accessible only for notify defined in this MIB.
code:	 */
code:	$variables{'code-definitions-parameters'}{'processed'}
code:	/*
code:	 * Other oids defined in this MIB.
code:	 */
code:	$variables{'code-definitions-oids'}{'processed'}
code:	/*
code:	 * variable$varlen ${mibName}_variables: tree for $mibName
code:	 * This variable defines function callbacks and type return information for the $mibName mib section
code:	 */
code:	struct variable$varlen ${mibName}_variables[] = {
code:		 /* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
code:		$variables{'variable-structure-info'}{'processed'}
code:	};
code:	/* (L = length of the oidsuffix) */
code:	struct ${mibName}_data *${mibName}Storage = NULL;
code:	/* global storage of our data, saved in and configured by header_complex() */
code:	$variables{'code-structure-storage'}{'processed'}
code:	/*
code:	 * init_$mibName(): Initialization routine.
code:	 * This is called when the agent starts up.  At a minimum, registration of your variables should
code:	 * take place here.
code:	 */
code:	void
code:	init_$mibName(void)
code:	{
code:		DEBUGMSGTL((\"$mibName\", \"initializing...  \"));
code:		 /* register ourselves with the agent to handle our mib tree */
code:		REGISTER_MIB(\"$mibName\", ${mibName}_variables, variable$varlen, ${mibName}_variables_oid);
code:		snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_$mibName, NULL);
code:		 /* register our config handler(s) to deal with registrations */
code:		snmpd_register_config_handler(\"$mibName\", parse_$mibName, NULL, \"HELP STRING\"); $variables{'code-parser-registration'}{'processed'}
code:		 /* we need to be called back later to store our data */
code:		snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_$mibName, NULL); $variables{'code-store-registration'}{'processed'}
code:		 /* place any other initialization junk you need here */
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	/*
code:	 * deinit_$mibName(): Deinitialization routine.
code:	 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
code:	 * should take place here.
code:	 */
code:	void
code:	deinit_$mibName(void)
code:	{
code:		DEBUGMSGTL((\"$mibName\", \"deinitializating...  \"));
code:		unregister_mib(${mibName}_variables_oid, sizeof(${mibName}_variables_oid)/sizeof(oid));
code:		snmpd_unregister_config_handler(\"$mibName\"); $variables{'code-parser-deregistration'}{'processed'}
code:		 /* place any other de-initialization junk you need here */
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	int
code:	term_$mibName(int majorID, int minorID, void *serverarg, void *clientarg)
code:	{
code:		deinit_$mibName();
code:		return 0;
code:	}
code:	/**
code:	 * \@fn struct ${mibName}_data *${mibName}_create(void)
code:	 * \@brief create a fresh data structure representing scalars in ${mibName}.
code:	 * Creates a new ${mibName}_data structure by allocating dynamic memory for the structure and
code:	 * initializing the default values of scalars in ${mibName}.
code:	 */
code:	struct ${mibName}_data *
code:	${mibName}_create(void)
code:	{
code:		struct ${mibName}_data *StorageNew = SNMP_MALLOC_STRUCT(${mibName}_data);
code:		DEBUGMSGTL((\"$mibName\", \"creating scalars...  \"));
code:		if (StorageNew != NULL) {
code:			 /* XXX: fill in default scalar values here into StorageNew */
code:			$variables{$mibName}{'code-default-values'}{'processed'}
code:		}
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return (StorageNew);
code:	}
code:	/**
code:	 * \@fn int ${mibName}_destroy(struct ${mibName}_data **thedata)
code:	 * \@brief delete a scalars structure from $mibName.
code:	 * \@param thedata pointer to the data structure in ${mibName}.
code:	 * Frees scalars that were previously removed from $mibName.  Note that the strings associated
code:	 * with octet strings, object identifiers and bit strings still attached to the structure will also
code:	 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
code:	 * NULL.
code:	 */
code:	int
code:	${mibName}_destroy(struct ${mibName}_data **thedata)
code:	{
code:		struct ${mibName}_data *StorageDel;
code:		DEBUGMSGTL((\"$mibName\", \"deleting scalars...  \"));
code:		if ((StorageDel = *thedata) != NULL) { $variables{$mibName}{'code-delete-scalars'}{'processed'}
code:			SNMP_FREE(StorageDel);
code:			*thedata = StorageDel;
code:		}
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn int ${mibName}_add(struct ${mibName}_data *thedata)
code:	 * \@param thedata the structure representing $mibName scalars.
code:	 * \@brief adds node to the ${mibName} scalar data set.
code:	 * Adds a scalar structure to the ${mibName} data set.  Note that this function is necessary even
code:	 * when the scalar values are not peristent.
code:	 */
code:	int
code:	${mibName}_add(struct ${mibName}_data *thedata)
code:	{
code:		DEBUGMSGTL((\"$mibName\", \"adding data...  \"));
code:		${mibName}Storage = thedata;
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn void parse_$mibName(const char *token, char *line)
code:	 * \@param token token used within the configuration file.
code:	 * \@param line line from configuration file matching the token.
code:	 * \@brief parse configuration file for $mibName entries.
code:	 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
code:	 * file line for the registsred token (in this case ${mibName}).  This routine is invoked by
code:	 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
code:	 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
code:	 * in the configuration MIB, this function will simply not be called.
code:	 */
code:	void
code:	parse_${mibName}(const char *token, char *line)
code:	{
code:		size_t tmpsize;
code:		struct ${mibName}_data *StorageTmp = ${mibName}_create();
code:		DEBUGMSGTL((\"$mibName\", \"parsing config...  \"));
code:		if (StorageTmp == NULL) {
code:			config_perror(\"malloc failure\");
code:			return;
code:		}
code:		 /* XXX: remove individual scalars that are not persistent */
code:		$variables{'code-config-scalar'}{'processed'} ${mibName}_add(StorageTmp);
code:		(void) tmpsize;
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	/*
code:	 * store_${mibName}(): stores .conf file entries needed to configure the mib.
code:	 */
code:	int
code:	store_$mibName(int majorID, int minorID, void *serverarg, void *clientarg)
code:	{
code:		char line[SNMP_MAXBUF];
code:		char *cptr;
code:		size_t tmpsize;
code:		struct ${mibName}_data *StorageTmp;
code:		DEBUGMSGTL((\"$mibName\", \"storing data...  \"));
code:		refresh_${mibName}();
code:		if ((StorageTmp = ${mibName}Storage) == NULL) {
code:			DEBUGMSGTL((\"$mibName\", \"error.\\n\"));
code:			return SNMPERR_GENERR;
code:		}
code:		(void) tmpsize;
code:		 /* XXX: comment entire section if no scalars are persistent */
code:		{
code:			memset(line,0,sizeof(line));
code:			strcat(line, \"$mibName \");
code:			cptr = line + strlen(line);
code:			 /* XXX: remove individual scalars that are not persistent */
code:			$variables{$mibName}{'code-persistent-scalars'}{'processed'} snmpd_store_config(line);
code:		}
code:		DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn void refresh_$mibName(void)
code:	 * \@brief refresh the scalar values of $mibName.
code:	 * Normally the values retrieved from the operating system are cached.  When the agent receives a
code:	 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
code:	 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
code:	 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
code:	 * time, or after a SIGPOLL has been received (and a scalar has been requested).
code:	 */
code:	void
code:	refresh_$mibName(void)
code:	{
code:		if (${mibName}Storage == NULL) {
code:			struct ${mibName}_data *StorageNew;
code:			if ((StorageNew = ${mibName}_create()) == NULL)
code:				return;
code:			${mibName}Storage = StorageNew;
code:			${mibName}_refresh = 1;
code:		}
code:		if (${mibName}_refresh == 0)
code:			return;
code:		${mibName}_refresh = 0;
code:		 /* XXX: Update scalars as required here... */
code:	}
/**
 * \@fn u_char * var_$mibName(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * \@param vp a pointer to the entry in the variables table for the requested variable.
 * \@param name the object identifier for which to find.
 * \@param length the length of the object identifier.
 * \@param exact whether the name is exact.
 * \@param var_len a pointer to the length of the representation of the object.
 * \@param write_method a pointer to a write method for the object.
 * \@brief locate variables in $mibName.
 * This function returns a pointer to a memory area that is static across the request that contains
 * the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
 * GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
 * telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
 * overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
 * writing.  Write-only objects can be effected in this way.
 */
code:	u_char *
code:	var_$mibName(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
code:	{
code:		struct ${mibName}_data *StorageTmp;
code:		if (header_generic(vp,name,length,exact,var_len,write_method) == MATCH_FAILED)
code:			return NULL;
code:		 /* Refresh the MIB values if required. */
code:		refresh_$mibName();
code:		if ((StorageTmp = ${mibName}Storage) == NULL)
code:			return NULL;
code:		 /* This is where we do the value assignments for the mib results. */
code:		switch(vp->magic) { $variables{$mibName}{'code-case-statements'}{'processed'}
code:		default:
code:			ERROR_MSG(\"\");
code:		}
code:		return NULL;
code:	}
code:	$variables{'code-parser'}{'processed'}
code:	$variables{'code-var-table'}{'processed'}
code:	$variables{'code-write-func'}{'processed'}
code:	$variables{'code-write-scalar-func'}{'processed'}
code:	$variables{'code-write-rowstatus'}{'processed'}
code:	#if !defined MODULE
code:	static void
code:	sa_version(int argc, char *argv[])
code:	{
code:		if (!sa_output && !sa_debug)
code:			return;
code:		fprintf(stdout, \"\\
code:	%2\$s\\n\\
code:	Copyright (c) 2008-2009  Monavacom Limited.  All Rights Reserved.\\n\\
code:	Distributed under Affero GPL Version 3, included here by reference.\\n\\
code:	See `%1\$s --copying' for copying permissions.\\n\\
code:	\", argv[0], ident);
code:	}
code:	static void
code:	sa_usage(int argc, char *argv[])
code:	{
code:		if (!sa_output && !sa_debug)
code:			return;
code:		fprintf(stderr, \"\\
code:	Usage:\\n\\
code:	    %1\$s [general-options] [options] [arguments]\\n\\
code:	    %1\$s {-H|--help-directives}\\n\\
code:	    %1\$s {-h|--help}\\n\\
code:	    %1\$s {-V|--version}\\n\\
code:	    %1\$s {-C|--copying}\\n\\
code:	\", argv[0]);
code:	}
code:	static void
code:	sa_help(int argc, char *argv[])
code:	{
code:		if (!sa_output && !sa_debug)
code:			return;
code:		fprintf(stdout, \"\\
code:	Usage:\\n\\
code:	    %1\$s [general-options] [options] [arguments]\\n\\
code:	    %1\$s {-h|--help}\\n\\
code:	    %1\$s {-V|--version}\\n\\
code:	    %1\$s {-C|--copying}\\n\\
code:	Arguments:\\n\\
code:	    None.\\n\\
code:	Options:\\n\\
code:	    -a, --log-addresses\\n\\
code:	        log addresses of connecting management stations.\\n\\
code:	    -A, --append\\n\\
code:	        append to logfiles without truncating.\\n\\
code:	    -c, --config-file CONFIGFILE\\n\\
code:	        use configuration file CONFIGFILE.\\n\\
code:	    -C, --config-only\\n\\
code:	        only load configuration given by -c option.\\n\\
code:	    -d, --dump\\n\\
code:	        dump sent and received PDUs.\\n\\
code:	    -D, --debug [LEVEL]\\n\\
code:	        set debugging verbosity to LEVEL.\\n\\
code:	    -D, --debug-tokens [TOKEN[,TOKEN]*]\\n\\
code:	        debug specified TOKEN's.\\n\\
code:	    -f, --dont-fork\\n\\
code:	        run in the foreground.\\n\\
code:	    -g, --gid, --groupid GID\\n\\
code:	        become group GID after listening.\\n\\
code:	    -h, --help, -?, --?\\n\\
code:	        print usage information and exit.\\n\\
code:	    -H, --help-directives\\n\\
code:	        print config directives and exit.\\n\\
code:	    -I, --initialize [-]MODULE[,MODULE]*\\n\\
code:	        initialize (or not, '-') these MODULE's.\\n\\
code:	    -k, --keep-open\\n\\
code:	        keep system files open between requests.\\n\\
code:	    -l, --log-file [LOGFILE]\\n\\
code:	        log to log file name LOGFILE.  [default: /var/log/$mibname.log]\\n\\
code:	    -L, --log-stderr\\n\\
code:	        log to controlling terminal standard error.\\n\\
code:	    -m, --mibs [+]MIB[,MIB]*\\n\\
code:	        load these (additional '+') MIBs.\\n\\
code:	    -M, --master\\n\\
code:	        run as SNMP master instead of AgentX sub-agent.\\n\\
code:	    -M, --mibdirs [+]MIBDIR[:MIBDIR]*\\n\\
code:	        search these (additional, '+') colon separated directories for MIBs.\\n\\
code:	    -n, --nodaemon\\n\\
code:	        run in the foreground.\\n\\
code:	    -n, --name NAME\\n\\
code:	        use NAME for configuration file base.  [default: $mibname]\\n\\
code:	    -p, --port PORTNUM\\n\\
code:	        listen on port number PORTNUM.  [default: 161]\\n\\
code:	    -p, --pidfile PIDFILE\\n\\
code:	        write daemon pid to PIDFILE.  [default: /var/run/$mibname.pid]\\n\\
code:	    -P, --pidfile PIDFILE\\n\\
code:	        write daemon pid to PIDFILE.  [default: /var/run/$mibname.pid]\\n\\
code:	    -q, --quiet\\n\\
code:	        suppress normal output.\\n\\
code:	    -q, --quick\\n\\
code:	        abbreviate output for machine readability.\\n\\
code:	    -r, --noroot\\n\\
code:	        do not require root privilege.\\n\\
code:	    -s, --log-syslog\\n\\
code:	        log to system logs.\\n\\
code:	    -S, --sysctl-file FILENAME\\n\\
code:	        write sysctl config file FILENAME.  [default: /etc/streams.conf]\\n\\
code:	    -t, --agent-alarms\\n\\
code:	        agent blocks {SIGALARM}.\\n\\
code:	    -T, --transport [TRANSPORT]\\n\\
code:	        default transport TRANSPORT.  [default: udp]\\n\\
code:	    -u, --uid, --userid UID\\n\\
code:	        become user UID after listening.\\n\\
code:	    -U, --dont-remove-pidfile\\n\\
code:	        do not remove PIDFILE when shutting down.\\n\\
code:	    -v, --version\\n\\
code:	        print version information and exit.\\n\\
code:	    -V, --verbose [LEVEL]\\n\\
code:	        be verbose to LEVEL.  [default: 1]\\n\\
code:	    -x, --agentx-socket [SOCKET]\\n\\
code:	        master AgentX on SOCKET.  [default: /var/agentx/master]\\n\\
code:	    -X, --agentx\\n\\
code:	        run as AgentX sub-agent instead of master (the default).\\n\\
code:	    -y, --copying\\n\\
code:	        print copying information and exit.\\n\\
code:	\", argv[0]);
code:	}
code:	static void
code:	sa_copying(int argc, char *argv[])
code:	{
code:		if (!sa_output && !sa_debug)
code:			return;
code:		fprintf(stdout, \"\\
code:	--------------------------------------------------------------------------------\\n\\
code:	%1\$s\\n\\
code:	--------------------------------------------------------------------------------\\n\\
code:	Copyright (c) 2008-2009  Monavacom Limited <http://www.monavacom.com>\\n\\
code:	Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com>\\n\\
code:	Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock\@openss7.org>\\n\\
code:	\\n\\
code:	All Rights Reserved.\\n\\
code:	--------------------------------------------------------------------------------\\n\\
code:	This program is free software; you can  redistribute  it and/or modify  it under\\n\\
code:	the terms of the GNU Affero General Public License as published by the Free\\n\\
code:	Software Foundation; Version 3 of the License.\\n\\
code:	\\n\\
code:	This program is distributed in the hope that it will  be useful, but WITHOUT ANY\\n\\
code:	WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A\\n\\
code:	PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.\\n\\
code:	\\n\\
code:	You should have received a copy of the GNU  Affero  General Public License along\\n\\
code:	with this program.   If not, see <http://www.gnu.org/licenses/>, or write to the\\n\\
code:	Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\\n\\
code:	--------------------------------------------------------------------------------\\n\\
code:	U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf\\n\\
code:	of the U.S. Government (\\\"Government\\\"), the following provisions apply to you. If\\n\\
code:	the Software is supplied by the  Department of Defense (\\\"DoD\\\"), it is classified\\n\\
code:	as \\\"Commercial  Computer  Software\\\"  under  paragraph  252.227-7014  of the  DoD\\n\\
code:	Supplement  to the  Federal Acquisition Regulations  (\\\"DFARS\\\") (or any successor\\n\\
code:	regulations) and the  Government  is acquiring  only the  license rights granted\\n\\
code:	herein (the license rights customarily provided to non-Government users). If the\\n\\
code:	Software is supplied to any unit or agency of the Government  other than DoD, it\\n\\
code:	is  classified as  \\\"Restricted Computer Software\\\" and the Government's rights in\\n\\
code:	the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition\\n\\
code:	Regulations (\\\"FAR\\\")  (or any successor regulations) or, in the cases of NASA, in\\n\\
code:	paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor\\n\\
code:	regulations).\\n\\
code:	--------------------------------------------------------------------------------\\n\\
code:	Commercial  licensing  and  support of this  software is  available from OpenSS7\\n\\
code:	Corporation at a fee.  See http://www.openss7.com/\\n\\
code:	--------------------------------------------------------------------------------\\n\\
code:	\", ident);
code:	}
code:	void
code:	sa_help_directives(int argc, char *argv[])
code:	{
code:		ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
code:		init_agent(\"$mibName\");
code:		 // init_mib_modules();
code:		init_mib();
code:		init_snmp(\"$mibName\");
code:		snmp_log(MY_FACILITY(LOG_INFO), \"Configuration directives understood:\\n\");
code:		 /* Unfortunately, read_config_print_usage() uses snmp_log(), meaning that it can only be
code:		   writen to standard error and not standard output. */
code:		read_config_print_usage(\"    \");
code:	}
code:	static int
code:	sa_sig_register(int signum, RETSIGTYPE(*handler) (int))
code:	{
code:		sigset_t mask;
code:		struct sigaction act;
code:		act.sa_handler = handler ? handler : SIG_DFL;
code:		act.sa_flags = handler ? SA_RESTART : 0;
code:		sigemptyset(&act.sa_mask);
code:		if (sigaction(signum, &act, NULL))
code:			return (-1);
code:		sigemptyset(&mask);
code:		sigaddset(&mask, signum);
code:		sigprocmask(handler ? SIG_UNBLOCK : SIG_BLOCK, &mask, NULL);
code:		return (0);
code:	}
code:	static int sa_alm_signal = 0;
code:	static int sa_pol_signal = 0;
code:	static int sa_hup_signal = 0;
code:	static int sa_int_signal = 0;
code:	static int sa_trm_signal = 0;
code:	static int sa_alm_handle = 0;
code:	void
code:	sa_alm_callback(uint req, void *arg)
code:	{
code:		if (req == sa_alm_handle)
code:			sa_alm_handle = 0;
code:		sa_alm_signal = 1;
code:		return;
code:	}
code:	static RETSIGTYPE
code:	sa_alm_handler(int signum)
code:	{
code:		sa_alm_signal = 1;
code:		return (RETSIGTYPE) (0);
code:	}
code:	static void
code:	sa_snmp_alm_handler(uint reg, void *clientarg)
code:	{
code:		sa_alm_signal = 1;
code:		return;
code:	}
code:	static int
code:	sa_alm_catch(void)
code:	{
code:		if (sa_alarms)
code:			return sa_sig_register(SIGALRM, &sa_alm_handler);
code:		return (-1);
code:	}
code:	static int
code:	sa_alm_block(void)
code:	{
code:		if (sa_alarms)
code:			return sa_sig_register(SIGALRM, NULL);
code:		if (sa_alm_handle) {
code:			uint handle = sa_alm_handle;
code:			sa_alm_handle = 0;
code:			snmp_alarm_unregister(handle);
code:		}
code:		return (0);
code:	}
code:	static int
code:	sa_alm_action(void)
code:	{
code:		sa_alm_signal = 0;
code:		return (0);
code:	}
code:	static RETSIGTYPE
code:	sa_pol_handler(int signum)
code:	{
code:		sa_pol_signal = 1;
code:		return (RETSIGTYPE) (0);
code:	}
code:	static int
code:	sa_pol_catch(void)
code:	{
code:		return sa_sig_register(SIGPOLL, &sa_pol_handler);
code:	}
code:	static int
code:	sa_pol_block(void)
code:	{
code:		return sa_sig_register(SIGPOLL, NULL);
code:	}
code:	/*
code:	 * Both the sc(4) module and sad(4) driver issue an M_PCSIG message with
code:	 * SIGPOLL to the stream head whenever the STREAMS configuration or autopush
code:	 * configuration changes, indicating to the agent which has the sc(4) or
code:	 * sad(4) Stream open that it is necessary to reread information from the
code:	 * kernel.  This fact is merely recorded, as this information is not read each
code:	 * time that a configuration change occurs, but only after a request from some
code:	 * portion of that information occurs. This condition is also set when the
code:	 * sc(4) and sad(4) Streams are first opened. The SIGPOLL will also deliver in
code:	 * siginfo the file descriptor issuing the signal, so we could distiguish
code:	 * between sc(4) and sad(4) signals, but since one can be pushed over the
code:	 * other, there is little point in distinguishing.
code:	 *
code:	 * sc(4) or sad(4) also should be modified to provide the general streams
code:	 * statistics supported here; even though they are available through the /proc
code:	 * filesystem on Linux Fast-STREAMS.
code:	 */
code:	static int
code:	sa_pol_action(void)
code:	{
code:		sa_pol_signal = 0;
code:		snmp_log(MY_FACILITY(LOG_INFO), \"%s: Caught SIGPOLL, will re-read data structures\",
code:			 sa_program);
code:		sa_changed = 1;
code:		return (0);
code:	}
code:	static RETSIGTYPE
code:	sa_hup_handler(int signum)
code:	{
code:		sa_hup_signal = 1;
code:		return (RETSIGTYPE) (0);
code:	}
code:	static int
code:	sa_hup_catch(void)
code:	{
code:		if (sa_agentx)
code:			return sa_sig_register(SIGHUP, &sa_hup_handler);
code:		return (-1);
code:	}
code:	static int
code:	sa_hup_block(void)
code:	{
code:		return sa_sig_register(SIGHUP, NULL);
code:	}
code:	static int
code:	sa_hup_action(void)
code:	{
code:		 /* There are several times that we might be sent a SIGHUP.  We might be sent a SIGHUP by
code:		   logrotate asking us to close and reopen our log files. */
code:		sa_hup_signal = 0;
code:		snmp_log(MY_FACILITY(LOG_WARNING), \"Caught SIGHUP, reopening files.\");
code:		if (sa_output > 1)
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"Reopening output file %s\", sa_logfile);
code:		if (sa_logfillog != 0) {
code:			fflush(stdlog);
code:			fclose(stdlog);
code:			snmp_disable_filelog();
code:			if ((stdlog = freopen(sa_logfile, sa_appendlog ? \"a\" : \"w\", stdlog)) == NULL) {
code:				 /* I hope we have another log sink. */
code:				snmp_log(MY_FACILITY(LOG_ERR), \"%s\", strerror(errno));
code:				snmp_log(MY_FACILITY(LOG_ERR), \"Could not reopen log file %s\", sa_logfile);
code:			}
code:			snmp_enable_filelog(sa_logfile, sa_appendlog);
code:		}
code:		return (0);
code:	}
code:	static RETSIGTYPE
code:	sa_int_handler(int signum)
code:	{
code:		sa_int_signal = 1;
code:		return (RETSIGTYPE) (0);
code:	}
code:	static int
code:	sa_int_catch(void)
code:	{
code:		return sa_sig_register(SIGINT, &sa_int_handler);
code:	}
code:	static int
code:	sa_int_block(void)
code:	{
code:		return sa_sig_register(SIGINT, NULL);
code:	}
code:	static void sa_exit(int retval);
code:	static int
code:	sa_int_action(void)
code:	{
code:		sa_int_signal = 0;
code:		snmp_log(MY_FACILITY(LOG_WARNING), \"%s: Caught SIGINT, shutting down\", sa_program);
code:		sa_exit(0);
code:		return (0);		/* should be no return */
code:	}
code:	static RETSIGTYPE
code:	sa_trm_handler(int signum)
code:	{
code:		sa_trm_signal = 1;
code:		return (RETSIGTYPE) (0);
code:	}
code:	static int
code:	sa_trm_catch(void)
code:	{
code:		return sa_sig_register(SIGTERM, &sa_trm_handler);
code:	}
code:	static int
code:	sa_trm_block(void)
code:	{
code:		return sa_sig_register(SIGTERM, NULL);
code:	}
code:	static void sa_exit(int retval);
code:	static int
code:	sa_trm_action(void)
code:	{
code:		sa_trm_signal = 0;
code:		snmp_log(MY_FACILITY(LOG_WARNING), \"%s: Caught SIGTERM, shutting down\", sa_program);
code:		sa_exit(0);
code:		return (0);		/* should be no return */
code:	}
code:	static void
code:	sa_sig_catch(void)
code:	{
code:		sa_alm_catch();
code:		sa_pol_catch();
code:		sa_hup_catch();
code:		sa_int_catch();
code:		sa_trm_catch();
code:	}
code:	static void
code:	sa_sig_block(void)
code:	{
code:		sa_alm_block();
code:		sa_pol_block();
code:		sa_hup_block();
code:		sa_int_block();
code:		sa_trm_block();
code:	}
code:	int
code:	sa_start_timer(long duration)
code:	{
code:		if (sa_alarms) {
code:			struct itimerval setting = {
code:				{0, 0},
code:				{duration / 1000, (duration % 1000) * 1000}
code:			};
code:			if (sa_alm_catch())
code:				return (-1);
code:			if (setitimer(ITIMER_REAL, &setting, NULL))
code:				return (-1);
code:			sa_alm_signal = 0;
code:			return (0);
code:		} else {
code:	#if defined NETSNMP_DS_APPLICATION_ID
code:			struct timeval setting = {
code:				duration / 1000, (duration % 1000) * 1000
code:			};
code:			sa_alm_handle = snmp_alarm_register_hr(setting, 0, sa_snmp_alm_handler, NULL);
code:	#else
code:			sa_alm_handle =
code:			    snmp_alarm_register((duration + 999) / 1000, 0, sa_snmp_alm_handler, NULL);
code:	#endif
code:			return (sa_alm_handle ? 0 : -1);
code:		}
code:	}
code:	static void
code:	sa_exit(int retval)
code:	{
code:		if (retval)
code:			snmp_log(MY_FACILITY(LOG_ERR), \"%s: Exiting %d\", sa_program, retval);
code:		else
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"%s: Exiting %d\", sa_program, retval);
code:		fflush(stdout);
code:		fflush(stderr);
code:		sa_sig_block();
code:		closelog();
code:		exit(retval);
code:	}
code:	static void
code:	sa_init_logging(int argc, char *argv[])
code:	{
code:		static char progname[256];
code:		 /* The purpose of this function is to bring logging up before forking (and while still in
code:		   the foreground) so that we can use the snmp_log() function before and during forking if
code:		   necessary.  Note that the default configuration for snmp_log() is to send all logs to
code:		   standard error. */
code:		strncpy(progname, basename(argv[0]), sizeof(progname));
code:		snmp_disable_log();
code:		if (sa_logfillog) {
code:			snmp_enable_filelog(sa_logfile, sa_appendlog);
code:		}
code:		if (sa_logstderr | sa_logstdout) {
code:	#if defined LOG_PERROR
code:			 /* Note that when we have Linux LOG_PERROR, and logs go both to syslog and stderr,
code:			   it is better to use the LOG_PERROR than to use snmp_log()'s print to stderr, as
code:			   the former is better formated. */
code:			if (!sa_logsyslog)
code:				snmp_enable_stderrlog();
code:	#else				/* defined LOG_PERROR */
code:			snmp_enable_stderrlog();
code:	#endif				/* defined LOG_PERROR */
code:		}
code:		if (sa_logsyslog) {
code:	#if !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT
code:			snmp_enable_syslog();
code:	#else				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
code:			snmp_enable_syslog_ident(\"$mibName\", LOG_DAEMON);
code:	#endif				/* !defined HAVE_SNMP_ENABLE_SYSLOG_IDENT */
code:			 /* Note that the way that snmp sets up the logger is not really the way we want it,
code:			   so close the log and reopen it the way we want. */
code:			closelog();
code:	#if defined LOG_PERROR
code:			openlog(\"$mibName\", LOG_PID | LOG_CONS | LOG_NDELAY | (sa_logstderr ? LOG_PERROR : 0),
code:				MY_FACILITY(0));
code:	#else				/* defined LOG_PERROR */
code:			openlog(\"$mibName\", LOG_PID | LOG_CONS | LOG_NDELAY, MY_FACILITY(0));
code:	#endif				/* defined LOG_PERROR */
code:		}
code:		if (sa_logcallog) {
code:			snmp_enable_calllog();
code:		}
code:	}
code:	static void
code:	sa_enter(int argc, char *argv[])
code:	{
code:		if (sa_nomead) {
code:			pid_t pid;
code:			if ((pid = fork()) < 0) {
code:				perror(argv[0]);
code:				exit(2);
code:			} else if (pid != 0) {
code:				 /* parent exits */
code:				exit(0);
code:			}
code:			setsid();	/* become a session leader */
code:			 /* fork once more for SVR4 */
code:			if ((pid = fork()) < 0) {
code:				perror(argv[0]);
code:				exit(2);
code:			} else if (pid != 0) {
code:				 /* parent responsible for writing pid file */
code:				if (sa_nomead || sa_pidfile[0] != '\\0') {
code:					FILE *pidf;
code:					 /* initialize default filename */
code:					if (sa_pidfile[0] == '\\0')
code:						snprintf(sa_pidfile, sizeof(sa_pidfile), \"/var/run/%s.pid\",
code:							 sa_program);
code:					if (sa_output > 1) {
code:						snmp_log(MY_FACILITY(LOG_NOTICE),
code:							 \"%s: Writing daemon pid to file %s\", sa_program,
code:							 sa_pidfile);
code:					}
code:					if ((pidf = fopen(sa_pidfile, \"w+\"))) {
code:						fprintf(pidf, \"%d\", (int) pid);
code:						fflush(pidf);
code:						fclose(pidf);
code:					} else {
code:						snmp_log(MY_FACILITY(LOG_ERR), \"%s: %m\", sa_program);
code:						snmp_log(MY_FACILITY(LOG_ERR),
code:							 \"%s: Could not write pid to file %s\", sa_program,
code:							 sa_pidfile);
code:						sa_exit(2);
code:						 /* no return */
code:					}
code:				}
code:				 /* parent exits */
code:				exit(0);
code:			}
code:			 /* child continues */
code:			 /* release current directory */
code:			if (chdir(\"/\") < 0) {
code:				perror(argv[0]);
code:				exit(2);
code:			}
code:			umask(0);	/* clear file creation mask */
code:			 /* rearrange file streams */
code:			fclose(stdin);
code:		}
code:		 /* continue as foreground or background */
code:		sa_init_logging(argc, argv);
code:		sa_sig_catch();
code:		snmp_log(MY_FACILITY(LOG_NOTICE), \"%s: Startup complete.\", sa_program);
code:	}
code:	static void
code:	sa_mloop(int argc, char *argv[])
code:	{
code:		if (sa_agentx) {
code:			if (sa_debug)
code:				snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: running as AgentX client\\n\", argv[0]);
code:			 /* run as an AgentX client */
code:			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
code:		} else {
code:			if (sa_debug)
code:				snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: running as SNMP master agent\\n\",
code:					 argv[0]);
code:			 /* run as SNMP master */
code:			ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
code:		}
code:		if (sa_alarms) {
code:			if (sa_debug)
code:				snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: using application alarms\\n\", argv[0]);
code:			 /* use application alarms */
code:			ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
code:		}
code:		 /* initialize agent */
code:		init_agent(\"$mibName\");
code:		 /* initialize MIB */
code:		init_$mibName();
code:		 /* initialize SNMP */
code:		init_snmp(\"$mibName\");
code:		if (!sa_agentx) {
code:			if (sa_debug)
code:				snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: running as SNMP master\\n\", argv[0]);
code:	#if !defined NETSNMP_DS_APPLICATION_ID
code:			init_master_agent(710, NULL, NULL);
code:	#else
code:			init_master_agent();
code:	#endif
code:		}
code:		for (;;) {
code:			int retval;
code:			 /* to use select or poll you need to use the snmp_select_info() to obtain the fd of
code:			   the agentx socket and add it to the fdset. */
code:			 /* note that SIGALRM is used by snmp: use the snmp_alarm() api instead */
code:	#if 0
code:			if (snmp_select() == 0) {
code:				if (sa_alarms == 0)
code:					run_alarms();
code:			}
code:	#endif
code:			retval = agent_check_and_process(1);	/* 0 == don't block */
code:			if (retval == 0) {
code:				 /* alarm occurred, alarm conditions checked */
code:			} else if (retval == -1) {
code:				 /* error (or signal) ocurred */
code:				if (sa_alm_signal) {
code:					sa_alm_action();
code:				}
code:				if (sa_pol_signal) {
code:					sa_pol_action();
code:				}
code:				if (sa_hup_signal) {
code:					sa_hup_action();
code:				}
code:				if (sa_int_signal) {
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: shutting down\\n\",
code:							 argv[0]);
code:					snmp_shutdown(\"$mibName\");
code:					sa_int_action();	/* no return */
code:				}
code:				if (sa_trm_signal) {
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: shutting down\\n\",
code:							 argv[0]);
code:					snmp_shutdown(\"$mibName\");
code:					sa_trm_action();	/* no return */
code:				}
code:			} else if (retval > 0) {
code:				 /* processed packets */
code:				if (sa_fclose) {
code:					 /* close files after each request */
code:					if (sa_fd != 0) {
code:						int fd = sa_fd;
code:						sa_fd = 0;
code:						close(fd);
code:					}
code:				}
code:				sa_stats_refresh = 1;
code:				sa_request++;
code:			}
code:		}
code:		if (sa_debug)
code:			snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: shutting down\\n\", argv[0]);
code:		snmp_shutdown(\"$mibName\");
code:	}
code:	int
code:	main(int argc, char *argv[])
code:	{
code:		for (;;) {
code:			int c, val, fd;
code:			char *cptr;
code:			struct passwd *pw;
code:			struct group *gr;
code:			struct stat st;
code:	#if defined _GNU_SOURCE
code:			int option_index = 0;
code:	                /* *INDENT-OFF* */
code:	                static struct option long_options[] = {
code:	                        {\"log-addresses\",	no_argument,		NULL, 'a'},
code:	                        {\"append\",		no_argument,		NULL, 'A'},
code:	                        {\"config-file\",		required_argument,	NULL, 'c'},
code:	                        {\"no-configs\",		no_argument,		NULL, 'C'},
code:	                        {\"dump\",		no_argument,		NULL, 'd'},
code:	                        {\"debug\",		optional_argument,	NULL, 'D'},
code:	                        {\"debug-tokens\",	optional_argument,	NULL, 'D'},
code:	                        {\"dont-fork\",		no_argument,		NULL, 'f'},
code:	                        {\"gid\",			required_argument,	NULL, 'g'},
code:	                        {\"groupid\",		required_argument,	NULL, 'g'},
code:	                        {\"help\",		no_argument,		NULL, 'h'},
code:	                        {\"?\",			no_argument,		NULL, 'h'},
code:	                        {\"help-directives\",	no_argument,		NULL, 'H'},
code:	                        {\"initialize\",		required_argument,	NULL, 'I'},
code:	                        {\"init-modules\",	required_argument,	NULL, 'I'},
code:	                        {\"keep-open\",		no_argument,		NULL, 'k'},
code:	                        {\"log-file\",		optional_argument,	NULL, 'l'},
code:	                        {\"logfile\",		optional_argument,	NULL, 'l'},
code:	                        {\"Lf\",			optional_argument,	NULL, 'l'},
code:	                        {\"LF\",			required_argument,	NULL, 'l'},
code:	                        {\"log-stderr\",		no_argument,		NULL, 'L'},
code:	                        {\"Le\",			no_argument,		NULL, 'L'},
code:	                        {\"LE\",			required_argument,	NULL, 'L'},
code:	                        {\"mibs\",		required_argument,	NULL, 'm'},
code:	                        {\"master\",		no_argument,		NULL, 'M'},
code:	                        {\"mibdirs\",		required_argument,	NULL, 'M'},
code:	                        {\"nodaemon\",		no_argument,		NULL, 'n'},
code:	                        {\"name\",		required_argument,	NULL, 'n'},
code:	                        {\"dry-run\",		no_argument,		NULL, 'N'},
code:	                        {\"log-stdout\",		no_argument,		NULL, 'o'},
code:	                        {\"Lo\",			no_argument,		NULL, 'o'},
code:	                        {\"LO\",			required_argument,	NULL, 'o'},
code:	                        {\"port\",		required_argument,	NULL, 'p'},
code:	                        {\"pidfile\",		required_argument,	NULL, 'P'},
code:	                        {\"quiet\",		no_argument,		NULL, 'q'},
code:	                        {\"quick\",		no_argument,		NULL, 'q'},
code:	                        {\"noroot\",		no_argument,		NULL, 'r'},
code:	                        {\"log-syslog\",		no_argument,		NULL, 's'},
code:	                        {\"Ls\",			no_argument,		NULL, 's'},
code:	                        {\"LS\",			required_argument,	NULL, 's'},
code:	                        {\"syslog\",		no_argument,		NULL, 's'},
code:	                        {\"sysctl-file\",		required_argument,	NULL, 'S'},
code:	                        {\"agent-alarms\",	no_argument,		NULL, 't'},
code:	                        {\"transport\",		optional_argument,	NULL, 'T'},
code:	                        {\"uid\",			required_argument,	NULL, 'u'},
code:	                        {\"userid\",		required_argument,	NULL, 'u'},
code:	                        {\"dont-remove-pidfile\",	no_argument,		NULL, 'U'},
code:	                        {\"leave-pidfile\",	no_argument,		NULL, 'U'},
code:	                        {\"version\",		no_argument,		NULL, 'v'},
code:	                        {\"verbose\",		optional_argument,	NULL, 'V'},
code:	                        {\"agentx-socket\",	required_argument,	NULL, 'x'},
code:	                        {\"agentx\",		no_argument,		NULL, 'X'},
code:	                        {\"copying\",		no_argument,		NULL, 'y'},
code:	#if 0
code:	                        {\"directory\",		required_argument,	NULL, 'd'},
code:	                        {\"basename\",		required_argument,	NULL, 'b'},
code:	                        {\"outfile\",		required_argument,	NULL, 'o'},
code:	                        {\"errfile\",		required_argument,	NULL, 'e'},
code:	#endif
code:	                        { 0, }
code:	                };
code:	                /* *INDENT-ON* */
code:			c = getopt_long_only(argc, argv,
code:					     \":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy\",
code:					     long_options, &option_index);
code:	#else				/* defined _GNU_SOURCE */
code:			c = getopt(argc, argv,
code:				   \":aAc:CdD::fg:hHI:kl::L::m:M::n::o::p:P:qrs::S:tT::u:UvV::x:Xy\");
code:	#endif				/* defined _GNU_SOURCE */
code:			if (c == -1) {
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: done options processing\\n\",
code:						 argv[0]);
code:				break;
code:			}
code:			switch (c) {
code:			case 0:
code:				goto bad_usage;
code:			case 'a':	/* -a, --log-addresses */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: logging addresses\\n\",
code:						 argv[0]);
code:				sa_logaddr++;
code:				break;
code:			case 'A':	/* -A, --append */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: will not truncate logfile\\n\",
code:						 argv[0]);
code:	#if defined NETSNMP_DS_LIB_APPEND_LOGFILES
code:				ds_set_boolean(DS_LIBRARY_ID, NETSNMP_DS_LIB_APPEND_LOGFILES, 1);
code:	#endif				/* defined NETSNMP_DS_LIB_APPEND_LOGFILES */
code:				sa_appendlog = 1;
code:				break;
code:			case 'c':	/* -c, --config-file CONFIGFILE */
code:				if (optarg == NULL)
code:					goto bad_option;
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG),
code:						 \"%s: using configuration file %s\\n\", argv[0], optarg);
code:				ds_set_string(DS_LIBRARY_ID, DS_LIB_OPTIONALCONFIG, optarg);
code:				break;
code:			case 'C':	/* -C, --no-configs */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG),
code:						 \"%s: not reading default config files\\n\", argv[0]);
code:				ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DONT_READ_CONFIGS, 1);
code:				break;
code:			case 'd':	/* -d, --dump */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: setting packet dump\\n\",
code:						 argv[0]);
code:				sa_dump = 1;
code:				 // snmp_set_dump_packet(sa_dump);
code:				ds_set_boolean(DS_LIBRARY_ID, DS_LIB_DUMP_PACKET, sa_dump);
code:				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, sa_dump);
code:				break;
code:			case 'D':	/* -D, --debug [LEVEL], --debug-tokens [TOKENS] */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: increasing debug verbosity\\n\",
code:						 argv[0]);
code:				if (optarg == NULL) {
code:					 /* no option: must be -D, --debug */
code:					sa_debug++;
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG),
code:							 \"%s: debug level is now %d\\n\", argv[0], sa_debug);
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG),
code:							 \"%s: debugging all tokens\\n\", argv[0]);
code:					if (sa_debug)
code:						debug_register_tokens(\"ALL\");
code:				} else {
code:					cptr = optarg;
code:					if ((val = strtol(optarg, &cptr, 0)) < 0)
code:						goto bad_option;
code:					if (*cptr == '\\0') {
code:						 /* it is just a number, must be -D, --debug [LEVEL] */
code:						sa_debug = val;
code:						if (sa_debug)
code:							snmp_log(MY_FACILITY(LOG_DEBUG),
code:								 \"%s: debug level is now %d\\n\", argv[0],
code:								 sa_debug);
code:					} else {
code:						 /* not a number, must be -D, --debug-tokens TOKENS */
code:						if (sa_debug)
code:							snmp_log(MY_FACILITY(LOG_DEBUG),
code:								 \"%s: debugging tokens %s\\n\", argv[0],
code:								 optarg);
code:						debug_register_tokens(optarg);
code:					}
code:				}
code:				break;
code:			case 'f':	/* -f, --dont-fork */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: suppressing daemon mode\\n\",
code:						 argv[0]);
code:				sa_nomead = 0;
code:				break;
code:			case 'u':	/* -u, --uid, --userid UID */
code:				cptr = optarg;
code:				if ((val = strtol(optarg, &cptr, 0)) < 0)
code:					goto bad_option;
code:				 /* UID can be name or number */
code:				if ((pw =
code:				     (*cptr == '\\0') ? getpwuid((uid_t) val) : getpwnam(optarg)) == NULL)
code:					goto bad_option;
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: will run as uid %s(%d)\\n\",
code:						 argv[0], pw->pw_name, pw->pw_uid);
code:				ds_set_int(DS_APPLICATION_ID, DS_AGENT_USERID, pw->pw_uid);
code:				break;
code:			case 'g':	/* -g, --gid, --groupdid GID */
code:				cptr = optarg;
code:				if ((val = strtol(optarg, &cptr, 0)) < 0)
code:					goto bad_option;
code:				 /* GID can be name or number */
code:				if ((gr =
code:				     (*cptr == '\\0') ? getgrgid((gid_t) val) : getgrnam(optarg)) == NULL)
code:					goto bad_option;
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: will run as gid %s(%d)\\n\",
code:						 argv[0], gr->gr_name, gr->gr_gid);
code:				ds_set_int(DS_APPLICATION_ID, DS_AGENT_GROUPID, gr->gr_gid);
code:				break;
code:			case 'h':	/* -h, --help, -?, --? */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: printing help message\\n\",
code:						 argv[0]);
code:				sa_help(argc, argv);
code:				exit(0);
code:			case 'H':	/* -H, --help-directives */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: printing config directives\\n\",
code:						 argv[0]);
code:				sa_help_directives(argc, argv);
code:				exit(0);
code:			case 'I':	/* -I, --init-modules, --initialize MODULE[{,| |:}MODULE]* */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG),
code:						 \"%s: will initialize modules: %s\\n\", argv[0], optarg);
code:				add_to_init_list(optarg);
code:				break;
code:			case 'k':	/* -k, --keep-open */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: keeping files open\\n\",
code:						 argv[0]);
code:				sa_fclose = 0;
code:				break;
code:			case 'l':	/* -l, --log-file, --logfile, -Lf, -LF p1[-p2] [LOGFILE] */
code:				if (optarg != NULL)
code:					strncpy(sa_logfile, optarg, sizeof(sa_logfile));
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: will log to file %s\\n\",
code:						 argv[0], sa_logfile);
code:				sa_logfillog = 1;
code:				break;
code:			case 'L':	/* -L, --log-stderr, -Le, -LE p1[-p2] */
code:				 /* Note that the recent NET-SNMP version of this option is far more
code:				   complicated: -Le is the same as the old version of the option; -Lf
code:				   LOGFILE is like the -l option; -Ls is like the -s option; -Lo logs
code:				   messages to standard output; -LX p1[-p2] [LOGFILE], where X = E, F, S or
code:				   O, logs priority p1 and above to X, or p1 thru p2 to X. */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: logging to standard error\\n\",
code:						 argv[0]);
code:				sa_logstderr = 1;
code:				break;
code:			case 'm':	/* -m, --mibs MIBS */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: using MIBS %s\\n\", argv[0],
code:						 optarg);
code:				break;
code:			case 'M':	/* -M, --master or -M, --mibdirs MIBDIRS */
code:				if (optarg) {
code:					 /* -M, --mibdirs MIBDIRS */
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: using MIBDIRS %s\\n\",
code:							 argv[0], optarg);
code:				} else {
code:					 /* -M, --master */
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG),
code:							 \"%s: setting SNMP master\\n\", argv[0]);
code:					sa_agentx = 0;
code:					ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 0);
code:				}
code:				break;
code:			case 'n':	/* -n, --nodaemon or -n, --name NAME */
code:				if (optarg) {
code:					 /* -n, --name NAME */
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: using name %s\\n\",
code:							 argv[0], optarg);
code:					ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME, optarg);
code:				} else {
code:					 /* -n, --nodaemon */
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG),
code:							 \"%s: suppressing deamon mode\\n\", argv[0]);
code:					sa_nomead = 0;
code:					ds_set_string(DS_APPLICATION_ID, DS_AGENT_PROGNAME,
code:						      basename(argv[0]));
code:				}
code:				break;
code:			case 'N':	/* -N, --dry-run */
code:	#if defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG),
code:						 \"%s: setting for dry-runs startup\\n\", argv[0]);
code:				ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_QUIT_IMMEDIATELY, 1);
code:				break;
code:	#else				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
code:				snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: -N option not supported\\n\", argv[0]);
code:				goto bad_option;
code:	#endif				/* defined NETSNMP_DS_AGENT_QUIT_IMMEDIATELY */
code:			case 'o':	/* -o, --log-stdout, -Lo, -LO p1[-p2] */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: logging to stdout\\n\",
code:						 argv[0]);
code:				sa_logstdout = 1;
code:				break;
code:			case 'p':	/* -p, --port PORTNUM or -p, --pidfile PIDFILE */
code:				cptr = optarg;
code:				if ((val = strtol(optarg, &cptr, 0)) < 0 || val > 16383)
code:					goto bad_option;
code:				if (*cptr == '\\0') {
code:					char buf[4096];
code:					 /* -p, --port PORTNUM */
code:					if ((cptr = ds_get_string(DS_APPLICATION_ID, DS_AGENT_PORTS)))
code:						snprintf(buf, sizeof(buf), \"%s,%s\", cptr, optarg);
code:					else
code:						strncpy(buf, optarg, sizeof(buf));
code:					ds_set_string(DS_APPLICATION_ID, DS_AGENT_PORTS, buf);
code:					break;
code:				}
code:				 /* fall through */
code:			case 'P':	/* -p, -P, --pidfile PIDFILE */
code:				if (optarg) {
code:					 /* either it exists */
code:					if (stat(optarg, &st) == -1) {
code:						 /* or we can create it */
code:						if ((fd = open(optarg, O_CREAT, 0600)) == -1) {
code:							perror(argv[0]);
code:							goto bad_option;
code:						}
code:						close(fd);
code:					}
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG),
code:							 \"%s: setting pid file to %s\\n\", argv[0], optarg);
code:					strncpy(sa_pidfile, optarg, sizeof(sa_pidfile));
code:				}
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: using pidfile %s\\n\", argv[0],
code:						 sa_pidfile);
code:				break;
code:			case 'q':	/* -q, --quiet, --quick */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: suppressing normal output\\n\",
code:						 argv[0]);
code:				sa_debug = 0;
code:				sa_output = 0;
code:				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
code:				 // snmp_set_quick_print();
code:				ds_set_boolean(DS_LIBRARY_ID, DS_LIB_QUICK_PRINT, 1);
code:				break;
code:			case 'r':	/* -r, --noroot */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG),
code:						 \"%s: setting for non-root access\\n\", argv[0]);
code:				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_NO_ROOT_ACCESS, 1);
code:				break;
code:			case 's':	/* -s, --log-syslog, -Ls, -LS p1[-p2] */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: logging to system logs\\n\",
code:						 argv[0]);
code:				sa_logsyslog = 1;
code:				break;
code:			case 'S':	/* -S, -sysctl-file FILENAME */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: using %s for backing\\n\",
code:						 argv[0], optarg);
code:				strncpy(sa_sysctlf, optarg, sizeof(sa_sysctlf));
code:				break;
code:			case 't':	/* -t, --agent-alarms */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: setting agent alarms\\n\",
code:						 argv[0]);
code:				sa_alarms = 0;
code:				ds_set_boolean(DS_LIBRARY_ID, DS_LIB_ALARM_DONT_USE_SIG, 1);
code:				break;
code:			case 'T':	/* -T, --transport [TRANSPORT] */
code:				if (optarg == NULL)
code:					goto udp_transport;
code:				if (!strcasecmp(\"TCP\", optarg)) {
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG),
code:							 \"%s: setting default transport to TCP\\n\", argv[0]);
code:					val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
code:					val |= SNMP_FLAGS_STREAM_SOCKET;
code:					ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
code:				} else if (!strcasecmp(\"UDP\", optarg)) {
code:				      udp_transport:
code:					if (sa_debug)
code:						snmp_log(MY_FACILITY(LOG_DEBUG),
code:							 \"%s: setting default transport to UDP\\n\", argv[0]);
code:					val = ds_get_int(DS_APPLICATION_ID, DS_AGENT_FLAGS);
code:					val &= ~SNMP_FLAGS_STREAM_SOCKET;
code:					ds_set_int(DS_APPLICATION_ID, DS_AGENT_FLAGS, val);
code:				} else
code:					goto bad_option;
code:				break;
code:			case 'U':
code:	#if defined NETSNMP_DS_AGENT_LEAVE_PIDFILE
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG),
code:						 \"%s: will leave pidfile after shutdown\\n\", argv[0]);
code:				ds_set_boolean(DS_APPLICATION_ID, NETSNMP_DS_AGENT_LEAVE_PIDFILE, 1);
code:	#else
code:				snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: -U option not supported\\n\");
code:				goto bad_option;
code:	#endif				/* defined NETSNMP_DS_AGENT_LEAVE_PIDFILE */
code:				break;
code:			case 'v':	/* -v, --version */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: printing version message\\n\",
code:						 argv[0]);
code:				sa_version(argc, argv);
code:				exit(0);
code:			case 'V':	/* -V, --verbose [LEVEL] */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG),
code:						 \"%s: increasing output verbosity\\n\", argv[0]);
code:				if (optarg == NULL) {
code:					sa_output++;
code:				} else {
code:					if ((val = strtol(optarg, NULL, 0)) < 0)
code:						goto bad_option;
code:					sa_output = val;
code:				}
code:				if (sa_output > 1)
code:					ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 1);
code:				else
code:					ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_VERBOSE, 0);
code:				break;
code:			case 'x':	/* -x, --agentx-socket SOCKET */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG),
code:						 \"%s: setting AgentX socket to %s\\n\", argv[0], optarg);
code:				ds_set_string(DS_APPLICATION_ID, DS_AGENT_X_SOCKET, optarg);
code:				 // ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_AGENTX_MASTER, 1);
code:				break;
code:			case 'X':	/* -X, --agentx */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: setting AgentX sub-agent\\n\",
code:						 argv[0]);
code:				sa_agentx = 1;
code:				ds_set_boolean(DS_APPLICATION_ID, DS_AGENT_ROLE, 1);
code:				break;
code:			case 'y':	/* -y, --copying */
code:				if (sa_debug)
code:					snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: printing copying message\\n\",
code:						 argv[0]);
code:				sa_copying(argc, argv);
code:				exit(0);
code:			case '?':
code:			case ':':
code:			default:
code:			      bad_option:
code:				optind--;
code:				goto bad_nonopt;
code:			      bad_nonopt:
code:				if (sa_output || sa_debug) {
code:					if (optind < argc) {
code:						fprintf(stderr, \"%s: syntax error near '\", argv[0]);
code:						while (optind < argc)
code:							fprintf(stderr, \"%s \", argv[optind++]);
code:						fprintf(stderr, \"'\\n\");
code:					} else {
code:						fprintf(stderr, \"%s: missing option or argument\", argv[0]);
code:						fprintf(stderr, \"\\n\");
code:					}
code:					fflush(stderr);
code:				      bad_usage:
code:					sa_usage(argc, argv);
code:				}
code:				exit(2);
code:			}
code:		}
code:		if (optind < argc) {
code:			if (sa_debug)
code:				snmp_log(MY_FACILITY(LOG_DEBUG), \"%s: excess non-option arguments\\n\",
code:					 argv[0]);
code:			goto bad_nonopt;
code:		}
code:		sa_enter(argc, argv);	/* daemonize if necessary */
code:		sa_mloop(argc, argv);	/* execute main loop */
code:		exit(0);
code:	}
code:	#endif /* !defined MODULE */

type:		code-definitions-oids
processoid:	code-definitions-oids
skipif:		$name eq $mibName || $mib->{type} eq "NOTIF"
code:		oid ${name}_oid[" .( countsubs $mib->{'objectID'} ). "] = { " .( stripone dotstocomma $mib->{'objectID'} ). " };

type:		code-definitions-notifications
processoid:	code-definitions-notifications
skipif:		$mib->{type} ne "NOTIF"
code:		oid ${name}_oid[" .( countsubs $mib->{'objectID'} ). "] = { " .( stripone dotstocomma $mib->{'objectID'} ). " };

type:		code-definitions-parameters
process:	code-definitions-parameters
skipif:		$vroutine ne $mibName || $mib->{'access'} ne "Notify" || $variables{$vroutine}{$i}{'isanindex'} == 1
code:		oid ${name}_oid[" .( countsubs $mib->{'objectID'} ). "] = { " .( stripone dotstocomma $mib->{'objectID'} ). " };

############################################################################
# var_ function for tables, which is handled specially and used above
#
#   Note: $vtable is set to the table name in the processtable loop.
############################################################################

#
# header file defs first
#
type:		code-var-table-decl
processtable:	code-var-table-decl
code:	FindVarMethod var_$vtable;
code:	struct ${vtable}_data *${vtable}_create(void);
code:	int ${vtable}_destroy(struct ${vtable}_data **);
code:	int ${vtable}_add(struct ${vtable}_data *);
code:	int ${vtable}_del(struct ${vtable}_data *);
code:	void parse_$vtable(const char *, char *);
code:	SNMPCallback store_$vtable;
code:	void refresh_$vtable(void);

#
# .conf Store Code per table
#
type:		code-store-registration
processtable:	code-store-registration
code:		snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
code:		store_$vtable, NULL);
#
# .conf Parser Code per table
#
type:		code-parser-registration
processtable:	code-parser-registration
code:		snmpd_register_config_handler(\"$vtable\", parse_$vtable, NULL, \"HELP STRING\");
#
# .conf Parser Code per table
#
type:		code-parser-deregistration
processtable:	code-parser-deregistration
code:	snmpd_unregister_config_handler(\"$vtable\");


type:		code-varlist-add
process:	code-varlist-add
skipif:		$variables{$vroutine}{$name}{'isanindex'} != 1
code:		 /* $name */
code:		snmp_varlist_add_variable(&vars, NULL, 0, $variables{$mib->{type}}{asnType}, (u_char *) $variables{$mib->{type}}{'storageret'}thedata->$name, $variables{$mib->{type}}{'sizeofstart'}thedata->$name$variables{$mib->{type}}{'sizeofend'});\n 

type:		code-parser
processtable:	code-parser
code:	/**
code:	 * \@fn struct ${vtable}_data *${vtable}_create(void)
code:	 * \@brief create a fresh data structure representing a new row in the ${vtable} table.
code:	 * Creates a new ${vtable}_data structure by allocating dynamic memory for the structure and
code:	 * initializing the default values of columns in the table.  The row status object, if any, should
code:	 * be set to RS_NOTREADY.
code:	 */
code:	struct ${vtable}_data *
code:	${vtable}_create(void)
code:	{
code:		struct ${vtable}_data *StorageNew = SNMP_MALLOC_STRUCT(${vtable}_data);
code:		DEBUGMSGTL((\"$vtable\", \"creating row...  \"));
code:		if (StorageNew != NULL) {
code:			 /* XXX: fill in default row values here into StorageNew */
code:			$variables{$vtable}{'code-default-values'}{'processed'} ". eval { my $x; if ($variables{$vtable}{'rowstatus'}) { $x = "StorageNew->$variables{$vtable}{'rowstatus'} = RS_NOTREADY;"; } $x; } ."
code:		}
code:		DEBUGMSGTL((\"$vtable\", \"done.\\n\"));
code:		return (StorageNew);
code:	}
code:	/**
code:	 * \@fn int ${vtable}_destroy(struct ${vtable}_data **thedata)
code:	 * \@brief delete a row structure from a table.
code:	 * \@param thedata pointer to the extracted or existing data structure in the table.
code:	 * Frees a table row that was previously removed from a table.  Note that the strings associated
code:	 * with octet strings, object identifiers and bit strings still attached to the structure will also
code:	 * be freed.  The pointer that was passed in @param thedata will be set to NULL if it is not already
code:	 * NULL.
code:	 */
code:	int
code:	${vtable}_destroy(struct ${vtable}_data **thedata)
code:	{
code:		struct ${vtable}_data *StorageDel;
code:		DEBUGMSGTL((\"$vtable\", \"deleting row...  \"));
code:		if ((StorageDel = *thedata) != NULL) { $variables{$vtable}{'code-delete-values'}{'processed'}
code:			SNMP_FREE(StorageDel);
code:			*thedata = StorageDel;
code:		}
code:		DEBUGMSGTL((\"$vtable\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn int ${vtable}_add(struct ${vtable}_data *thedata)
code:	 * \@param thedata the structure representing the new row in the table.
code:	 * \@brief adds a row to the ${vtable} table data set.
code:	 * Adds a table row structure to the ${vtable} table.  Note that this function is necessary even
code:	 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
code:	 * by the agent to create rows within the table autonomously.
code:	 */
code:	int
code:	${vtable}_add(struct ${vtable}_data *thedata)
code:	{
code:		struct variable_list *vars = NULL;
code:		DEBUGMSGTL((\"$vtable\", \"adding data...  \"));
code:		 /* add the index variables to the varbind list, which is used by header_complex to index the data */
code:		$variables{$vtable}{'code-varlist-add'}{'processed'} header_complex_add_data(&${vtable}Storage, vars, thedata);
code:		DEBUGMSGTL((\"$vtable\",\"registered an entry\\n\"));
code:		DEBUGMSGTL((\"$vtable\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn int ${vtable}_del(struct ${vtable}_data *thedata)
code:	 * \@brief delete a row structure from a table.
code:	 * \@param thedata pointer to the extracted or existing data structure in the table.
code:	 * Deletes a table row structure from the ${vtable} table but does not free it.  Note that this
code:	 * function is necessary even when the table rows are not persistent.  This function can be used
code:	 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
code:	 * structure may either be already extracted from the data set, or the structure may still exist in
code:	 * the data set.  This function will extract the row from the table if it has not already been
code:	 * performed by the caller.
code:	 */
code:	int
code:	${vtable}_del(struct ${vtable}_data *thedata)
code:	{
code:		struct ${vtable}_data *StorageDel;
code:		DEBUGMSGTL((\"$vtable\", \"deleting data...  \"));
code:		if ((StorageDel = thedata) != NULL) {
code:			struct header_complex_index *hciptr;
code:			if ((hciptr = header_complex_find_entry(${vtable}Storage, StorageDel)) != NULL)
code:			    header_complex_extract_entry(&${vtable}Storage, hciptr);
code:		}
code:		DEBUGMSGTL((\"$vtable\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * \@fn void parse_$vtable(const char *token, char *line)
code:	 * \@param token token used within the configuration file.
code:	 * \@param line line from configuration file matching the token.
code:	 * \@brief parse configuration file for $vtable entries.
code:	 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
code:	 * file line for the registsred token (in this case ${vtable}).  This routine is invoked by UCD-SNMP
code:	 * to read the values of each row in the table from the configuration file.  Note that this
code:	 * procedure may exist regardless of the persistence of the table.  If there are no configured
code:	 * entries in the configuration table, this function will simply not be called.
code:	 */
code:	void
code:	parse_$vtable(const char *token, char *line)
code:	{
code:		size_t tmpsize;
code:		struct ${vtable}_data *StorageTmp = ${vtable}_create();
code:		DEBUGMSGTL((\"$vtable\", \"parsing config...  \"));
code:		if (StorageTmp == NULL) {
code:			config_perror(\"malloc failure\");
code:			return;
code:		}
code:		 /* XXX: remove individual columns if not persistent */
code:		$variables{$vtable}{'code-parser-sections'}{'processed'} ${vtable}_add(StorageTmp);
code:		(void) tmpsize;
code:		DEBUGMSGTL((\"$vtable\", \"done.\\n\"));
code:	}
code:	/*
code:	 * store_$vtable(): store configuraiton file for $vtable
code:	 * stores .conf file entries needed to configure the mib.
code:	 */
code:	int
code:	store_$vtable(int majorID, int minorID, void *serverarg, void *clientarg)
code:	{
code:		char line[SNMP_MAXBUF];
code:		char *cptr;
code:		size_t tmpsize;
code:		struct ${vtable}_data *StorageTmp;
code:		struct header_complex_index *hcindex;
code:		DEBUGMSGTL((\"$vtable\", \"storing data...  \"));
code:		refresh_${vtable}();
code:		(void) tmpsize;
code:		for(hcindex=${vtable}Storage; hcindex != NULL; hcindex = hcindex->next) {
code:			StorageTmp = (struct ${vtable}_data *) hcindex->data;
code:			 /* XXX: comment entire section if row not persistent */
code:			". eval { my $x; if ($variables{$vtable}{'storagetype'}) { $x = "if (StorageTmp->$variables{$vtable}{'storagetype'} == ST_NONVOLATILE)"; } $x; } ." {
code:				memset(line,0,sizeof(line));
code:				strcat(line, \"$vtable \");
code:				cptr = line + strlen(line);
code:				 /* XXX: remove individual columns if not persistent */
code:				$variables{$vtable}{'code-persistent-sections'}{'processed'} snmpd_store_config(line);
code:			}
code:		}
code:		DEBUGMSGTL((\"$vtable\", \"done.\\n\"));
code:		return SNMPERR_SUCCESS;
code:	}

# individual sections for the parser
type:		code-parser-sections
process:	code-parser-sections
skipif:		!$mib->{'type'} || $mib->{'access'} =~ /WriteOnly/
code:		line = read_config_read_data($variables{$mib->{type}}{asnType}, line, &StorageTmp->$name, &". eval("\"$variables{$mib->{type}}{'tmpsize'}\"") ."); " . eval ("\"$variables{$mib->{type}}{vartest}\"") . "

#
# .conf persistent save Code per table
#
type:		code-persistent-sections
process:	code-persistent-sections
skipif:		!$mib->{'type'} || $mib->{'access'} =~ /WriteOnly/
code:		cptr = read_config_store_data($variables{$mib->{type}}{asnType}, cptr, &StorageTmp->$name, &". eval("\"$variables{$mib->{type}}{'tmpsize'}\"") .");

#
# Code code per table
#
type:		code-var-table
processtable:	code-var-table
code:	\n/**
code:	 * \@fn void refresh_$vtable(void)
code:	 * \@brief refresh the scalar values of the $vtable.
code:	 * Normally the values retrieved from the operating system are cached.  When the agent receives a
code:	 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
code:	 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
code:	 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
code:	 * time, or after a SIGPOLL has been received (and a row or column has been requested).
code:	 */
code:	void
code:	refresh_$vtable(void)
code:	{
code:		if (${vtable}_refresh == 0)
code:			return;
code:		${vtable}_refresh = 0;
code:		 /* XXX: Here, update the table as required... */
code:	}
code:	/**
code:	 * \@fn void refresh_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	 * \@brief refresh the contents of the $vtable row.
code:	 * Normally the values retrieved from the operating system are cached.  However, if a row contains
code:	 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
code:	 * may be necessary to refresh the row on some other basis, but normally only once per request.
code:	 */
code:	void
code:	refresh_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	{
code:		if (StorageTmp->${vtable}_request == sa_request)
code:			return;
code:		StorageTmp->${vtable}_request = sa_request;
code:	}
code:	/**
code:	 * \@fn u_char *var_$vtable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
code:	 * \@brief locate variables in $vtable.
code:	 * Handle this table separately from the scalar value case.  The workings of this are basically the
code:	 * same as for var_$mibName above.
code:	 */
code:	u_char *
code:	var_$vtable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
code:	{
code:		struct ${vtable}_data *StorageTmp = NULL;
code:		DEBUGMSGTL((\"$mibName\", \"var_$vtable: Entering...  \\n\"));
code:		 /* Make sure that the storage data does not need to be refreshed before checking the header. */
code:		refresh_$vtable();
code:		 /* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
code:		if ((StorageTmp = header_complex(${vtable}Storage, vp,name,length, exact, var_len,write_method)) == NULL)
code:			return NULL;
code:		refresh_${vtable}_row(StorageTmp);
code:		 /* This is where we do the value assignments for the mib results. */
code:		switch(vp->magic) { $variables{$vtable}{'code-case-statements'}{'processed'}
code:		default:
code:			ERROR_MSG(\"\");
code:		}
code:		return NULL;
code:	}


############################################################################
# case statement sections
############################################################################
type:		code-case-statements
process:	code-case-statements
skipif:		$mib->{'access'} =~ /NoAccess|Notify/ || ( $variables{$vroutine}{$name}{'isanindex'} == 1 && $variables{$vroutine}{$name}{'ismyindex'} != 1 )
code:		case $NAME:
code:			" . (($mib->{'access'} =~ /ReadWrite|WriteOnly|Create/) ? "*write_method = write_$name;" : "*write_method = NULL; /* read-only */") . "
code:			" . (($mib->{'access'} =~ /WriteOnly/) ? "*var_len = 0; /* write-only */" : "*var_len = $variables{$mib->{'type'}}{'sizeofstart'}StorageTmp->$name$variables{$mib->{'type'}}{'sizeofend'};") . "
code:			" . (($mib->{'access'} =~ /WriteOnly/) ? "return (u_char *) NULL; /* write-only */" : "return (u_char *) $variables{$mib->{'type'}}{'storageret'}StorageTmp->$name;") . "

############################################################################
# storage structure information
############################################################################
type:		variable-structure-info
process:	variable-structure-info
skipif:		$mib->{'access'} =~ /NoAccess|Notify/ || $variables{$name}{'myoid'} != 1
code:		" . sprintf("#define   %-20s  ($count %% 256)", $NAME) . "
code:		" . sprintf("  { %-20s, %-14s, %-6.6s, %s, %d, { %s } },", $NAME, $variables{$mib->{'type'}}{'asnType'}, $accessToUCD{$mib->{'access'}}, "var_$vroutine", $depth-1, $subid) . "

############################################################################
# write function definition, also appended to the end of the .c file.
############################################################################
#
# Header info: declare write functions for set processing
#
type:		code-write-func-decl
process:	code-write-func-decl
skipif:		$mib->{'access'} !~ /Write|Create/
code:		WriteMethod write_$name;
#
#
#
type:		code-delete-scalar
process:	code-delete-scalar
skipif:		$vroutine ne $mibName
code:		$variables{$mib->{type}}{deletevar}
#
#
#
type:		code-config-scalar
process:	code-config-scalar
skipif:		$vroutine ne $mibName || $mib->{'access'} =~ /WriteOnly|NoAccess|Notify/ || $variables{$vroutine}{$name}{'isanindex'} == 1
code:		line = read_config_read_data($variables{$mib->{type}}{asnType}, line, &StorageTmp->$name, &". eval("\"$variables{$mib->{type}}{'tmpsize'}\"") ."); " . eval ("\"$variables{$mib->{type}}{vartest}\"") . "
#
#
#
type:		code-persistent-scalars
process:	code-persistent-scalars
skipif:		$vroutine ne $mibName || $mib->{'access'} =~ /WriteOnly|NoAccess|Notify/ || $variables{$vroutine}{$name}{'isanindex'} == 1
code:		cptr = read_config_store_data($variables{$mib->{type}}{asnType}, cptr, &StorageTmp->$name, &". eval("\"$variables{$mib->{type}}{'tmpsize'}\"") .");
#
#
#
type:		code-write-length-check-string
process:	code-write-length-check-string
skipif:		$mib->{type} !~ /OCTETSTR|OBJECTID/
code:		" . eval{ my ($e, $x); foreach $e (@{$mib->{'ranges'}}) { $x .= " $e->{low}..$e->{high}"; } unless ($x eq "") { $x = "\n /* Note: ranges $x */"; } $x; } . " if ($variables{$mib->{'type'}}{varlencheck}" . eval { my ($e, $x, $s); foreach $e (@{$mib->{'ranges'}}) { $x .= $s; if ($e->{low} == $e->{high}) { $x .= "var_val_len != $e->{low} $variables{$mib->{type}}{varsize}"; } else { $x .= "($e->{low} $variables{$mib->{type}}{varsize} > var_val_len || var_val_len > $e->{high} $variables{$mib->{type}}{varsize})"; } $s = "&&"; } unless ($x eq "") { $x = "||($x)"; } $x; } . ") {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad length\\n\");
code:			return SNMP_ERR_WRONGLENGTH;
code:		}
#
# BITS are ASN.1 BitString.  The content passed to us by UCD-SNMP is the contents of the ASN.1
# BitString type which consists of one octet indicating the number of bits in the last octet that
# are unused (0..7) and then the octets containing bits themselves.  Therefore, the length cannot be
# less than two or there is an error.
#
type:		code-write-length-check-bits
process:	code-write-length-check-bits
skipif:		$mib->{type} ne "BITS"
code:		if ($variables{$mib->{'type'}}{varlencheck} " .  eval { my ($i, $x); foreach $i (sort {$mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}} keys(%{$mib->{'enums'}})) { if ($x < $mib->{'enums'}{$i}) { $x = $mib->{'enums'}{$i}; } } if ($x > 0) { $x = "|| var_val_len != (($x >> 3) + 2)"; } $x; } ." ) {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad length\\n\");
code:			return SNMP_ERR_WRONGLENGTH;
code:		}
#
type:		code-write-length-check-fixed
process:	code-write-length-check-fixed
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/
code:		if ($variables{$mib->{'type'}}{varlencheck}) {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad length\\n\");
code:			return SNMP_ERR_WRONGLENGTH;
code:		}
#
type:		code-write-value-check-range
process:	code-write-value-check-range
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/ || !scalar @{$mib->{'ranges'}}
code:		" . eval{ my ($e, $x); foreach $e (@{$mib->{'ranges'}}) { $x .= " $e->{low}..$e->{high}"; } unless ($x eq "") { $x = "\n /* Note: ranges $x */"; } $x; } . eval { my ($e, $x, $s); foreach $e (@{$mib->{'ranges'}}) { $x .= $s; if ($e->{low} == $e->{high}) { $x .= "$variables{$mib->{type}}{varname} != $e->{low}"; } else { $x .= "($e->{low} > $variables{$mib->{type}}{varname} || $variables{$mib->{type}}{varname} > $e->{high})"; } $s = "&&"; } unless ($x eq "") { $x = "\n if ($x) { snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\"); return SNMP_ERR_WRONGVALUE; }"; } $x; } . "
#
type:		code-write-value-check-enum
process:	code-write-value-check-enum
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/ || !scalar keys(%{$mib->{'enums'}}) || $mib->{'textualConvention'} eq "RowStatus" || $mib->{'textualConvention'} eq "StorageType" || $mib->{'textualConvention'} eq "TruthValue"
code:		" . eval { my ($i, $x); foreach $i (sort {$mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}} keys(%{$mib->{'enums'}})) { $x .= sprintf("case %-40s:\n","${NAME}_" . uc($i)); } $x =~ s/-/_/g; unless ($x eq "") { $x = "\n switch($variables{$mib->{type}}{varname}) { $x break; default: snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\"); return SNMP_ERR_WRONGVALUE; }"; } $x; } . "
#
type:		code-write-value-check-rowstatus
process:	code-write-value-check-rowstatus
skipif:		$mib->{'textualConvention'} ne "RowStatus"
code:		\n /* check legal range, and notReady is reserved for us, not a user */
code:		if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\");
code:			return SNMP_ERR_WRONGVALUE;
code:		}
#
type:		code-write-value-check-storagetype
process:	code-write-value-check-storagetype
skipif:		$mib->{'textualConvention'} ne "StorageType"
code:		switch (set_value) {
code:		case ST_OTHER:
code:		case ST_VOLATILE:
code:		case ST_NONVOLATILE:
code:		case ST_PERMANENT:
code:		case ST_READONLY:
code:			break;
code:		default:
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\");
code:			return SNMP_ERR_WRONGVALUE;
code:		}
#
type:		code-write-value-check-truthvalue
process:	code-write-value-check-truthvalue
skipif:		$mib->{'textualConvention'} ne "TruthValue"
code:		switch (set_value) {
code:		case TV_TRUE:
code:		case TV_FALSE:
code:			break;
code:		default:
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\");
code:			return SNMP_ERR_WRONGVALUE;
code:		}
#
type:		code-write-value-check-bits
process:	code-write-value-check-bits
skipif:		$mib->{type} ne "BITS" || !scalar keys(%{$mib->{'enums'}})
code:		". eval { my ($i, $x); foreach $i (sort {$mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}} keys(%{$mib->{'enums'}})) { if ($x < $mib->{'enums'}{$i}) { $x = $mib->{'enums'}{$i}; } } if ($x > 0) { $x = "\n if (var_val_len < 1 || *var_val != (8 - ($x & 0x07))) { snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\"); return SNMP_ERR_WRONGVALUE; }"; } $x; } . "
#
# C code
#
type:		code-write-scalar-func
process:	code-write-scalar-func
skipif:		$vroutine ne $mibName || $mib->{'access'} !~ /Write|Create/
code:	\n/**
code:	 * \@fn int write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	 * \@param action the stage of the SET operation.
code:	 * \@param var_val pointer to the varbind value.
code:	 * \@param var_val_type the ASN type.
code:	 * \@param var_val_len the length of the varbind value.
code:	 * \@param statP static pointer.
code:	 * \@param name the varbind OID.
code:	 * \@param name_len number of elements in OID.
code:	 * \@brief Scalar write routine.
code:	 */
code:	int
code:	write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	{
code:		static $variables{$mib->{'type'}}{tmpvar} old_value;
code:		struct ${vroutine}_data *StorageTmp = NULL;
code:		$variables{$mib->{type}}{varinit}
code:		DEBUGMSGTL((\"$mibName\", \"write_$name entering action=%d...  \\n\", action));
code:		if ((StorageTmp = ${vroutine}Storage) == NULL)
code:			return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */
code:		switch ( action ) {
code:		case RESERVE1:
code:			if (var_val_type != $variables{$mib->{'type'}}{asnType}){
code:				snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name not $variables{$mib->{'type'}}{asnType}\\n\");
code:				return SNMP_ERR_WRONGTYPE;
code:			} " . $variables{$vroutine}{$name}{'code-write-length-check-string'}{'processed'} . $variables{$vroutine}{$name}{'code-write-length-check-bits'}{'processed'} . $variables{$vroutine}{$name}{'code-write-length-check-fixed'}{'processed'} . (defined $mib->{'defaultValue'} ? "\n /* Note: default value $mib->{'defaultValue'} */" : "") . $variables{$vroutine}{$name}{'code-write-value-check-range'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-bits'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-enum'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-rowstatus'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-storagetype'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-truthvalue'}{'processed'} . "
code:			break;
code:		case RESERVE2: /* memory reseveration, final preparation... */ ".eval ("\"$variables{$mib->{type}}{reserve2}\"")."
code:			break;
code:		case FREE: /* Release any resources that have been allocated */ ".eval ("\"$variables{$mib->{type}}{free}\"")."
code:			break;
code:		case ACTION: /* The variable has been stored in $variables{$mib->{'type'}}{varname} for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */ ".eval ("\"$variables{$mib->{type}}{action}\"")."
code:			break;
code:		case UNDO: /* Back out any changes made in the ACTION case */ ".eval ("\"$variables{$mib->{type}}{undo}\"")."
code:			break;
code:		case COMMIT: /* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */ ".eval ("\"$variables{$mib->{'type'}}{'commit'}\"")."
code:			break;
code:		}
code:		return SNMP_ERR_NOERROR;
code:	}
#
type:		code-write-rowstatus-check
process:	code-write-rowstatus-check
skipif:		!$variables{$vroutine}{'rowstatus'} || $vroutine eq $mibName || $mib->{'textualConvention'} eq "RowStatus" || $mib->{'access'} !~ /ReadWrite|Create/
code:		if (statP == NULL) {
code:			 /* have row but no column */
code:			switch (StorageTmp->$variables{$vroutine}{'rowstatus'}) {
code:			case RS_ACTIVE:
code:				 /* cannot create non-existent column while active */
code:				snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: but column non-existent\\n\");
code:				return SNMP_ERR_INCONSISTENTVALUE;
code:			case RS_NOTINSERVICE:
code:			case RS_NOTREADY:
code:				 /* assume column can be created */
code:				break;
code:			}
code:		}
#
# C code
#
type:		code-write-func
process:	code-write-func
skipif:		$vroutine eq $mibName || $mib->{'textualConvention'} eq "RowStatus" || $mib->{'access'} !~ /Write|Create/
code:	\n/**
code:	 * \@fn int write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	 * \@param action the stage of the SET operation.
code:	 * \@param var_val pointer to the varbind value.
code:	 * \@param var_val_type the ASN type.
code:	 * \@param var_val_len the length of the varbind value.
code:	 * \@param statP static pointer.
code:	 * \@param name the varbind OID.
code:	 * \@param name_len number of elements in OID.
code:	 * \@brief Table row and column write routine.
code:	 */
code:	int
code:	write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	{
code:		static $variables{$mib->{'type'}}{tmpvar} old_value;
code:		struct ${vroutine}_data *StorageTmp = NULL;
code:		size_t newlen=name_len - (sizeof(${mibName}_variables_oid)/sizeof(oid) + $depth - 1);
code:		$variables{$mib->{type}}{varinit}
code:		DEBUGMSGTL((\"$mibName\", \"write_$name entering action=%d...  \\n\", action));
code:		if ((StorageTmp = header_complex(${vroutine}Storage, NULL, &name[sizeof(${mibName}_variables_oid)/sizeof(oid) + $depth - 1], &newlen, 1, NULL, NULL)) == NULL)
code:			return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */
code:		switch ( action ) {
code:		case RESERVE1: $variables{$vroutine}{$name}{'code-write-rowstatus-check'}{'processed'}
code:			if (var_val_type != $variables{$mib->{'type'}}{asnType}){
code:				snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name not $variables{$mib->{'type'}}{asnType}\\n\");
code:				return SNMP_ERR_WRONGTYPE;
code:			} " . $variables{$vroutine}{$name}{'code-write-length-check-string'}{'processed'} . $variables{$vroutine}{$name}{'code-write-length-check-bits'}{'processed'} . $variables{$vroutine}{$name}{'code-write-length-check-fixed'}{'processed'} . (defined $mib->{'defaultValue'} ? "\n /* Note: default value $mib->{'defaultValue'} */" : "") . $variables{$vroutine}{$name}{'code-write-value-check-range'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-bits'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-enum'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-rowstatus'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-storagetype'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-truthvalue'}{'processed'} . "
code:			break;
code:		case RESERVE2: /* memory reseveration, final preparation... */ ".eval ("\"$variables{$mib->{type}}{reserve2}\"")."
code:			break;
code:		case FREE: /* Release any resources that have been allocated */ ".eval ("\"$variables{$mib->{type}}{free}\"")."
code:			break;
code:		case ACTION: /* The variable has been stored in $variables{$mib->{'type'}}{varname} for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */ ".eval ("\"$variables{$mib->{type}}{action}\"")."
code:			break;
code:		case UNDO: /* Back out any changes made in the ACTION case */ ".eval ("\"$variables{$mib->{type}}{undo}\"")."
code:			break;
code:		case COMMIT: /* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */ ".eval ("\"$variables{$mib->{'type'}}{'commit'}\"")."
code:			break;
code:		}
code:		return SNMP_ERR_NOERROR;
code:	}
############################################################################
# copy memory from varlist
############################################################################
type:		code-varlist-copy
process:	code-varlist-copy
skipif:		$variables{$vroutine}{$name}{'isanindex'} != 1
code:		".eval("\"$variables{$mib->{type}}{action2}\"")."
code:		vp = vp->next_variable;
############################################################################
# fill out default values in row
############################################################################
type:		code-default-values
process:	code-default-values
skipif:		!$mib->{'defaultValue'}
code:		".eval("\"$variables{$mib->{type}}{action3}\"")."
############################################################################
# delete values from mib
############################################################################
type:		code-delete-scalars
process:	code-delete-scalars
skipif:		$vroutine ne $mibName || $mib->{'access'} =~ /NoAccess|Notify/ || !($mib->{type} eq "OCTETSTR" || $mib->{type} eq "OBJECTID" || $mib->{type} eq "BITS")
code:		".eval("\"$variables{$mib->{type}}{deletevar}\"")."
############################################################################
# delete values from a row
############################################################################
type:		code-delete-values
process:	code-delete-values
skipif:		!($mib->{type} eq "OCTETSTR" || $mib->{type} eq "OBJECTID" || $mib->{type} eq "BITS")
code:		".eval("\"$variables{$mib->{type}}{deletevar}\"")."
############################################################################
# add null pointers to a varlist; value to be parsed later
############################################################################
type:		code-varlist-add-null
process:	code-varlist-add-null
skipif:		$variables{$vroutine}{$name}{'isanindex'} != 1
code:		 /* $name */
code:		snmp_varlist_add_variable(&vars, NULL, 0, $variables{$mib->{'type'}}{asnType}, NULL, 0);\n 
############################################################################
# write function definition for a RowStatus object,
#   - allows for creation/deletion.
############################################################################
#
# Header info: declare write functions for set processing
#
type:		code-write-rowstatus-decl
process:	code-write-rowstatus-decl
skipif:		$mib->{'textualConvention'} ne "RowStatus"
code:		WriteMethod write_$name;
#
#
#
type:		code-write-rowstatus-oid
process:	code-write-rowstatus-oid
skipif:		$mib->{'textualConvention'} ne "RowStatus"
code:		oid ${vroutine}_variables_oid[] = { " .( stripone dotstocomma $mib->{'objectID'} ). " };
#
# code
#
type:		code-write-rowstatus
process:	code-write-rowstatus
skipif:		$mib->{'textualConvention'} ne "RowStatus"
code:	\n/**
code:	 * \@fn int write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	 * \@param action the stage of the SET operation.
code:	 * \@param var_val pointer to the varbind value.
code:	 * \@param var_val_type the ASN type.
code:	 * \@param var_val_len the length of the varbind value.
code:	 * \@param statP static pointer.
code:	 * \@param name the varbind OID.
code:	 * \@param name_len number of elements in OID.
code:	 * \@brief Row status write routine.
code:	 */
code:	int
code:	write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	{
code:		struct ${vroutine}_data *StorageTmp = NULL;
code:		static struct ${vroutine}_data *StorageNew, *StorageDel;
code:		size_t newlen=name_len - (sizeof(${vroutine}_variables_oid)/sizeof(oid) + 3 - 1);
code:		static int old_value;
code:		int set_value;
code:		static struct variable_list *vars, *vp;
code:		StorageTmp = header_complex(${vroutine}Storage, NULL, &name[sizeof(${vroutine}_variables_oid)/sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
code:		if (var_val_type != ASN_INTEGER || var_val == NULL) {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name not ASN_INTEGER\\n\");
code:			return SNMP_ERR_WRONGTYPE;
code:		}
code:		set_value = *((long *) var_val); $variables{$vroutine}{$name}{'code-write-value-check-rowstatus'}{'processed'}
code:		switch ( action ) {
code:		case RESERVE1:
code:			 /* stage one: test validity */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:			case RS_CREATEANDWAIT:
code:				if (StorageTmp != NULL)
code:					 /* cannot create existing row */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				break;
code:			case RS_ACTIVE:
code:			case RS_NOTINSERVICE:
code:				if (StorageTmp == NULL)
code:					 /* cannot change state of non-existent row */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				if (StorageTmp->$name == RS_NOTREADY)
code:					 /* cannot change state of row that is not ready */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				 /* XXX: interaction with row storage type needed */
code:				if (set_value == RS_NOTINSERVICE && StorageTmp->${vroutine}_refs > 0)
code:					 /* row is busy and cannot be moved to the RS_NOTINSERVICE state */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				break;
code:			case RS_DESTROY:
code:				 /* destroying existent or non-existent row is ok */
code:				if (StorageTmp == NULL)
code:					break;
code:				 /* XXX: interaction with row storage type needed */
code:				if (StorageTmp->${vroutine}_refs > 0)
code:					 /* row is busy and cannot be deleted */
code:					return SNMP_ERR_INCONSISTENTVALUE;
code:				break;
code:			case RS_NOTREADY:
code:				 /* management station cannot set this, only agent can */
code:			default:
code:				return SNMP_ERR_INCONSISTENTVALUE;
code:			}
code:			break;
code:		case RESERVE2:
code:			 /* memory reseveration, final preparation... */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:			case RS_CREATEANDWAIT:
code:				 /* creation */
code:				vars = NULL;
code:				$variables{$vroutine}{'code-varlist-add-null'}{'processed'} if (header_complex_parse_oid(&(name[sizeof(${vroutine}_variables_oid)/sizeof(oid)+2]), newlen, vars) != SNMPERR_SUCCESS) {
code:					 /* XXX: free, zero vars */
code:					return SNMP_ERR_INCONSISTENTNAME;
code:				}
code:				vp = vars;
				if ((StorageNew = ${vroutine}_create()) == NULL) {
code:					 /* XXX: free, zero vars */
code:					return SNMP_ERR_RESOURCEUNAVAILABLE;
code:				} $variables{$vroutine}{'code-varlist-copy'}{'processed'}
code:				 /* XXX: free, zero vars, no longer needed? */
code:				break;
code:			}
code:			break;
code:		case FREE:
code:			 /* Release any resources that have been allocated */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:			case RS_CREATEANDWAIT:
code:				 /* creation */
code:				${vroutine}_destroy(&StorageNew);
code:				 /* XXX: free, zero vars */
code:				break;
code:			}
code:			break;
code:		case ACTION:
code:			 /* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:			case RS_CREATEANDWAIT:
code:				 /* row creation, so add it */
code:				${vroutine}_add(StorageNew);
code:				break;
code:			case RS_ACTIVE:
code:			case RS_NOTINSERVICE:
code:				 /* set the flag? */
code:				old_value = StorageTmp->$name;
code:				StorageTmp->$name = set_value;
code:				break;
code:			case RS_DESTROY:
code:				 /* destroy */
code:				if (StorageTmp != NULL) {
code:					 /* exists, extract it for now */
code:					StorageDel = StorageTmp;
code:					${vroutine}_del(StorageDel);
code:				} else {
code:					StorageDel = NULL;
code:				}
code:				break;
code:			}
code:			break;
code:		case UNDO:
code:			 /* Back out any changes made in the ACTION case */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:			case RS_CREATEANDWAIT:
code:				 /* row creation, so remove it again */
code:				${vroutine}_del(StorageNew);
code:				break;
code:			case RS_ACTIVE:
code:			case RS_NOTINSERVICE:
code:				 /* restore state */
code:				StorageTmp->$name = old_value;
code:				break;
code:			case RS_DESTROY:
code:				 /* row deletion, so add it again */
code:				${vroutine}_add(StorageDel);
code:				break;
code:			}
code:			break;
code:		case COMMIT:
code:			 /* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
code:			switch (set_value) {
code:			case RS_CREATEANDGO:
code:				 /* row creation, set final state */
code:				 /* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
code:				StorageTmp->$name = RS_ACTIVE;
code:				break;
code:			case RS_CREATEANDWAIT:
code:				 /* row creation, set final state */
code:				 /* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
code:				StorageTmp->$name = RS_NOTINSERVICE;
code:				break;
code:			case RS_ACTIVE:
code:			case RS_NOTINSERVICE:
code:				 /* state change already performed */
code:				break;
code:			case RS_DESTROY:
code:				 /* row deletion, free it its dead */
code:				${vroutine}_destroy(&StorageDel);
code:				 /* ${vroutine}_destroy() can handle NULL pointers. */
code:				break;
code:			}
code:			break;
code:		}
code:		return SNMP_ERR_NOERROR;
code:	}
