#!/usr/bin/awk -f
# =============================================================================
# 
# @(#) $RCSfile: openss7-modules,v $ $Name:  $($Revision: 1.1.2.11 $) $Date: 2011-09-20 09:51:33 $
#
# -----------------------------------------------------------------------------
#
# Copyright (c) 2008-2013  Monavacon Limited <http://www.monavacon.com/>
# Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
# Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>
#
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>, or write to
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# -----------------------------------------------------------------------------
#
# U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
# behalf of the U.S. Government ("Government"), the following provisions apply
# to you.  If the Software is supplied by the Department of Defense ("DoD"), it
# is classified as "Commercial Computer Software" under paragraph 252.227-7014
# of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
# successor regulations) and the Government is acquiring only the license rights
# granted herein (the license rights customarily provided to non-Government
# users).  If the Software is supplied to any unit or agency of the Government
# other than DoD, it is classified as "Restricted Computer Software" and the
# Government's rights in the Software are defined in paragraph 52.227-19 of the
# Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
# the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
# (or any successor regulations).
#
# -----------------------------------------------------------------------------
#
# Commercial licensing and support of this software is available from OpenSS7
# Corporation at a fee.  See http://www.openss7.com/
#
# -----------------------------------------------------------------------------
#
# Last Modified $Date: 2011-09-20 09:51:33 $ by $Author: brian $
#
# =============================================================================

function getline_command(cmd)
{
    cmd | getline; close(cmd); return $0
}
function date(format)
{
    if (format) {
	return getline_command("date +\"" format "\"")
    } else {
	return getline_command("date -uIseconds")
    }
}
function year()
{
    return date("%Y")
}
function allyears(    this, last, sep, result)
{
    last = year(); sep = ""; result = ""
    for (this = 2009; this <= last; this++) {
	result = result sep this
	sep = ", "
    }
    return result
}
function print_vinfo(level, string)
{
    if ((values["quiet"]+0 == 0) && (values["verbose"]+0 >= level)) {
	print blu me ": I: " string std > stdout
	fflush(stdout)
	written[stdout] = 1
    }
}
function print_vmore(level, string)
{
    if (prog == "yes" && (values["quiet"]+0 == 0) && (values["verbose"]+0 >= level)) {
	printf "%s", blu me ": I: " string std cr lf > stdout
	fflush(stdout)
	written[stdout] = 1
    }
}
function print_debug(level, string)
{
    if (values["debug"]+0 >= level) {
	print mag me ": D: " string std > stderr
	fflush(stderr)
	written[stderr] = 1
    }
}
function print_dmore(level, string)
{
    if (prog == "yes" && values["debug"]+0 >= level) {
	printf "%s", mag me ": D: " string std cr lf > stderr
	fflush(stderr)
	written[stderr] = 1
    }
}
function print_error(string)
{
    print red me ": E: " string std > stderr
    if (count_errs) errors = errors "\n"
    errors = errors red me ": E: " string std
    fflush(stderr)
    written[stderr] = 1
    count_errs++
}
function print_emore(string)
{
    print red me ": E: " string std > stderr
    if (count_errs) errors = errors "\n"
    errors = errors red me ": E: " string std
    fflush(stderr)
    written[stderr] = 1
}
function print_warns(string)
{
    if ((values["quiet"] == 0) || (values["verbose"]+0 > 0) || (values["debug"]+0 > 0)) {
	print org me ": W: " string std > stderr
	fflush(stderr)
	written[stderr] = 1
    }
    count_warn++
}
function print_wmore(string)
{
    if ((values["quiet"] == 0) || (values["verbose"]+0 > 0) || (values["debug"]+0 > 0)) {
	print org me ": W: " string std > stderr
	fflush(stderr)
	written[stderr] = 1
    }
}
function usage(output)
{
    if (values["quiet"])
	return
    print "\
" me ":\n\
  $Id: openss7-modules,v 1.1.2.11 2011-09-20 09:51:33 brian Exp $\n\
Usage:\n\
  [awk -f ]" me " -- [options] [mode] [" longargs["kernels"] "]\n\
  [awk -f ]" me " -- -" gensub(/!/, "", 1, longopts["help"]) ", --help\n\
  [awk -f ]" me " -- -" gensub(/!/, "", 1, longopts["version"]) ", --version\n\
  [awk -f ]" me " -- -" gensub(/!/, "", 1, longopts["copying"]) ", --copying\
" > output
    written[output] = 1
}
function help_usage(name,  line,sep,dflt,env,valu)
{
    line = ""; sep = ""; dflt = ""; env = ""
    if (name in defaults && longopts[name] !~ /!/) {
	if (longopts[name]~/:/) {
	    dflt = defaults[name]
	} else {
	    if (defaults[name]) { dflt = "yes" } else { dflt = "no" }
	}
	#if (dflt) {
	    line = line sep "[default: '" dflt "']"; sep = " "
	#}
    }
    if (name in environs && longopts[name] !~ /!/) {
	if (longopts[name]!~/:/) env = "?"
	if (environs[name])
	    line = line sep "{" env environs[name] "}"; sep = " "
    }
    if (name in values && longopts[name] !~ /!/) {
	if (longopts[name]~/:/) {
	    valu = values[name]
	} else {
	    if (values[name]) { valu = "yes" } else { valu = "no" }
	}
	if (line) sep = "\n      "
	line = line sep "(current: '" valu "')"; sep = " "
    }
    return line
}
function help_opttags(name,  line,char,opt,oth)
{
    line = ""
    if (name in longopts) {
	opt = longopts[name]
	if (opt~/[[:alnum:]]/) {
	    char = opt
	    gsub(/[:!]/,"",char)
	    line = "-" char ", --" name
	} else {
	    line = "--" name
	}
	if (name in longargs) { line = line " " longargs[name] } else
	if (opt~/::$/) { line = line " [" toupper(name) "]" } else
	if (opt~/:$/)  { line = line " " toupper(name) } else
	if (opt!~/!$/) { line = line ", --no-" name }
	if (opt~/[[:alnum:]]/) {
	    for (oth in longopts) {
		if (opt != longopts[oth]) continue
		if (oth == name) continue
		line = line ", --" oth
		if (oth in longargs) { line = line " " longargs[oth] } else
		if (opt~/::$/) { line = line " [" toupper(oth) "]" } else
		if (opt~/:$/)  { line = line " " toupper(oth) } else
		if (opt!~/!$/) { line = line ", --no-" oth }
	    }
	}
    }
    return line
}
function help_option(output, name,
		     desc)
{
    printf "  %s\n", help_opttags(name) > output
    if (name in descrips && descrips[name])
	printf "      %s\n", gensub(/\n/, "\n      ", "g", descrips[name]) > output
    if ((name in defaults || name in environs) && help_usage(name))
	printf "      %s\n", help_usage(name) > output
}
function help_options(output,		opt,char,pos,long,n,sorted,i)
{
    if (!optstring) return
    print "Options:" > output; written[output] = 1
    # index all of the long options
    for (opt in longopts) {
	char = substr(longopts[opt],1,1)
	if (char && char != ":") {
	    if (char in optchars) {
		if (char == substr(opt,1,1))
		    optchars[char] = opt
	    } else
		optchars[char] = opt
	}
    }
    for (pos=1;pos<=length(optstring);pos++) {
	char = substr(optstring,pos,1)
	if (char == "*") {
	    # document any long-only options
	    n = asorti(longopts,sorted)
	    for (i=1;i<=n;i++) {
		long = sorted[i]
		if (longopts[long]~/^[[:alnum:]]/) continue
		help_option(output, long)
	    }
	}
	if (char!~/[[:alnum:]]/) continue
	if (!(char in optchars)) continue
	help_option(output, optchars[char])
    }
}
function help(output)
{
    if (values["quiet"])
	return
    usage(output)
    print "\
Arguments:\n\
  " longargs["kernels"] "\n\
      " descrips["kernels"] "\
" > output
    help_options(output)
    written[output] = 1
}
function version(output)
{
    if (values["quiet"])
	return
    print "\
Version 2.1\n\
$Id: openss7-modules,v 1.1.2.11 2011-09-20 09:51:33 brian Exp $\n\
Copyright (c) 2008, " allyears() "  Monavacon Limited.\n\
Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008  OpenSS7 Corporation.\n\
Copyright (c) 1997, 1998, 1999, 2000, 2001  Brian F. G. Bidulock.\n\
\n\
All Rights Reserved.\n\
\n\
This is free software; see the source for copying conditions.  There is NO\n\
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\
\n\
Distributed by OpenSS7 under GNU Affero General Public License Version 3,\n\
with conditions, incorporated herein by reference.\n\
\n\
See " me " -- --copying' for copying permissions.\
" > output
    written[output] = 1
}
function copying(output)
{
    if (values["quiet"])
	return
    print "\
--------------------------------------------------------------------------------\n\
$Id: openss7-modules,v 1.1.2.11 2011-09-20 09:51:33 brian Exp $\n\
--------------------------------------------------------------------------------\n\
Copyright (c) 2008, " allyears() "  Monavacon Limited.\n\
Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008  OpenSS7 Corporation.\n\
Copyright (c) 1997, 1998, 1999, 2000, 2001  Brian F. G. Bidulock.\n\
\n\
All Rights Reserved.\n\
--------------------------------------------------------------------------------\n\
This program is free software; you can  redistribute  it and/or modify  it under\n\
the terms  of the  GNU  Affero General Public  License as published  by the Free\n\
Software Foundation; version 3 of the License.\n\
\n\
This program is distributed in the hope that it will  be useful, but WITHOUT ANY\n\
WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A\n\
PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.\n\
\n\
You should have received a copy of the  GNU Affero General Public License  along\n\
with this program.   If not, see <http://www.gnu.org/licenses/>, or write to the\n\
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
--------------------------------------------------------------------------------\n\
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf\n\
of the U.S. Government (\"Government\"), the following provisions apply to you. If\n\
the Software is supplied by the  Department of Defense (\"DoD\"), it is classified\n\
as \"Commercial  Computer  Software\"  under  paragraph  252.227-7014  of the  DoD\n\
Supplement  to the  Federal Acquisition Regulations  (\"DFARS\") (or any successor\n\
regulations) and the  Government  is acquiring  only the  license rights granted\n\
herein (the license rights customarily provided to non-Government users). If the\n\
Software is supplied to any unit or agency of the Government  other than DoD, it\n\
is  classified as  \"Restricted Computer Software\" and the Government's rights in\n\
the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition\n\
Regulations (\"FAR\")  (or any successor regulations) or, in the cases of NASA, in\n\
paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor\n\
regulations).\n\
--------------------------------------------------------------------------------\n\
Commercial  licensing  and  support of this  software is  available from OpenSS7\n\
Corporation at a fee.  See http://www.openss7.com/\n\
--------------------------------------------------------------------------------\
" > output
    written[output] = 1
}
function getopt_long(argc, argv, optstring, longopts, longindex,
		     pos, needarg, wantarg, modearg)
{
    option = ""; optval = ""; optarg = ""; optset = ""; pos = 0; needarg = 0; wantarg = 0; modearg = 0
    if (optind == 0) { optind = 1; more = "" }
    while ((optind < argc) || (more != "")) {
	if (more) { arg = "-" more; more = "" }
	else { arg = argv[optind]; optind++ }
	if (arg ~ /^--?[a-zA-Z0-9]/) {
	    if (wantarg) {
		more = substr(arg, 2)
		if (option in defaults)
		    optarg = defaults[option]
		return optval
	    }
	    if (needarg) {
		print_error("option -" optval " requires an argument")
		usage(stderr)
		exit 2
	    }
	    if (arg ~ /^--[a-zA-Z0-9][-_a-zA-Z0-9]*=.*$/) {
		option = arg; sub(/^--/, "", option); sub(/=.*$/, "", option)
		optarg = arg; sub(/^--([a-zA-Z0-9][-_a-zA-Z0-9]*)=/, "", optarg)
		optset = 1
		if (!(option in longopts)) {
		    print_error("option --" option " not recognized")
		    usage(stderr)
		    exit 2
		}
		if (longopts[option] !~ /:/) {
		    print_error("option --" option " does not take an argument")
		    usage(stderr)
		    exit 2
		}
		optval = substr(longopts[option], 1, 1)
		return optval
	    }
	    if (arg ~ /^--[a-zA-Z0-9][-_a-zA-Z0-9]*$/) {
		option = arg; sub(/^--/, "", option)
		optset = 1
		if (!(option in longopts)) {
		    optset = 0
		    sub(/^no-/,"",option)
		    if (!(option in longopts)) {
			print_error("option --" option " not recognized")
			usage(stderr)
			exit 2
		    }
		}
		if (longopts[option] ~ /::/) { wantarg = 1 } else
		if (longopts[option] ~ /:/ ) { needarg = 1 } else
		if (longopts[option] ~ /!/ ) { modearg = 1 }
		if ((wantarg || needarg || modearg) && !optset) {
		    print_error("option --no-" option " not recognized")
		    usage(stderr)
		    exit 2
		}
		optval = substr(longopts[option], 1, 1)
		for (option in longopts)
		    if (substr(longopts[option], 1, 1) == optval)
			break
		if (!needarg && !wantarg)
		    return optval
		continue
	    }
	    if (arg ~ /^-[a-zA-Z0-9]/) {
		optval = substr(arg, 2, 1)
		pos = index(optstring, optval)
		optset = 1
		if (pos == 0 || substr(optstring, pos, 1) == "*") {
		    print_error("option -" optval " not recognized")
		    usage(stderr)
		    exit 2
		}
		if (substr(optstring, pos+1, 1) == ":") {
		    if (length(arg) > 2) {
			if (substr(optstring, pos+2, 1) == ":") {
			    more = substr(arg, 3)
			    if (more && more !~ /^[a-zA-Z0-9]/) {
				print_error("bad option sequence " arg)
				usage(stderr)
				exit 2
			    }
			} else
			    optarg = substr(arg, 3)
			for (option in longopts)
			    if (substr(longopts[option], 1, 1) == optval)
				break
			return optval
		    }
		    if (substr(optstring, pos+2, 1) == ":") { wantarg = 1 } else
		    if (substr(optstring, pos+1, 1) == ":") { needarg = 1 }
		    for (option in longopts)
			if (substr(longopts[option], 1, 1) == optval)
			    break
		    continue
		} else optset = 1
		if (length(arg) > 2) { more = substr(arg, 3) } else { more = "" }
		if (more && more !~ /^[a-zA-Z0-9]/) {
		    print_error("bad option sequence " arg)
		    usage(stderr)
		    exit 2
		}
		for (option in longopts)
		    if (substr(longopts[option], 1, 1) == optval)
			break
		return optval
	    }
	}
	if (arg == "--") {
	    if (wantarg) {
		if (option in defaults)
		    optarg = defaults[option]
		optind--
		return optval
	    }
	    return -1
	}
	if (needarg || wantarg) {
	    optarg = arg
	    return optval
	}
	optind--
	return -1
    }
    if (wantarg) {
	if (option in defaults)
	    optarg = defaults[option]
	return optval
    }
    if (needarg) {
	print_error("option -" optval " requires an argument")
	usage(stderr)
	exit 2
    }
    return -1
}
function system_command(cmd)
{
    print_debug(3, "x: " cmd); return system(cmd)
}
function rpmlessthan(ver1,ver2,	    seg1,seg2,n,n1,n2,i,num1,num2,m,m1,m2,j,s1,s2,x1,x2)
{
    n1 = split(ver1,seg1,/[-:]/)
    n2 = split(ver2,seg2,/[-:]/)
    if (n1>n2) { n = n1 } else { n = n2 }
    for (i=1;i<=n;i++) {
	if (!(i in seg1) && (i in seg2)) { return 1 }
	if ((i in seg1) && !(i in seg2)) { return 0 }
	m1 = split(seg1[i],num1,/[^[:alnum:]]/)
	m2 = split(seg2[i],num2,/[^[:alnum:]]/)
	if (m1>m2) { m = m1 } else { m = m2 }
	for (j=1;j<=m;j++) {
	    if (!(j in num1) && (j in num2)) { return 1 }
	    if ((j in num1) && !(j in num2)) { return 0 }
	    s1 = num1[j]
	    s2 = num2[j]
	    while (1) {
		sub(/^[^[:alnum:]]+/, "", s1)
		sub(/^[^[:alnum:]]+/, "", s2)
		if (s1~/^[[:digit:]]/ || s2~/^[[:digit:]]/) {
		    x1 = s1; sub(/^0*/, "", x1); sub(/[^[:digit:]].*$/, "", x1)
		    x2 = s2; sub(/^0*/, "", x2); sub(/[^[:digit:]].*$/, "", x2)
		    if (length(x1) < length(x2)) return 1
		    if (length(x2) > length(x1)) return 0
		    if (x1 < x2) return 1
		    if (x2 < x1) return 0
		    sub(/^0*[[:digit:]]*/, "", s1)
		    sub(/^0*[[:digit:]]*/, "", s2)
		} else {
		    x1 = s1; sub(/[^[:alpha:]].*$/, "", x1)
		    x2 = s2; sub(/[^[:alpha:]].*$/, "", x2)
		    if (x1 == "" && x2 == "") break
		    if (x1 < x2) return 1
		    if (x2 < x1) return 0
		    sub(/^([[:alpha:]]*)/, "", s1)
		    sub(/^([[:alpha:]]*)/, "", s2)
		}
	    }
	}
    }
    # dead equal
    return 0
}

function rpmsort(versions, n,		swapped,i,version) {
    do {
	swapped = 0
	for (i=1;i<n;i++) {
	    if (rpmlessthan(versions[i+1],versions[i]) == 1) {
		version = versions[i+1]
		versions[i+1] = versions[i]
		versions[i] = version
		swapped = 1
	    }
	}
    } while (swapped)
}
#
# pathversion()
#
# Get the module version for the symbolic link.  This is the directory in which
# it resides instead of the module kernel version.
#
function pathversion(module,			pfx,kversion)
{
    pfx = "r: pathvers,  "
    kversion = module
    if (sub(/^.*\/lib\/modules\//, "", kversion)) {
	sub(/\/.*$/, "", kversion)
    } else {
	kversion = ""
    }
    return kversion
}
function pathsubdir(module,			pfx,subdir)
{
    pfx = "r: subdir,    "
    subdir = module 
    if (sub(/^.*\/lib\/modules\/[^\/][^\/]*\//, "", subdir)) {
	if (values["style"] != "suse11") {
	    sub(/^[^\/]*\//, "", subdir)
	} else sub(/^kernel\//, "", subdir)
	sub(/\/[^\/][^\/]*$/, "", subdir)
    } else {
	subdir = values["package"]
    }
    return subdir
}
function fileversion(module,			pfx,kversion)
{
    pfx = "r: filevers,  "
    kversion = ""
    if (system("test -r \"" module "\"") == 0) {
	command = catcommand(module) " | strings | grep -m 1 '^vermagic='"
	while((command | getline) == 1) { sub(/=/, " "); kversion = $2 }
	close(command)
	if (!kversion) print_error(pfx "no vermagic for " module)
    } else {
	print_error(pfx "cannot read " module)
    }
    return kversion
}
#global counts["hard"] = hard counts
#global counts["link"] = link counts
#global counts["uniq"] = uniq counts
#global counts["kern"] = kern counts
#global modules[file] = kversion
#global subdirs[file] = subpath
#global kernels[i] = kversion (rpm sorted)
#global modnames[kversion,name] = file
#global names[name] = 1
#global weakmods[file] = kversion
#global weaklinks[file] = module
#global weaknames[kversion,name] = file
function getstructure(		pfx,dirs,dir,paths,path,command,h,l,u,k,ph,pl,file,module,weakmod,subdir,name,kversion,kversions,cmd)
{
    pfx = "r: structure, "
    if ("weakdir" in values)
    { subdir =   values["weakdir"] } else
    { subdir = defaults["weakdir"] }
    sub(/^\/\/*/, "", subdir)
    sub(/\/\/*$/, "", subdir)
    if (!subdir) subdir = "weak-updates"
    dirs = ""
    dir = values["rootdir"] "/lib/modules"
    if (system_command("test -d " dir) == 0)
	if (dirs == "") { dirs = dir } else { dirs = dirs " " dir }
    if (values["rootdir"] != values["basedir"]) {
	dir = values["basedir"] "/lib/modules"
	if (system_command("test -d " dir) == 0)
	    if (dirs == "") { dirs = dir } else { dirs = dirs " " dir }
    }
    k = 0
    if (dirs != "") {
	print_vinfo(2, pfx "dirs = " dirs)
	command = "find " dirs " -maxdepth 2 -type d 2>/dev/null"
	while ((command | getline) == 1) {
	    if (/\/kernel/) {
		kversion = pathversion($0)
		if (kversion && !(kversion in kversions)) {
		    kversions[kversion] = 1; k++
		}
	    }
	    if ($0"/"!~"/(extra|updates|openss7|" subdir ")/") continue
	    paths[$0] = 1
	}
	close(command)
    }
    dirs = ""
    for (path in paths) {
	if (dirs == "") { dirs = path } else { dirs = dirs " " path }
    }
    if (values["test"]) {
	if (dirs == "") { dirs = "`pwd`" } else { dirs = "`pwd`" " " dirs }
    }
    h = 0; l = 0; u = 0; k = 0
    if (dirs != "") {
	print_vinfo(2, pfx "dirs = " dirs)
	ph = 0; pl = 0
	command = "find " dirs " -name '*.ko' -o -name '*.ko.gz' 2>/dev/null"
	while ((command | getline file) == 1) {
	    #if (file~/\/lib\/modules\/[^\/]*\/kernel\//) continue
	    name = file; sub(/^.*\//, "", name)
	    if (!(name in names)) { names[name] = 1; u++ }
	    kversion = pathversion(file)
	    if (!kversion) { kversion = fileversion(file) }
	    if (!kversion) { continue }
	    if (kversion in kremoved) {
		print_vinfo(3, pfx "marking for deletion: " file)
		delmods[file] = kversion
		if ((kversion,name) in modremoves)
		{ modremoves[kversion,name] = modremoves[kversion,name] "," file } else
		{ modremoves[kversion,name] = file }
	    }
	    if (!(kversion in kversions)) { kversions[kversion] = 1; k++ }
	    if (file~"/(extra|updates|openss7|" subdir ")/") {
		weakmods[file] = fileversion(file)
		print_debug(3,pfx "module " file " = " kversion)
		if (system("test -L " file) == 0) {
		    cmd = "readlink " file
		    while ((cmd | getline) == 1) { module = $0 }
		    close(cmd)
		    weaklinks[file] = module
		    print_debug(3,pfx "symbolic link " file " -> " module)
		}
		l++; pl++
		if (pl >= 100) {
		    print_vmore(3, pfx sprintf("%03d modules; %03d links; %03d names; %02d kernels", h, l, u, k))
		    pl = 0; ph = 0
		}
		if ((kversion,name) in weaknames && weaknames[kversion,name] != file)
		{ weaknames[kversion,name] = weaknames[kversion,name] "," file
		  print_error(pfx "conflict amoung updates for " name ", " weaknames[kversion,name]) } else
		{ weaknames[kversion,name] = file }
		weaknames[name] = 1
		#print_vinfo(4, pfx "name = " name)
		#print_vinfo(4, pfx "vers = " kversion)
		#print_vinfo(4, pfx "file = " file)
		#print_vinfo(4, pfx "weak = " "yes")
		#print_vinfo(4, pfx "link = " module)
	    } else {
		modules[file] = kversion
		subdirs[file] = pathsubdir(file)
		h++; ph++
		if (ph >= 100) {
		    print_vmore(3, pfx sprintf("%03d modules; %03d links; %03d names; %02d kernels", h, l, u, k))
		    pl = 0; ph = 0
		}
		if ((kversion,name) in modnames && modnames[kversion,name] != file)
		{ modnames[kversion,name] = modnames[kversion,name] "," file
		  print_error(pfx "conflict amoung modules for " name ", " modnames[kversion,name]) } else
		{ modnames[kversion,name] = file }
		modnames[name] = 1
		#print_vinfo(4, pfx "name = " name)
		#print_vinfo(4, pfx "vers = " kversion)
		#print_vinfo(4, pfx "file = " file)
		#print_vinfo(4, pfx "weak = " "no")
		#print_vinfo(4, pfx "subd = " subdirs[file])
	    }
	}
	close(command)
    }
    print_vinfo(2, pfx sprintf("%03d modules; %03d links; %03d names; %02d kernels", h, l, u, k))
    counts["hard"] = h
    counts["link"] = l
    counts["uniq"] = u
    counts["kern"] = k
    asorti(kversions,kernels)
    rpmsort(kernels,k)
    # Fill in the gaps between installed kernel module version.  That is, assign the more recent
    # installed kernel modules for kernels that do not have any modules of their own.  Smear them
    # one way and then the other to fill in the gaps.
    n = 0
    for (name in names) {
	module = ""
	#weakmod = ""
	for (k=counts["kern"];k>0;k--) { kversion = kernels[k]
	    if (module == "")
	    { if ( ((kversion,name) in modnames )) { module =  modnames[kversion,name] } else
	    { if ( ((kversion,name) in weaknames)) { module = weaknames[kversion,name] } } } else
	    { if (!((kversion,name) in modnames )) {  modnames[kversion,name] = module } }
	    #if (weakmod == "")
	    #{ if ( ((kversion,name) in weaknames)) { weakmod = weaknames[kversion,name] } } else
	    #{ if (!((kversion,name) in weaknames)) { weaknames[kversion,name] = weakmod } }
	}
	module = ""
	#weakmod = ""
	for (k=1;k<=counts["kern"];k++) { kversion = kernels[k]
	    if (module == "")
	    { if ( ((kversion,name) in modnames )) { module =  modnames[kversion,name] } else
	    { if ( ((kversion,name) in weaknames)) { module = weaknames[kversion,name] } } } else
	    { if (!((kversion,name) in modnames )) {  modnames[kversion,name] = module } }
	    #if (weakmod == "")
	    #{ if ( ((kversion,name) in weaknames)) { weakmod = weaknames[kversion,name] } } else
	    #{ if (!((kversion,name) in weaknames)) { weaknames[kversion,name] = weakmod } }
	}
	n++
    }
    for (k=1;k<=counts["kern"];k++) { kversion = kernels[k]
	for (name in names) {
	    if (name in weaknames) {
		if (!((kversion,name) in weaknames))
		    print_warns(pfx sprintf("weakname for (%s,%s) does not exist", kversion,name))
		else
		    print_debug(4,pfx sprintf("weakname for (%s,%s) is %s", kversion,name,weaknames[kversion,name]))
	    }
	    if (name in modnames) {
		if (!((kversion,name) in modnames))
		    print_error(pfx sprintf("modname for (%s,%s) does not exist", kversion,name))
		else
		    print_debug(4,pfx sprintf("modname for (%s,%s) is %s", kversion,name,modnames[kversion,name]))
	    }
	}
    }
    return n
}
function readsymmap(kversion, file, command, pfx, maps,
		    fmt,n,pn,sym,c,pc,bads,d,pd)
{
    # read the symbol map for kernel "kversion"
    fmt = "%05d maps, %04d bads, %04d dups"
    n = 0; c = 0; d = 0; pn = 0; pc = 0; pd = 0
    print_vinfo(2, pfx "file = " file)
    if (system("test -r " file) == 0) {
	print_vmore(2, pfx sprintf(fmt, n, c, d))
	while ((command | getline) == 1) {
	    if (NF!=3) continue
	    if (!($3 in maps)) {
		maps[$3] = $1
		n++; pn++
		if (pn >= 1000) {
		    print_vmore(2, pfx sprintf(fmt, n, c, d))
		    pn = 0; pc = 0; pd = 0
		}
	    } else
	    if (maps[$3] != $1) {
		maps[$3] = $1
		bads[$3] = 1
		c++; pc++
		if (pc >= 100) {
		    print_vmore(2, pfx sprintf(fmt, n, c, d))
		    pn = 0; pc = 0; pd = 0
		}
	    } else {
		d++; pd++
		if (pd >= 100) {
		    print_vmore(2, pfx sprintf(fmt, n, c, d))
		    pn = 0; pc = 0; pd = 0
		}
	    }
	}
	close(command)
	for (sym in bads) { delete maps[sym]; n-- }
    } else {
	print_debug(2,pfx "file not found " file)
    }
    print_vinfo(2, pfx sprintf(fmt, n, c, d))
    return n
}
function catcommand(file,
		    command)
{
    command = "cat " file
    if (file~/\.gz/)
	command = "gzip -dc " file
    if (file~/\.bz2/)
	command = "bzip2 -dc " file
    if (file~/\.xz/)
	command = "xz -dc " file
    return command
}
function nmbcommand(file,
		    name,command)
{
    command = "nm -Bs " file
    name = "/var/tmp/" me "." PROCINFO["pid"] ".vmlinux"
    if (file~/\.gz/)
	command = "( gzip -dc " file " >" name "; nm -Bs " name "; rm -f -- " name " ) 2>/dev/null"
    if (file~/\.bz2/)
	command = "( bzip2 -dc " file " >" name "; nm -Bs " name "; rm -f -- " name " ) 2>/dev/null"
    if (file~/\.xz/)
	command = "( xz -dc " file " >" name "; nm -Bs " name "; rm -f -- " name " ) 2>/dev/null"
    return command
}
#global sysmaps[kversion,sym] = address
#global counts["sysmap",kversion] = count
function readsysmap(kversion, file,
		    pfx,n,sym,add,maps,command)
{
    pfx = "r: sysmap,    "
    command = catcommand(file)
    n = readsymmap(kversion, file, command, pfx, maps)
    for (sym in maps) {
	add = maps[sym]
	sysmaps[kversion,sym] = add
	if ((kversion,sym) in allsyms && allsyms[kversion,sym] != add) {
	    if (usesysmap[kversion] != 0) {
		print_warns(pfx "kernel, " kversion ", does not match running kernel of same version")
		usesysmap[kversion] = 0
	    }
	    print_debug(9,pfx sprintf("0x%s != 0x%s (%s:%s)",add,allsyms[kversion,sym],kversion,sym))
	    #print_debug(9,pfx "ksym(" kversion ":" sym ") = 0x" add " != 0x" allsyms[kversion,sym])
	}
    }
    return n
}
function readvmlinux(kversion, file,
		     pfx,n,sym,add,maps,command)
{
    pfx = "r: vmlinux,   "
    command = nmbcommand(file)
    n = readsymmap(kversion, file, command, pfx, maps)
    for (sym in maps) {
	add = maps[sym]
	sysmaps[kversion,sym] = add
	if ((kversion,sym) in allsyms && allsyms[kversion,sym] != add) {
	    if (usesysmap[kversion] != 0) {
		print_warns(pfx "kernel, " kversion ", does not match running kernel of same version")
		usesysmap[kversion] = 0
	    }
	    print_debug(9,pfx sprintf("0x%s != 0x%s (%s:%s)",add,allsyms[kversion,sym],kversion,sym))
	    #print_debug(9,pfx "ksym(" kversion ":" sym ") = 0x" add " != 0x" allsyms[kversion,sym])
	}
    }
    return n
}
#global allsyms[sym] = address
#global counts["allsym",kversion] = count
function readallsym(kversion, file,
		    pfx,n,sym,add,maps,command)
{
    pfx = "r: allsym,    "
    command = catcommand(file)
    n = readsymmap(kversion, file, command, pfx, maps)
    if (n == 0) usesysmap[kversion] = 0
    for (sym in maps) {
	add = maps[sym]
	allsyms[kversion,sym] = add
	if ((kversion,sym) in sysmaps && sysmaps[kversion,sym] != add) {
	    if (usesysmap[kversion] != 0) {
		print_warns(pfx "kernel, " kversion ", does not match running kernel of same version")
		usesysmap[kversion] = 0
	    }
	    print_debug(9,pfx sprintf("0x%s != 0x%s (%s:%s)",add,sysmaps[kversion,sym],kversion,sym))
	    #print_debug(9,pfx "ksym(" kversion ":" sym ") = 0x" add " != 0x" sysmaps[kversion,sym])
	}
    }
    return n
}
#global symvers[kversion,sym] = crc
#global counts["symver",kversion] = count
function readsymabi(kversion, file,
		    pfx,n,command,sym,crc)
{
    pfx = "r: symabi,    "
    n = 0
    print_vinfo(2, pfx "file = " file)
    if (system("test -r " file) == 0) {
	command = catcommand(file)
	while ((command | getline) == 1) {
	    if (NF<4) continue
	    if ($2 != "vmlinux") continue
	    sym = $4; crc = $3
	    if (!((kversion,sym) in symvers)) {
		symvers[kversion,sym] = crc
		n++
	    } else
	    if (symvers[kversion,sym] != crc) {
		print_error(pfx "conflicting crc for " sym " in " kversion)
		symvers[kversion,sym] = crc
	    } else {
		print_warns(pfx "duplicate crc for " sym " in " kversion)
	    }
	    if (crc != "0x00000000") {
		modversions = 1
	    }
	}
	close(command)
    } else {
	print_vinfo(2,pfx "no symbol versions for kernel " kversion ", file " file)
    }
    return n
}
function readsymver(kversion, file,
		    pfx,fmt,n,pn,command,sym,crc)
{
    pfx = "r: symver,    "
    n = 0; pn = 0
    print_vinfo(2, pfx "file = " file)
    if (system("test -r " file) == 0) {
	command = catcommand(file)
	while ((command | getline) == 1) {
	    if (NF<3) continue
	    if ($3 != "vmlinux") continue
	    sym = $2; crc = $1
	    if (!((kversion,sym) in symvers)) {
		symvers[kversion,sym] = crc
		n++; pn++
		if (pn >= 200) {
		    print_vmore(2,pfx "syms " n)
		    pn = 0
		}
	    } else
	    if (symvers[kversion,sym] != crc) {
		print_error(pfx "conflicting crc for " sym " in " kversion)
		symvers[kversion,sym] = crc
	    } else {
		print_warns(pfx "duplicate crc for " sym " in " kversion)
	    }
	    if (crc != "0x00000000") {
		modversions = 1
	    }
	}
	close(command)
    } else {
	print_vinfo(2,pfx "no symbol versions for kernel " kversion ", file " file)
    }
    print_vmore(2, pfx "syms " n)
    return n
}
function readkernel(kversion,
		    pfx,fmt,n,m,pm,s,ps,find,command,module,SECTION,string,char,sym,crc,file,dir,tmpdir,dirs,written)
{
    pfx = "r: kernel,    "
    fmt = "%04d modules, %05d symbols"
    print_vinfo(2, pfx "version = " kversion)
    tmpdir = "/var/tmp/" me "." PROCINFO["pid"] ".modules"
    system_command("mkdir -p -- " tmpdir)
    find = "find /lib/modules/" kversion "/kernel -type f \\( -name '*.ko' -o -name '*.ko.gz' \\) 2>/dev/null"
    if (system("test -d /lib/modules/" kversion "/kernel") != 0) {
	system_command("rm -rf-- " tmpdir)
	return
    }
    system_command("rm -f -- " tmpdir "/modules.list 2>/dev/null")
    written = 0
    while ((find | getline file) == 1) {
	if (file~/\.ko\.gz$/) {
	    dir = tmpdir "/" file
	    sub(/\/[^\/]*$/, "", dir)
	    if (!(dir in dirs)) {
		system_command("mkdir -p -- " dir)
		dirs[dir] = 1
	    }
	    sub(/\.ko\.gz$/, ".ko", file)
	    system_command("gzip -dc " file ".gz >" tmpdir "/" file)
	    print tmpdir "/" file >> tmpdir "/modules.list"
	} else {
	    print file >> tmpdir "/modules.list"
	}
	written = 1
    }
    close(find)
    if (written == 0) {
	system_command("rm -rf-- " tmpdir)
	return
    }
    close(tmpdir "/modules.list")
    command = "cat " tmpdir "/modules.list | xargs -r objdump -j __versions -s"
    SECTION = ""; string = ""; module = ""
    n = 0; m = 0; s = 0; pm = 0; ps = 0
    print_vmore(2, pfx sprintf(fmt, m, s))
    while ((command | getline) == 1) {
	if (SECTION) {
	    if (/^$/) {
		SECTION = ""
	    } else
	    if (SECTION == "__versions") {
		sub(/^ .... /, ""); sub(/  .*$/, ""); gsub(/ /, "")
		string = string $0
		if (length(string) < 128)
		    continue
		sub(/(00)+$/, "",string)
		crc = "0x" substr(string,7,2) substr(string,5,2) substr(string,3,2) substr(string,1,2)
		sub(/^......../, "", string)
		if (crc == "0x00000000")
		{ crc = "0x" substr(string,1,8); sub(/^......../,"",string) }
		sub(/^00000000/, "", string)
		sym = ""
		while (string) {
		    char = "0x" substr(string,1,2)
		    sub(/^../, "", string)
		    char = strtonum(char)
		    if (32 <= char && char <= 126)
			sym = sym sprintf("%c", char)
		}
		if (sym~/[^A-Za-z0-9_]/)
		    print_error(pfx "ksym(" kversion ":" sym ") = " crc)
		if (!((kversion,sym) in sysmaps) && !((kversion,sym) in allsyms)) {
		    continue
		}
		if (!((kversion,"__kcrctab_"sym) in sysmaps) && !((kversion,"__kcrctab_"sym) in allsyms)) {
		    continue
		}
		if (!((kversion,sym) in symvers)) {
		    symvers[kversion,sym] = crc
		    n++; s++; ps++
		    #if (ps >= 1000) {
			#print_vmore(2, pfx sprintf(fmt, m, s))
			#ps = 0; pm = 0
		    #}
		} else
		if (symvers[kversion,sym] != crc) {
		    print_error(pfx "conflicting crc for " sym " in " kversion)
		    symvers[kversion,sym] = crc
		}
		# expect duplicates
		if (crc != "0x00000000") {
		    modversions = 1
		}
	    }
	} else {
	    if (/^$/)
		continue
	    if (sub(/^Contents of section /,"")) {
		sub(/:.*$/, "")
		SECTION = $0
		string = ""
	    } else
	    if (sub(/:.*file format.*$/, "")) {
		if (module) {
		    m++; pm++
		    if (pm >= 100) {
			print_vmore(2, pfx sprintf(fmt, m, s))
			ps = 0; pm = 0
		    }
		}
		module = $0
		if (module~"^" tmpdir "/") {
		    sub("^" tmpdir "/", "", module)
		    module = module ".gz"
		}
	    }
	}
    }
    close(command)
    system_command("rm -rf-- " tmpdir)
    print_vinfo(2, pfx sprintf(fmt, m, s))
    if (n == 0) print_warns(pfx "no symbol versions for kernel " kversion ", from kernel modules")
    if (m == 0) print_warns(pfx "no kernel  modules for kernel " kversion)
    return n
}
function getsysmap(kversion,
		   pfx,n,file)
{
    pfx = "r: sysmap,    "
    n = 0
    print_vinfo(2, pfx "version = " kversion)
    if (("sysmap",kversion) in counts) {
	n = counts["sysmap",kversion]
    } else {
	file = values["sysmap"]
	gsub(/\$KVERSION/,kversion,file)
	gsub(/\$PACKAGE/,values["package"],file)
	if (values["basedir"] && system("test -r " values["basedir"] file) == 0)
	    file = values["basedir"] file
	else
	    file = values["rootdir"] file
	n = readsysmap(kversion, file)
	counts["sysmap",kversion] = n
    }
    print_vinfo(2, pfx "syms " n)
    return n
}
function getvmlinux(kversion,
		    pfx,n,file)
{
    pfx = "r: vmlinux,   "
    n = 0
    print_vinfo(2, pfx "version = " kversion)
    if (("vmlinux",kversion) in counts) {
	n = counts["vmlinux",kversion]
    } else {
	file = values["vmlinux"]
	gsub(/\$KVERSION/,kversion,file)
	gsub(/\$PACKAGE/,values["package"],file)
	if (values["basedir"] && system("test -r " values["basedir"] file) == 0)
	    file = values["basedir"] file
	else
	    file = values["rootdir"] file
	n = readvmlinux(kversion, file)
	counts["vmlinux",kversion] = n
    }
    print_vinfo(2, pfx "syms " n)
    return n
}
function getallsym(kversion,
		   pfx,n,file)
{
    pfx = "r: allsym,    "
    n = 0
    print_vinfo(2, pfx "version = " kversion)
    if (("allsym",kversion) in counts) {
	n = counts["allsym",kversion]
    } else {
	file = values["allsym"]
	n = readallsym(kversion, file)
	counts["allsym",kversion] = n
    }
    print_vinfo(2, pfx "syms " n)
    return n
}
# getsysver()
# There are three places to check: /boot/symvers-$kversion.gz, /lib/modules/$kversion/build/-
# Modules.symvers and /usr/src/openss7-*/$kversion/System.symvers.  If there are no files in these
# locations, they we are obtaining information for a Debian kernel for which our kernel modules were
# not built.  Therefore, there is only one remaining way to obtain the kernel symbol versions and
# that is to get them from the modules installed under kernel (assuming that they are all "used").
# When not all a "used" we simply have no idea.  We could perhaps check that at least the kernel
# series is correct.
#
#global havesymvers[kversion] = 1
function getsysver(kversion,
		   pfx,n,file)
{
    pfx = "r: sysver,    "
    n = 0
    print_vinfo(2, pfx "version = " kversion)
    if (("symver",kversion) in counts) {
	n = counts["symver",kversion]
    } else {
	if (n == 0 && "sysver" in values) {
	    file = values["sysver"]
	    gsub(/\$KVERSION/,kversion,file)
	    gsub(/\$PACKAGE/,values["package"],file)
	    if (values["basedir"] && system("test -r " values["basedir"] file) == 0)
		file = values["basedir"] file
	    else
		file = values["rootdir"] file
	    n = readsymver(kversion, file)
	}
	if (n == 0 && "symver" in values) {
	    file = values["symver"]
	    gsub(/\$KVERSION/,kversion,file)
	    gsub(/\$PACKAGE/,values["package"],file)
	    if (values["basedir"] && system("test -r " values["basedir"] file) == 0)
		file = values["basedir"] file
	    else
		file = values["rootdir"] file
	    n = readsymver(kversion, file)
	}
	if (n == 0 && "symabi" in values) {
	    file = values["symabi"]
	    gsub(/\$KVERSION/,kversion,file)
	    gsub(/\$PACKAGE/,values["package"],file)
	    if (values["basedir"] && system("test -r " values["basedir"] file) == 0)
		file = values["basedir"] file
	    else
		file = values["rootdir"] file
	    n = readsymabi(kversion, file)
	}
	if (n == 0) {
	    print_warns(pfx "=== ripping symbol versions from existing kernel modules")
	    print_wmore(pfx "=== this will take some time...  to avoid this delay,")
	    print_wmore(pfx "=== install the debian linux-headers-" kversion " package")
	    n = readkernel(kversion)
	} else {
	    havesymvers[kversion] = 1
	}
	counts["symver",kversion] = n
    }
    print_vinfo(2, pfx "syms " n)
    return n
}
#global usesysmap[kversion] = 0/1
function getsysinfo(kversion,
		    pfx,fmt,s,n,e)
{
    pfx = "r: sysinfo,   "
    fmt = "%04d symbs, %04d addrs, %04d expts"
    s = 0; n = 0; e = 0
    usesysmap[kversion] = 1
    print_vmore(3, pfx sprintf(fmt, s, n, e))
    if (kversion == krunning) {
	s = getallsym(kversion)
	if (s == 0) { return s }
	print_vmore(3, pfx sprintf(fmt, s, n, e))
    }
    n = n + getsysmap(kversion)
    n = n + getvmlinux(kversion)
    if (n == 0) { return n }
    print_vmore(3, pfx sprintf(fmt, s, n, e))
    e = getsysver(kversion)
    print_vinfo(2, pfx sprintf(fmt, s, n, e))
    if (e == 0) { return e }
    if (kversion == krunning) {
	if (values["style"] == "arch") {
	    usesysmap[kversion] = usesysmap[krunning]
	} else
	if (values["style"] == "suse11") {
	    usesysmap[kversion] = 0
	} else
	if (values["style"] == "suse10") {
	    usesysmap[kversion] = 0
	} else
	if (values["style"] == "redhat") {
	    usesysmap[kversion] = usesysmap[krunning]
	} else
	if (values["style"] == "ubuntu") {
	    usesysmap[kversion] = usesysmap[krunning]
	} else
	if (values["style"] == "debian") {
	    usesysmap[kversion] = usesysmap[krunning]
	} else
	if (values["style"] == "mandriva") {
	    usesysmap[kversion] = usesysmap[krunning]
	} else {
	    usesysmap[kversion] = usesysmap[krunning]
	}
    }
    return (s+n+e)
}
#global modinfo[module] = count of module information
#global export[module,sym] = crc
#global linked[module,sym] = add
#global weaken[module,sym] = add
#global wanted[module,sym] = crc
#global needed[module,sym] = crc
#
#global exportsyms[module] = sym,...
#global linkedsyms[module] = sym,...
#global wantedsyms[module] = sym,...
#global neededsyms[module] = sym,...
#
# getmodule()
# Get the provided and required symbols for a module and other module information.  A check is made
# to ensure that we have not already acquired the information.  There are four arrays: export
# contains symbols exported by this module, linked contains ripped symbols; wanted contains weak
# symbols; needed contains strong symbols.  A global modinfos array contains additional module
# information.
#
# need[] - required exported symbols
# want[] - required weak exported symbols
# link[] - required ripped symbols
# weak[] - required weak ripped symbols
#
function getmodule_modinfo(module, string, input,
			   line,char,label)
{
    sub(/^ .... /, "",input);
    sub(/  .*$/, "",input);
    gsub(/ /, "",input)
    string = string input
    sub(/^(00)+/, "", string)
    while (string~/^(0[^0]|[^0]0|[^0][^0])*00/) {
	line = ""
	while (length(string) > 0) {
	    char = "0x" substr(string,1,2)
	    sub(/^../,"",string)
	    char = strtonum(char)
	    if (32 <= char && char <= 126)
		line = line sprintf("%c", char)
	    else
	    if (char == 0) {
		sub(/^(00)+/, "", string)
		break
	    }
	}
	if (match(line,/^[^=]*=/)) {
	    label = substr(line,RSTART,RLENGTH-1);
	    sub(/^[^=]*=/, "", line)
	    if ((module,label) in modinfos)
	    { modinfos[module,label] = modinfos[module,label] "," line } else
	    { modinfos[module,label] = line }
	}
    }
    return string
}
function getmodule_versions(format, module, SECTION, string, input,
			    have, link, need, want,
			    pfx,crc,sym,char,add)
{
    pfx = "r: requires,  " SECTION ":"
    sub(/^ .... /, "",input);
    sub(/  .*$/, "",input);
    gsub(/ /, "",input)
    string = string input
    if (length(string) < 128)
	return string
    sub(/(00)+$/, "",string)
    if (format~/^elf32/) {
	# FIXME: only works for little-endian
	crc = "0x" substr(string,7,2) substr(string,5,2) substr(string,3,2) substr(string,1,2)
	string = substr(string,9)
    } else
    if (format~/^elf64/) {
	# FIXME: only works for little-endian
	crc = substr(string,7,2) substr(string,5,2) substr(string,3,2) substr(string,1,2)
	if (SECTION != "__weak_absolute") {
	    if (crc == "00000000") { #big endian detect
		crc = "0x" substr(string,9,8)
	    } else {
		crc = "0x" crc
	    }
	} else {
	    if (crc == "ffffffff") { #big endian detect
		crc = "0x" substr(string,1,16)
	    } else {
		crc = "0x" substr(string,15,2) substr(string,13,2) substr(string,11,2) substr(string,9,2) crc
	    }
	}
	string = substr(string,17)
    } else {
	print_error(pfx "unknown elf format " format)
	# FIXME: only works for little-endian
	crc = "0x" substr(string,7,2) substr(string,5,2) substr(string,3,2) substr(string,1,2)
	string = substr(string,9)
	sub(/^00000000/, "", string)
    }
    sym = ""
    while (length(string) > 0) {
	char = "0x" substr(string,1,2)
	sub(/^../,"",string)
	char = strtonum(char)
	if (32 <= char && char <= 126)
	    sym = sym sprintf("%c", char)
    }
    if (sym in need) {
	if (SECTION == "__versions"      )	{ print_debug(4, pfx "hard (" crc ") for needed " sym ", " module); need[sym] = crc; r++ }
	if (SECTION == "__weak_versions" )	{ print_warns(   pfx "weak (" crc ") for needed " sym ", " module); need[sym] = crc; r++ }
	if (SECTION == "__weak_absolute" )	{ print_error(   pfx "link (" crc ") for needed " sym ", " module); need[sym] = crc; r++ }
	r++
    } else
    if (sym in want) {
	add = "00000000"
	if (SECTION == "__versions"      )	{ print_debug(4, pfx "hard (" crc ") for wanted " sym ", " module); need[sym] = crc; r++; delete want[sym]; w-- }
	if (SECTION == "__weak_versions" )	{ print_debug(4, pfx "weak (" crc ") for wanted " sym ", " module); want[sym] = crc; w++ }
	if (SECTION == "__weak_absolute" )	{ print_debug(4, pfx "link (" crc ") for wanted " sym ", " module); weak[sym] = add; a++; link[sym] = add; l++; delete want[sym]; w-- }
    } else
    if (sym in link) {
	add = link[sym]
	if (SECTION == "__versions"      )	{ print_error(   pfx "hard (" crc ") for linked " sym ", " module); link[sym] = add; l++ }
	if (SECTION == "__weak_versions" )	{ print_debug(4, pfx "weak (" crc ") for linked " sym ", " module); weak[sym] = add; a++; want[sym] = crc; w++; delete link[sym]; l-- }
	if (SECTION == "__weak_absolute" )	{ print_debug(4, pfx "link (" crc ") for linked " sym ", " module); weak[sym] = add; a++ }
    } else {
	if (sym != "struct_module" && sym != "module_layout") {
	    if (SECTION == "__weak_versions")
	    { print_debug(5, pfx "(" crc ") not usable " sym ", " module) } else
	    { print_warns(pfx "(" crc ") not usable " sym ", " module) }
	}
    }
    return string
}
function getmodule(module,
		   #r, w, l, a, #global
		   pfx,fmt,command,result,n,h,have,link,need,want,sym,crc,SECTION,string,char,line,input,section,format)
{
    pfx = "r: required,  "
    n = 0
    if (system("test -r " module) == 0) {
	h = 0; r = 0; w = 0; l = 0; a = 0
	fmt = "%04d needs,  %04d wants,  %04d links,  %04d weaks,  %s"
	print_vmore(3, pfx sprintf(fmt, r, w, l, a, module))
	#command = "objdump -t -j '*ABS*' -j '*UND*' -j '__versions' -j '__weak_versions' -j '__weak_absolute' -j '.modinfo' -s " module
	#command = "f='" module "'; case $f in (*.ko) echo $f ;; (*.ko.gz) gzip -dc $f >/var/tmp/`basename $f .gz` ; echo /var/tmp/`basename $f .gz` ;; esac | xargs -r objdump -t -j '*ABS*' -j '*UND*' -j '__versions' -j '__weak_versions' -j '__weak_absolute' -j '.modinfo' -s "
	command = "f='" module "'; case $f in (*.ko) echo $f ;; (*.ko.gz) gzip -dc $f >/var/tmp/`basename $f .gz` ; echo /var/tmp/`basename $f .gz` ;; esac | while read f; do objdump -t $f; objdump -j '__versions' -j '__weak_versions' -j '__weak_absolute' -j '.modinfo' -s $f 2>/dev/null || :; done"
	SECTION = ""; string = ""
	while ((result = (command | getline)) != -1) {
	    if (SECTION == "__versions" || SECTION == "__weak_versions" || SECTION == "__weak_absolute") {
		if (result==1&&!/^$/&&!sub(/^Contents of section /,"")) {
		    input = $0
		    section = SECTION
		} else { sub(/:.*$/,"")
		    input = ""
		    section = $0
		}
		string = getmodule_versions(format,module,SECTION,string,input,have,link,need,want)
		if (SECTION != section) {
		    SECTION = section
		    string = ""
		}
	    } else
	    if (SECTION == "SYMBOL TABLE") {
		if (result==1&&!/^$/&&!sub(/^Contents of section /,"")) {
		    if (NF < 4) continue
		    if (substr($0,length($1)+2,1) == "l") {
			if (substr($0,length($1)+8,1) == "O") {
			    if (sub(/^_?_?__ksymtab/,"",$(NF-2))) {
				sub(/\+.*/,"",$(NF-2))
				if (sub(/^_?__ksymtab_/,"",$NF)) {
				    if (!($NF in have)) {
					print_debug(4,pfx sprintf("%s: have %-28s = 0x%-12s, %s", SECTION, $NF, "", module))
					have[$NF] = ""; h++; n++
				    }
				}
			    }
			}
		    } else
		    if ($(NF-2) == "*ABS*") {
			if (substr($0,length($1)+2,7) ~ /^g     [FO ]$/) {
			    if (sub(/^_?__(weak_)?crc_/, "", $NF)) {
				sub(/^00000000/, "", $1)
				if (!($NF in have) || have[$NF] == "") {
				    print_debug(4,pfx sprintf("%s: have %-28s = 0x%-12s, %s", SECTION, $NF, $1, module))
				    #print_debug(4,pfx SECTION ": have " $NF " = 0x" $1 ", " module)
				    if (!($NF in have)) { h++; n++ }
				    have[$NF] = "0x" $1
				}
			    } else {
				# This might wind up in link[] or want[]
				if (!($NF in link)) {
				    print_debug(4,pfx sprintf("%s: link %-28s = %-12s, %s", SECTION, $NF, $1, module))
				    #print_debug(4,pfx SECTION ": link " $NF " = " $1 ", " module)
				    link[$NF] = $1; l++; n++
				}
			    }
			}
		    } else
		    if ($(NF-2) == "*UND*") {
			if (substr($0,length($1)+3,1) == "w") {
			    # This might wind up in link[] or want[]
			    if (!($NF in want)) {
				print_debug(4,pfx sprintf("%s: want %-28s = \"\", %s", SECTION, $NF, module))
				#print_debug(4,pfx SECTION ": want " $NF " = \"\", " module)
				want[$NF] = ""; w++; n++
			    }
			} else {
			    if (!($NF in need)) {
				print_debug(4,pfx sprintf("%s: need %-28s = \"\", %s", SECTION, $NF, module))
				#print_debug(4,pfx SECTION ": need " $NF " = \"\", " module)
				need[$NF] = ""; r++; n++
			    }
			}
		    }
		} else { sub(/:.*$/,"")
		    print_vmore(3, pfx sprintf(fmt, r, w, l, a, module))
		    haves[module] = h
		    needs[module] = r; r = 0
		    wants[module] = w; w = 0
		    links[module] = l
		    weaks[module] = a
		    fmt = "%04d needed, %04d wanted, %04d linked, %04d weaken, %s"
		    SECTION = $0
		    string = ""
		}
	    } else
	    if (SECTION == ".modinfo") {
		if (result==1&&!/^$/&&!sub(/^Contents of section /,"")) {
		    input = $0
		    section = SECTION
		} else { sub(/:.*$/,"")
		    input = ""
		    section = $0
		}
		string = getmodule_modinfo(module,string,input)
		if (SECTION != section) {
		    SECTION = section
		    string = ""
		}
	    } else
	    if (!SECTION) {
		if (result==1&&!/^$/&&!sub(/^Contents of section /,"")&&!/SYMBOL TABLE:/) {
		    if (sub(/:.*file format/,"")) {
			#module = $1 # we only get one module at a time here...
			format = $2
			SECTION = ""
			string = ""
		    } else {
			print_error(pfx "unhandled line: `" $0 "'")
		    }
		} else { sub(/:.*$/,"")
		    SECTION = $0
		    string = ""
		}
	    } else
	    {
		print_error(pfx "unhandled line: `" $0 "'")
	    }
	    if (result != 1)
		break
	}
	close(command)
	system("rm -f -- /var/tmp/`basename " module " .gz`")
	print_vmore(2, pfx sprintf(fmt, r, w, l, a, module))
	if ((module,"vermagic") in modinfos) {
	    modfver[module] = modinfos[module,"vermagic"]; sub(/ .*$/, "", modfver[module])
	} else {
	    print_warns(pfx "no vermagic string found in module " module)
	}
	for (sym in have) {
	    crc = have[sym]
	    export[module,sym] = crc
	    if (module in exportsyms)
	    { exportsyms[module] = exportsyms[module] "," sym } else
	    { exportsyms[module] = sym }
	    if (!crc && modversions) print_warns(pfx sprintf("unversioned export %-20s in %s", sym, module))
	    #print_debug(6,pfx sprintf("export %-20s in %s", sym, module))
	}
	for (sym in link) {
	    crc = link[sym]
	    linked[module,sym] = crc
	    if (sym in weak) { weaken[module,sym] = weak[sym] }
	    if (module in linkedsyms)
	    { linkedsyms[module] = linkedsyms[module] "," sym } else
	    { linkedsyms[module] = sym }
	    if (!crc && !(sym in weak)) print_warns(pfx sprintf("unresolved  linked %-20s in %s", sym, module))
	    #print_debug(6,pfx sprintf("linked %-20s in %s", sym, module))
	}
	for (sym in want) {
	    crc = want[sym]
	    wanted[module,sym] = crc
	    if (sym in weak) { weaken[module,sym] = weak[sym] }
	    if (module in wantedsyms)
	    { wantedsyms[module] = wantedsyms[module] "," sym } else
	    { wantedsyms[module] = sym }
	    if (!crc && !(sym in weak) && modversions) print_warns(pfx sprintf("unversioned wanted %-20s in %s", sym, module))
	    #print_debug(6,pfx sprintf("wanted %-20s in %s", sym, module))
	}
	for (sym in need) {
	    crc = need[sym]
	    needed[module,sym] = crc
	    if (module in neededsyms)
	    { neededsyms[module] = neededsyms[module] "," sym } else
	    { neededsyms[module] = sym }
	    if (!crc && modversions) print_warns(pfx sprintf("unversioned needed %-20s in %s", sym, module))
	    #print_debug(6,pfx sprintf("needed %-20s in %s", sym, module))
	}
    } else {
	print_error(pfx "cannot read " module)
    }
    return n
}
# getmodinfo()
# Get the required symbols for each of the modules for a given kernel version.
function getmodinfo(kversion,
		     pfx,fmt,n,pn,w,pw,i,m,pm,name,module,pair,pairs,link,nums)
{
    pfx = "r: modinfo,   "
    fmt = "%05d symbols, %04d modules, %04d weakmods"
    print_vinfo(2, pfx "version = " kversion)
    n = 0; w = 0; m = 0
    if (("modinfo",kversion) in counts) {
	split(counts["modinfo",kversion],nums,/,/)
	n = nums[1]; m = nums[2]; w = nums[3]
    } else {
	pw = 0; pm = 0; pn = 0
	print_vmore(2, pfx sprintf(fmt, n, m, w))
	for (name in names) {
	    if ((name in modnames) || (name in weaknames)) {
		if ((kversion,name) in modnames) {
		    module = modnames[kversion,name]
		    if (module in modinfo)
		    { i = modinfo[module] } else
		    { i = getmodule(module); modinfo[module] = i }
		    n = n + i; pn = pn + i
		    m++; pm++
		    if (pn >= 200 || pm >= 20) {
			print_vmore(2, pfx sprintf(fmt, n, m, w))
			pm = 0; pw = 0; pn = 0
		    }
		}
		if ((kversion,name) in weaknames) {
		    module = weaknames[kversion,name]
		    if (module in weaklinks) { module = weaklinks[module] }
		    if (module in modinfo)
		    { i = modinfo[module] } else
		    { i = getmodule(module); modinfo[module] = i }
		    n = n + i; pn = pn + i
		    w++; pw++
		    if (pn >= 200 || pw >= 100) {
			print_vmore(2, pfx sprintf(fmt, n, m, w))
			pm = 0; pw = 0; pn = 0
		    }
		}
	    } else {
		print_error(pfx "no module name for " kversion "," name)
	    }
	}
	counts["modinfo",kversion] = n "," m "," w
    }
    print_vinfo(2, pfx sprintf(fmt, n, m, w))
#    if (m == 0) {
#	for (pair in modnames) {
#	    module = modnames[pair]
#	    link = ""
#	    if (!(module in modules)) {
#		print_error(pfx "module in modnames but not modules, " module)
#	    } else {
#		split(pair,pairs,SUBSEP)
#		print_vinfo(2, pfx sprintf("kversion = %-24s, name = %-24s, version = %-24s, file = %s, link = %s", pairs[1], pairs[2], modules[module], module, link))
#	    }
#	}
#    }
#    if (w == 0) {
#	for (pair in weaknames) {
#	    module = weaknames[pair]
#	    if (module in weaklinks) { link = weaklinks[module] } else { link = "" }
#	    if (!(module in weakmods)) {
#		print_error(pfx "module in weaknames but not weakmods, " module)
#	    } else {
#		split(pair,pairs,SUBSEP)
#		print_vinfo(2, pfx sprintf("kversion = %-24s, name = %-24s, version = %-24s, file = %s, link = %s", pairs[1], pairs[2], weakmods[module], module, link))
#	    }
#	}
#    }
    return n
}
function getresolve(kversion, kver,
		    creates, unlinks, changes, relinks, dolinks, removes, retains, inserts,
		    pfx,n,ksyms,pair,pairs,ver,name,module,sym,syms,s,add,crc,d,deleted,relink,reload,resolve,
		    exporting,linking,needing,wanting,kmodver,files,i,file)
{
    pfx = "p: resolve,   "
    # map symbols exported by modules in the module set
    n = 0
    print_vinfo(2, pfx sprintf("(%-12s,%-12s) %-30s", kversion, kver, "collecting module names..."))
    for (name in names) {
	if ((kver,name) in modnames) {
	    module = modnames[kver,name]
	    if (!(module in delmods)) {
		if ((kversion,name) in weaknames) {
		    file = weaknames[kversion,name]
		    if (!(file in weaklinks) && file in weakmods) {
			if (modinfomatches(module, file) || system("test " module " -ef " file) == 0) {
			    module = file
			}
		    }
		} else {
		    print_debug(4,pfx "no weakname for (" kversion "," name ")")
		}
	    }
	    resolve[name] = module
	    if (module in exportsyms) exporting[name] = module
	    if (module in linkedsyms)   linking[name] = module
	    if (module in neededsyms)   needing[name] = module
	    if (module in wantedsyms)   wanting[name] = module
	    if (module in delmods)    deleted[module] = name
	} else {
	    print_debug(4,pfx "no modname for (" kver "," name ")")
	}
    }
    print_vinfo(2, pfx sprintf("(%-12s,%-12s) %-30s", kversion, kver, "mapping module symbol exports..."))
    for (name in exporting) {
	module = exporting[name]
	split(exportsyms[module],syms,/,/)
	for (s in syms) { sym = syms[s]
	    crc = export[module,sym]
	    ksyms[sym,crc] = module
	    n++
	}
    }
    # test solution
    print_vinfo(2, pfx sprintf("(%-12s,%-12s) %-30s", kversion, kver, "resolving ripped symbols..."))
    d = 0
    for (name in linking) {
	module = linking[name]
	if ((module in deleted)) continue
	split(linkedsyms[module],syms,/,/)
	for (s in syms) { sym = syms[s]
	    add = linked[module,sym]
	    if (kversion == krunning) {
		if ((kversion,sym) in allsyms) {
		    if (allsyms[kversion,sym] != add) {
			print_debug(4,pfx "must relink " name ", allsyms(" kversion ":" sym ") = " add " != " allsyms[kversion,sym])
			add = allsyms[kversion,sym]
			relink[name] = module
			if (name in reload)
			{ reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
			{ reload[name] = "\t" sym " = 0x" add ";" }
		    } else {
			print_debug(4,pfx "good link " name ", allsyms(" kversion ":" sym ") = " add " == " allsyms[kversion,sym])
		    }
		    continue
		} else {
		    print_debug(4,pfx sprintf("no kallsyms for (%s,%s)", kversion, sym))
		}
	    } else {
		print_debug(9,pfx sprintf("cannot use kallsyms for (%s,%s)", kversion, sym))
	    }
	    if (kversion in usesysmap && usesysmap[kversion]) {
		if ((kversion,sym) in sysmaps) {
		    if (sysmaps[kversion,sym] != add) {
			print_debug(4,pfx "must relink " name ", sysmaps(" kversion ":" sym ") = " add " != " sysmaps[kversion,sym])
			add = sysmaps[kversion,sym]
			relink[name] = module
			if (name in reload)
			{ reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
			{ reload[name] = "\t" sym " = 0x" add ";" }
		    } else {
			print_debug(4,pfx "good link " name ", sysmaps(" kversion ":" sym ") = " add " == " sysmaps[kversion,sym])
		    }
		    continue
		} else {
		    print_debug(4,pfx sprintf("no sysmap for (%s,%s)", kversion, sym))
		}
	    } else {
		print_debug(9,pfx sprintf("cannot use sysmap for (%s,%s)", kversion, sym))
	    }
	    print_vinfo(3,pfx "cannot resolve linked " sym " from " name)
	    if ((module,sym) in weaken) {
		gsub(/[1-9a-fA-F]/,"0",add)
		if (weaken[module,sym]!~/^00*$/) {
		    print_debug(4,pfx "must relink " name ", weaken(" kversion ":" sym ") = " add " != " weaken[module,sym])
		    relink[name] = module
		    if (name in reload)
		    { reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
		    { reload[name] = "\t" sym " = 0x" add ";" }
		} else {
		    print_debug(4,pfx "good link " name ", weaken(" kversion ":" sym ") = " add " == " weaken[module,sym])
		}
		continue
	    }
	    if ((module in deleted)) continue
	    print_debug(4,pfx "deleting " name)
	    deleted[module] = name
	    d++
	}
    }
    do {
	print_vinfo(2, pfx sprintf("(%-12s,%-12s) %-30s", kversion, kver, "resolving exported symbols..."))
	d = 0
	for (name in needing) {
	    print_vmore(2, pfx sprintf("%-40s", "resolving " name "..."))
	    module = needing[name]
	    if ((module in deleted)) continue
	    split(neededsyms[module],syms,/,/)
	    for (s in syms) { sym = syms[s]
		crc = needed[module,sym]
		if ((sym,crc) in ksyms) {
		    if (!(ksyms[sym,crc] in deleted)) continue
		} else
		if ((kversion,sym) in symvers) {
		    if (symvers[kversion,sym] == crc) continue
		} else {
		    if ((kversion,sym) in allsyms || (kversion in usesysmap && usesysmap[kversion] && (kversion,sym) in sysmaps)) {
			kmodver = ""
			if (module in modules)
			    kmodver = modules[module]
			else
			if (module in weakmods)
			    kmodver = weakmods[module]
			# kver here is the solution slice version rather than the version for which
			# the modules were compiled.
			print_debug(3,pfx "kmodver  " kmodver  " ======> " gensub(/-.*$/,"","g",kmodver))
			print_debug(3,pfx "kversion " kversion " ======> " gensub(/-.*$/,"","g",kversion))
			if (kversion in havesymvers) {
			    # The symbol is provided in the system maps, but not exported by the
			    # kernel.  The possibility here is that the symbol has been removed from
			    # the export list for the kernel under consideration.  We can absolute
			    # link the symbol if we are brave.  This could, however, cause a kernel
			    # module to crash once it is loaded in the worst case.  When the
			    # upstream kernel version against which the modules were built does not
			    # match the upstream kernel version of the kernel for which we are
			    # weak-updating, it is just too dangerous.  Otherwise, we might consider
			    # linking.
			    if (gensub(/-.*$/,"","g",kmodver) == gensub(/-.*$/,"","g",kversion)) {
				if ((kversion,sym) in allsyms)
				{ add = allsyms[kversion,sym] } else
				{ add = sysmaps[kversion,sym] }
				relink[name] = module
				if (name in reload) {
				    # need this to be indempotent
				    if ("\n" "\t" sym " = 0x" add ";" "\n" !~ "\n" reload[name] "\n")
					reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";"
				} else { reload[name] = "\t" sym " = 0x" add ";" }
				print_warns(pfx sym " will be relinked to vmlinux-" kversion)
				continue
			    } else {
				print_vinfo(3,pfx sym " not exported by vmlinux-" kversion)
			    }
			} else {
			    # We don't have a complete set of symbol versions because we only ripped
			    # the used symbol version from the existing kernel modules included with
			    # the kernel.  Therefore, we can either ASSUME that the versions are the
			    # same and risk a module load failure, or we can mitigate some risk by
			    # checking whether the upstream kernel version for kver is the same as
			    # kversion.  The problem is that when there is not a full symbol
			    # versions file, depmod will use -F and the system map (which omits
			    # __crc_ symbols) and will not detect a version mismatch.  However, when
			    # modprobe goes to load the module, the kernel module loader will reject
			    # it.
			    if (gensub(/-.*$/,"","g",kmodver) == gensub(/-.*$/,"","g",kversion)) {
				# might be worth the risk
				print_warns(pfx sym " assumed exported by vmlinux-" kversion)
				continue
			    } else {
				# might not be worth the risk
				print_vinfo(3,pfx sym " unknown export for vmlinux-" kversion)
			    }
			}
		    } else {
			# When the symbol is not in the system map, then it cannot be present in the
			# kernel regardless of whether we have a full set of symbol versions or not.
			print_vinfo(3,pfx "cannot resolve needed " sym " from " name)
		    }
		}
		if ((module in deleted)) continue
		deleted[module] = name
		d++
	    }
	}
    } while (d)
    for (name in wanting) {
	print_vmore(2, pfx sprintf("%-40s", "weak resolving " name "..."))
	module = wanting[name]
	if ((module in deleted)) continue
	split(wantedsyms[module],syms,/,/)
	for (s in syms) { sym = syms[s]
	    crc = wanted[module,sym]
	    if ((sym,crc) in ksyms) {
		add = "00000000"
		if (ksyms[sym,crc] in deleted && (module,sym) in weaken && (weaken[module,sym]!~/^00*$/)) {
		    relink[name] = module
		    if (name in reload)
		    { reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
		    { reload[name] = "\t" sym " = 0x" add ";" }
		}
	    } else
	    if ((kversion,sym) in symvers) {
		if (symvers[kversion,sym] == crc) {
		    if ((module,sym) in weaken) {
			if ((kversion,sym) in allsyms) {
			    add = allsyms[kversion,sym]
			    if (weaken[module,sym] != add) {
				relink[name] = module
				if (name in reload)
				{ reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
				{ reload[name] = "\t" sym " = 0x" add ";" }
			    }
			} else
			if (kversion != krunning && (kversion,sym) in sysmaps) {
			    add = sysmaps[kversion,sym]
			    if (weaken[module,sym] != add) {
				relink[name] = module
				if (name in reload)
				{ reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
				{ reload[name] = "\t" sym " = 0x" add ";" }
			    }
			} else {
			    add = "00000000"
			    if (weaken[module,sym]!~/^00*$/) {
				relink[name] = module
				if (name in reload)
				{ reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
				{ reload[name] = "\t" sym " = 0x" add ";" }
			    }
			}
		    }
		} else {
		    add = "00000000"
		    if ((module,sym) in weaken && (weaken[module,sym]!~/^00*$/)) {
			relink[name] = module
			if (name in reload)
			{ reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
			{ reload[name] = "\t" sym " = 0x" add ";" }
		    }
		}
	    } else {
		if ((module,sym) in weaken) {
		    if ((kversion,sym) in allsyms) {
			add = allsyms[kversion,sym]
			if (weaken[module,sym] != add) {
			    relink[name] = module
			    if (name in reload)
			    { reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
			    { reload[name] = "\t" sym " = 0x" add ";" }
			}
		    } else
		    if (kversion != krunning && (kversion,sym) in sysmaps) {
			add = sysmaps[kversion,sym]
			if (weaken[module,sym] != add) {
			    relink[name] = module
			    if (name in reload)
			    { reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
			    { reload[name] = "\t" sym " = 0x" add ";" }
			}
		    } else {
			add = "00000000"
			if (weaken[module,sym]!~/^00*$/) {
			    relink[name] = module
			    if (name in reload)
			    { reload[name] = reload[name] "\n" "\t" sym " = 0x" add ";" } else
			    { reload[name] = "\t" sym " = 0x" add ";" }
			}
		    }
		}
	    }
	}
    }
    print_vinfo(2, pfx sprintf("%-40s", "...done"))
    d = 0
    for (name in resolve) {
	module = resolve[name]
	if (module in deleted) {
	    if ((kversion,name) in weaknames) {
		file = weaknames[kversion,name]
		if (file ~/,/) {
		    split(file,files,/,/)
		    file = files[1]
		}
		if (file in weaklinks) {
		    # will be removing a symbolic link
		    if (kver in unlinks)
		    { unlinks[kver] = unlinks[kver] "," name } else
		    { unlinks[kver] = name }
		    d++
		} else
		if (file in weakmods) {
		    # will be removing a relinked module
		    if (kver in unlinks)
		    { unlinks[kver] = unlinks[kver] "," name } else
		    { unlinks[kver] = name }
		    d++
		}
	    } else
	    if ((kversion,name) in modnames) {
		file = modnames[kversion,name]
		if (file ~/,/) {
		    split(file,files,/,/)
		    file = files[1]
		}
		if (file in modules) {
		    # will be removing a module
		    if (kver in removes)
		    { removes[kver] = removes[kver] "," name } else
		    { removes[kver] = name }
		    d++
		}
	    } else {
		if (kver in removes)
		{ removes[kver] = removes[kver] "," name } else
		{ removes[kver] = name }
		d++
	    }
	} else
	if (module in modules && modules[module] == kversion) {
	    if (kver in inserts)
	    { inserts[kver] = inserts[kver] "," name } else
	    { inserts[kver] = name }
	    if (name in relink) {
		# also relinking it
		if (kver in dolinks)
		{ dolinks[kver] = dolinks[kver] "," name } else
		{ dolinks[kver] = name }
		if ((kversion,name) in modnames) {
		    file = modnames[kversion,name]
		    reloads[file] = reload[name]
		}
	    }
	} else {
	    if ((kversion,name) in weaknames) {
		file = weaknames[kversion,name]
		if (file ~ /,/) {
		    split(file,files,/,/)
		    file = files[1]
		}
		if (file in weaklinks) {
		    if (weaklinks[file] == module || system("test " module " -ef " file) == 0) {
			if (!(name in relink)) {
			    # will be keeping a symbolic link
			    if (kver in retains)
			    { retains[kver] = retains[kver] "," name } else
			    { retains[kver] = name }
			} else {
			    # will be relinking
			    if (kver in relinks)
			    { relinks[kver] = relinks[kver] "," name } else
			    { relinks[kver] = name }
			    reloads[file] = reload[name]
			}
		    } else {
			# will be overwritting a symbolic link
			if (kver in changes)
			{ changes[kver] = changes[kver] "," name } else
			{ changes[kver] = name }
			if (name in relink) {
			    # and relinking it
			    if (kver in relinks)
			    { relinks[kver] = relinks[kver] "," name } else
			    { relinks[kver] = name }
			    reloads[file] = reload[name]
			}
		    }
		} else
		if (file in weakmods) {
		    if (modinfomatches(module, file) || system("test " module " -ef " file) == 0) {
			if (!(name in relink)) {
			    # will be keeping a relinked module
			    if (kver in retains)
			    { retains[kver] = retains[kver] "," name } else
			    { retains[kver] = name }
			} else {
			    # need to overwrite it and relink it
			    if (kver in changes)
			    { changes[kver] = changes[kver] "," name } else
			    { changes[kver] = name }
			    if (kver in relinks)
			    { relinks[kver] = relinks[kver] "," name } else
			    { relinks[kver] = name }
			    reloads[file] = reload[name]
			}
		    } else {
			# will be overwritting a relinked module
			if (kver in changes)
			{ changes[kver] = changes[kver] "," name } else
			{ changes[kver] = name }
			if (name in relink) {
			    # and relinking it
			    if (kver in relinks)
			    { relinks[kver] = relinks[kver] "," name } else
			    { relinks[kver] = name }
			    reloads[file] = reload[name]
			}
		    }
		}
	    } else {
		if ("weakdir" in values) {
		    if (values["weakdir"] ~ /^\//)
		    { file = values["weakdir"] } else
		    { file = values["basedir"] "/lib/modules/" kversion "/"   values["weakdir"] } 
		} else
		    { file = values["basedir"] "/lib/modules/" kversion "/" defaults["weakdir"] }
		gsub(/\$KVERSION/,kversion,file)
		gsub(/\$PACKAGE/,values["package"],file)
		file = file "/" subdirs[module] "/" name
		if (kver in creates)
		{ creates[kver] = creates[kver] "," name } else
		{ creates[kver] = name }
		if (name in relink) {
		    # and relinking it
		    if (kver in relinks)
		    { relinks[kver] = relinks[kver] "," name } else
		    { relinks[kver] = name }
		    reloads[file] = reload[name]
		}
	    }
	}
    }
    return d
}
function readloaded(kversion,
		    command,loaded)
{
    loaded = ""
    command = "cat /proc/modules"
    while ((command | getline) == 1) {
	if (loaded) { loaded = $1 "," loaded } else { loaded = $1 }
    }
    close(command)
    return loaded
}
function print_action(action, file, prep, kversion,
		      module,modver)
{
    if (values["verbose"]+0 == 1) {
	module = file; gsub(/^.*\//, "", module)
	modver = file; if (sub(/^.*\/lib\/modules\//, "", modver)) { sub(/\/.*$/, "", modver) } else { sub(/\/[^\/]*$/, "", modver) }
	print_vinfo(1, sprintf("%-10s %-28s %-4s %-28s from %s", action, module, prep, kversion, modver))
    }
}
function doit(cmd,
	      loaded,name,subdir)
{
    if (values["dry-run"]) {
	print_vinfo(2, "x: execute,   " cmd)
	return 0
    }
    return system_command(cmd)
}
#global rmdirs[directory] = 1
function removefiles(kversion, name,
		     pfx,file,modules,files,j,dir)
{
    pfx = "w: delete,    "
    if ((kversion,name) in modremoves) {
	if (values["delete-modules"]) {
	    file = modremoves[kversion,name]
	    if (split(file,files,/,/)) {
		for (j in files) { file = files[j]
		    print_action("deleting", file, "from", kversion)
		    doit("rm -f -- " file)
		    #if (file in delmods) delete delmods[file]
		    dir = file; sub(/\/[^\/]*$/, "", dir)
		    rmdirs[dir] = 1
		}
	    }
	}
	delete modremoves[kversion,name]
    } else
    if ((kversion,name) in modnames) {
	file = modnames[kversion,name]
	if (split(file,files,/,/)) {
	    for (j in files) { file = files[j]
		print_action("deleting", file, "from", kversion)
		doit("rm -f -- " file)
		dir = file; sub(/\/[^\/]*$/, "", dir)
		rmdirs[dir] = 1
	    }
	}
	delete modnames[kversion,name]
    } else {
	print_error(pfx "no modremove for " kversion ":" name)
    }
}
#global mkdirs[directory] = 1
function createlinks(kversion, kver, name,
		     pfx,module,file,files,n,j)
{
    pfx = "w: create,    "
    if ((kver,name) in modnames) {
	module = modnames[kver,name]
	if ("weakdir" in values)
	{ if (values["weakdir"] ~ /^\//)
	{ file = values["weakdir"] } else
	{ file = values["basedir"] "/lib/modules/" kversion "/"   values["weakdir"] } } else
	{ file = values["basedir"] "/lib/modules/" kversion "/" defaults["weakdir"] }
	gsub(/\$KVERSION/,kversion,file)
	gsub(/\$PACKAGE/,values["package"],file)
	file = file "/" subdirs[module]
	if (!(file in mkdirs)) {
	    if (system_command("test -d " file) != 0)
		doit("mkdir -p " file)
	    mkdirs[file] = 1
	}
	file = file "/" name
	print_action("adding", module, " to ", kversion)
	doit("ln -sf " module " " file)
	# this is a correction to internal data structures
	if (module in modules)
	    weakmods[file] = modules[module]
	else
	    weakmods[file] = kversion # FIXME (an error really)
	weaklinks[file] = module
	if ((kversion,name) in weaknames && weaknames[kversion,name] != file)
	{ weaknames[kversion,name] = weaknames[kversion,name] "," file
	  print_error(pfx "conflict amoung updates for " name ", " weaknames[kversion,name]) }
	{ weaknames[kversion,name] = file }
    } else {
	print_error(pfx "no modname for " kver ":" name)
    }
}
function removelinks(kversion, name,
		     pfx,file,module,files,j,dir)
{
    pfx = "w: unlink,    "
    if ((kversion,name) in weaknames) {
	file = weaknames[kversion,name]
	if (split(file,files,/,/)) {
	    for (j in files) { file = files[j]
		print_action("removing", file, "from", kversion)
		doit("rm -f -- " file)
		if (file in weaklinks)
		    delete weaklinks[file]
		if (file in weakmods)
		    delete weakmods[file]
		dir = file; sub(/\/[^\/]*$/, "", dir)
		rmdirs[dir] = 1
	    }
	}
	delete weaknames[kversion,name]
    } else {
	print_error(pfx "no weakname for " kversion ":" name)
    }
}
function changelinks(kversion, kver, name,
		     pfx,module,file)
{
    pfx = "w: change,    "
    if ((kver,name) in modnames) {
	module = modnames[kver,name]
	if ((kversion,name) in weaknames) {
	    file = weaknames[kversion,name]
	    doit("ln -sf " module " " file)
	    # this is a correction to internal data structures
	    if (module in modules)
		weakmods[file] = modules[module]
	    else
		weakmods[file] = kversion # FIXME (an error really)
	    weaklinks[file] = module
	    if ((kversion, name) in weaknames && weaknames[kversion,name] != file)
	    { weaknames[kversion,name] = weaknames[kversion,name] "," file
	      print_error(pfx "conflict amoung updates for " name ", " weaknames[kversion,name]) }
	    { weaknames[kversion,name] = file }
	} else {
	    print_error(pfx "no weakname for " kversion ":" name)
	}
    } else {
	print_error(pfx "no modname for " kver ":" name)
    }
}
function relinklinks(kversion, kver, name,
		     pfx,n,m,module,file,syms,s,sym,add,old,gzip,source)
{
    pfx = "w: relink,    "
    n = 0; m = 0
    if ((kver,name) in modnames) {
	module = modnames[kver,name]
	if ((kversion,name) in weaknames) {
	    file = weaknames[kversion,name]  # note that createlinks created this entry
	    if (file in weaklinks)
		module = weaklinks[file]
	} else
	if ((kversion,name) in modnames) {
	    file = modnames[kversion,name]
	} else {
	    print_error(pfx "no weakname nor modname for " kversion ":" name)
	    return
	}
	if (file in reloads) {
	    script = me "." PROCINFO["pid"] ".lds"
	    text = "SECTIONS\n{\n" reloads[file] "\n}"
	    print text > script
	    print_debug(3,pfx gensub(/\n/, "\n" me ": D: " pfx, "g", text))
	    close(script)
	    if (file~/\.ko\.gz$/) {
		gzip = ".gz"
		source = file
		sub(/\.ko\.gz$/, ".ko", source)
		doit("gzip -dc " file " >" source)
	    } else {
		gzip = ""
		source = file
	    }
	    kmod = file; sub(/\/[^\/]*$/, "/", kmod)
	    kmod = kmod me "." PROCINFO["pid"] ".ko"
	    print_action("relinking", module, " in ", kversion)
	    if (doit("ld -r -o " kmod " " source " " script) == 0) {
		if (gzip) {
		    doit("rm -f -- " source)
		    doit("gzip -f9 " kmod)
		}
		doit("mv -f -- " kmod gzip " " file)
	    } else {
		print_error(pfx "relinking failed for " file)
		print_action("removing", module, "from", kversion)
		doit("rm -f -- " kmod " " kmod gzip " " file " " source)
	    }
	    system_command("rm -f -- " script)
	}
    } else {
	print_error(pfx "no modname for " kver ":" name)
    }
}
function removedirs(kversion,
		    pfx,dir)
{
    pfx = "w: rmdirs,    "
    for (dir in rmdirs) {
	print_action("removing", dir, "from", kversion)
	doit("rmdir " dir " 2>/dev/null")
    }
    delete rmdirs
}
function modinfomatch(module1, module2, info,		item1, item2)
{
    if ((module1,info) in modinfos) { item1 = modinfos[module1,info] } else { item1 = "" }
    if ((module2,info) in modinfos) { item2 = modinfos[module2,info] } else { item2 = "" }
    if (item1 == item2) { return 1 } else {
	print_warns("t: infomatch, \"" info "\" does not match between " module1 " and " module2)
	print_wmore("t: infomatch, \"" info "\" '" item1 "' does not match '" item2 "'")
	return 0
    }
}
function modinfomatches(module1, module2,		result)
{
    if (!modinfomatch(module1, module2, "vermagic"   )) { return 0 }
    if (!modinfomatch(module1, module2, "version"    )) { return 0 }
    if (!modinfomatch(module1, module2, "srcversion" )) { return 0 }
    if (!modinfomatch(module1, module2, "license"    )) { return 0 }
    if (!modinfomatch(module1, module2, "description")) { return 0 }
    if (!modinfomatch(module1, module2, "author"     )) { return 0 }
    return 1
}
function chckunneeded(kversion, kver,
		      creates, unlinks, changes, relinks, dolinks, removes, retains, inserts,
		      pfx,pair,pairs,file,name,files,i)
{
    pfx = "p: unneeded,  "
    for (pair in weaknames) {
	if (split(pair,pairs,SUBSEP) != 2) continue
	if (pairs[1] != kversion) continue
	file = weaknames[pair]
	name = pairs[2]
	if (file~/,/) {
	    if (!(kver in unlinks) || ","unlinks[kver]"," !~ ","name",") {
		print_debug(3, pfx "module is redundant, (" kversion "," name ")")
		if (kver in unlinks)
		{ unlinks[kver] = unlinks[kver] "," name } else
		{ unlinks[kver] = name }
	    }
	} else
	if (kver) {
	    # unnecessary weak links (installed module exists)
	    if (kver in inserts && ","inserts[kver]"," ~ ","name",") {
		if (!(kver in unlinks) || ","unlinks[kver]"," !~ ","name",") {
		    print_debug(3, pfx "module is installed, (" kversion "," name ")")
		    if (kver in unlinks)
		    { unlinks[kver] = unlinks[kver] "," name } else
		    { unlinks[kver] = name }
		}
	    } else
	    if (kver in dolinks && ","dolinks[kver]"," ~ ","name",") {
		if (!(kver in unlinks) || ","unlinks[kver]"," !~ ","name",") {
		    print_debug(3, pfx "module is  reloaded, (" kversion "," name ")")
		    if (kver in unlinks)
		    { unlinks[kver] = unlinks[kver] "," name } else
		    { unlinks[kver] = name }
		}
	    }
	}
	# unnecessary weak links (reference a deleted module)
	split(file,files,/,/)
	for (i in files) { file = files[i]
	    if (file in weaklinks && weaklinks[file] in delmods) {
		if (!(kver in unlinks) || ","unlinks[kver]"," !~ ","name",") {
		    print_debug(3, pfx "module link removed, (" kversion "," name ")")
		    if (kver in unlinks)
		    { unlinks[kver] = unlinks[kver] "," name } else
		    { unlinks[kver] = name }
		}
	    } else
	    if (file in weakmods && weakmods[file] in kremoved)  {
		if (!(kver in unlinks) || ","unlinks[kver]"," !~ ","name",") {
		    print_debug(3, pfx "module load removed, (" kversion "," name ")")
		    if (kver in unlinks)
		    { unlinks[kver] = unlinks[kver] "," name } else
		    { unlinks[kver] = name }
		}
	    }
	}
    }
    for (pair in modremoves) {
	if (split(pair,pairs,SUBSEP) != 2) continue
	if (pairs[1] != kversion) continue
	file = modremoves[pair]
	name = pairs[2]
	split(file,files,/,/)
	for (i in files) { file = files[i]
	    if (!(kver in removes) || ","removes[kver]"," !~ ","name",") {
		print_debug(3, pfx "module file deleted, (" kversion "," name ")")
		if (kver in removes)
		{ removes[kver] = removes[kver] "," name } else
		{ removes[kver] = name }
	    }
	}
    }
}
function chcksolution(kversion, kver,
		      creates, unlinks, changes, relinks, dolinks, removes, retains, inserts,
		      pfx,fmt,loaded,n,labels,i,name,created,removed,changed,altered)
{
    pfx = "p: checking,  "
    print_vinfo(2, pfx "solution for " kversion " is " kver)
    fmt = pfx "solution for " kversion " %-7s %3d %s"
    change = 0
    if (kver in creates) {
	n = split(creates[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "creates", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " creates " labels[i])
	change = 1
    }
    if (kver in unlinks) {
	n = split(unlinks[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "unlinks", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " unlinks " labels[i])
	change = 1
    }
    if (kver in changes) {
	n = split(changes[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "changes", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " changes " labels[i])
	change = 1
    }
    if (kver in relinks) {
	n = split(relinks[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "relinks", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " relinks " labels[i])
	change = 1
    }
    if (kver in dolinks) {
	n = split(dolinks[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "relinks", n, "modules"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " relinks " labels[i])
	change = 1
    }
    if (kver in removes) {
	n = split(removes[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "removes", n, "modules"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " removes " labels[i])
	change = 1
    }
    if (kver in retains) {
	n = split(retains[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "retains", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " retains " labels[i])
    }
    if (kver in inserts) {
	n = split(inserts[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "inserts", n, "modules"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " inserts " labels[i])
	if (kversion in kinserts) change = 1
    }
    if (change == 0) {
	print_vinfo(2, pfx "solution for " kversion " is no change")
	return 1
    }
    if (kversion == krunning) {
	altered = 0
	if (values["preserve"]) {
	    # refuse to change anything for a loaded kernel module
	    loaded = readloaded(kversion)
	    n = split(loaded, labels, /,/)
	    for (i=1;i<=n;i++) { name = labels[i] ".ko"
		if (kver in creates && ","creates[kver]"," ~ ","name",") {
		    print_warns(pfx "not creating link for loaded module " name)
		    altered = 1
		}
		if (kver in unlinks && ","unlinks[kver]"," ~ ","name",") {
		    print_warns(pfx "not removing link for loaded module " name)
		    altered = 1
		}
		if (kver in changes && ","changes[kver]"," ~ ","name",") {
		    print_warns(pfx "not changing link for loaded module " name)
		    altered = 1
		}
		if (kver in relinks && ","relinks[kver]"," ~ ","name",") {
		    print_warns(pfx "not relinkin link for loaded module " name)
		    altered = 1
		}
	    }
	}
	if (!values["overwrite"]) {
	    # refuse to overwrite an existing link
	    if (kver in changes) {
		split(changes[kver],labels,/,/)
		for (i in labels) { name = labels[i]
		    print_warns(pfx "not overwritting link for module " name)
		    altered = 1
		}
	    }
	    if (kver in relinks) {
		split(relinks[kver],labels,/,/)
		for (i in labels) { name = labels[i]
		    if (kver in creates && ","creates[kver]"," ~ ","name",") {
			print_warns(pfx "not overwritting link for module " name)
			altered = 1
		    } else
		    if (kver in inserts && ","inserts[kver]"," ~ ","name",") {
			print_warns(pfx "not overwritting installed module " name)
			altered = 1
		    } else {
			print_warns(pfx "not overwritting module " name)
			altered = 1
		    }
		}
	    }
	}
	if (altered) {
	    # tell ourselves to correct on reboot
	    print_warns(pfx "*** REBOOT REQUIRED ***")
	    doit("touch /.openss7_update-" krunning)
	    return 0
	}
    }
    return 1
}
function makesolution(kversion, kver,
		      creates, unlinks, changes, relinks, dolinks, removes, retains, inserts,
		      pfx,fmt,c,u,a,l,d,i,labels,n,name,pair,pairs)
{
    pfx = "w: solution,  "
    fmt = pfx "sym links: %04d created, %04d unlinked, %04d changed, %04d relinked, %04d deleted, %04d inserted"
    c = 0; u = 0; a = 0; l = 0; d = 0; i =0
    print_vinfo(2, pfx "solution = " kver)
    print_vinfo(2, sprintf(fmt, c, u, a, l, d, i))
    # create symbolic links
    if (kver in creates) {
	if (split(creates[kver],labels,/,/)) {
	    for (n in labels) { name = labels[n]
		createlinks(kversion, kver, name)
		c++
		print_vmore(3, sprintf(fmt, c, u, a, l, d, i))
	    }
	}
    }
    print_vmore(2, sprintf(fmt, c, u, a, l, d, i))
    # remove symbolic links to old modules
    if (kver in unlinks) {
	if (split(unlinks[kver],labels,/,/)) {
	    for (n in labels) { name = labels[n]
		removelinks(kversion, name)
		u++
		print_vmore(3, sprintf(fmt, c, u, a, l, d, i))
	    }
	}
    }
    print_vmore(2, sprintf(fmt, c, u, a, l, d, i))
    # change symbolic links
    if (kver in changes) {
	if (split(changes[kver],labels,/,/)) {
	    for (n in labels) { name = labels[n]
		changelinks(kversion, kver, name)
		a++
		print_vmore(3, sprintf(fmt, c, u, a, l, d, i))
	    }
	}
    }
    print_vmore(2, sprintf(fmt, c, u, a, l, d, i))
    # relink modules
    if (kver in relinks) {
	if (split(relinks[kver],labels,/,/)) {
	    for (n in labels) { name = labels[n]
		relinklinks(kversion, kver, name)
		l++
		print_vmore(3, sprintf(fmt, c, u, a, l, d, i))
	    }
	}
    }
    print_vmore(2, sprintf(fmt, c, u, a, l, d, i))
    # relink inserts
    if (kver in dolinks) {
	if (split(dolinks[kver],labels,/,/)) {
	    for (n in labels) { name = labels[n]
		relinklinks(kversion, kver, name)
		l++
		print_vmore(3, sprintf(fmt, c, u, a, l, d, i))
	    }
	}
    }
    print_vmore(2, sprintf(fmt, c, u, a, l, d, i))
    # remove modules
    if (kver in removes) {
	if (split(removes[kver],labels,/,/)) {
	    for (n in labels) { name = labels[n]
		removefiles(kversion,name)
		d++
		print_vmore(3, sprintf(fmt, c, u, a, l, d, i))
	    }
	}
    }
    print_vmore(2, sprintf(fmt, c, u, a, l, d, i))
    # insert modules
    if (kver in inserts) {
	if (split(inserts[kver],labels,/,/)) {
	    for (n in labels) { name = labels[n]
		i++
		print_vmore(3, sprintf(fmt, c, u, a, l, d, i))
	    }
	}
    }
    print_vinfo(2, sprintf(fmt, c, u, a, l, d, i))
    removedirs(kversion)
    return (c+u+a+d+i)
}
function modlink(kversion, reloads,
		  pfx,n,m,name,module,sym,syms,s,add,crc,old)
{
    pfx = "w: modlink,   "
    print_vmore(3, pfx "relinking...")
    n = 0; m = 0
    for (name in names) {
	if ((kversion,name) in modnames) {
	    module = modnames[kversion,name]
	} else {
	    print_error(pfx sprintf("no modname for (%s,%s)", kversion,name))
	    continue
	}
	if ((kversion,name) in weaknames) {
	    file = weaknames[kversion,name]
	    if (file in weaklinks) {
		module = weaklinks[file]
	    }
	} else  {
	    continue
	}
	if (!(module in linkedsyms) && !(module in wantedsyms)) {
	    continue
	}
	if (module in linkedsyms) {
	    split(linkedsyms[module],syms,/,/)
	    for (s in syms) { sym = syms[s]
		if (!((module,sym) in linked)) {
		    print_error(pfx sprintf("%s in linksysms, but no (%s,%s) in linked!", sym, module,sym))
		    continue
		}
		add = linked[module,sym]
		if ((kversion,sym) in allsyms) {
		    if (allsyms[kversion,sym] == add) continue
		    old = add
		    add = allsyms[kversion,sym]
		} else
		if (kversion != krunning && (kversion,sym) in sysmaps) {
		    if (sysmaps[kversion,sym] == add) continue
		    old = add
		    add = sysmaps[kversion,sym]
		} else {
		    if ((module,sym) in weaken && weaken[module,sym]~/^00*$/) continue
		    print_error(pfx kversion " does not provide an address for " sym)
		    add = "00000000"
		}
		n++
		print_vmore(3, pfx sprintf("%-12s %03d relinked of %03d %-40s", "addresses", n, m, sym))
		#linked[module,sym] = add
		if (file in reloads)
		{ reloads[file] = reloads[file] "\n\t" sym " = 0x" add ";" } else
		{ reloads[file] = "\t" sym " = 0x" add ";" }
	    }
	}
	if (module in wantedsyms) {
	    split(wantedsyms[module],syms,/,/)
	    for (s in syms) { sym = syms[s]
		if (!((module,sym) in wanted)) {
		    print_error(pfx sprintf("%s in linksysms, but no (%s,%s) in wanted!", sym, module,sym))
		    continue
		}
		crc = wanted[module,sym]
		if ((kversion,sym) in symvers) {
		    if (symvers[kversion,sym] != crc) {
			add = "00000000"
			if (!((module,sym) in weaken) || weaken[module,sym]~/^00*$/) continue
		    } else
		    if ((kversion,sym) in allsyms) {
			add = allsyms[kversion,sym]
			if ((module,sym) in weaken && allsyms[kversion,sym] == weaken[module,sym]) continue
		    } else
		    if (kversion != krunning && (kversion,sym) in sysmaps) {
			add = sysmaps[kversion,sym]
			if ((module,sym) in weaken && sysmaps[kversion,sym] == weaken[module,sym]) continue
		    } else {
			add = "00000000"
			if (!((module,sym) in weaken) || weak[module,sym]~/^00*$/) continue
		    }
		} else {
		    if ((kversion,sym) in allsyms) {
			add = allsyms[kversion,sym]
			if ((module,sym) in weaken && allsyms[kversion,sym] == weaken[module,sym]) continue
		    } else
		    if (kversion != krunning && (kversion,sym) in sysmaps) {
			add = sysmaps[kversion,sym]
			if ((module,sym) in weaken && sysmaps[kversion,sym] == weaken[module,sym]) continue
		    } else {
			add = "00000000"
			if (!((module,sym) in weaken) || weaken[module,sym]~/^00*$/) continue
		    }
		}
		n++
		print_vmore(3, pfx sprintf("%-12s %03d prelinks of %03d %-40s", "addresses", n, m, sym))
		if (file in reloads)
		{ reloads[file] = reloads[file] "\n\t" sym " = 0x" add ";" } else
		{ reloads[file] = "\t" sym " = 0x" add ";" }
	    }
	}
    }
}
function modload(kversion, symbols, weakmod, module,
		pfx,script,pair,pairs,sym,add,file,text,gzip,source)
{
    pfx = "w: modload,   "
    script = me "." PROCINFO["pid"] ".lds"
    text = "SECTIONS\n{\n" symbols "\n}"
    print text > script
    print_debug(3,pfx gensub(/\n/, "\n" me ": D: " pfx, "g", text))
    close(script)
    if (weakmod~/\.ko\.gz$/) {
	gzip = ".gz"
	source = weakmod
	sub(/\.ko\.gz$/, ".ko", source)
	doit("gzip -dc " weakmod " >" source)
    } else {
	gzip = ""
	source = weakmod
    }
    file = weakmod; sub(/\/[^\/]*$/, "/", file)
    file = file me "." PROCINFO["pid"] ".ko"
    print_action("relinking", module, " in ", kversion)
    if (doit("ld -r -o " file " " source " " script) == 0) {
	if (gzip) {
	    doit("rpm -f -- " source)
	    doit("gzip -f9 " file)
	}
	doit("mv -f -- " file gzip " " weakmod)
    } else {
	print_error(pfx "relinking failed for " weakmod)
	print_action("removing", module, "from", kversion)
	doit("rm -f -- " file " " file gzip " " weakmod " " source)
    }
    system_command("rm -f -- " script)
}
function testdepmod(		pfx,command,result)
{
    pfx = "t: depmod,    "
    if (!("depmodx" in values)) {
	result = 0
	command = "/sbin/depmod --help 2>&1"
	while ((command | getline) == 1) { if (/[[:space:]]-E,?[[:space:]]/) { result = 1 } }
	close(command)
	if (result) {
	    values["depmodx"] = 1
	    print_vinfo(2, pfx "depmod supports -E option")
	} else {
	    values["depmodx"] = 0
	    print_vinfo(2, pfx "depmod does not support -E option")
	}
    }
}
function testwstyle(		pfx,command,result)
{
    pfx = "t: wstyle,    "
    if (!("style" in values) || !values["style"]) {
	if (system_command("test -e /lib/modules/" krunning "/extramodules") == 0) {
	    values["style"] = "arch"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "updates" }
	} else
	if (system_command("test -r /usr/lib/module-init-tools/weak-modules2") == 0) {
	    values["style"] = "suse11"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "weak-updates" }
	} else
	if (system_command("test -r /usr/lib/module-init-tools/weak-modules") == 0) {
	    values["style"] = "suse10"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "weak-updates" }
	} else
	if (system_command("test -r /sbin/weak-modules") == 0) {
	    values["style"] = "redhat"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "weak-updates" }
	} else
	if (system_command("test -r /boot/abi-" krunning) == 0) {
	    values["style"] = "ubuntu"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "updates" }
	} else {
	    values["style"] = "debian"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "updates" }
	}
    } else
    if (values["style"] !~ /^(debian|ubuntu|redhat|suse10|suse11|mandriva|arch)$/) {
	print_error(pfx "style is '" values["style"] "' but must be one of {debian|ubuntu|redhat|suse10|suse11|mandriva|arch}")
	usage(stderr)
	exit 2
    }
}
function dompatch(kversion,
		  pfx,command,file,string,dir,patch) {
    if (system("test -x /sbin/openss7-patch") == 0) {
	command = "/sbin/openss7-patch"
    } else
    if (system("test -x /usr/sbin/openss7-patch") == 0) {
	command = "/usr/sbin/openss7-patch"
    } else {
	print_debug(4, pfx "cannot find openss7-patch script")
	return
    }
    dir = "/lib/modules/" kversion
    command = command " -m /lib/modules/" kversion
    if (values["basedir"]) {
	command = command " -b " values["basedir"]
	dir = values["basedir"] dir
    }
    file = dir "/modules.patch"
    if (system("test -r \"" file "\"") != 0) {
	patch = "/var/lib/openss7/patches"
	if (system("test -r \"" patch "\"") == 0) {
	    if ((getline string < patch) == 1)
		close(patch)
	}
	if (length(string) != 48) {
	    print_debug(4, pfx "patch length " length(string) " != 48")
	    return
	}
	if (system("test -d \"" dir "\"") != 0) {
	    print_debug(4, pfx "directory " dir " does not exist")
	    return
	}
	print "specfs.ko: d5f3c4981e2e41f3bdba506861e8b5eca27e48c9b4eecdda 24 " string > file
	close(file)
    }
    doit(command)
}
function dodepmod(kversion,
		  command,file) {
    command = "/sbin/depmod -a"
    if (values["basedir"]) {
	command = command " -b " values["basedir"]
    }
    if (values["depmodx"]) {
	file = values["sysver"]; gsub(/\$KVERSION/,kversion,file); gsub(/\$PACKAGE/,values["package"],file)
	if (values["basedir"] && system_command("test -r " values["basedir"] file) == 0)
	    command = command " -E " values["basedir"] file
	else if (system_command("test -r " values["rootdir"] file) == 0)
	    command = command " -E " values["rootdir"] file
	else if (system_command("test -r System.symvers") == 0)
	    command = command " -E System.symvers"
	else {
	    file = values["sysmap"]; gsub(/\$KVERSION/,kversion,file); gsub(/\$PACKAGE/,values["package"],file)
	    if (values["basedir"] && system_command("test -r " values["basedir"] file) == 0)
		command = command " -e -F " values["basedir"] file
	    else if (system_command("test -r " values["rootdir"] file) == 0)
		command = command " -e -F " values["rootdir"] file
	}
    } else {
	file = values["sysmap"]; gsub(/\$KVERSION/,kversion,file); gsub(/\$PACKAGE/,values["package"],file)
	if (values["basedir"] && system_command("test -r " values["basedir"] file) == 0)
	    command = command " -e -F " values["basedir"] file
	else if (system_command("test -r " values["rootdir"] file) == 0)
	    command = command " -e -F " values["rootdir"] file
    }
    command = command " " kversion
    doit(command)
}
function initstart(	n,scripts,i,script,command) {
    if (system_command("test -r /proc/1/comm -a `cat /proc/1/comm` = 'systemd'") == 0) {
	if (!("unitfiles" in values))
	    return
	n = split(values["unitfiles"],scripts,/,/)
	if (n == 0)
	    return
	if (system_command("test -x /usr/bin/systemctl") == 0) {
	    for (i=1;i<=n;i++) { script = scripts[i]
		if (script~/shutdown/)
		    continue
		command = "/usr/bin/systemctl start " script
		doit(command)
	    }
	}
    } else {
	if (!("initscripts" in values))
	    return
	n = split(values["initscripts"],scripts,/,/)
	if ( n == 0 )
	    return
	if (system_command("test -x /sbin/service") == 0) {
	    for (i=1;i<=n;i++) { script = scripts[i]
		command = "/sbin/service " script " start"
		doit(command)
	    }
	} else
	if (system_command("test -x /usr/bin/invoke-rc.d") == 0) {
	    for (i=1;i<=n;i++) { script = scripts[i]
		command = "/usr/sbin/invoke-rc.d " script " start"
		doit(command)
	    }
	} else {
	    for (i=1;i<=n;i++) { script = scripts[i]
		if (system_command("test -x /etc/init.d/" script) == 0) {
		    command = "/etc/init.d/" script " start"
		    doit(command)
		}
	    }
	}
    }
}
function initstop(	n,scripts,i,script,command) {
    if (system_command("test -r /proc/1/comm -a `cat /proc/1/comm` = 'systemd'") == 0) {
	if (!("unitfiles" in values))
	    return
	n = split(values["unitfiles"],scripts,/,/)
	if (n == 0)
	    return
	if (system_command("test -x /usr/bin/systemctl") == 0) {
	    for (i=n;i>=1;i--) { script = scripts[i]
		if (script!~/shutdown/)
		    continue
		command = "/usr/bin/systemctl start " script
		doit(command)
	    }
	}
    } else {
	if (!("initscripts" in values))
	    return
	n = split(values["initscripts"],scripts,/,/)
	if (n == 0)
	    return
	if (system_command("test -x /sbin/service") == 0) {
	    for (i=n;i>=1;i--) { script = scripts[i]
		command = "/sbin/service " script " stop"
		doit(command)
	    }
	} else
	if (system_command("test -x /usr/bin/invoke-rc.d") == 0) {
	    for (i=n;i>=1;i--) { script = scripts[i]
		command = "/usr/sbin/invoke-rc.d " script " stop"
		doit(command)
	    }
	} else {
	    for (i=n;i>=1;i--) { script = scripts[i]
		if (system_command("test -x /etc/init.d/" script) == 0) {
		    command = "/etc/init.d/" script " stop"
		    doit(command)
		}
	    }
	}
    }
}
function remove_kernel(kversion,
		       pfx,dir)
{
    pfx = "p: rmvkernel, "
    if ( "weakdir" in values) {
	if (values["weakdir"]~/^\//) dir = values["weakdir"]
	else dir = values["basedir"] "/lib/modules/$KVERSION/"   values["weakdir"]
    }   else dir = values["basedir"] "/lib/modules/$KVERSION/" defaults["weakdir"]
    gsub(/\$KVERSION/,kversion,dir)
    gsub(/\$PACKAGE/,values["package"],dir)
    doit("rm -fr -- " dir)
}
function link_kernel(kversion,
		     pfx,n,name,weakmod,module,reloads)
{
    pfx = "p: lnkkernel, "
    if (getsysinfo(kversion) == 0)
	return
    getmodinfo(kversion)
    modlink(kversion, reloads)
    n = 0
    print_vmore(3,pfx "relinking...")
    for (name in names) {
	if ((kversion,name) in weaknames) {
	    weakmod = weaknames[kversion,name]
	    if (weakmod in reloads) {
		if (weakmod in weaklinks) { module = weaklinks[weakmod] } else { module = weakmod }
		modload(kversion, reloads[weakmod], weakmod, module)
		n++
		print_vmore(3,pfx sprintf("%-12s %03d %-40s", "modules", n, module))
	    }
	}
    }
    print_vinfo(2,pfx sprintf("%-12s %03d %-40s", "modules", n, ""))
}
# add_kernel()
# A kernel of version kversion has just been added to the distro.  What we need to do is to
# weak-update all of the openss7 and client kernel modules from the openss7 subdirectories of
# previous kernels and relink any absolute kernel addresses.
#
function add_kernel(kversion,
		    pfx,solution,score,s,k,kver,retn,creates,unlinks,changes,relinks,dolinks,removes,retains,inserts,command,file)
{
    pfx = "p: addkernel, "
    if (getsysinfo(kversion) == 0) return
    getmodinfo(kversion)
    solution = "(none)"; score = counts["uniq"]; s = 0
    print_vmore(3, pfx sprintf("%04d solutions, kversion = %-20s", s, kversion))
    for (k=counts["kern"];k>0;k--) { kver = kernels[k]
	getmodinfo(kver)
	retn = getresolve(kversion, kver, creates, unlinks, changes, relinks, dolinks, removes, retains, inserts)
	s++
	print_vmore(3, pfx sprintf("%04d solutions, kversion = %-20s", s, kversion))
	if (retn < score) { score = retn; solution = kver }
	if (score == 0) break
    }
    print_vinfo(2, pfx sprintf("%04d solutions, kversion = %-20s", s, kversion))
    chckunneeded(kversion, solution, creates, unlinks, changes, relinks, dolinks, removes, retains, inserts)
    if (chcksolution(kversion, solution, creates, unlinks, changes, relinks, dolinks, removes, retains, inserts)) {
	makesolution(kversion, solution, creates, unlinks, changes, relinks, dolinks, removes, retains, inserts)
	dompatch(kversion)
	dodepmod(kversion)
	if (("initscripts" in values && values["initscripts"]) ||
	    ("unitfiles"   in values && values["unitfiles"]  )) {
	    if ( kversion == krunning ) {
		if (kversion in kremoved)
		    initstop()
		if (kversion in kinserts)
		    initstart()
	    } else {
		print_vinfo(2, "not running init scripts for kversion = " kversion)
	    }
	}
    } else {
	print_vinfo(2, "not making solution for kversion = " kversion)
    }
}
function remove_kernels(kversion,	pfx,kversions,v,dir)
{
    pfx = "p: rmvkerns,  "
    v = split(kversion,kversions); rpmsort(kversions, v)
    for (;v in kversions;v--) {
	remove_kernel(kversions[v])
    }
}
function link_kernels(kversion,
		     pfx,kversions,v)
{
    pfx = "p: lnkkerns,  "
    print_vinfo(2, pfx "kversions = " kversion)
    getstructure()
    v = split(kversion,kversions); rpmsort(kversions,v)
    for (;v in kversions;v--) {
	link_kernel(kversions[v])
    }
}
function add_kernels(kversion,
		     pfx,kversions,v,olddry)
{
    pfx = "p: addkerns,  "
    if  (!kversion) {
	command = "ls /lib/modules"
	while ((command | getline) == 1) { if (/^[23]\./) if (kversion) { kversion = kversion " " $0 } else { kversion = $0 } }
	close(command)
    }
    getstructure()
    v = split(kversion,kversions); rpmsort(kversions,v)
    for (;v in kversions;v--) {
	add_kernel(kversions[v])
    }
}
function update_kernels(kversion,
			pfx,kversions,command)
{
    pfx = "p: updkernels, "
    delete kremoved
    delete kinserts
    add_kernels(kversion)
}
function boot_kernels(kversion,
		      pfx,kversions,command)
{
    pfx = "p: bootkernel, "
    delete kremoved
    delete kinserts
    kversion = krunning
    add_kernels(kversion)
}
function add_modules(kversion,
		     pfx,kversions,command)
{
    pfx = "p: addmodules, "
    if (split(kversion,kversions) != 1) {
	print_error("o: one and only one KVERSION permitted for --add-modules")
	usage(stderr); exit 2 }
    kversion = kversions[1]
    delete kremoved
    kinserts[kversion] = 1
    kversion = ""
    add_kernels(kversion)
}

function link_modules(kversion,
		      pfx,kversions,v,command)
{
    pfx = "p: lnkmodules, "
    if (split(kversion,kversions) != 1) {
	print_error("o: one and only one KVERSION permitted for --link-modules")
	usage(stderr); exit 2 }
    kversion = kversions[1]
    delete kremoved
    delete kinserts
    kversion = ""
    command = "ls /lib/modules"
    while ((command | getline) == 1) { if (/^[23]\./) if (kversion) { kversion = kversion " " $0 } else { kversion = $0 } }
    close(command)
    link_kernels(kversion)
}

function remove_modules(kversion,
			pfx,kversions,v,command)
{
    pfx = "p: rmvmodules, "
    if (split(kversion,kversions) != 1) {
	print_error("o: one and only one KVERSION permitted for --remove-modules")
	usage(stderr); exit 2 }
    kversion = kversions[1]
    kremoved[kversion] = 1
    delete kinserts
    kversion = ""
    add_kernels(kversion)
}
function update_modules(kversion,
			pfx,kversions,command)
{
    pfx = "p: updmodules, "
    delete kremoved
    delete kinserts
    kversion = ""
    add_kernels(kversion)
}
BEGIN {
    LINT = "yes"
    me = "openss7-modules"
    count_errs = 0; count_warn = 0; errors = ""
    if (!("TERM" in ENVIRON)) ENVIRON["TERM"] = "dumb"
    if (ENVIRON["TERM"] == "dumb" || system("test -t 1 -a -t 2") != 0) {
	stdout = "/dev/stdout"
	stderr = "/dev/stderr"
	cr = ""; lf = "\n"
	blk = ""; hblk = ""
	red = ""; hred = ""
	grn = ""; hgrn = ""
	org = ""; horg = ""
	blu = ""; hblu = ""
	mag = ""; hmag = ""
	cyn = ""; hcyn = ""
	std = ""; prog = "no"
    } else {
	stdout = "/dev/stdout"
	stderr = "/dev/stderr"
	cr = "\r"; lf = ""
	blk = "\033[0;30m"; hblk = "\033[1;30m"
	red = "\033[0;31m"; hred = "\033[1;31m"
	grn = "\033[0;32m"; hgrn = "\033[1;32m"
	org = "\033[0;33m"; horg = "\033[1;33m"
	blu = "\033[0;34m"; hblu = "\033[1;34m"
	mag = "\033[0;35m"; hmag = "\033[1;35m"
	cyn = "\033[0;36m"; hcyn = "\033[1;36m"
	std = "\033[m"; prog = "yes"
    }
    krunning = getline_command("uname -r")
    if ("kversion" in ENVIRON) { d["kversion"] = ENVIRON["kversion"] }
    else                       { d["kversion"] = krunning }
    d["package" ] = "openss7"
    d["style"   ] = "debian"
    d["basedir" ] = ""
    d["weakdir" ] = "weak-updates"
    d["allsym"  ] = "/proc/kallsyms"
    d["sysmap"  ] = "/boot/System.map-$KVERSION"
    d["vmlinux" ] = "/usr/src/linux-$KVERSION/vmlinux"
    d["sysver"  ] = "/lib/modules/$KVERSION/build/Module.symvers"
    d["symver"  ] = "/boot/symvers-$KVERSION.gz"
    d["symabi"  ] = "/boot/abi-$KVERSION"
    d["inits"   ] = "specfs,streams,strace,strerr,openss7"
    d["units"   ] = "streams.target"
											  descrips["kernels"       ] = "kernel versions for which to perform operations"					; longargs["kernels"       ] = "KERNEL ..."
    longopts["kversion"      ] = "k:" ; defaults["kversion"      ] = d["kversion"]	; descrips["kversion"      ] = "default kernel version"
    longopts["add-kernel"    ] = "A!" ;							  descrips["add-kernel"    ] = "mode: add kernels with versions"
    longopts["link-kernel"   ] = "L!" ;							  descrips["link-kernel"   ] = "mode: link kernels with versions"
    longopts["remove-kernel" ] = "R!" ;							  descrips["remove-kernel" ] = "mode: remove kernels with versions"
    longopts["update-kernel" ] = "U!" ;							  descrips["update-kernel" ] = "mode: update kernels with versions"
    longopts["boot-kernel"   ] = "B!" ;							  descrips["boot-kernel"   ] = "mode: update boooting kernel with version"
    longopts["add-modules"   ] = "a!" ;							  descrips["add-modules"   ] = "mode: add kernel modules to kernel versions"
    longopts["link-modules"  ] = "l!" ;							  descrips["link-modules"  ] = "mode: link modules for kernel with versions"
    longopts["remove-modules"] = "r!" ; defaults["remove-modules"] = d["kversion"]	; descrips["remove-modules"] = "mode: remove kernel modules from kernel versions"
    longopts["update-modules"] = "u!" ; defaults["update-modules"] = d["kversion"]	; descrips["update-modules"] = "mode: update kernel modules from kernel versions"
    longopts["modules"       ] = "M:" ; defaults["modules"       ] = ""			; descrips["modules"       ] = "modules for which to generate symbols (search when unspec.)"				; longargs["modules"       ] = "MODULE ..."
    longopts["rootdir"       ] = "c:" ; defaults["rootdir"       ] = ""			; descrips["rootdir"       ] = "root of the kernels being installed"
    longopts["basedir"       ] = "b:" ; defaults["basedir"       ] = d["basedir" ]	; descrips["basedir"       ] = "use a base directory other than root, BASEDIR"
    longopts["weakdir"       ] = "w:" ; defaults["weakdir"       ] = d["weakdir" ]	; descrips["weakdir"       ] = "where to place weak update symbolic links\nabsolute or rel. to /lib/modules/$KVERSION)"
    longopts["allsym"        ] = "y:" ; defaults["allsym"        ] = d["allsym"  ]      ; descrips["allsym"        ] = "kernel symbols file (search when unspec.)"
    longopts["sysmap"        ] = "F:" ; defaults["sysmap"        ] = d["sysmap"  ]	; descrips["sysmap"        ] = "system map file (same as depmod) (search when unspec.)"
    longopts["vmlinux"       ] = "I:" ; defaults["vmlinux"       ] = d["vmlinux" ]	; descrips["vmlinux"       ] = "kernel vmlinux image"
    longopts["sysver"        ] = "E:" ; defaults["sysver"        ] = d["sysver"  ]	; descrips["sysver"        ] = "system version file (same as depmod) (search when unspec.)"
    longopts["symver"        ] = "S:" ; defaults["symver"        ] = d["symver"  ]	; descrips["symver"        ] = "system version file (compressed) (search when unspec.)"
    longopts["symabi"        ] = "Y:" ; defaults["symabi"        ] = d["symabi"  ]	; descrips["symabi"        ] = "system version file (ubuntu abi) (search when unspec.)"
    longopts["package"       ] = "P:" ; defaults["package"       ] = d["package" ]	; descrips["package"       ] = "package name (used to find subdirectories)"
    longopts["style"         ] = "s:" ; defaults["style"         ] = d["style"   ]	; descrips["style"         ] = "style of weak-updates (detect when unspec.)"						; longargs["style"         ] = "{debian|redhat|suse10|suse11|ubuntu|mandriva|arch}"
    longopts["initscripts"   ] = "i::"; defaults["initscripts"   ] = d["inits"   ]	; descrips["initscripts"   ] = "comma-separated list of init scripts to run"						; longargs["initscripts"   ] = "[SCRIPT[,SCRIPT]...]"
    longopts["unitfiles"     ] = "f::"; defaults["unitfiles"     ] = d["units"   ]	; descrips["unitfiles"     ] = "comma-separated list of unit files to run"						; longargs["unitfiles"     ] = "[UNIT[,UNIT]...]"
    longopts["delete-modules"] = "d"  ; defaults["delete-modules"] = 0			; descrips["delete-modules"] = "delete modules for specified kernel version"
    longopts["depmodx"       ] = "x"  ; defaults["depmodx"       ] = 0			; descrips["depmodx"       ] = "depmod supports -E option (detect when unspec.)"
    longopts["preserve"      ] = "p"  ; defaults["preserve"      ] = 1			; descrips["preserve"      ] = "preserve configuration for running kernel"
    longopts["overwrite"     ] = "o"  ; defaults["overwrite"     ] = 0			; descrips["overwrite"     ] = "overwrite configuration for running kernel"
    longopts["test"          ] = "t"  ; defaults["test"          ] = 0			; descrips["test"          ] = "test modules in current directory"
    longopts["exit-on-error" ] = "e"  ; defaults["exit-on-error" ] = 0			; descrips["exit-on-error" ] = "exit with error status on program errors"
    longopts["dryrun"        ] = "n"  ; defaults["dryrun"        ] = 0			; descrips["dryrun"        ] = "don't perform actions, just check them"
    longopts["dry-run"       ] = "n"  ; defaults["dry-run"       ] = 0			; descrips["dry-run"       ] = "don't perform actions, just check them"
    longopts["quiet"         ] = "q"  ; defaults["quiet"         ] = 0			; descrips["quiet"         ] = "suppress normal output"
    longopts["silent"        ] = "q"  ; defaults["silent"        ] = 0			; descrips["silent"        ] = "suppress normal output"
    longopts["debug"         ] = "D::"; defaults["debug"         ] = 0			; descrips["debug"         ] = "increase or set debug level DEBUG"							; environs["debug"        ] = "OS7UPDT_DEBUG"
    longopts["verbose"       ] = "v::"; defaults["verbose"       ] = 0			; descrips["verbose"       ] = "increase or set verbosity level VERBOSITY"						; environs["verbose"      ] = "OS7UPDT_VERBOSE"
    longopts["help"          ] = "h!" ;							  descrips["help"          ] = "display this usage information and exit"
    longopts["version"       ] = "V!" ;							  descrips["version"       ] = "display script version and exit"
    longopts["copying"       ] = "C!" ;							  descrips["copying"       ] = "display coding permissions and exit"
    delete d
    values["kversion"      ] = defaults["kversion"      ]
    values["allsym"        ] = defaults["allsym"        ]
    values["sysmap"        ] = defaults["sysmap"        ]
    values["vmlinux"       ] = defaults["vmlinux"       ]
    values["sysver"        ] = defaults["sysver"        ]
    values["symver"        ] = defaults["symver"        ]
    values["symabi"        ] = defaults["symabi"        ]
    values["package"       ] = defaults["package"       ]
    values["rootdir"       ] = defaults["rootdir"       ]
    values["basedir"       ] = defaults["basedir"       ]
    values["delete-modules"] = defaults["delete-modules"]
    values["preserve"      ] = defaults["preserve"      ]
    values["overwrite"     ] = defaults["overwrite"     ]
    values["test"          ] = defaults["test"          ]
    values["exit-on-error" ] = defaults["exit-on-error" ]
    values["dryrun"        ] = defaults["dryrun"        ]
    values["dry-run"       ] = defaults["dry-run"       ]
    values["quiet"         ] = defaults["quiet"         ]
    values["silent"        ] = defaults["silent"        ]
    values["debug"         ] = defaults["debug"         ]
    values["verbose"       ] = defaults["verbose"       ]
    optstring = "k:ALRUBalruM:c:b:w:y:F:I:E:S:Y:P:s:i::f::podtxenqD::v::hVC"
    optind = 0
    #opts = ""; for (i=1;i<ARGC;i++) { if (i == 1) { opts = ARGV[i] } else { opts = opts " " ARGV[i] } }
    #print me ": D: o: command line: " opts > stderr; written[stderr] = 1
    command = ""
    while (1) {
	c = getopt_long(ARGC, ARGV, optstring, longopts)
	#if (c != -1) { print me ": D: o: option -" c ", longopt --" option ", optset = " optset ", optarg = " optarg > stderr; written[stderr] = 1 }
	if (c == -1) break
	else if (c~/[kMcbwyFIESYPsif]/)			{ values[option] = optarg }
	else if (c~/[podtxenq]/)			{ values[option] = optset }
	else if (c~/[Dv]/)	{ if (optarg  != "")	{ values[option] = optarg } else { if (optset)  { values[option]++ } else { values[option] = optset } } }
	else if (c~/[ALRUBalru]/)			{ values[option] = optset; if (!optset && command == option)	{ command = "" } else
										   if (optset && !command)		{ command = option } else
										   if (optset) {  print_error("option --" option " is incompatible with --" command); exit 2 } }
	else if (c~/[hVC]/)	{ command = option }
	else			{ usage(  stderr); exit 2 }
    }
    if (values["quiet"  ] == defaults["quiet"  ] &&
	values["debug"  ] == defaults["debug"  ] &&
	values["verbose"] == defaults["verbose"]) {
	if ("V" in ENVIRON) {
	    if (ENVIRON["V"] == "0") {
		values["quiet"  ] = 1
		values["debug"  ] = 0
		values["verbose"] = 0
	    } else
	    if (ENVIRON["V"] == "1") {
		values["quiet"  ] = 0
		values["debug"  ] = 0
		values["verbose"] = 2
	    }
	}
    }
    if (values["verbose"]+0 >=3 && values["debug"]+0 == defaults["debug"]+0)
	values["debug"] = values["verbose"] - 2
    while (optind < ARGC) {
	if ("kernels" in values)
	{ values["kernels"] = values["kernels"] " " ARGV[optind] } else
	{ values["kernels"] = ARGV[optind] }
	optind++
    }
    for (i=1;ARGC>i;i++) { delete ARGV[i] }
    if (command == "boot-kernel") {
	if (values["preserve" ] == defaults["preserve" ] &&
	    values["overwrite"] == defaults["overwrite"]) {
	    if ("initscripts" in values)
		delete values["initscripts"]
	    if ("unitfiles" in values)
		delete values["unitfiles"]
	    values["preserve" ] = 0
	    values["overwrite"] = 1
	}
	values["kernels"] = values["kversion"]
    }
    for (value in values) {
	if (!values[value] && (value in environs) && (environs[value] in ENVIRON) && ENVIRON[environs[value]]) {
	    print_debug(1,"o: assigning value for " value " from environment " environs[value])
	    values[value] = ENVIRON[environs[value]]
	}
	if (!values[value] && (value in defaults) && defaults[value]) {
	    print_debug(1,"o: assigning value for " value " from default " defaults[value])
	    values[value] = defaults[value]
	}
    }
    for (value in values) {
	print_debug(1, "o: \"" value "\" = " values[value])
    }
    modversions = 0
    testdepmod()
    testwstyle()
    if (command == "help"          ) { help(   stdout); exit 0 }
    if (command == "version"       ) { version(stdout); exit 0 }
    if (command == "copying"       ) { copying(stdout); exit 0 }
    if (!("kernels" in values)     ) { values["kernels"] = ""  }
    if (command == "add-kernel"    ) { add_kernels(    values["kernels"])} else
    if (command == "link-kernel"   ) { link_kernels(   values["kernels"])} else
    if (command == "remove-kernel" ) { remove_kernels( values["kernels"])} else
    if (command == "update-kernel" ) { update_kernels( values["kernels"])} else
    if (command == "boot-kernel"   ) { boot_kernels(   values["kernels"])} else
    if (command == "add-modules"   ) { add_modules(    values["kernels"])} else
    if (command == "link-modules"  ) { link_modules(   values["kernels"])} else
    if (command == "remove-modules") { remove_modules( values["kernels"])} else
    if (command == "update-modules") { update_modules( values["kernels"])} else
    {
	print_error("o: nothing to do")
	usage(stderr)
	exit 2
    }
    if (count_errs && ("exit-on-error" in values) && (values["exit-on-error"] != 0))
	exit 1
    exit 0
}
END {
    if (errors) { print errors > stderr; written[stderr] = 1 }
    if (count_errs) print_emore("errs = " count_errs)
    if (count_warn) print_wmore("warn = " count_warn)
    for (file in written)
	close(file)
}

# =============================================================================
#
# $Log: openss7-modules,v $
# Revision 1.1.2.11  2011-09-20 09:51:33  brian
# - updates from git
#
# Revision 1.1.2.10  2011-09-02 08:46:30  brian
# - sync up lots of repo and build changes from git
#
# Revision 1.1.2.9  2011-07-28 09:40:37  brian
# - updates to debian debuginfo build and mandriva compressed manpages and modules
#
# Revision 1.1.2.8  2011-07-27 07:52:20  brian
# - work to support Mageia/Mandriva compressed kernel modules and URPMI repo
#
# Revision 1.1.2.7  2011-05-31 09:46:02  brian
# - new distros
#
# Revision 1.1.2.6  2011-05-15 12:01:20  brian
# - many build system refinements
#
# Revision 1.1.2.5  2011-05-10 13:45:31  brian
# - weak modules workup
#
# Revision 1.1.2.4  2011-04-12 06:33:27  brian
# - passes distcheck
#
# Revision 1.1.2.3  2011-04-11 06:13:43  brian
# - working up weak updates
#
# Revision 1.1.2.2  2011-04-07 15:24:01  brian
# - weak reference corrections
#
# Revision 1.1.2.1  2011-04-05 16:35:10  brian
# - weak module design
#
# =============================================================================
# vim: ft=awk sw=4 nocin nosi fo+=tcqlorn
