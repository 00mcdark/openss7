#!/usr/bin/awk -f
# =============================================================================
# 
# @(#) $RCSfile: openss7-modules,v $ $Name:  $($Revision: 1.1.2.4 $) $Date: 2011-04-12 06:33:27 $
#
# -----------------------------------------------------------------------------
#
# Copyright (c) 2008-2011  Monavacon Limited <http://www.monavacon.com/>
# Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
# Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>
#
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>, or write to
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# -----------------------------------------------------------------------------
#
# U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
# behalf of the U.S. Government ("Government"), the following provisions apply
# to you.  If the Software is supplied by the Department of Defense ("DoD"), it
# is classified as "Commercial Computer Software" under paragraph 252.227-7014
# of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
# successor regulations) and the Government is acquiring only the license rights
# granted herein (the license rights customarily provided to non-Government
# users).  If the Software is supplied to any unit or agency of the Government
# other than DoD, it is classified as "Restricted Computer Software" and the
# Government's rights in the Software are defined in paragraph 52.227-19 of the
# Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
# the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
# (or any successor regulations).
#
# -----------------------------------------------------------------------------
#
# Commercial licensing and support of this software is available from OpenSS7
# Corporation at a fee.  See http://www.openss7.com/
#
# -----------------------------------------------------------------------------
#
# Last Modified $Date: 2011-04-12 06:33:27 $ by $Author: brian $
#
# =============================================================================

function getline_command(cmd)
{
    cmd | getline; close(cmd); return $0
}
function date(format)
{
    if (format) {
	return getline_command("date +\"" format "\"")
    } else {
	return getline_command("date -uIseconds")
    }
}
function year()
{
    return date("%Y")
}
function allyears(    this, last, sep, result)
{
    last = year(); sep = ""; result = ""
    for (this = 2009; this <= last; this++) {
	result = result sep this
	sep = ", "
    }
    return result
}
function print_vinfo(level, string)
{
    if ((values["quiet"] == 0) && (values["verbose"] >= level)) {
	print blu me ": I: " string std > stdout
	written[stdout] = 1
    }
}
function print_vmore(level, string)
{
    if (prog == "yes" && (values["quiet"] == 0) && (values["verbose"] >= level)) {
	printf "%s", blu me ": I: " string std cr lf > stdout
	fflush(stdout)
	written[stdout] = 1
    }
}
function print_debug(level, string)
{
    if (values["debug"] >= level) {
	print mag me ": D: " string std > stderr
	written[stderr] = 1
    }
}
function print_dmore(level, string)
{
    if (prog == "yes" && values["debug"] >= level) {
	printf "%s", mag me ": D: " string std cr lf > stderr
	fflush(stderr)
	written[stderr] = 1
    }
}
function print_error(string)
{
    print red me ": E: " string std > stderr
    if (count_errs) errors = errors "\n"
    errors = errors red me ": E: " string std
    written[stderr] = 1
    count_errs++
}
function print_emore(string)
{
    print red me ": E: " string std > stderr
    if (count_errs) errors = errors "\n"
    errors = errors red me ": E: " string std
    written[stderr] = 1
}
function print_warns(string)
{
    if ((values["quiet"] == 0) || (values["verbose"] > 0) || (values["debug"] > 0)) {
	print org me ": W: " string std > stderr
	written[stderr] = 1
    }
    count_warn++
}
function print_wmore(string)
{
    if ((values["quiet"] == 0) || (values["verbose"] > 0) || (values["debug"] > 0)) {
	print org me ": W: " string std > stderr
	written[stderr] = 1
    }
}
function usage(output)
{
    if (values["quiet"])
	return
    print "\
" me ":\n\
  $Id: openss7-modules,v 1.1.2.4 2011-04-12 06:33:27 brian Exp $\n\
Usage:\n\
  [awk -f ]" me " -- [options] [mode] [" longargs["kernels"] "]\n\
  [awk -f ]" me " -- -" gensub(/!/, "", 1, longopts["help"]) ", --help\n\
  [awk -f ]" me " -- -" gensub(/!/, "", 1, longopts["version"]) ", --version\n\
  [awk -f ]" me " -- -" gensub(/!/, "", 1, longopts["copying"]) ", --copying\
" > output
    written[output] = 1
}
function help_usage(name,  line,sep,dflt,env,valu)
{
    line = ""; sep = ""; dflt = ""; env = ""
    if (name in defaults && longopts[name] !~ /!/) {
	if (longopts[name]~/:/) {
	    dflt = defaults[name]
	} else {
	    if (defaults[name]) { dflt = "yes" } else { dflt = "no" }
	}
	#if (dflt) {
	    line = line sep "[default: '" dflt "']"; sep = " "
	#}
    }
    if (name in environs && longopts[name] !~ /!/) {
	if (longopts[name]!~/:/) env = "?"
	if (environs[name])
	    line = line sep "{" env environs[name] "}"; sep = " "
    }
    if (name in values && longopts[name] !~ /!/) {
	if (longopts[name]~/:/) {
	    valu = values[name]
	} else {
	    if (values[name]) { valu = "yes" } else { valu = "no" }
	}
	if (line) sep = "\n      "
	line = line sep "(current: '" valu "')"; sep = " "
    }
    return line
}
function help_opttags(name,  line,char,opt,oth)
{
    line = ""
    if (name in longopts) {
	opt = longopts[name]
	if (opt~/[[:alnum:]]/) {
	    char = opt
	    gsub(/[:!]/,"",char)
	    line = "-" char ", --" name
	} else {
	    line = "--" name
	}
	if (name in longargs) { line = line " " longargs[name] } else
	if (opt~/::$/) { line = line " [" toupper(name) "]" } else
	if (opt~/:$/)  { line = line " " toupper(name) } else
	if (opt!~/!$/) { line = line ", --no-" name }
	if (opt~/[[:alnum:]]/) {
	    for (oth in longopts) {
		if (opt != longopts[oth]) continue
		if (oth == name) continue
		line = line ", --" oth
		if (oth in longargs) { line = line " " longargs[oth] } else
		if (opt~/::$/) { line = line " [" toupper(oth) "]" } else
		if (opt~/:$/)  { line = line " " toupper(oth) } else
		if (opt!~/!$/) { line = line ", --no-" oth }
	    }
	}
    }
    return line
}
function help_option(output, name,
		     desc)
{
    printf "  %s\n", help_opttags(name) > output
    if (name in descrips && descrips[name])
	printf "      %s\n", gensub(/\n/, "\n      ", "g", descrips[name]) > output
    if ((name in defaults || name in environs) && help_usage(name))
	printf "      %s\n", help_usage(name) > output
}
function help_options(output,		opt,char,pos,long,n,sorted,i)
{
    if (!optstring) return
    print "Options:" > output; written[output] = 1
    # index all of the long options
    for (opt in longopts) {
	char = substr(longopts[opt],1,1)
	if (char && char != ":") {
	    if (char in optchars) {
		if (char == substr(opt,1,1))
		    optchars[char] = opt
	    } else
		optchars[char] = opt
	}
    }
    for (pos=1;pos<=length(optstring);pos++) {
	char = substr(optstring,pos,1)
	if (char == "*") {
	    # document any long-only options
	    n = asorti(longopts,sorted)
	    for (i=1;i<=n;i++) {
		long = sorted[i]
		if (longopts[long]~/^[[:alnum:]]/) continue
		help_option(output, long)
	    }
	}
	if (char!~/[[:alnum:]]/) continue
	if (!(char in optchars)) continue
	help_option(output, optchars[char])
    }
}
function help(output)
{
    if (values["quiet"])
	return
    usage(output)
    print "\
Arguments:\n\
  " longargs["kernels"] "\n\
      " descrips["kernels"] "\
" > output
    help_options(output)
    written[output] = 1
}
function version(output)
{
    if (values["quiet"])
	return
    print "\
Version 2.1\n\
$Id: openss7-modules,v 1.1.2.4 2011-04-12 06:33:27 brian Exp $\n\
Copyright (c) 2008, " allyears() "  Monavacon Limited.\n\
Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008  OpenSS7 Corporation.\n\
Copyright (c) 1997, 1998, 1999, 2000, 2001  Brian F. G. Bidulock.\n\
\n\
All Rights Reserved.\n\
\n\
This is free software; see the source for copying conditions.  There is NO\n\
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\
\n\
Distributed by OpenSS7 under GNU Affero General Public License Version 3,\n\
with conditions, incorporated herein by reference.\n\
\n\
See " me " -- --copying' for copying permissions.\
" > output
    written[output] = 1
}
function copying(output)
{
    if (values["quiet"])
	return
    print "\
--------------------------------------------------------------------------------\n\
$Id: openss7-modules,v 1.1.2.4 2011-04-12 06:33:27 brian Exp $\n\
--------------------------------------------------------------------------------\n\
Copyright (c) 2008, " allyears() "  Monavacon Limited.\n\
Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008  OpenSS7 Corporation.\n\
Copyright (c) 1997, 1998, 1999, 2000, 2001  Brian F. G. Bidulock.\n\
\n\
All Rights Reserved.\n\
--------------------------------------------------------------------------------\n\
This program is free software; you can  redistribute  it and/or modify  it under\n\
the terms  of the  GNU  Affero General Public  License as published  by the Free\n\
Software Foundation; version 3 of the License.\n\
\n\
This program is distributed in the hope that it will  be useful, but WITHOUT ANY\n\
WARRANTY; without even  the implied warranty of MERCHANTABILITY or FITNESS FOR A\n\
PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.\n\
\n\
You should have received a copy of the  GNU Affero General Public License  along\n\
with this program.   If not, see <http://www.gnu.org/licenses/>, or write to the\n\
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n\
--------------------------------------------------------------------------------\n\
U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on behalf\n\
of the U.S. Government (\"Government\"), the following provisions apply to you. If\n\
the Software is supplied by the  Department of Defense (\"DoD\"), it is classified\n\
as \"Commercial  Computer  Software\"  under  paragraph  252.227-7014  of the  DoD\n\
Supplement  to the  Federal Acquisition Regulations  (\"DFARS\") (or any successor\n\
regulations) and the  Government  is acquiring  only the  license rights granted\n\
herein (the license rights customarily provided to non-Government users). If the\n\
Software is supplied to any unit or agency of the Government  other than DoD, it\n\
is  classified as  \"Restricted Computer Software\" and the Government's rights in\n\
the Software  are defined  in  paragraph 52.227-19  of the  Federal  Acquisition\n\
Regulations (\"FAR\")  (or any successor regulations) or, in the cases of NASA, in\n\
paragraph  18.52.227-86 of  the  NASA  Supplement  to the FAR (or any  successor\n\
regulations).\n\
--------------------------------------------------------------------------------\n\
Commercial  licensing  and  support of this  software is  available from OpenSS7\n\
Corporation at a fee.  See http://www.openss7.com/\n\
--------------------------------------------------------------------------------\
" > output
    written[output] = 1
}
function getopt_long(argc, argv, optstring, longopts, longindex,
		     pos, needarg, wantarg, modearg)
{
    option = ""; optval = ""; optarg = ""; optset = ""; pos = 0; needarg = 0; wantarg = 0; modearg = 0
    if (optind == 0) { optind = 1; more = "" }
    while ((optind < argc) || (more != "")) {
	if (more) { arg = "-" more; more = "" }
	else { arg = argv[optind]; optind++ }
	if (arg ~ /^--?[a-zA-Z0-9]/) {
	    if (wantarg) {
		more = substr(arg, 2)
		if (option in defaults)
		    optarg = defaults[option]
		return optval
	    }
	    if (needarg) {
		print_error("option -" optval " requires an argument")
		usage(stderr)
		exit 2
	    }
	    if (arg ~ /^--[a-zA-Z0-9][-_a-zA-Z0-9]*=.*$/) {
		option = arg; sub(/^--/, "", option); sub(/=.*$/, "", option)
		optarg = arg; sub(/^--([a-zA-Z0-9][-_a-zA-Z0-9]*)=/, "", optarg)
		optset = 1
		if (!(option in longopts)) {
		    print_error("option --" option " not recognized")
		    usage(stderr)
		    exit 2
		}
		if (longopts[option] !~ /:/) {
		    print_error("option --" option " does not take an argument")
		    usage(stderr)
		    exit 2
		}
		optval = substr(longopts[option], 1, 1)
		return optval
	    }
	    if (arg ~ /^--[a-zA-Z0-9][-_a-zA-Z0-9]*$/) {
		option = arg; sub(/^--/, "", option)
		optset = 1
		if (!(option in longopts)) {
		    optset = 0
		    sub(/^no-/,"",option)
		    if (!(option in longopts)) {
			print_error("option --" option " not recognized")
			usage(stderr)
			exit 2
		    }
		}
		if (longopts[option] ~ /::/) { wantarg = 1 } else
		if (longopts[option] ~ /:/ ) { needarg = 1 } else
		if (longopts[option] ~ /!/ ) { modearg = 1 }
		if ((wantarg || needarg || modearg) && !optset) {
		    print_error("option --no-" option " not recognized")
		    usage(stderr)
		    exit 2
		}
		optval = substr(longopts[option], 1, 1)
		for (option in longopts)
		    if (substr(longopts[option], 1, 1) == optval)
			break
		if (!needarg && !wantarg)
		    return optval
		continue
	    }
	    if (arg ~ /^-[a-zA-Z0-9]/) {
		optval = substr(arg, 2, 1)
		pos = index(optstring, optval)
		optset = 1
		if (pos == 0 || substr(optstring, pos, 1) == "*") {
		    print_error("option -" optval " not recognized")
		    usage(stderr)
		    exit 2
		}
		if (substr(optstring, pos+1, 1) == ":") {
		    if (length(arg) > 2) {
			if (substr(optstring, pos+2, 1) == ":") {
			    more = substr(arg, 3)
			    if (more && more !~ /^[a-zA-Z0-9]/) {
				print_error("bad option sequence " arg)
				usage(stderr)
				exit 2
			    }
			} else
			    optarg = substr(arg, 3)
			for (option in longopts)
			    if (substr(longopts[option], 1, 1) == optval)
				break
			return optval
		    }
		    if (substr(optstring, pos+2, 1) == ":") { wantarg = 1 } else
		    if (substr(optstring, pos+1, 1) == ":") { needarg = 1 }
		    for (option in longopts)
			if (substr(longopts[option], 1, 1) == optval)
			    break
		    continue
		} else optset = 1
		if (length(arg) > 2) { more = substr(arg, 3) } else { more = "" }
		if (more && more !~ /^[a-zA-Z0-9]/) {
		    print_error("bad option sequence " arg)
		    usage(stderr)
		    exit 2
		}
		for (option in longopts)
		    if (substr(longopts[option], 1, 1) == optval)
			break
		return optval
	    }
	}
	if (arg == "--") {
	    if (wantarg) {
		if (option in defaults)
		    optarg = defaults[option]
		optind--
		return optval
	    }
	    return -1
	}
	if (needarg || wantarg) {
	    optarg = arg
	    return optval
	}
	optind--
	return -1
    }
    if (wantarg) {
	if (option in defaults)
	    optarg = defaults[option]
	return optval
    }
    if (needarg) {
	print_error("option -" optval " requires an argument")
	usage(stderr)
	exit 2
    }
    return -1
}
function system_command(cmd)
{
    print_debug(3, "x: " cmd); return system(cmd)
}
function rpmlessthan(ver1,ver2,	    seg1,seg2,n,n1,n2,i,num1,num2,m,m1,m2,j,s1,s2,x1,x2)
{
    n1 = split(ver1,seg1,/[-:]/)
    n2 = split(ver2,seg2,/[-:]/)
    if (n1>n2) { n = n1 } else { n = n2 }
    for (i=1;i<=n;i++) {
	if (!(i in seg1) && (i in seg2)) { return 1 }
	if ((i in seg1) && !(i in seg2)) { return 0 }
	m1 = split(seg1[i],num1,/[^[:alnum:]]/)
	m2 = split(seg2[i],num2,/[^[:alnum:]]/)
	if (m1>m2) { m = m1 } else { m = m2 }
	for (j=1;j<=m;j++) {
	    if (!(j in num1) && (j in num2)) { return 1 }
	    if ((j in num1) && !(j in num2)) { return 0 }
	    s1 = num1[j]
	    s2 = num2[j]
	    while (1) {
		sub(/^[^[:alnum:]]+/, "", s1)
		sub(/^[^[:alnum:]]+/, "", s2)
		if (s1~/^[[:digit:]]/ || s2~/^[[:digit:]]/) {
		    x1 = s1; sub(/^0*/, "", x1); sub(/[^[:digit:]].*$/, "", x1)
		    x2 = s2; sub(/^0*/, "", x2); sub(/[^[:digit:]].*$/, "", x2)
		    if (length(x1) < length(x2)) return 1
		    if (length(x2) > length(x1)) return 0
		    if (x1 < x2) return 1
		    if (x2 < x1) return 0
		    sub(/^0*[[:digit:]]*/, "", s1)
		    sub(/^0*[[:digit:]]*/, "", s2)
		} else {
		    x1 = s1; sub(/[^[:alpha:]].*$/, "", x1)
		    x2 = s2; sub(/[^[:alpha:]].*$/, "", x2)
		    if (x1 == "" && x2 == "") break
		    if (x1 < x2) return 1
		    if (x2 < x1) return 0
		    sub(/^([[:alpha:]]*)/, "", s1)
		    sub(/^([[:alpha:]]*)/, "", s2)
		}
	    }
	}
    }
    # dead equal
    return 0
}

function rpmsort(versions, n,		swapped,i,version) {
    do {
	swapped = 0
	for (i=1;i<n;i++) {
	    if (rpmlessthan(versions[i+1],versions[i]) == 1) {
		version = versions[i+1]
		versions[i+1] = versions[i]
		versions[i] = version
		swapped = 1
	    }
	}
    } while (swapped)
}
#
# pathversion()
#
# Get the module version for the symbolic link.  This is the directory in which
# it resides instead of the module kernel version.
#
function pathversion(module,			pfx,kversion)
{
    pfx = "r: pathvers,  "
    kversion = module
    if (sub(/^.*\/lib\/modules\//, "", kversion)) {
	sub(/\/.*$/, "", kversion)
    } else {
	kversion = ""
    }
    if (!kversion) print_debug(5, pfx "no version in path for " module)
    return kversion
}
function pathsubdir(module,			pfx,subdir)
{
    pfx = "r: subdir,    "
    subdir = module 
    if (sub(/^.*\/lib\/modules\/[^\/][^\/]*\//, "", subdir)) {
	if (values["style"] != "suse11") {
	    sub(/^[^\/]*\//, "", subdir)
	} else sub(/^kernel\//, "", subdir)
	sub(/\/[^\/][^\/]*$/, "", subdir)
    } else {
	subdir = values["package"]
    }
    return subdir
}
function fileversion(module,			pfx,kversion)
{
    pfx = "r: filevers,  "
    kversion = ""
    if (system_command("test -r \"" module "\"") == 0) {
	command = "strings " module " | grep -m 1 '^vermagic='"
	while((command | getline) == 1) { sub(/=/, " "); kversion = $2 }
	close(command)
	if (!kversion) print_error(pfx "no vermagic for " module)
    } else {
	print_error(pfx "cannot read " module)
    }
    return kversion
}
function getstructure(counts, kernels, modules, subdirs, modnames, names, weakmods, weaklinks, weaknames,
		      pfx,dirs,dir,paths,path,command,h,l,u,k,file,module,subdir,name,kversion,kversions,cmd)
{
    pfx = "r: structure, "
    if ("weakdir" in values)
    { subdir =   values["weakdir"] } else
    { subdir = defaults["weakdir"] }
    sub(/^\/\/*/, "", subdir)
    sub(/\/\/*$/, "", subdir)
    if (!subdir) subdir = "weak-updates"
    dirs = ""
    dir = values["rootdir"] "/lib/modules"
    if (system_command("test -d " dir) == 0)
	if (dirs == "") { dirs = dir } else { dirs = dirs " " dir }
    if (values["rootdir"] != values["basedir"]) {
	dir = values["basedir"] "/lib/modules"
	if (system_command("test -d " dir) == 0)
	    if (dirs == "") { dirs = dir } else { dirs = dirs " " dir }
    }
    k = 0
    if (dirs != "") {
	print_vinfo(2, pfx "dirs = " dirs)
	command = "find " dirs " -maxdepth 2 -type d 2>/dev/null"
	while ((command | getline) == 1) {
	    if (/\/kernel/) {
		kversion = pathversion($0)
		if (kversion && !(kversion in kversions)) {
		    print_debug(2, pfx "adding kernel = " kversion)
		    kversions[kversion] = 1; k++
		}
	    }
	    if ($0"/"!~"/(extra|updates|openss7|" subdir ")/") continue
	    paths[$0] = 1
	}
	close(command)
    }
    dirs = ""
    for (path in paths) {
	if (dirs == "") { dirs = path } else { dirs = dirs " " path }
    }
    if (dirs == "") { dirs = "`pwd`" } else { dirs = "`pwd`" " " dirs }
    print_vinfo(2, pfx "dirs = " dirs)
    h = 0; l = 0; u = 0
    command = "find " dirs " -name '*.ko' 2>/dev/null"
    while ((command | getline file) == 1) {
	name = file; sub(/^.*\//, "", name)
	if (!(name in names)) { names[name] = 1; u++ }
	if (file~"/" subdir "/") {
	    kversion = pathversion(file)
	    if (kversion && !(kversion in kversions)) { kversions[kversion] = 1; k++ }
	    weakmods[file] = kversion
	    if (system_command("test -L " file) == 0) {
		cmd = "readlink " file
		while ((cmd | getline) == 1) { module = $0 }
		close(cmd)
		weaklinks[file] = module
	    }
	    l++
	    if ((kversion,name) in weaknames && weaknames[kversion,name] != file)
	    { weaknames[kversion,name] = weaknames[kversion,name] "," file
	      print_error(pfx "conflict amoung updates for " name ", " weaknames[kversion,name]) }
	    { weaknames[kversion,name] = file }
	    print_vinfo(4, pfx "name = " name)
	    print_vinfo(4, pfx "vers = " kversion)
	    print_vinfo(4, pfx "file = " file)
	    print_vinfo(4, pfx "weak = " "yes")
	    print_vinfo(4, pfx "link = " module)
	} else {
	    kversion = pathversion(file)
	    if (!kversion) { kversion = fileversion(file) }
	    if (kversion && !(kversion in kversions)) { kversions[kversion] = 1; k++ }
	    modules[file] = kversion
	    subdirs[file] = pathsubdir(file)
	    h++
	    if ((kversion,name) in modnames && modnames[kverison,name] != file)
	    { modnames[kversion,name] = modnames[kversion,name] "," file
	      print_error(pfx "conflict amoung modules for " name ", " modnames[kversion,name]) }
	    { modnames[kversion,name] = file }
	    print_vinfo(4, pfx "name = " name)
	    print_vinfo(4, pfx "vers = " kversion)
	    print_vinfo(4, pfx "file = " file)
	    print_vinfo(4, pfx "weak = " "no")
	    print_vinfo(4, pfx "subd = " subdirs[file])
	}
	print_vmore(3, pfx sprintf("%03d modules; %03d links; %03d names; %02d kernels", h, l, u, k))
    }
    close(command)
    print_vinfo(2, pfx sprintf("%03d modules; %03d links; %03d names; %02d kernels", h, l, u, k))
    counts["hard"] = h
    counts["link"] = l
    counts["uniq"] = u
    counts["kern"] = k
    asorti(kversions,kernels)
    rpmsort(kernels,k)
    # Fill in the gaps between installed kernel module version.  That is, assign the more recent
    # installed kernel modules for kernels that do not have any modules of their own.  Smear them
    # one way and then the other to fill in the gaps.
    n = 0
    for (name in names) {
	module = ""
	for (k=counts["kern"];k>0;k--) { kversion = kernels[k]
	    if (module == "")
	    { if ( ((kversion,name) in modnames)) { module = modnames[kversion,name] } } else
	    { if (!((kversion,name) in modnames)) { modnames[kversion,name] = module } }
	}
	module = ""
	for (k=1;k<=counts["kern"];k++) { kversion = kernels[k]
	    if (module == "")
	    { if ( ((kversion,name) in modnames)) { module = modnames[kversion,name] } } else
	    { if (!((kversion,name) in modnames)) { modnames[kversion,name] = module } }
	}
	n++
    }
    for (k=1;k<=counts["kern"];k++) { kversion = kernels[k]
	print_debug(2,pfx "kversion = " kversion)
	for (name in names) {
	    if (!((kversion,name) in modnames))
		print_error(pfx sprintf("modname for (%s,%s) does not exist", kversion,name))
	    else
		print_debug(2,pfx sprintf("modname for (%s,%s) is %s", kversion,name,modnames[kversion,name]))
	}
    }
    return n
}
function readsysmap(kversion, file,
		    sysmaps, #global
		    pfx,fmt,n,sym,c,bads,d,maps) # syms, sysmaps
{
    # read the system map for kernel "kversion"
    pfx = "r: sysmap,    "
    fmt = "%04d maps, %04d bads, %04d dups"
    n = 0; c = 0; d = 0
    print_vinfo(2, pfx "file = " file)
    if (system_command("test -r " file) == 0) {
	print_vinfo(2, pfx sprintf(fmt, n, c, d))
	while ((getline < file) == 1) {
	    if (NF<3) continue
	    if (!($3 in maps)) {
		maps[$3] = $1
		n++
		print_vmore(2, pfx sprintf(fmt, n, c, d))
	    } else
	    if (maps[$3] != $1) {
		print_debug(3,pfx "conflicting add for " $3 " in " kversion)
		maps[$3] = $1
		bads[$3] = 1
		c++
		print_vmore(2, pfx sprintf(fmt, n, c, d))
	    } else {
		print_debug(3,pfx "duplicate add for " $3 " in " kversion)
		d++
		print_vmore(2, pfx sprintf(fmt, n, c, d))
	    }
	}
	close(file)
	for (sym in bads) { delete maps[sym]; n-- }
    } else {
	print_warns(pfx "file not found " file)
    }
    print_vinfo(2, pfx sprintf(fmt, n, c, d))
    for (sym in maps) {
	print_debug(6, pfx "(" kversion "," sym ") = " maps[sym])
	sysmaps[kversion,sym] = maps[sym]
    }
    return n
}
function readsymabi(kversion, file,
		    symvers, #global
		    pfx,n,command,sym,crc)
{
    pfx = "r: symabi,    "
    n = 0
    print_vinfo(2, pfx "file = " file)
    if (system_command("test -r " file) == 0) {
	if (file~/\.gz/)
	    command = "zcat " file
	else
	    command = "cat " file
	while ((command | getline) == 1) {
	    if (NF<4) continue
	    if ($2 != "vmlinux") continue
	    sym = $4; crc = $3
	    if (!((kversion,sym) in symvers)) {
		symvers[kversion,sym] = crc
		print_debug(5, pfx "ksym(" kversion ":" sym ") = " crc)
		n++
	    } else
	    if (symvers[kversion,sym] != crc) {
		print_error(pfx "conflicting crc for " sym " in " kversion)
		symvers[kversion,sym] = crc
	    } else {
		print_warns(pfx "duplicate crc for " sym " in " kversion)
	    }
	}
	close(command)
    } else {
	print_warns(pfx "no symbol versins for kernel " kversion ", file " file)
    }
    print_debug(1, pfx "syms " n)
    return n
}
function readsymver(kversion, file,
		    symvers, #global
		    pfx,n,command,sym,crc)
{
    pfx = "r: symver,    "
    n = 0
    print_vinfo(2, pfx "file = " file)
    if (system_command("test -r " file) == 0) {
	if (file~/\.gz/)
	    command = "zcat " file
	else
	    command = "cat " file
	while ((command | getline) == 1) {
	    if (NF<3) continue
	    if ($3 != "vmlinux") continue
	    sym = $2; crc = $1
	    if (!((kversion,sym) in symvers)) {
		symvers[kversion,sym] = crc
		print_debug(5, pfx "ksym(" kversion ":" sym ") = " crc)
		n++
	    } else
	    if (symvers[kversion,sym] != crc) {
		print_error(pfx "conflicting crc for " sym " in " kversion)
		symvers[kversion,sym] = crc
	    } else {
		print_warns(pfx "duplicate crc for " sym " in " kversion)
	    }
	}
	close(command)
    } else {
	print_warns(pfx "no symbol versions for kernel " kversion ", file " file)
    }
    print_debug(1, pfx "syms " n)
    return n
}
function readkernel(kversion,
		    sysmaps, symvers, #global
		    pfx,fmt,n,m,s,find,command,module,HEADER,string,char,sym,crc)
{
    pfx = "r: kernel,    "
    fmt = "%04d modules, %05d symbols"
    print_vinfo(2, pfx "version = " kversion)
    find = "find /lib/modules/" kversion "/kernel -type f -name '*.ko'"
    n = 0; m = 0; s = 0
    print_vinfo(2, pfx sprintf(fmt, m, s))
    while ((find | getline module) == 1) {
	command = "objdump -j __versions -s " module
	HEADER = 1; string = ""
	while ((command | getline) == 1) {
	    if (/^Contents of section/) {
		HEADER = 0
		continue
	    }
	    if (HEADER) {
		continue
	    }
	    sub(/^ .... /, ""); sub(/  .*$/, ""); gsub(/ /, "")
	    string = string $0
	    if (length(string) < 128)
		continue
	    sub(/(00)+$/, "",string)
	    crc = "0x" substr(string,7,2) substr(string,5,2) substr(string,3,2) substr(string,1,2)
	    sub(/^......../, "", string)
	    if (crc == "0x00000000")
	    { crc = "0x" substr(string,1,8); sub(/^......../,"",string) }
	    sub(/^00000000/, "", string)
	    sym = ""
	    while (string) {
		char = "0x" substr(string,1,2)
		sub(/^../, "", string)
		char = strtonum(char)
		if (32 <= char && char <= 126)
		    sym = sym sprintf("%c", char)
	    }
	    if (sym~/[^A-Za-z0-9_]/)
		print_error(pfx "ksym(" kversion ":" sym ") = " crc)
	    if (!((kversion,sym) in sysmaps)) {
		print_debug(5,pfx "(" kversion "," sym ") not in sysmaps")
		continue
	    }
	    if (!((kversion,"__kcrctab_"sym) in sysmaps)) {
		print_debug(5,pfx "(" kversion "," sym ") not exported by kernel")
		continue
	    }
	    if (!((kversion,sym) in symvers)) {
		symvers[kversion,sym] = crc
		print_debug(6, pfx "ksym(" kversion ":" sym ") = " crc)
		n++; s++
		print_vmore(2, pfx sprintf(fmt, m, s))
	    } else
	    if (symvers[kversion,sym] != crc) {
		print_error(pfx "conflicting crc for " sym " in " kversion)
		symvers[kversion,sym] = crc
	    }
	    # expect duplicates
	}
	close(command)
	m++
	print_vmore(2, pfx sprintf(fmt, m, s))
    }
    close(find)
    if (m != 0) print_vinfo(2, pfx sprintf(fmt, m, s))
    if (n == 0) print_warns(pfx "no symbol versions for kernel " kversion ", from kernel modules")
    if (m == 0) print_warns(pfx "no kernel  modules for kernel " kversion)
    return n
}
function getsysmap(kversion, sysmaps, sysmap,
		   pfx,n,file)
{
    pfx = "r: sysmap,    "
    n = 0
    print_vinfo(2, pfx "version = " kversion)
    if (kversion in sysmap) {
	n = sysmap[kversion]
    } else {
	file = values["sysmap"]
	gsub(/\$KVERSION/,kversion,file)
	gsub(/\$PACKAGE/,values["package"],file)
	if (values["basedir"] && system_command("test -r " values["basedir"] file) == 0)
	    file = values["basedir"] file
	else
	    file = values["rootdir"] file
	n = readsysmap(kversion, file, sysmaps)
	sysmap[kversion] = n
    }
    print_vinfo(2, pfx "syms " n)
    return n
}
# getsysver()
# There are three places to check: /boot/symvers-$kversion.gz, /lib/modules/$kversion/build/-
# Modules.symvers and /usr/src/openss7-*/$kversion/System.symvers.  If there are no files in these
# locations, they we are obtaining information for a Debian kernel for which our kernel modules were
# not built.  Therefore, there is only one remaining way to obtain the kernel symbol versions and
# that is to get them from the modules installed under kernel (assuming that they are all "used").
# When not all a "used" we simply have no idea.  We could perhaps check that at least the kernel
# series is correct.
#
function getsysver(kversion,
		   sysmaps, symvers, symver, #global
		   pfx,n,file)
{
    pfx = "r: sysver,    "
    n = 0
    print_vinfo(2, pfx "version = " kversion)
    if (kversion in symver) {
	n = symver[kversion]
    } else {
	if (n == 0 && "sysver" in values) {
	    file = values["sysver"]
	    gsub(/\$KVERSION/,kversion,file)
	    gsub(/\$PACKAGE/,values["package"],file)
	    if (values["basedir"] && system_command("test -r " values["basedir"] file) == 0)
		file = values["basedir"] file
	    else
		file = values["rootdir"] file
	    n = readsymver(kversion, file, symvers)
	}
	if (n == 0 && "symver" in values) {
	    file = values["symver"]
	    gsub(/\$KVERSION/,kversion,file)
	    gsub(/\$PACKAGE/,values["package"],file)
	    if (values["basedir"] && system_command("test -r " values["basedir"] file) == 0)
		file = values["basedir"] file
	    else
		file = values["rootdir"] file
	    n = readsymver(kversion, file, symvers)
	}
	if (n == 0 && "symabi" in values) {
	    file = values["symabi"]
	    gsub(/\$KVERSION/,kversion,file)
	    gsub(/\$PACKAGE/,values["package"],file)
	    if (values["basedir"] && system_command("test -r " values["basedir"] file) == 0)
		file = values["basedir"] file
	    else
		file = values["rootdir"] file
	    n = readsymabi(kversion, file, symvers)
	}
	if (n == 0) {
	    n = readkernel(kversion, sysmaps, symvers)
	}
	symver[kversion] = n
    }
    print_vinfo(2, pfx "syms " n)
    return n
}
function getsysinfo(kversion,
		    sysmaps, symvers, sysmap, symver, #global
		    pfx,n,e)
{
    pfx = "r: sysinfo,   "
    n = 0; e = 0
    print_vmore(3, pfx sprintf("%04d addrs,  %04d expts", n, e))
    n = getsysmap(kversion, sysmaps, sysmap)
    if (n == 0) { return n }
    print_vmore(3, pfx sprintf("%04d addrs,  %04d expts", n, e))
    e = getsysver(kversion, sysmaps, symvers, symver)
    print_vinfo(2, pfx sprintf("%04d addrs,  %04d expts", n, e))
    if (e == 0) { return e }
    return (n+e)
}
# getmodule()
# Get the provided and required symbols for a module and other module information.  A check is made
# to ensure that we have not already acquired the information.  There are four arrays: export
# contains symbols exported by this module, linked contains ripped symbols; wanted contains weak
# symbols; needed contains strong symbols.  A global modinfos array contains additional module
# information.
#
# need[] - required exported symbols
# want[] - required weak exported symbols
# link[] - required ripped symbols
# weak[] - required weak ripped symbols
#
function getmodule(module, export, linked, wanted, weaken, needed,
		   pfx,fmt,n,h,r,w,l,a,command,have,link,need,want,sym,crc,SECTION,string,char,line)
{
    pfx = "r: required,  "
    n = 0
    if (system_command("test -r " module) == 0) {
	h = 0; r = 0; w = 0; l = 0; a = 0
	fmt = "%04d needs,  %04d wants,  %04d links,  %04d weaks,  %s"
	print_vmore(3, pfx sprintf(fmt, r, w, l, a, module))
	command = "objdump -t -j '*ABS*' -j '*UND*' -j '__versions' -j '__weak_versions' -j '__weak_absolute' -j '.modinfo' -s " module
	SECTION = ""; string = ""
	while ((command | getline) == 1) {
	    if (/SYMBOL TABLE:/) {
		SECTION = "SYMBOL TABLE"
		continue
	    }
	    if (sub(/^Contents of section /,"")) {
		sub(/:.*$/, "")
		if (SECTION == "SYMBOL TABLE") {
		    print_vmore(3, pfx sprintf(fmt, r, w, l, a, module))
		    haves[module] = h
		    needs[module] = r; r = 0
		    wants[module] = w; w = 0
		    links[module] = l
		    weaks[module] = a
		    fmt = "%04d needed, %04d wanted, %04d linked, %04d weaken, %s"
		}
		SECTION = $0
		string = ""
		continue
	    }
	    if (SECTION == "SYMBOL TABLE") {
		if (NF < 4) continue
		if ($(NF-2) == "*ABS*") {
		    if (substr($0,length($1)+2,7) ~ /^g     [FO ]$/) {
			if (sub(/^_?__(weak_)?crc_/, "", $NF)) {
			    sub(/^00000000/, "", $1)
			    print_debug(5, pfx "symbol " $NF " is provided")
			    have[$NF] = "0x" $1; h++; n++
			} else {
			    # This might wind up in link[] or want[]
			    print_debug(5, pfx "symbol " $NF " is linked")
			    link[$NF] = $1; l++; n++
			}
		    } else {
			print_debug(5, pfx "symbol " $NF " is not interesting")
			continue
		    }
		} else
		if ($(NF-2) == "*UND*") {
		    if (substr($0,length($1)+3,1) == "w") {
			# This might wind up in link[] or want[]
			print_debug(5, pfx "symbol " $NF " is wanted")
			want[$NF] = ""; w++; n++
		    } else {
			print_debug(5, pfx "symbol " $NF " is needed")
			need[$NF] = ""; r++; n++
		    }
		} else {
		    print_debug(5, pfx "symbol " $NF " is not interesting")
		    continue
		}
	    } else
	    if (SECTION == "__versions" || SECTION == "__weak_versions" || SECTION == "__weak_absolute") {
		sub(/^ .... /, ""); sub(/  .*$/, ""); gsub(/ /, "")
		string = string $0
		if (length(string) < 128)
		    continue
		sub(/(00)+$/, "",string)
		crc = "0x" substr(string,7,2) substr(string,5,2) substr(string,3,2) substr(string,1,2)
		sub(/^......../, "", string)
		if (SECTION != "__weak_absolute") {
		    if (crc == "0x00000000")
		    { crc = "0x" substr(string,1,8); sub(/^......../,"",string) }
		}
		sub(/^00000000/, "", string)
		sym = ""
		while (string) {
		    char = "0x" substr(string,1,2)
		    sub(/^../, "", string)
		    char = strtonum(char)
		    if (32 <= char && char <= 126)
			sym = sym sprintf("%c", char)
		}
		if (sym in need) {
		    if (SECTION == "__versions"      )	{ print_debug(4, pfx "hard (" crc ") for needed " sym ", " module); need[sym] = crc; r++ }
		    if (SECTION == "__weak_versions" )	{ print_warns(   pfx "weak (" crc ") for needed " sym ", " module); need[sym] = crc; r++ }
		    if (SECTION == "__weak_absolute" )	{ print_error(   pfx "link (" crc ") for needed " sym ", " module); need[sym] = crc; r++ }
		    r++
		} else
		if (sym in want) {
		    add = "00000000"
		    if (SECTION == "__versions"      )	{ print_debug(4, pfx "hard (" crc ") for wanted " sym ", " module); need[sym] = crc; r++; delete want[sym]; w-- }
		    if (SECTION == "__weak_versions" )	{ print_debug(4, pfx "weak (" crc ") for wanted " sym ", " module); want[sym] = crc; w++ }
		    if (SECTION == "__weak_absolute" )	{ print_debug(4, pfx "link (" crc ") for wanted " sym ", " module); weak[sym] = add; a++; link[sym] = add; l++; delete want[sym]; w-- }
		} else
		if (sym in link) {
		    add = link[sym]
		    if (SECTION == "__versions"      )	{ print_error(   pfx "hard (" crc ") for linked " sym ", " module); link[sym] = add; l++ }
		    if (SECTION == "__weak_versions" )	{ print_debug(4, pfx "weak (" crc ") for linked " sym ", " module); weak[sym] = add; a++; want[sym] = crc; w++; delete link[sym]; l-- }
		    if (SECTION == "__weak_absolute" )	{ print_debug(4, pfx "link (" crc ") for linked " sym ", " module); weak[sym] = add; a++ }
		} else {
		    if (sym != "struct_module" && sym != "module_layout") {
			if (SECTION == "__weak_versions")
			{ print_debug(5, pfx "(" crc ") not usable " sym ", " module) } else
			{ print_warns(pfx "(" crc ") not usable " sym ", " module) }
		    }
		    continue
		}
	    } else
	    if (SECTION == ".modinfo") {
		sub(/^ .... /, ""); sub(/  .*$/, ""); gsub(/ /, "")
		string = string $0
		gsub(/^00(00)*/, "", string)
		while (string~/^(0[^0]|[^0]0|[^0][^0])*00/) {
		    line = ""
		    while (string) {
			char = "0x" substr(string,1,2)
			sub(/^../, "", string)
			char = strtonum(char)
			if (32 <= char && char <= 126)
			    line = line sprintf("%c", char)
			else
			if (char == 0) {
			    gsub(/^00(00)*/, "", string)
			    break
			}
		    }
		    if (match(line,/^[^=]*=/)) {
			label = substr(line,RSTART,RLENGTH-1);
			sub(/^[^=]*=/, "", line)
			if ((module,label) in modinfos)
			{ modinfos[module,label] = modinfos[module,label] "," line } else
			{ modinfos[module,label] = line }
		    }
		}
	    }
	    print_vmore(3, pfx sprintf(fmt, r, w, l, a, module))
	}
	close(command)
	print_vmore(2, pfx sprintf(fmt, r, w, l, a, module))
	if ((module,"vermagic") in modinfos) {
	    modfver[module] = modinfos[module,"vermagic"]; sub(/ .*$/, "", modfver[module])
	} else {
	    print_warns(pfx "no vermagic string found in module " module)
	}
	for (sym in have) {
	    crc = have[sym]
	    export[module,sym] = crc
	    if (module in exportsyms)
	    { exportsyms[module] = exportsyms[module] "," sym } else
	    { exportsyms[module] = sym }
	    if (!crc) print_warns(pfx sprintf("unversioned export %-20s in %s", sym, module))
	}
	for (sym in link) {
	    crc = link[sym]
	    linked[module,sym] = crc
	    if (sym in weak) { weaken[module,sym] = weak[sym] }
	    if (module in linkedsyms)
	    { linkedsyms[module] = linkedsyms[module] "," sym } else
	    { linkedsyms[module] = sym }
	    if (!crc) print_warns(pfx sprintf("unresolved  linked %-20s in %s", sym, module))
	}
	for (sym in want) {
	    crc = want[sym]
	    wanted[module,sym] = crc
	    if (sym in weak) { weaken[module,sym] = weak[sym] }
	    if (module in wantedsyms)
	    { wantedsyms[module] = wantedsyms[module] "," sym } else
	    { wantedsyms[module] = sym }
	    if (!crc) print_warns(pfx sprintf("unversioned wanted %-20s in %s", sym, module))
	}
	for (sym in need) {
	    crc = need[sym]
	    needed[module,sym] = crc
	    if (module in neededsyms)
	    { neededsyms[module] = neededsyms[module] "," sym } else
	    { neededsyms[module] = sym }
	    if (!crc) print_warns(pfx sprintf("unversioned needed %-20s in %s", sym, module))
	}
    } else {
	print_error(pfx "cannot read " module)
    }
    return n
}
# getmodinfo()
# Get the required symbols for each of the modules for a given kernel version.
function getmodinfo(kversion, modules, subdirs, modnames, names, weakmods, weaknames, weaklinks, modinfo, export, linked, wanted, weaken, needed,
		     pfx,n,w,i,m,name,module,pair,pairs,link)
{
    pfx = "r: modinfo,   "
    n = 0; w = 0; m = 0
    print_vmore(3, pfx sprintf("%04d symbols, %04d modules, %04d weakmods", n, m, w))
    for (name in names) {
	if (((kversion,name) in modnames) || ((kversion,name) in weaknames)) {
	    if ((kversion,name) in modnames) {
		module = modnames[kversion,name]
		if (module in modinfo)
		{ i = modinfo[module] } else
		{ i = getmodule(module, export, linked, wanted, weaken, needed); modinfo[module] = i }
		n = n + i
		m++
		print_vmore(3, pfx sprintf("%04d symbols, %04d modules, %04d weakmods", n, m, w))
	    }
	    if ((kversion,name) in weaknames) {
		module = weaknames[kversion,name]
		if (module in weaklinks) { module = weaklinks[module] }
		if (module in modinfo)
		{ i = modinfo[module] } else
		{ i = getmodule(module, export, linked, wanted, weaken, needed); modinfo[module] = i }
		n = n + i
		w++
		print_vmore(3, pfx sprintf("%04d symbols, %04d modules, %04d weakmods", n, m, w))
	    } else {
		print_debug(5,pfx "no weakmod name for " kversion "," name)
	    }
	} else {
	    print_error(pfx "no module name for " kversion "," name)
	}
    }
    print_vinfo(2, pfx sprintf("%04d symbols, %04d modules, %04d weakmods", n, m, w))
    if (m == 0) {
	for (pair in modnames) {
	    module = modnames[pair]
	    link = ""
	    if (!(module in modules)) {
		print_error(pfx "module in modnames but not modules, " module)
	    } else {
		split(pair,pairs,SUBSEP)
		print_debug(4, pfx sprintf("kversion = %-24s, name = %-24s, version = %-24s, file = %s, link = %s", pairs[1], pairs[2], modules[module], module, link))
	    }
	}
    }
    if (w == 0) {
	for (pair in weaknames) {
	    module = weaknames[pair]
	    if (module in weaklinks) { link = weaklinks[module] } else { link = "" }
	    if (!(module in weakmods)) {
		print_error(pfx "module in weaknames but not weakmods, " module)
	    } else {
		split(pair,pairs,SUBSEP)
		print_debug(4, pfx sprintf("kversion = %-24s, name = %-24s, version = %-24s, file = %s, link = %s", pairs[1], pairs[2], weakmods[module], module, link))
	    }
	}
    }
    return n
}
function getresolve(kversion, kver, sysmaps, symvers, modules, subdirs, modnames, weaknames,
		    names, export, linked, needed, wanted, weaken, creates, unlinks, changes,
		    relinks, removes, retains, inserts, unneeded,
		    pfx,n,ksyms,pair,pairs,ver,name,module,sym,syms,s,add,crc,d,deleted,resolve,relink)
{
    pfx = "p: resolve,   "
    # map symbols exported by modules in the module set
    n = 0
    print_vmore(3, pfx sprintf("%-40s", "mapping module symbol exports..."))
    for (name in names) {
	module = modnames[kver,name]
	resolve[name] = module
	if (!(module in exportsyms)) continue
	split(exportsyms[module],syms,/,/)
	for (s in syms) { sym = syms[s]
	    crc = export[module,sym]
	    ksyms[sym,crc] = module
	    n++
	}
    }
    # test solution
    print_vmore(3, pfx sprintf("%-40s", "resolving ripped symbols..."))
    d = 0
    for (name in resolve) {
	module = resolve[name]
	if ((module in deleted)) continue
	if (!(module in linkedsyms)) continue
	split(linkedsyms[module],syms,/,/)
	for (s in syms) { sym = syms[s]
	    add = linked[module,sym]
	    if ((kversion,sym) in sysmaps) {
		if (sysmaps[kversion,sym] == add) {
		    print_debug(4, sym " provided by vmlinux-" kversion)
		    continue
		} else
		if ((module,sym) in weaken) {
		    print_debug(4, sym " not provided by vmlinux-" kversion)
		    continue
		} else {
		    print_debug(4, sym " relinked to vmlinux-" kversion)
		    relink[name] = module
		    continue
		}
	    } else
	    if ((module,sym) in weaken) {
		print_debug(4, sym " not provided by vmlinux-" kversion)
		continue
	    } else {
		print_debug(2,pfx "cannot resolve linked " sym " from " name)
		if ((module in deleted)) continue
		deleted[module] = name
		d++
	    }
	}
    }
    do {
	print_vmore(3, pfx sprintf("%-40s", "resolving exported symbols..."))
	d = 0
	for (name in resolve) {
	    print_vmore(3, pfx sprintf("%-40s", "resolving " name "..."))
	    module = resolve[name]
	    if ((module in deleted)) continue
	    if (!(module in neededsyms)) continue
	    split(neededsyms[module],syms,/,/)
	    for (s in syms) { sym = syms[s]
		crc = needed[module,sym]
		if ((kversion,sym) in symvers) {
		    if (symvers[kversion,sym] == crc) {
			print_debug(4, sym " exported by vmlinux-" kversion)
			continue
		    }
		    print_debug(2,pfx "ksyms(" kversion ":" sym ") = " crc " != " symvers[kversion,sym])
		} else
		if ((sym,crc) in ksyms) {
		    if (!(ksyms[sym,crc] in deleted)) {
			print_debug(4, sym " exported by " ksyms[sym,crc])
			continue
		    }
		    print_debug(2,pfx "ksyms(" kversion ":" sym ") = " crc ", in deleted module " ksyms[sym,crc])
		} else {
		    if ((kversion,sym) in sysmaps) {
			print_debug(2, sym " provided by vmlinux-" kversion)
		    } else {
			print_warns(pfx "cannot resolve needed " sym " from " name)
		    }
		}
		if ((module in deleted)) continue
		print_debug(1,pfx "deleting module " name " from solution " kver)
		deleted[module] = name
		d++
	    }
	}
    } while (d)
    # this is really just for reporting
    for (name in resolve) {
	print_vmore(3, pfx sprintf("%-40s", "weak resolving " name "..."))
	module = resolve[name]
	if ((module in deleted)) continue
	if (!(module in wantedsyms)) continue
	split(wantedsyms[module],syms,/,/)
	for (s in syms) { sym = syms[s]
	    crc = wanted[module,sym]
	    if ((kversion,sym) in symvers) {
		if (symvers[kversion,sym] == crc) {
		    print_debug(4, sym " provided by vmlinux-" kversion)
		    continue
		}
		print_debug(2,pfx "ksyms(" kversion ":" sym ") = " crc " != " symvers[kversion,sym])
	    } else
	    if ((sym,crc) in ksyms) {
		if (!(ksyms[sym,crc] in deleted)) {
		    print_debug(4, sym " provided by " ksyms[sym,crc])
		    continue
		}
		print_debug(2,pfx "ksyms(" kversion ":" sym ") = " crc ", in deleted module " ksyms[sym,crc])
	    } else {
		if ((kversion,sym) in sysmaps) {
		    print_debug(2, sym " provided by vmlinux-" kversion)
		} else {
		    print_warns(pfx "cannot resolve wanted " sym " from " name)
		}
	    }
	}
    }
    print_vinfo(2, pfx sprintf("%-40s", "...done"))
    d = 0
    for (name in resolve) {
	module = resolve[name]
	if (modules[module] == kversion) {
	    if (kver in inserts)
	    { inserts[kver] = inserts[kver] "," name } else
	    { inserts[kver] = name }
	} else
	if (module in deleted) {
	    if ((kversion,name) in weaknames) {
		file = weaknames[kversion,name]
		if (file ~/,/) {
		    unneeded[kversion,name] = 1
		    split(file,files,/,/)
		    file = files[1]
		}
		if (file in weaklinks) {
		    # will be removing a symbolic link
		    if (kver in unlinks)
		    { unlinks[kver] = unlinks[kver] "," name } else
		    { unlinks[kver] = name }
		    d++
		} else
		if (file in weakmods) {
		    # will be removing a relinked module
		    if (kver in unlinks)
		    { unlinks[kver] = unlinks[kver] "," name } else
		    { unlinks[kver] = name }
		    d++
		}
	    } else {
		if (kver in removes)
		{ removes[kver] = removes[kver] "," name } else
		{ removes[kver] = name }
		d++
	    }
	} else {
	    if ((kversion,name) in weaknames) {
		file = weaknames[kversion,name]
		if (file ~ /,/) {
		    unneeded[kversion,name] = 1
		    split(file,files,/,/)
		    file = files[1]
		}
		if (file in weaklinks) {
		    if (weaklinks[file] == module || system("test " module " -ef " file) == 0) {
			if (!(name in relink)) {
			    # will be keeping a symbolic link
			    if (kver in retains)
			    { retains[kver] = retains[kver] "," name } else
			    { retains[kver] = name }
			} else {
			    # will be relinking
			    if (kver in relinks)
			    { relinks[kver] = relinks[kver] "," name } else
			    { relinks[kver] = name }
			}
		    } else {
			# will be overwritting a symbolic link
			if (kver in changes)
			{ changes[kver] = changes[kver] "," name } else
			{ changes[kver] = name }
			if (name in relink) {
			    # and relinking it
			    if (kver in relinks)
			    { relinks[kver] = relinks[kver] "," name } else
			    { relinks[kver] = name }
			}
		    }
		} else
		if (file in weakmods) {
		    if (modinfomatches(module, file) || system("test " module " -ef " file) == 0) {
			if (!(name in relink)) {
			    # will be keeping a relinked module
			    if (kver in retains)
			    { retains[kver] = retains[kver] "," name } else
			    { retains[kver] = name }
			} else {
			    # need to overwrite it and relink it
			    if (kver in changes)
			    { changes[kver] = changes[kver] "," name } else
			    { changes[kver] = name }
			    if (kver in relinks)
			    { relinks[kver] = relinks[kver] "," name } else
			    { relinks[kver] = name }
			}
		    } else {
			# will be overwritting a relinked module
			if (kver in changes)
			{ changes[kver] = changes[kver] "," name } else
			{ changes[kver] = name }
			if (name in relink) {
			    # and relinking it
			    if (kver in relinks)
			    { relinks[kver] = relinks[kver] "," name } else
			    { relinks[kver] = name }
			}
		    }
		}
	    } else {
		if ("weakdir" in values) {
		    if (values["weakdir"] ~ /^\//)
		    { file = values["weakdir"] } else
		    { file = values["basedir"] "/lib/modules/" kversion "/"   values["weakdir"] } 
		} else
		    { file = values["basedir"] "/lib/modules/" kversion "/" defaults["weakdir"] }
		gsub(/\$KVERSION/,kversion,file)
		gsub(/\$PACKAGE/,values["package"],file)
		file = file "/" subdirs[module] "/" name
		if (kver in creates)
		{ creates[kver] = creates[kver] "," name } else
		{ creates[kver] = name }
		if (name in relink) {
		    # and relinking it
		    if (kver in relinks)
		    { relinks[kver] = relinks[kver] "," name } else
		    { relinks[kver] = name }
		}
	    }
	}
    }
    for (pair in weaknames) {
	if (split(pair,pairs,SUBSEP) != 2) continue
	if (pairs[1] != kversion) continue
	if (weaknames[pair]~/,/) {
	    unneeded[pair] = 1
	    continue
	}
	name = pairs[2]
	if (kver in inserts && ","inserts[kver]"," ~ ","name",") {
	    unneeded[pair] = 1
	}
    }
    return d
}
function readloaded(kversion,
		    file,loaded)
{
    loaded = ""
    file = "/proc/modules"
    while ((getline < file) == 1) {
	if (loaded) { loaded = $1 "," loaded } else { loaded = $1 }
    }
    close(file)
    return loaded
}
function print_action(action, file, prep, kversion,
		      module,modver)
{
    module = file; gsub(/^.*\//, "", module)
    modver = file; if (sub(/^.*\/lib\/modules\//, "", modver)) { sub(/\/.*$/, "", modver) } else { sub(/\/[^\/]*$/, "", modver) }
    print_vinfo(1, sprintf("%-10s %-28s %-4s %-28s from %s", action, module, prep, kversion, modver))
}
function doit(cmd,
	      loaded,name,subdir)
{
    if (values["dry-run"]) {
	print_vinfo(2, "x: execute,   " cmd)
	return 0
    }
    return system_command(cmd)
}
function removefromlist(what, array, place) {
    if (what == array[place]) { delete array[place]; return 1 }
    if (sub("^"what",",  "", array[place])) { return 1 }
    if (sub(","what"$",  "", array[place])) { return 1 }
    if (sub(","what",", ",", array[place])) { return 1 }
    return 0
}
function createlinks(kversion, kver, name,
		     modnames, weaknames, weaklinks, weakmods, subdirs, dirs, #global
		     pfx,module,file,files,n,j)
{
    pfx = "w: create,    "
    if ((kver,name) in modnames) {
	module = modnames[kver,name]
	if ("weakdir" in values)
	{ if (values["weakdir"] ~ /^\//)
	{ file = values["weakdir"] } else
	{ file = values["basedir"] "/lib/modules/" kversion "/"   values["weakdir"] } } else
	{ file = values["basedir"] "/lib/modules/" kversion "/" defaults["weakdir"] }
	gsub(/\$KVERSION/,kversion,file)
	gsub(/\$PACKAGE/,values["package"],file)
	file = file "/" subdirs[module]
	if (!(file in dirs)) {
	    if (system_command("test -d " file) != 0)
		doit("mkdir -p " file)
	    dirs[file] = 1
	}
	file = file "/" name
	print_action("adding", module, " to ", kversion)
	doit("ln -sf " module " " file)
	# this is a correction to internal data structures
	weakmods[file] = kversion # FIXME
	weaklinks[file] = module
	if ((kversion,name) in weaknames && weaknames[kversion,name] != file)
	{ weaknames[kversion,name] = weaknames[kversion,name] "," file
	  print_error(pfx "conflict amoung updates for " name ", " weaknames[kversion,name]) }
	{ weaknames[kversion,name] = file }
    } else {
	print_error(pfx, "no modname for " kver ":" name)
    }
}
function removelinks(kversion, name,
		     weaknames, weaklinks, weakmods, #global
		     pfx,file,module,files,j)
{
    pfx = "w: unlink,    "
    if ((kversion,name) in weaknames) {
	file = weaknames[kversion,name]
	if (split(file,files,/,/)) {
	    for (j in files) { file = files[j]
		print_action("removing", file, "from", kversion)
		doit("rm -f -- " file)
		if (file in weaklinks)
		    delete weaklinks[file]
		if (file in weakmods)
		    delete weakmods[file]
	    }
	}
	delete weaknames[kversion,name]
    } else {
	print_error(pfx, "no weakname for " kversion ":" name)
    }
}
function changelinks(kversion, kver, name,
		     modnames, weaknames, weaklinks, #global
		     pfx,module,file)
{
    pfx = "w: change,    "
    if ((kver,name) in modnames) {
	module = modnames[kver,name]
	if ((kversion,name) in weaknames) {
	    file = weaknames[kversion,name]
	    doit("ln -sf " module " " file)
	    # this is a correction to internal data structures
	    weakmods[file] = kversion # FIXME
	    weaklinks[file] = module
	    if ((kversion, name) in weaknames && weaknames[kversion,name] != file)
	    { weaknames[kversion,name] = weaknames[kversion,name] "," file
	      print_error(pfx "conflict amoung updates for " name ", " weaknames[kversion,name]) }
	    { weaknames[kversion,name] = file }
	} else {
	    print_error(pfx, "no weakname for " kversion ":" name)
	}
    } else {
	print_error(pfx, "no modname for " kver ":" name)
    }
}
function relinklinks(kversion, kver, name,
		     modnames, weaknames, weaklinks, #global
		     pfx,module,file)
{
    pfx = "w: relink,    "
    if ((kver,name) in modnames) {
	module = modnames[kver,name]
	if ((kversion,name) in weaknames) {
	    file = weaknames[kversion,name]  # note that createlinks created this entry
	    # FIXME
	    # FIXME
	    # FIXME
	    # FIXME
	    # FIXME
	    # FIXME
	} else {
	    print_error(pfx, "no weakname for " kversion ":" name)
	}
    } else {
	print_error(pfx, "no modname for " kver ":" name)
    }
}

function modinfomatch(module1, module2, info,		item1, item2)
{
    if ((module1,info) in modinfos) { item1 = modinfos[module1,info] } else { item1 = "" }
    if ((module2,info) in modinfos) { item2 = modinfos[module2,info] } else { item2 = "" }
    if (item1 == item2) { return 1 } else {
	print_warns("t: infomatch, \"" info "\" does not match between " module1 " and " module2)
	print_wmore("t: infomatch, \"" info "\" '" item1 "' does not match '" item2 "'")
	return 0
    }
}
function modinfomatches(module1, module2,		result)
{
    if (!modinfomatch(module1, module2, "vermagic"   )) { return 0 }
    if (!modinfomatch(module1, module2, "version"    )) { return 0 }
    if (!modinfomatch(module1, module2, "srcversion" )) { return 0 }
    if (!modinfomatch(module1, module2, "license"    )) { return 0 }
    if (!modinfomatch(module1, module2, "description")) { return 0 }
    if (!modinfomatch(module1, module2, "author"     )) { return 0 }
    return 1
}
function chcksolution(kversion, kver, creates, unlinks, changes, relinks, removes, retains, inserts, unneeded,
		      modules, subdirs, modnames, weakmods, weaklinks, weaknames, #global
		      pfx,fmt,loaded,n,labels,i,name,created,removed,changed,altered)
{
    pfx = "w: checking,  "
    if (!kver) {
	print_warns(pfx "no solution for " kversion)
	return 0
    }
    print_vinfo(2, pfx "solution for " kversion " is " kver)
    fmt = pfx "solution for " kversion " %-7s %3d %s"
    if (kver in creates) {
	n = split(creates[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "creates", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " creates " labels[i])
    }
    if (kver in unlinks) {
	n = split(unlinks[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "unlinks", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " unlinks " labels[i])
    }
    if (kver in changes) {
	n = split(changes[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "changes", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " changes " labels[i])
    }
    if (kver in relinks) {
	n = split(relinks[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "relinks", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " relinks " labels[i])
    }
    if (kver in removes) {
	n = split(removes[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "removes", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " removes " labels[i])
    }
    if (kver in retains) {
	n = split(retains[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "retains", n, "links"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " retains " labels[i])
    }
    if (kver in inserts) {
	n = split(inserts[kver],labels,/,/)
	print_vinfo(2, sprintf(fmt, "inserts", n, "modules"))
	for(i=1;i<=n;i++) print_vinfo(3,pfx "solution for " kversion " inserts " labels[i])
    }
    if (kversion == krunning) {
	if (!(kver in creates) && !(kver in unlinks) && !(kver in changes) && !(kver in relinks) && !(kversion in uneeded)) {
	    print_vinfo(2, pfx "solution for " kversion " is no change")
	    return 1
	}
	altered = 0
	if (values["preserve"]) {
	    # refuse to change anything for a loaded kernel module
	    loaded = readloaded(kversion)
	    n = split(loaded, labels, /,/)
	    for (i=1;i<=n;i++) { name = labels[i] ".ko"
		if (kver in creates && ","creates[kver]"," ~ ","name",") {
		    print_warns(pfx "not creating link for loaded module " name)
		    altered = 1
		}
		if (kver in unlinks && ","unlinks[kver]"," ~ ","name",") {
		    print_warns(pfx "not removing link for loaded module " name)
		    altered = 1
		}
		if (kver in changes && ","changes[kver]"," ~ ","name",") {
		    print_warns(pfx "not changing link for loaded module " name)
		    altered = 1
		}
		if (kver in relinks && ","relinks[kver]"," ~ ","name",") {
		    print_warns(pfx "not relinkin link for loaded module " name)
		    altered = 1
		}
		if ((kversion,name) in unneeded) {
		    print_warns(pfx "not deleting link for loaded module " name)
		    altered = 1
		}
	    }
	}
	if (!values[overwrite]) {
	    # refuse to overwrite an existing link
	    if (kver in changes) {
		split(changes[kver],labels,/,/)
		for (i in labels) { name = labels[i]
		    print_warns(pfx "not overwritting link for module " name)
		    altered = 1
		}
	    }
	    if (kver in relinks) {
		split(relinks[kver],labels,/,/)
		for (i in labels) { name = labels[i]
		    print_warns(pfx "not overwritting link for module " name)
		    altered = 1
		}
	    }
	}
	if (altered) return 0
    }
    return 1
}
function makesolution(kversion, kver, creates, unlinks, changes, relinks, removes, retains, inserts,
		      modules, subdirs, modnames, weakmods, weaklinks, weaknames, #global
		      pfx,fmt,c,r,a,l,labels,i,name,dirs,pair,pairs)
{
    pfx = "w: solution,  "
    fmt = pfx "sym links: %04d created, %04d removed, %04d changed, %04d relinked"
    c = 0; r = 0; a = 0; l = 0
    if (kver)
	print_vinfo(2, pfx "solution = (none)")
    else
	print_vinfo(2, pfx "solution = " kver)
    print_vinfo(2, sprintf(fmt, c, r, a, l))
    # create symbolic links
    if (kver && kver in creates) {
	if (split(creates[kver],labels,/,/)) {
	    for (i in labels) { name = labels[i]
		createlinks(kversion, kver, name, modnames, weaknames, weaklinks, weakmods, subdirs,
			    dirs)
		c++
		print_vmore(3, sprintf(fmt, c, r, a, l))
	    }
	}
    }
    print_vmore(2, sprintf(fmt, c, r, a, l))
    # remove symbolic links to old modules
    if (kver && kver in unlinks) {
	if (split(unlinks[kver],labels,/,/)) {
	    for (i in labels) { name = labels[i]
		removelinks(kversion, name, weaknames, weaklinks, weakmods)
		r++
		print_vmore(3, sprintf(fmt, c, r, a, l))
	    }
	}
    }
    print_vmore(2, sprintf(fmt, c, r, a, l))
    # change symbolic links
    if (kver && kver in changes) {
	if (split(changes[kver],labels,/,/)) {
	    for (i in labels) { name = labels[i]
		changelinks(kversion, kver, name, modnames, weaknames, weaklinks)
		a++
		print_vmore(3, sprintf(fmt, c, r, a, l))
	    }
	}
    }
    print_vmore(2, sprintf(fmt, c, r, a, l))
    # relink modules
    if (kver && kver in relinks) {
	if (split(changes[kver],labels,/,/)) {
	    for (i in labels) { name = labels[i]
		relinklinks(kversion, kver, name, modnames, weaknames, weaklinks)
		l++
		print_vmore(3, sprintf(fmt, c, r, a, l))
	}
    }
    print_vmore(2, sprintf(fmt, c, r, a, l))
    # remove symbolic links to modules installed for this kernel
    for (pair in weaknames) {
	if (split(pair,pairs,SUBSEP) != 2) continue
	if (pairs[1] != kversion) continue
	name = pairs[2]
	if (kver && kver in creates && ","creates[kver]"," ~ ","name",") continue
	if (kver && kver in unlinks && ","unlinks[kver]"," ~ ","name",") continue
	if (kver && kver in changes && ","changes[kver]"," ~ ","name",") continue
	removelinks(kversion, name, weaknames, weaklinks, weakmods)
	r++
	print_vmore(3, sprintf(fmt, c, r, a, l))
    }
    print_vinfo(2, sprintf(fmt, c, r, a, l))
    return (c+r+a)
}
function modlink(kversion,sysmaps, symvers, subdirs, modnames, names, weaknames, weaklinks, linked, wanted, weaken, reloads,
		  pfx,n,m,name,module,sym,syms,s,add,crc,old)
{
    pfx = "w: modlink,   "
    print_vmore(3, pfx "relinking...")
    n = 0; m = 0
    for (name in names) {
	if ((kversion,name) in modnames) {
	    module = modnames[kversion,name]
	} else {
	    print_error(pfx sprintf("no modname for (%s,%s)", kversion,name))
	    continue
	}
	if ((kversion,name) in weaknames) {
	    file = weaknames[kversion,name]
	    if (file in weaklinks) {
		module = weaklinks[file]
	    }
	} else  {
	    print_debug(2, pfx "not weak updated " module)
	    continue
	}
	if (!(module in linkedsyms) && !(module in wantedsyms)) {
	    print_debug(2, pfx "no linked or wanted symbols in " module)
	    continue
	}
	if (module in linkedsyms) {
	    split(linkedsyms[module],syms,/,/)
	    for (s in syms) { sym = syms[s]
		if (!((module,sym) in linked)) {
		    print_error(pfx sprintf("%s in linksysms, but no (%s,%s) in linked!", sym, module,sym))
		    continue
		}
		add = linked[module,sym]
		if ((kversion,sym) in sysmaps) {
		    if (sysmaps[kversion,sym] == add) {
			print_debug(2, pfx "correct address for " sym)
			continue
		    }
		    old = add
		    add = sysmaps[kversion,sym]
		    print_debug(2, pfx sprintf("relink %-24s old = %-18s, %-40s", sym, old, module))
		    print_debug(2, pfx sprintf("relink %-24s new = %-18s, %-40s", sym, add, ""))
		} else {
		    if ((module,sym) in weaken && weaken[module,sym]~/^00*$/) {
			print_debug(2, pfx "correct address for " sym)
			continue
		    }
		    print_error(pfx kversion " does not provide an address for " sym)
		    add = "00000000"
		}
		n++
		print_vmore(3, pfx sprintf("%-12s %03d relinked of %03d %-40s", "addresses", n, m, sym))
		#linked[module,sym] = add
		if (file in reloads)
		{ reloads[file] = reloads[file] "\n\t" sym " = 0x" add ";" } else
		{ reloads[file] = "\t" sym " = 0x" add ";" }
	    }
	}
	if (module in wantedsyms) {
	    split(wantedsyms[module],syms,/,/)
	    for (s in syms) { sym = syms[s]
		if (!((module,sym) in wanted)) {
		    print_error(pfx sprintf("%s in linksysms, but no (%s,%s) in wanted!", sym, module,sym))
		    continue
		}
		crc = wanted[module,sym]
		if ((kversion,sym) in symvers) {
		    if (symvers[kversion,sym] != crc) {
			add = "00000000"
			if (!((module,sym) in weaken) || weaken[module,sym]~/^00*$/) {
			    print_debug(2, pfx "wrong crc + correct address (" add "), not relinking " sym)
			    continue
			}
			print_debug(2, pfx "wrong crc + wrong address (" weaken[module,sym] "), relinking to (" add ") for " sym)
		    } else
		    if ((kversion,sym) in sysmaps) {
			add = sysmaps[kversion,sym]
			if ((module,sym) in weaken && sysmaps[kversion,sym] == weaken[module,sym]) {
			    print_debug(2, pfx "correct crc + in maps + correct address (" weaken[module,sym] "), not relinking" sym)
			    continue
			}
			print_debug(2, pfx "correct crc + in maps + wrong address (" weaken[module,sym] "), relinking to (" add ") for " sym)
		    } else {
			add = "00000000"
			if (!((module,sym) in weaken) || weak[module,sym]~/^00*$/) {
			    print_debug(2, pfx "correct crc + not in maps + correct address (" add "), not relinking " sym)
			    continue
			}
			print_debug(2, pfx, "correct crc + not in maps + wrong address (" weaken[module,sym] "), relinking to (" add ") for " sym)
		    }
		} else {
		    if ((kversion,sym) in sysmaps) {
			add = sysmaps[kversion,sym]
			if ((module,sym) in weaken && sysmaps[kversion,sym] == weaken[module,sym]) {
			    print_debug(2, pfx "no crc + in maps + correct address (" weaken[module,sym] "), not relinking" sym)
			    continue
			}
			print_debug(2, pfx "no crc + in maps + wrong address (" weaken[module,sym] "), relinking to (" add ") for " sym)
		    } else {
			add = "00000000"
			if (!((module,sym) in weaken) || weaken[module,sym]~/^00*$/) {
			    print_debug(2, pfx "no crc + not in maps + correct address (" add "), not relinking " sym)
			    continue
			}
			print_debug(2, pfx "no crc + not in maps + wrong address (" weaken[module,sym] "), relinking to (" add ") for " sym)
		    }
		}
		print_debug(2, pfx sprintf("relink %-24s add = %-18s, %-40s", sym, add, module))
		n++
		print_vmore(3, pfx sprintf("%-12s %03d prelinks of %03d %-40s", "addresses", n, m, sym))
		if (file in reloads)
		{ reloads[file] = reloads[file] "\n\t" sym " = 0x" add ";" } else
		{ reloads[file] = "\t" sym " = 0x" add ";" }
	    }
	}
    }
}
function modload(kversion, symbols, weakmod, module,
		pfx,script,pair,pairs,sym,add,file,text)
{
    pfx = "w: modload,   "
    script = me "." PROCINFO["pid"] ".lds"
    text = "SECTIONS\n{\n" symbols "\n}"
    print text > script
    print_debug(3,pfx gensub(/\n/, "\n" me ": D: " pfx, "g", text))
    close(script)
    file = weakmod; sub(/\/[^\/]*$/, "/", file)
    file = file me "." PROCINFO["pid"] ".ko"
    print_action("relinking", module, " in ", kversion)
    if (doit("ld -r -o " file " " weakmod " " script) == 0) {
	doit("mv -f -- " file " " weakmod)
    } else {
	print_error(pfx "relinking failed for " weakmod)
	print_action("removing", module, "from", kversion)
	doit("rm -f -- " file " " weakmod)
    }
    system_command("rm -f -- " script)
}
function testdepmod(			pfx,command,result)
{
    pfx = "t: depmod,    "
    if (!("depmodx" in values)) {
	result = 0
	command = "/sbin/depmod --help 2>&1"
	while ((command | getline) == 1) { if (/[[:space:]]-E[[:space:]]/) { result = 1 } }
	close(command)
	if (result) {
	    values["depmodx"] = 1
	    print_vinfo(2, pfx "depmod supports -E option")
	} else {
	    values["depmodx"] = 0
	    print_vinfo(2, pfx "depmod does not support -E option")
	}
    }
}
function testwstyle(			pfx,command,result)
{
    pfx = "t: wstyle,    "
    if (!("style" in values) || !values["style"]) {
	if (system_command("test -r /usr/lib/module-init-tools/weak-modules2") == 0) {
	    values["style"] = "suse11"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "weak-updates" }
	} else
	if (system_command("test -r /usr/lib/module-init-tools/weak-modules") == 0) {
	    values["style"] = "suse10"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "weak-updates" }
	} else
	if (system_command("test -r /sbin/weak-modules") == 0) {
	    values["style"] = "redhat"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "weak-updates" }
	} else
	if (system_command("test -r /boot/abi-" krunning) == 0) {
	    values["style"] = "ubuntu"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "updates" }
	} else {
	    values["style"] = "debian"
	    if (!("weakdir" in values) || values["weakdir"] == defaults["weakdir"])
	    { values["weakdir"] = "updates" }
	}
    } else
    if (values["style"] !~ /^(debian|redhat|suse10|suse11)$/) {
	print_error(pfx "style is '" values["style"] "' but must be one of {debian|redhat|suse10|suse11}")
	usage(stderr)
	exit 2
    }
}
function dodepmod(kversion,		command,file) {
    command = "/sbin/depmod -a"
    if (values["basedir"]) {
	command = command " -b " values["basedir"]
    }
    if (values["depmodx"]) {
	file = values["sysver"]; gsub(/\$KVERSION/,kversion,file); gsub(/\$PACKAGE/,values["package"],file)
	if (values["basedir"] && system_command("test -r " values["basedir"] file) == 0)
	    command = command " -E " values["basedir"] file
	else if (system_command("test -r " values["rootdir"] file) == 0)
	    command = command " -E " values["rootdir"] file
	else if (system_command("test -r System.symvers") == 0)
	    command = command " -E System.symvers"
	else {
	    file = values["sysmap"]; gsub(/\$KVERSION/,kversion,file); gsub(/\$PACKAGE/,values["package"],file)
	    if (values["basedir"] && system_command("test -r " values["basedir"] file) == 0)
		command = command " -e -F " values["basedir"] file
	    else if (system_command("test -r " values["rootdir"] file) == 0)
		command = command " -e -F " values["rootdir"] file
	}
    } else {
	file = values["sysmap"]; gsub(/\$KVERSION/,kversion,file); gsub(/\$PACKAGE/,values["package"],file)
	if (values["basedir"] && system_command("test -r " values["basedir"] file) == 0)
	    command = command " -e -F " values["basedir"] file
	else if (system_command("test -r " values["rootdir"] file) == 0)
	    command = command " -e -F " values["rootdir"] file
    }
    command = command " " kversion
    doit(command)
}
function remove_kernel(kversion,	pfx,dir)
{
    pfx = "p: rmvkernel, "
    print_debug(1, pfx "kversion = " kversion)
    if ( "weakdir" in values) {
	if (values["weakdir"]~/^\//) dir = values["weakdir"]
	else dir = values["basedir"] "/lib/modules/$KVERSION/"   values["weakdir"]
    }   else dir = values["basedir"] "/lib/modules/$KVERSION/" defaults["weakdir"]
    gsub(/\$KVERSION/,kversion,dir)
    gsub(/\$PACKAGE/,values["package"],dir)
    doit("rm -fr -- " dir)
}
function link_kernel(kversion,
		     counts, kernels, #global
		     sysmaps, sysmap, symvers, symver, #global
		     modules, subdirs, modnames, names, modinfo, export, linked, wanted, weaken, needed, #global
		     weakmods, weaklinks, weaknames, #global
		     pfx,n,name,weakmod,module,reloads)
{
    pfx = "p: lnkkernel, "
    print_debug(1, pfx "kversion = " kversion)
    if (getsysinfo(kversion, sysmaps, symvers, sysmap, symver) == 0)
	return
    getmodinfo(kversion, modules, subdirs, modnames, names, weakmods, weaknames, weaklinks, modinfo, export, linked, wanted, weaken, needed)
    modlink(kversion, sysmaps, symvers, subdirs, modnames, names, weaknames, weaklinks, linked, wanted, weaken, reloads)
    n = 0
    print_vmore(3,pfx "relinking...")
    for (name in names) {
	if ((kversion,name) in weaknames) {
	    weakmod = weaknames[kversion,name]
	    if (weakmod in reloads) {
		if (weakmod in weaklinks) { module = weaklinks[weakmod] } else { module = weakmod }
		modload(kversion, reloads[weakmod], weakmod, module)
		n++
		print_vmore(3,pfx sprintf("%-12s %03d %-40s", "modules", n, module))
	    }
	}
    }
    print_vinfo(2,pfx sprintf("%-12s %03d %-40s", "modules", n, ""))
}
# add_kernel()
# A kernel of version kversion has just been added to the distro.  What we need to do is to
# weak-update all of the openss7 and client kernel modules from the openss7 subdirectories of
# previous kernels and relink any absolute kernel addresses.
#
function add_kernel(kversion,
		    counts, kernels, #global
		    sysmaps, sysmap, symvers, symver, #global
		    modules, subdirs, modnames, names, modinfo, export, linked, wanted, weaken, needed, #global
		    weakmods, weaklinks, weaknames, #global
		    pfx,solution,score,s,k,kver,retn,creates,unlinks,changes,relinks,removes,retains,inserts,unneeded,command,file)
{
    pfx = "p: addkernel, "
    if (getsysinfo(kversion, sysmaps, symvers, sysmap, symver) == 0)
	return
    getmodinfo(kversion, modules, subdirs, modnames, names, weakmods, weaknames, weaklinks, modinfo, export, linked, wanted, weaken, needed)
    solution = ""; score = counts["uniq"]; s = 0
    print_vmore(3, pfx sprintf("%04d solutions, kversion = %-20s", s, kversion))
    for (k=counts["kern"];k>0;k--) { kver = kernels[k]
	getmodinfo(kver, modules, subdirs, modnames, names, weakmods, weaknames, weaklinks, modinfo, export, linked, wanted, weaken, needed)
	retn = getresolve(kversion, kver, sysmaps, symvers, modules, subdirs, modnames, weaknames,
			  names, export, linked, needed, wanted, weaken, creates, unlinks, changes,
			  relinks, removes, retains, inserts, unneeded)
	s++
	print_vmore(3, pfx sprintf("%04d solutions, kversion = %-20s", s, kversion))
	if (retn < score) { score = retn; solution = kver }
	if (score == 0) break
    }
    print_vinfo(2, pfx sprintf("%04d solutions, kversion = %-20s", s, kversion))
    if (chcksolution(kversion, kver, creates, unlinks, changes, relinks, removes, retains, inserts,
		     unneeded, modules, subdirs, modnames, weakmods, weaklinks, weaknames)) {
	if (makesolution(kversion, solution, creates, unlinks, changes, relinks, removes, retains,
			 inserts, modules, subdirs, modnames, weakmods, weaklinks, weaknames)) {
	    dodepmod(kversion)
	}
    }
}
function remove_kernels(kversion,	pfx,kversions,v,dir)
{
    pfx = "p: rmvkerns,  "
    v = split(kversion,kversions); rpmsort(kversions, v)
    for (;v in kversions;v--) {
	remove_kernel(kversions[v])
    }
}
function link_kernels(kversion,
		     pfx,kversions,v,
		     counts,kernels, #global
		     sysmaps,sysmap,symvers,symver, #global
		     modules,subdirs,modnames,names,modinfo,export,linked,wanted,weaken,needed, #global
		     weakmods,weaklinks,weaknames) #global
{
    pfx = "p: lnkkerns,  "
    print_vinfo(2, pfx "kversions = " kversion)
    getstructure(counts, kernels, modules, subdirs, modnames, names, weakmods, weaklinks, weaknames)
    v = split(kversion,kversions); rpmsort(kversions,v)
    for (;v in kversions;v--) {
	link_kernel(kversions[v],
		    counts, kernels, #global
		    sysmaps, sysmap, symvers, symver, #global
		    modules, subdirs, modnames, names, modinfo, export, linked, wanted, weaken, needed, #global
		    weakmods, weaklinks, weaknames) #global
    }
}
function add_kernels(kversion,
		     pfx,kversions,v,olddry,
		     counts,kernels, #global
		     sysmaps,sysmap,symvers,symver, #global
		     modules,subdirs,modnames,names,modinfo,export,linked,wanted,weaken,needed, #global
		     weakmods,weaklinks,weaknames) #global
{
    pfx = "p: addkerns,  "
    print_debug(1, pfx "kversions = " kversion)
    getstructure(counts, kernels, modules, subdirs, modnames, names, weakmods, weaklinks, weaknames)
    v = split(kversion,kversions); rpmsort(kversions,v)
    for (;v in kversions;v--) {
	add_kernel(kversions[v],
		   counts, kernels, #global
		   sysmaps, sysmap, symvers, symver, #global
		   modules, subdirs, modnames, names, modinfo, export, linked, wanted, weaken, needed, #global
		   weakmods, weaklinks, weaknames) #global
	link_kernel(kversions[v],
		    counts, kernels, #global
		    sysmaps, sysmap, symvers, symver, #global
		    modules, subdirs, modnames, names, modinfo, export, linked, wanted, weaken, needed, #global
		    weakmods, weaklinks, weaknames) #global
    }
}
function update_kernels(kversion,
			pfx,kversions,command)
{
    print_debug(1,"p: updkernels, kversion = " kversion)
    if  (!kversion) {
	command = "ls /lib/modules"
	while ((command | getline) == 1) { if (kversion) { kversion = kversion " " $0 } else { kversion = $0 } }
	close(command)
    }
    add_kernels(kversion)
}
function boot_kernels(kversion,
		      pfx,kversions,command)
{
    print_debug(1,"p: bootkernel, kversion = " kversion)
    add_kernels(kversion)
}
function add_modules(kversion,
		     pfx,kversions,command)
{
    if (split(kversion,kversions) != 1) {
	print_error("o: one and only one KVERSION permitted for --add-modules")
	usage(stderr); exit 2 }
    kversion = kversions[1]
    print_debug(1,"p: addmodules, kversion = " kversion)
    kversion = ""
    command = "ls /lib/modules"
    while ((command | getline) == 1) { if (kversion) { kversion = kversion " " $0 } else { kversion = $0 } }
    close(command)
    add_kernels(kversion)
}

function link_modules(kversion,
		      pfx,kversions,v,command)
{
    if (split(kversion,kversions) != 1) {
	print_error("o: one and only one KVERSION permitted for --link-modules")
	usage(stderr); exit 2 }
    kversion = kversions[1]
    print_debug(1,"p: lnkmodules, kversion = " kversion)
    kversion = ""
    command = "ls /lib/modules"
    while ((command | getline) == 1) { if (kversion) { kversion = kversion " " $0 } else { kversion = $0 } }
    close(command)
    link_kernels(kversion)
}

function remove_modules(kversion,
			pfx,kversions,v,command)
{
    if (split(kversion,kversions) != 1) {
	print_error("o: one and only one KVERSION permitted for --remove-modules")
	usage(stderr); exit 2 }
    kversion = kversions[1]
    print_debug(1,"p: rmvmodules, kversion = " kversion)
    kversion = ""
    command = "ls /lib/modules"
    while ((command | getline) == 1) { if (kversion) { kversion = kversion " " $0 } else { kversion = $0 } }
    close(command)
    add_kernels(kversion)
}
function update_modules(kversion,
			pfx,kversions,command)
{
    print_debug(1,"p: updmodules, kversion = " kversion)
    kversion = ""
    command = "ls /lib/modules"
    while ((command | getline) == 1) { if (kversion) { kversion = kversion " " $0 } else { kversion = $0 } }
    close(command)
    add_kernels(kversion)
}
BEGIN {
    LINT = "yes"
    me = "openss7-modules"
    count_errs = 0; count_warn = 0; errors = ""
    if (!("TERM" in ENVIRON)) ENVIRON["TERM"] = "dumb"
    if (ENVIRON["TERM"] == "dumb" || system("test -t 1 -a -t 2") != 0) {
	stdout = "/dev/stdout"
	stderr = "/dev/stderr"
	cr = ""; lf = "\n"
	blk = ""; hblk = ""
	red = ""; hred = ""
	grn = ""; hgrn = ""
	org = ""; horg = ""
	blu = ""; hblu = ""
	mag = ""; hmag = ""
	cyn = ""; hcyn = ""
	std = ""; prog = "no"
    } else {
	stdout = "/dev/stdout"
	stderr = "/dev/stderr"
	cr = "\r"; lf = ""
	blk = "\033[0;30m"; hblk = "\033[1;30m"
	red = "\033[0;31m"; hred = "\033[1;31m"
	grn = "\033[0;32m"; hgrn = "\033[1;32m"
	org = "\033[0;33m"; horg = "\033[1;33m"
	blu = "\033[0;34m"; hblu = "\033[1;34m"
	mag = "\033[0;35m"; hmag = "\033[1;35m"
	cyn = "\033[0;36m"; hcyn = "\033[1;36m"
	std = "\033[m"; prog = "yes"
    }
    krunning = getline_command("uname -r")
    if ("kversion" in ENVIRON) { d["kversion"] = ENVIRON["kversion"] }
    else                       { d["kversion"] = krunning }
    d["package" ] = "openss7"
    d["style"   ] = "debian"
    d["basedir" ] = ""
    d["weakdir" ] = "weak-updates"
    d["sysmap"  ] = "/boot/System.map-$KVERSION"
    d["sysver"  ] = "/lib/modules/$KVERSION/build/Module.symvers"
    d["symver"  ] = "/boot/symvers-$KVERSION.gz"
    d["symabi"  ] = "/boot/abi-$KVERSION"
    d["inits"   ] = "specfs,streams,strace,strerr,openss7"
											  descrips["kernels"       ] = "kernel versions for which to perform operations"					; longargs["kernels"       ] = "KERNEL ..."
    longopts["kversion"      ] = "k:" ; defaults["kversion"      ] = d["kversion"]	; descrips["kversion"      ] = "default kernel version"
    longopts["add-kernel"    ] = "A!" ;							  descrips["add-kernel"    ] = "mode: add kernels with versions"
    longopts["link-kernel"   ] = "L!" ;							  descrips["link-kernel"   ] = "mode: link kernels with versions"
    longopts["remove-kernel" ] = "R!" ;							  descrips["remove-kernel" ] = "mode: remove kernels with versions"
    longopts["update-kernel" ] = "U!" ;							  descrips["update-kernel" ] = "mode: update kernels with versions"
    longopts["boot-kernel"   ] = "B!" ;							  descrips["boot-kernel"   ] = "mode: update boooting kernel with version"
    longopts["add-modules"   ] = "a!" ;							  descrips["add-modules"   ] = "mode: add kernel modules to kernel versions"
    longopts["link-modules"  ] = "l!" ;							  descrips["link-modules"  ] = "mode: link modules for kernel with versions"
    longopts["remove-modules"] = "r!" ; defaults["remove-modules"] = d["kversion"]	; descrips["remove-modules"] = "mode: remove kernel modules from kernel versions"
    longopts["update-modules"] = "u!" ; defaults["update-modules"] = d["kversion"]	; descrips["update-modules"] = "mode: update kernel modules from kernel versions"
    longopts["modules"       ] = "M:" ; defaults["modules"       ] = ""			; descrips["modules"       ] = "modules for which to generate symbols (search when unspec.)"				; longargs["modules"       ] = "MODULE ..."
    longopts["rootdir"       ] = "c:" ; defaults["rootdir"       ] = ""			; descrips["rootdir"       ] = "root of the kernels being installed"
    longopts["basedir"       ] = "b:" ; defaults["basedir"       ] = d["basedir" ]	; descrips["basedir"       ] = "use a base directory other than root, BASEDIR"
    longopts["weakdir"       ] = "w:" ; defaults["weakdir"       ] = d["weakdir" ]	; descrips["weakdir"       ] = "where to place weak update symbolic links\nabsolute or rel. to /lib/modules/$KVERSION)"	; longargs["weakdir"       ] = "PATH"
    longopts["sysmap"        ] = "F:" ; defaults["sysmap"        ] = d["sysmap"  ]	; descrips["sysmap"        ] = "system map file (same as depmod) (search when unspec.)"
    longopts["sysver"        ] = "E:" ; defaults["sysver"        ] = d["sysver"  ]	; descrips["sysver"        ] = "system version file (same as depmod) (search when unspec.)"
    longopts["symver"        ] = "S:" ; defaults["symver"        ] = d["symver"  ]	; descrips["symver"        ] = "system version file (compressed) (search when unspec.)"
    longopts["symabi"        ] = "Y:" ; defaults["symabi"        ] = d["symabi"  ]	; descrips["symabi"        ] = "system version file (ubuntu abi) (search when unspec.)"
    longopts["package"       ] = "P:" ; defaults["package"       ] = d["package" ]	; descrips["package"       ] = "package name (used to find subdirectories)"
    longopts["style"         ] = "s:" ; defaults["style"         ] = d["style"   ]	; descrips["style"         ] = "style of weak-updates (detect when unspec.)"						; longargs["style"         ] = "{debian|redhat|suse10|suse11|ubuntu}"
    longopts["initscripts"   ] = "i::"; defaults["initscripts"   ] = d["inits"   ]	; descrips["initscripts"   ] = "comma-separated list of init scripts to run"						; longargs["initscripts"   ] = "[SCRIPT[,SCRIPT]...]"
    longopts["depmodx"       ] = "x"  ; defaults["depmodx"       ] = 0			; descrips["depmodx"       ] = "depmod supports -E option (detect when unspec.)"
    longopts["preserve"      ] = "p"  ; defaults["preserve"      ] = 1			; descrips["preserve"      ] = "preserve configuration for running kernel"
    longopts["overwrite"     ] = "o"  ; defaults["overwrite"     ] = 0			; descrips["overwrite"     ] = "overwrite configuration for running kernel"
    longopts["exit-on-error" ] = "e"  ; defaults["exit-on-error" ] = 0			; descrips["exit-on-error" ] = "exit with error status on program errors"
    longopts["dryrun"        ] = "n"  ; defaults["dryrun"        ] = 0			; descrips["dryrun"        ] = "don't perform actions, just check them"
    longopts["dry-run"       ] = "n"  ; defaults["dry-run"       ] = 0			; descrips["dry-run"       ] = "don't perform actions, just check them"
    longopts["quiet"         ] = "q"  ; defaults["quiet"         ] = 0			; descrips["quiet"         ] = "suppress normal output"
    longopts["silent"        ] = "q"  ; defaults["silent"        ] = 0			; descrips["silent"        ] = "suppress normal output"
    longopts["debug"         ] = "D::"; defaults["debug"         ] = 0			; descrips["debug"         ] = "increase or set debug level DEBUG"							; environs["debug"        ] = "OS7UPDT_DEBUG"
    longopts["verbose"       ] = "v::"; defaults["verbose"       ] = 0			; descrips["verbose"       ] = "increase or set verbosity level VERBOSITY"						; environs["verbose"      ] = "OS7UPDT_VERBOSE"
    longopts["help"          ] = "h!" ;							  descrips["help"          ] = "display this usage information and exit"
    longopts["version"       ] = "V!" ;							  descrips["version"       ] = "display script version and exit"
    longopts["copying"       ] = "C!" ;							  descrips["copying"       ] = "display coding permissions and exit"
    delete d
    values["kversion"     ] = defaults["kversion"     ]
    values["sysmap"       ] = defaults["sysmap"       ]
    values["sysver"       ] = defaults["sysver"       ]
    values["symver"       ] = defaults["symver"       ]
    values["symabi"       ] = defaults["symabi"       ]
    values["package"      ] = defaults["package"      ]
    values["rootdir"      ] = defaults["rootdir"      ]
    values["basedir"      ] = defaults["basedir"      ]
    values["preserve"     ] = defaults["preserve"     ]
    values["overwrite"    ] = defaults["overwrite"    ]
    values["exit-on-error"] = defaults["exit-on-error"]
    values["dryrun"       ] = defaults["dryrun"       ]
    values["dry-run"      ] = defaults["dry-run"      ]
    values["quiet"        ] = defaults["quiet"        ]
    values["silent"       ] = defaults["silent"       ]
    values["debug"        ] = defaults["debug"        ]
    values["verbose"      ] = defaults["verbose"      ]
    optstring = "k:ALRUalruM:c:b:w:F:E:S:Y:P:s:i::poxenqD::v::hVC"
    optind = 0
    #opts = ""; for (i=1;i<ARGC;i++) { if (i == 1) { opts = ARGV[i] } else { opts = opts " " ARGV[i] } }
    #print me ": D: o: command line: " opts > stderr; written[stderr] = 1
    command = ""
    while (1) {
	c = getopt_long(ARGC, ARGV, optstring, longopts)
	#if (c != -1) { print me ": D: o: option -" c ", longopt --" option ", optset = " optset ", optarg = " optarg > stderr; written[stderr] = 1 }
	if (c == -1) break
	else if (c~/[kMcbwFESPsi]/)			{ values[option] = optarg }
	else if (c~/[poxenq]/)				{ values[option] = optset }
	else if (c~/[Dv]/)	{ if (optarg  != "")	{ values[option] = optarg } else { if (optset)  { values[option]++ } else { values[option] = optset } } }
	else if (c~/[ALRUBalru]/)			{ values[option] = optset; if (!optset && command == option)	{ command = "" } else
										   if (optset && !command)		{ command = option } else
										   if (optset) {  print_error("option --" option " is incompatible with --" command); exit 2 } }
	else if (c~/[hVC]/)	{ command = option }
	else			{ usage(  stderr); exit 2 }
    }
    if (values["quiet"  ] == defaults["quiet"  ] &&
	values["debug"  ] == defaults["debug"  ] &&
	values["verbose"] == defaults["verbose"]) {
	if ("V" in ENVIRON) {
	    if (ENVIRON["V"] == "0") {
		values["quiet"  ] = 1
		values["debug"  ] = 0
		values["verbose"] = 0
	    } else
	    if (ENVIRON["V"] == "1") {
		values["quiet"  ] = 0
		values["debug"  ] = 0
		values["verbose"] = 2
	    }
	}
    }
    if (values["verbose"] >=3 && values["debug"] == defaults["debug"])
	values["debug"] = values["verbose"] - 2
    while (optind < ARGC) {
	if ("kernels" in values)
	{ values["kernels"] = values["kernels"] " " ARGV[optind] } else
	{ values["kernels"] = ARGV[optind] }
	optind++
    }
    for (i=1;ARGC>i;i++) { delete ARGV[i] }
    if (command == "boot-kernel") {
	if (values["preserve" ] == defaults["preserve" ] &&
	    values["overwrite"] == defaults["overwrite"]) {
	    if ("initscripts" in values)
		delete values["initscripts"]
	    values["preserve" ] = 0
	    values["overwrite"] = 1
	}
	values["kernels"] = values["kversion"]
    }
    for (value in values) {
	if (!values[value] && (value in environs) && (environs[value] in ENVIRON) && ENVIRON[environs[value]]) {
	    print_debug(1,"o: assigning value for " value " from environment " environs[value])
	    values[value] = ENVIRON[environs[value]]
	}
	if (!values[value] && (value in defaults) && defaults[value]) {
	    print_debug(1,"o: assigning value for " value " from default " defaults[value])
	    values[value] = defaults[value]
	}
    }
    for (value in values) {
	print_debug(1, "o: \"" value "\" = " values[value])
    }
    testdepmod()
    testwstyle()
    if (command == "help"          ) { help(   stdout); exit 0 }
    if (command == "version"       ) { version(stdout); exit 0 }
    if (command == "copying"       ) { copying(stdout); exit 0 }
    if (!("kernels" in values)     ) { values["kernels"] = ""  }
    if (command == "add-kernel"    ) { add_kernels(    values["kernels"])} else
    if (command == "link-kernel"   ) { link_kernels(   values["kernels"])} else
    if (command == "remove-kernel" ) { remove_kernels( values["kernels"])} else
    if (command == "update-kernel" ) { update_kernels( values["kernels"])} else
    if (command == "boot-kernel"   ) { boot_kernels(   values["kernels"])} else
    if (command == "add-modules"   ) { add_modules(    values["kernels"])} else
    if (command == "link-modules"  ) { link_modules(   values["kernels"])} else
    if (command == "remove-modules") { remove_modules( values["kernels"])} else
    if (command == "update-modules") { update_modules( values["kernels"])} else
    {
	print_error("o: nothing to do")
	usage(stderr)
	exit 2
    }
    if (count_errs && ("exit-on-error" in values) && (values["exit-on-error"] != 0))
	exit 1
    exit 0
}
END {
    if (errors) { print errors > stderr; written[stderr] = 1 }
    if (count_errs) print_emore("errs = " count_errs)
    if (count_warn) print_wmore("warn = " count_warn)
    for (file in written)
	close(file)
}

# =============================================================================
#
# $Log: openss7-modules,v $
# Revision 1.1.2.4  2011-04-12 06:33:27  brian
# - passes distcheck
#
# Revision 1.1.2.3  2011-04-11 06:13:43  brian
# - working up weak updates
#
# Revision 1.1.2.2  2011-04-07 15:24:01  brian
# - weak reference corrections
#
# Revision 1.1.2.1  2011-04-05 16:35:10  brian
# - weak module design
#
# =============================================================================
# vim: ft=awk sw=4 nocin nosi fo+=tcqlorn
