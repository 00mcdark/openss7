/*****************************************************************************

 @(#) $RCSfile$ $Name$($Revision$) $Date$

 -----------------------------------------------------------------------------

 Copyright (c) 2008-2009  Monavacom Limited <http://www.monavacom.com/>
 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2001  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date$ by $Author$

 -----------------------------------------------------------------------------

 $Log$
 *****************************************************************************/

#ident "@(#) $RCSfile$ $Name$($Revision$) $Date$"

static char const ident[] = "$RCSfile$ $Name$($Revision$) $Date$";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "m3uaAspMIB_storage.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int m3uaAspMIB_refresh = 1;
volatile int m3uaAspTable_refresh = 1;
volatile int m3uaAspAgTable_refresh = 1;
volatile int m3uaAspSgTable_refresh = 1;
volatile int m3uaAspSgpTable_refresh = 1;
volatile int m3uaAspSpTable_refresh = 1;
volatile int m3uaAspMtTable_refresh = 1;
volatile int m3uaAspRsTable_refresh = 1;
volatile int m3uaAspRlTable_refresh = 1;
volatile int m3uaAspRtTable_refresh = 1;
volatile int m3uaAspRcTable_refresh = 1;
volatile int m3uaAspAsTable_refresh = 1;
volatile int m3uaAspAfTable_refresh = 1;

/*
 * m3uaAspMIB_variables_oid: object identifier for m3uaAspMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid m3uaAspMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311 };
oid m3uaAspTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 1, 2, 1 };
oid m3uaAspAgTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 2, 2, 1 };
oid m3uaAspSgTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 3, 1, 1 };
oid m3uaAspSgpTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 4, 1, 1 };
oid m3uaAspSpTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 5, 2, 1 };
oid m3uaAspMtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 6, 1, 1 };
oid m3uaAspRsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 7, 1, 1 };
oid m3uaAspRtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 9, 1, 1 };
oid m3uaAspRcTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 10, 1, 1 };

/*
 * Oids for use in notifications defined in this MIB.
 */
oid m3uaAspRsAlarm_oid[13] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 7, 0 };

/*
 * Oids accessible only for notify defined in this MIB.
 */

/*
 * Other oids defined in this MIB.
 */
oid m3uaAspRsEvents_oid[12] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 7 };

/*
 * variable7 m3uaAspMIB_variables: tree for m3uaAspMIB
 * This variable defines function callbacks and type return information for the m3uaAspMIB mib section
 */
struct variable7 m3uaAspMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   M3UAASPNEXTINDEX      (1 % 256)
	{M3UAASPNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaAspMIB, 4, {1, 2, 1, 1}},
#define   M3UAASPNAME           (6 % 256)
	{M3UAASPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 2}},
#define   M3UAASPNAME           (7 % 256)
	{M3UAASPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 2}},
#define   M3UAASPADMINISTRATIVESTATE  (8 % 256)
	{M3UAASPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 3}},
#define   M3UAASPADMINISTRATIVESTATE  (9 % 256)
	{M3UAASPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 3}},
#define   M3UAASPCAPABILITIES   (10 % 256)
	{M3UAASPCAPABILITIES, ASN_BIT_STR, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 4}},
#define   M3UAASPIDPOLICY       (11 % 256)
	{M3UAASPIDPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 5}},
#define   M3UAASPREGISTRATIONPOLICY  (12 % 256)
	{M3UAASPREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 6}},
#define   M3UAASPASSOCIATIONPOLICY  (13 % 256)
	{M3UAASPASSOCIATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 7}},
#define   M3UAASPSTATUS         (14 % 256)
	{M3UAASPSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 8}},
#define   M3UAASPAGNEXTINDEX    (15 % 256)
	{M3UAASPAGNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaAspMIB, 4, {1, 2, 2, 1}},
#define   M3UAASPAGPROTOCOLVERSION  (19 % 256)
	{M3UAASPAGPROTOCOLVERSION, ASN_OBJECT_ID, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 2}},
#define   M3UAASPAGOPTIONS      (20 % 256)
	{M3UAASPAGOPTIONS, ASN_BIT_STR, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 3}},
#define   M3UAASPAGREGISTRATIONPOLICY  (21 % 256)
	{M3UAASPAGREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 4}},
#define   M3UAASPAGASPIDPOLICY  (22 % 256)
	{M3UAASPAGASPIDPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 5}},
#define   M3UAASPAGASPPROTOCOLPAYLOADID  (23 % 256)
	{M3UAASPAGASPPROTOCOLPAYLOADID, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 6}},
#define   M3UAASPAGIPPORT       (24 % 256)
	{M3UAASPAGIPPORT,, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 7}},
#define   M3UAASPAGMINOSTREAMS  (25 % 256)
	{M3UAASPAGMINOSTREAMS, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 8}},
#define   M3UAASPAGMAXISTREAMS  (26 % 256)
	{M3UAASPAGMAXISTREAMS, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 9}},
#define   M3UAASPAGTIMERT7      (27 % 256)
	{M3UAASPAGTIMERT7, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 10}},
#define   M3UAASPAGTIMERT19     (28 % 256)
	{M3UAASPAGTIMERT19, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 11}},
#define   M3UAASPAGTIMERT21     (29 % 256)
	{M3UAASPAGTIMERT21, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 12}},
#define   M3UAASPAGTIMERT25A    (30 % 256)
	{M3UAASPAGTIMERT25A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 13}},
#define   M3UAASPAGTIMERT28A    (31 % 256)
	{M3UAASPAGTIMERT28A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 14}},
#define   M3UAASPAGTIMERT29A    (32 % 256)
	{M3UAASPAGTIMERT29A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 15}},
#define   M3UAASPAGTIMERT30A    (33 % 256)
	{M3UAASPAGTIMERT30A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 16}},
#define   M3UAASPAGSTATUS       (34 % 256)
	{M3UAASPAGSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 17}},
#define   M3UAASPSGNAME         (39 % 256)
	{M3UAASPSGNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 2}},
#define   M3UAASPSGADMINISTRATIVESTATE  (40 % 256)
	{M3UAASPSGADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 3}},
#define   M3UAASPSGOPERATIONALSTATE  (41 % 256)
	{M3UAASPSGOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 4}},
#define   M3UAASPSGPROCEDUREALSTATUS  (42 % 256)
	{M3UAASPSGPROCEDUREALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 5}},
#define   M3UAASPSGUSGAGESTATE  (43 % 256)
	{M3UAASPSGUSGAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 6}},
#define   M3UAASPSGASPSTATE     (44 % 256)
	{M3UAASPSGASPSTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 7}},
#define   M3UAASPSGMAXINITRETRANS  (45 % 256)
	{M3UAASPSGMAXINITRETRANS, ASN_UNSIGNED, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 8}},
#define   M3UAASPSGMAXPATHRETRANS  (46 % 256)
	{M3UAASPSGMAXPATHRETRANS, ASN_UNSIGNED, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 9}},
#define   M3UAASPSGMAXLIFETIME  (47 % 256)
	{M3UAASPSGMAXLIFETIME, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 10}},
#define   M3UAASPSGTIMERT1      (48 % 256)
	{M3UAASPSGTIMERT1, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 11}},
#define   M3UAASPSGTIMERT2      (49 % 256)
	{M3UAASPSGTIMERT2, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 12}},
#define   M3UAASPSGTIMERT3      (50 % 256)
	{M3UAASPSGTIMERT3, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 13}},
#define   M3UAASPSGTIMERT4      (51 % 256)
	{M3UAASPSGTIMERT4, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 14}},
#define   M3UAASPSGTIMERT5      (52 % 256)
	{M3UAASPSGTIMERT5, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 15}},
#define   M3UAASPSGTIMERT5      (53 % 256)
	{M3UAASPSGTIMERT5, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 15}},
#define   M3UAASPSGTIMERT19A    (54 % 256)
	{M3UAASPSGTIMERT19A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 16}},
#define   M3UAASPSGTIMERT24     (55 % 256)
	{M3UAASPSGTIMERT24, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 17}},
#define   M3UAASPSGTIMERT31A    (56 % 256)
	{M3UAASPSGTIMERT31A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 18}},
#define   M3UAASPSGTIMERT32A    (57 % 256)
	{M3UAASPSGTIMERT32A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 19}},
#define   M3UAASPSGTIMERT33A    (58 % 256)
	{M3UAASPSGTIMERT33A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 20}},
#define   M3UAASPSGTIMERT34A    (59 % 256)
	{M3UAASPSGTIMERT34A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 21}},
#define   M3UAASPSGTIMERT1T     (60 % 256)
	{M3UAASPSGTIMERT1T, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 22}},
#define   M3UAASPSGTIMERT2T     (61 % 256)
	{M3UAASPSGTIMERT2T, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 23}},
#define   M3UAASPSGSTATUS       (62 % 256)
	{M3UAASPSGSTATUS, ASN_INTEGER, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 24}},
#define   M3UAASPSGPNAME        (68 % 256)
	{M3UAASPSGPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 2}},
#define   M3UAASPSGPADMINISTRATIVESTATE  (69 % 256)
	{M3UAASPSGPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 3}},
#define   M3UAASPSGPPROCEDURALSTATUS  (70 % 256)
	{M3UAASPSGPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 4}},
#define   M3UAASPSGPOPERATIONALSTATE  (71 % 256)
	{M3UAASPSGPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 5}},
#define   M3UAASPSGPUSAGESTATE  (72 % 256)
	{M3UAASPSGPUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 6}},
#define   M3UAASPSGPASPSTATE    (73 % 256)
	{M3UAASPSGPASPSTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 7}},
#define   M3UAASPSGPPRIMARYADDRESS  (74 % 256)
	{M3UAASPSGPPRIMARYADDRESS, ASN_OCTET_STR, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 8}},
#define   M3UAASPSGPHOSTNAME    (75 % 256)
	{M3UAASPSGPHOSTNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 9}},
#define   M3UAASPSGPSTATUS      (76 % 256)
	{M3UAASPSGPSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 10}},
#define   M3UAASPSPNEXTINDEX    (77 % 256)
	{M3UAASPSPNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaAspMIB, 4, {1, 2, 5, 1}},
#define   M3UAASPSPNAME         (81 % 256)
	{M3UAASPSPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 2}},
#define   M3UAASPSPOPERATIONALSTATE  (82 % 256)
	{M3UAASPSPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 3}},
#define   M3UAASPSPUSAGESTATE   (83 % 256)
	{M3UAASPSPUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 4}},
#define   M3UAASPSPADMINISTRATIVESTATE  (84 % 256)
	{M3UAASPSPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 5}},
#define   M3UAASPSPALARMSTATUS  (85 % 256)
	{M3UAASPSPALARMSTATUS, ASN_BIT_STR, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 6}},
#define   M3UAASPSPPROCEDURALSTATUS  (86 % 256)
	{M3UAASPSPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 7}},
#define   M3UAASPSPAVAILABILTYSTATUS  (87 % 256)
	{M3UAASPSPAVAILABILTYSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 8}},
#define   M3UAASPSPPOINTCODE    (88 % 256)
	{M3UAASPSPPOINTCODE, ASN_OCTET_STR, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 9}},
#define   M3UAASPSPTIMERT1R     (89 % 256)
	{M3UAASPSPTIMERT1R, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 10}},
#define   M3UAASPSPTIMERT18     (90 % 256)
	{M3UAASPSPTIMERT18, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 11}},
#define   M3UAASPSPTIMERT20     (91 % 256)
	{M3UAASPSPTIMERT20, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 12}},
#define   M3UAASPSPTIMERT22A    (92 % 256)
	{M3UAASPSPTIMERT22A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 13}},
#define   M3UAASPSPTIMERT23A    (93 % 256)
	{M3UAASPSPTIMERT23A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 14}},
#define   M3UAASPSPTIMERT24A    (94 % 256)
	{M3UAASPSPTIMERT24A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 15}},
#define   M3UAASPSPTIMERT26A    (95 % 256)
	{M3UAASPSPTIMERT26A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 16}},
#define   M3UAASPSPTIMERT27A    (96 % 256)
	{M3UAASPSPTIMERT27A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 17}},
#define   M3UAASPSPSTATUS       (97 % 256)
	{M3UAASPSPSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 18}},
#define   M3UAASPMTNAME         (102 % 256)
	{M3UAASPMTNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 2}},
#define   M3UAASPMTADMINISTRATIVESTATE  (103 % 256)
	{M3UAASPMTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 3}},
#define   M3UAASPMTOPERATIONALSTATE  (104 % 256)
	{M3UAASPMTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 4}},
#define   M3UAASPMTPROCEDURALSTATUS  (105 % 256)
	{M3UAASPMTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 5}},
#define   M3UAASPMTUSAGESTATE   (106 % 256)
	{M3UAASPMTUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 6}},
#define   M3UAASPMTASSTATE      (107 % 256)
	{M3UAASPMTASSTATE, ASN_INTEGER, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 7}},
#define   M3UAASPMTSTATUS       (108 % 256)
	{M3UAASPMTSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 8}},
#define   M3UAASPRSNAME         (113 % 256)
	{M3UAASPRSNAME, ASN_OCTET_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 2}},
#define   M3UAASPRSREMOTEPOINTCODE  (114 % 256)
	{M3UAASPRSREMOTEPOINTCODE, ASN_OCTET_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 3}},
#define   M3UAASPRSOPERATIONALSTATE  (115 % 256)
	{M3UAASPRSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 4}},
#define   M3UAASPRSADMINISTRATIVESTATE  (116 % 256)
	{M3UAASPRSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 5}},
#define   M3UAASPRSUSAGESTATE   (117 % 256)
	{M3UAASPRSUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 6}},
#define   M3UAASPRSALARMSTATUS  (118 % 256)
	{M3UAASPRSALARMSTATUS, ASN_BIT_STR, RWRITE, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 7}},
#define   M3UAASPRSPROCEDURALSTATUS  (119 % 256)
	{M3UAASPRSPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 8}},
#define   M3UAASPRSTIMERT8      (120 % 256)
	{M3UAASPRSTIMERT8, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 9}},
#define   M3UAASPRSTIMERT11     (121 % 256)
	{M3UAASPRSTIMERT11, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 10}},
#define   M3UAASPRSTIMERT15     (122 % 256)
	{M3UAASPRSTIMERT15, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 11}},
#define   M3UAASPRSTIMERT16     (123 % 256)
	{M3UAASPRSTIMERT16, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 12}},
#define   M3UAASPRSTIMERT18A    (124 % 256)
	{M3UAASPRSTIMERT18A, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 13}},
#define   M3UAASPRSOPTIONS      (125 % 256)
	{M3UAASPRSOPTIONS, ASN_BIT_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 14}},
#define   M3UAASPRSAVAILABILITYSTATUS  (126 % 256)
	{M3UAASPRSAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 15}},
#define   M3UAASPRSCONGESTIONLEVEL  (127 % 256)
	{M3UAASPRSCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 16}},
#define   M3UAASPRSSTATUS       (128 % 256)
	{M3UAASPRSSTATUS, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 17}},
#define   M3UAASPRLCOST         (134 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (135 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (136 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (137 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (138 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (139 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (140 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRTCOST         (147 % 256)
	{M3UAASPRTCOST, ASN_UNSIGNED, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 1}},
#define   M3UAASPRTTIMERT6      (148 % 256)
	{M3UAASPRTTIMERT6, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 2}},
#define   M3UAASPRTTIMERT10     (149 % 256)
	{M3UAASPRTTIMERT10, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 3}},
#define   M3UAASPRTAVAILABILITYSTATUS  (150 % 256)
	{M3UAASPRTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 4}},
#define   M3UAASPRTADMINSTRATIVESTATE  (151 % 256)
	{M3UAASPRTADMINSTRATIVESTATE, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 5}},
#define   M3UAASPRTOPERATIONALSTATE  (152 % 256)
	{M3UAASPRTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 6}},
#define   M3UAASPRTPROCEDURALSTATUS  (153 % 256)
	{M3UAASPRTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 7}},
#define   M3UAASPRTUSAGESTATE   (154 % 256)
	{M3UAASPRTUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 8}},
#define   M3UAASPRTSTATUS       (155 % 256)
	{M3UAASPRTSTATUS, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 9}},
#define   M3UAASPRCVALUE        (162 % 256)
	{M3UAASPRCVALUE, ASN_UNSIGNED, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 1}},
#define   M3UAASPRCREGSTRATIONPOLICY  (163 % 256)
	{M3UAASPRCREGSTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 3}},
#define   M3UAASPRCTRAFFICMODE  (164 % 256)
	{M3UAASPRCTRAFFICMODE, ASN_OBJECT_ID, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 4}},
#define   M3UAASPRCSTATUS       (165 % 256)
	{M3UAASPRCSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 5}},
#define   M3UAASPASASSTATE      (173 % 256)
	{M3UAASPASASSTATE, ASN_INTEGER, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 1}},
#define   M3UAASPASOPERATIONALSTATE  (174 % 256)
	{M3UAASPASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 2}},
#define   M3UAASPASPROCEDURALSTATUS  (175 % 256)
	{M3UAASPASPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 3}},
#define   M3UAASPASUSAGESTATE   (176 % 256)
	{M3UAASPASUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 4}},
#define   M3UAASPAFASSTATE      (185 % 256)
	{M3UAASPAFASSTATE, ASN_INTEGER, RWRITE, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 1}},
#define   M3UAASPAFADMINISTRATIVESTATE  (186 % 256)
	{M3UAASPAFADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 2}},
#define   M3UAASPAFOPERATIONALSTATE  (187 % 256)
	{M3UAASPAFOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 3}},
#define   M3UAASPAFPROCEDURALSTATUS  (188 % 256)
	{M3UAASPAFPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 4}},
#define   M3UAASPAFUSAGESTATE   (189 % 256)
	{M3UAASPAFUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 5}},
};

/* (L = length of the oidsuffix) */
struct m3uaAspMIB_data *m3uaAspMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *m3uaAspTableStorage = NULL;
struct header_complex_index *m3uaAspAgTableStorage = NULL;
struct header_complex_index *m3uaAspSgTableStorage = NULL;
struct header_complex_index *m3uaAspSgpTableStorage = NULL;
struct header_complex_index *m3uaAspSpTableStorage = NULL;
struct header_complex_index *m3uaAspMtTableStorage = NULL;
struct header_complex_index *m3uaAspRsTableStorage = NULL;
struct header_complex_index *m3uaAspRlTableStorage = NULL;
struct header_complex_index *m3uaAspRtTableStorage = NULL;
struct header_complex_index *m3uaAspRcTableStorage = NULL;
struct header_complex_index *m3uaAspAsTableStorage = NULL;
struct header_complex_index *m3uaAspAfTableStorage = NULL;

/*
 * init_m3uaAspMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_m3uaAspMIB(void)
{
	DEBUGMSGTL(("m3uaAspMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("m3uaAspMIB", m3uaAspMIB_variables, variable7, m3uaAspMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_m3uaAspMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("m3uaAspMIB", parse_m3uaAspMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspTable", parse_m3uaAspTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspAgTable", parse_m3uaAspAgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspSgTable", parse_m3uaAspSgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspSgpTable", parse_m3uaAspSgpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspSpTable", parse_m3uaAspSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspMtTable", parse_m3uaAspMtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspRsTable", parse_m3uaAspRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspRlTable", parse_m3uaAspRlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspRtTable", parse_m3uaAspRtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspRcTable", parse_m3uaAspRcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspAsTable", parse_m3uaAspAsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspAfTable", parse_m3uaAspAfTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspAgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspSgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspSgpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspMtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspRlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspRtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspRcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspAsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspAfTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
}

/*
 * deinit_m3uaAspMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_m3uaAspMIB(void)
{
	DEBUGMSGTL(("m3uaAspMIB", "deinitializating...  "));
	unregister_mib(m3uaAspMIB_variables_oid, sizeof(m3uaAspMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("m3uaAspMIB");
	snmpd_unregister_config_handler("m3uaAspTable");
	snmpd_unregister_config_handler("m3uaAspAgTable");
	snmpd_unregister_config_handler("m3uaAspSgTable");
	snmpd_unregister_config_handler("m3uaAspSgpTable");
	snmpd_unregister_config_handler("m3uaAspSpTable");
	snmpd_unregister_config_handler("m3uaAspMtTable");
	snmpd_unregister_config_handler("m3uaAspRsTable");
	snmpd_unregister_config_handler("m3uaAspRlTable");
	snmpd_unregister_config_handler("m3uaAspRtTable");
	snmpd_unregister_config_handler("m3uaAspRcTable");
	snmpd_unregister_config_handler("m3uaAspAsTable");
	snmpd_unregister_config_handler("m3uaAspAfTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
}

int
term_m3uaAspMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_m3uaAspMIB();
	return 0;
}

/**
 * @fn struct m3uaAspMIB_data *m3uaAspMIB_create(void)
 * @brief create a fresh data structure representing scalars in m3uaAspMIB.
 * Creates a new m3uaAspMIB_data structure by allocating dynamic memory for the structure and
 * initializing the default values of scalars in m3uaAspMIB.
 */
struct m3uaAspMIB_data *
m3uaAspMIB_create(void)
{
	struct m3uaAspMIB_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspMIB_data);

	DBUGMSGTL(("m3uaAspMIB", "creating scalars...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default scalar values here into StorageNew */

	}
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspMIB_destroy(struct m3uaAspMIB_data **thedata)
 * @brief delete a scalars structure from m3uaAspMIB.
 * @param thedata pointer to the data structure in m3uaAspMIB.
 * Frees scalars that were previously removed from m3uaAspMIB.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspMIB_destroy(struct m3uaAspMIB_data **thedata)
{
	struct m3uaAspMIB_data *StorageDel;

	DEBUGMSGTL(("m3uaAspMIB", "deleting scalars...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspMIB_add(struct m3uaAspMIB_data *thedata)
 * @param thedata the structure representing m3uaAspMIB scalars.
 * @brief adds node to the m3uaAspMIB scalar data set.
 * Adds a scalar structure to the m3uaAspMIB data set.  Note that this function is necessary even
 * when the scalar values are not peristent.
 */
int
m3uaAspMIB_add(struct m3uaAspMIB_data *thedata)
{
	DEBUGMSGTL(("m3uaAspMIB", "adding data...  "));
	m3uaAspMIBStorage = thedata;
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspMIB(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspMIB entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspMIB).  This routine is invoked by
 * UCD-SNMP to read the values of scalars in the MIB from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the MIB.  If there are no configured entries
 * in the configuration MIB, this function will simply not be called.
 */
void
parse_m3uaAspMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspMIB_data *StorageTmp = m3uaAspMIB_create();

	DEBUGMSGTL(("m3uaAspMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual scalars that are not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspNextIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgNextIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpNextIndex, &tmpsize);
	m3uaAspMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
}

/*
 * store_m3uaAspMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspMIB_data *StorageTmp;

	DEBUGMSGTL(("m3uaAspMIB", "storing data...  "));
	refresh_m3uaAspMIB();
	if ((StorageTmp = m3uaAspMIBStorage) == NULL) {
		DEBUGMSGTL(("m3uaAspMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: comment entire section if no scalars are persistent */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspMIB ");
		cptr = line + strlen(line);
		/* XXX: remove individual scalars that are not persistent */
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspNextIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgNextIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpNextIndex, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_m3uaAspMIB(void)
 * @brief refresh the scalar values of m3uaAspMIB.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_m3uaAspMIB(void)
{
	if (m3uaAspMIBStorage == NULL) {
		struct m3uaAspMIB_data *StorageNew;

		if ((StorageNew = m3uaAspMIB_create()) == NULL)
			return;
		m3uaAspMIBStorage = StorageNew;
		m3uaAspMIB_refresh = 1;
	}
	if (m3uaAspMIB_refresh == 0)
		return;
	m3uaAspMIB_refresh = 0;
	/* XXX: Update scalars as required here... */
}

/**
* @fn u_char * var_m3uaAspMIB(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
* @param vp a pointer to the entry in the variables table for the requested variable.
* @param name the object identifier for which to find.
* @param length the length of the object identifier.
* @param exact whether the name is exact.
* @param var_len a pointer to the length of the representation of the object.
* @param write_method a pointer to a write method for the object.
* @brief locate variables in m3uaAspMIB.
* This function returns a pointer to a memory area that is static across the request that contains
* the UCD-SNMP representation of the scalar (so that it may be used to read from for a GET,
* GET-NEXT or GET-BULK request).  This returned pointer may be NULL, in which case the function is
* telling UCD-SNMP that the scalar does not exist for reading; however, if write_method is
* overwritten with a non-NULL value, the function is telling UCD-SNMP that the scalar exists for
* writing.  Write-only objects can be effected in this way.
*/
u_char *
var_m3uaAspMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_m3uaAspMIB();
	if ((StorageTmp = m3uaAspMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPNEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspNextIndex);
		return (u_char *) &StorageTmp->m3uaAspNextIndex;
	case M3UAASPAGNEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAgNextIndex);
		return (u_char *) &StorageTmp->m3uaAspAgNextIndex;
	case M3UAASPSPNEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSpNextIndex);
		return (u_char *) &StorageTmp->m3uaAspSpNextIndex;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn struct m3uaAspTable_data *m3uaAspTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspTable table.
 * Creates a new m3uaAspTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspTable_data *
m3uaAspTable_create(void)
{
	struct m3uaAspTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspTable_data);

	DBUGMSGTL(("m3uaAspTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->m3uaAspStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("m3uaAspTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspTable_destroy(struct m3uaAspTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspTable_destroy(struct m3uaAspTable_data **thedata)
{
	struct m3uaAspTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspName);
		StorageDel->m3uaAspNameLen = 0;
		SNMP_FREE(StorageDel->m3uaAspName);
		StorageDel->m3uaAspNameLen = 0;
		SNMP_FREE(StorageDel->m3uaAspCapabilities);
		StorageDel->m3uaAspCapabilitiesLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspTable_add(struct m3uaAspTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspTable table data set.
 * Adds a table row structure to the m3uaAspTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspTable_add(struct m3uaAspTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspIndex, sizeof(thedata->m3uaAspIndex));
	/* m3uaAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspIndex, sizeof(thedata->m3uaAspIndex));
	header_complex_add_data(&m3uaAspTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspTable_del(struct m3uaAspTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspTable_del(struct m3uaAspTable_data *thedata)
{
	struct m3uaAspTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspTable_data *StorageTmp = m3uaAspTable_create();

	DEBUGMSGTL(("m3uaAspTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspName, &StorageTmp->m3uaAspNameLen);
	if (StorageTmp->m3uaAspName == NULL) {
		config_perror("invalid specification for m3uaAspName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspName, &StorageTmp->m3uaAspNameLen);
	if (StorageTmp->m3uaAspName == NULL) {
		config_perror("invalid specification for m3uaAspName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspCapabilities, &StorageTmp->m3uaAspCapabilitiesLen);
	if (StorageTmp->m3uaAspCapabilities == NULL) {
		config_perror("invalid specification for m3uaAspCapabilities");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspIdPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRegistrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAssociationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspStatus, &tmpsize);
	m3uaAspTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspTable", "done.\n"));
}

/*
 * store_m3uaAspTable(): store configuraiton file for m3uaAspTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspTable", "storing data...  "));
	refresh_m3uaAspTable();
	(void) tmpsize;
	for (hcindex = m3uaAspTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspName, &StorageTmp->m3uaAspNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspName, &StorageTmp->m3uaAspNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspCapabilities, &StorageTmp->m3uaAspCapabilitiesLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspIdPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRegistrationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAssociationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspAgTable_data *m3uaAspAgTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspAgTable table.
 * Creates a new m3uaAspAgTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspAgTable_data *
m3uaAspAgTable_create(void)
{
	struct m3uaAspAgTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspAgTable_data);

	DBUGMSGTL(("m3uaAspAgTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->m3uaAspAgMinOstreams = 32;
		StorageNew->m3uaAspAgStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("m3uaAspAgTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspAgTable_destroy(struct m3uaAspAgTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspAgTable_destroy(struct m3uaAspAgTable_data **thedata)
{
	struct m3uaAspAgTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspAgTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspAgProtocolVersion);
		StorageDel->m3uaAspAgProtocolVersionLen = 0;
		SNMP_FREE(StorageDel->m3uaAspAgOptions);
		StorageDel->m3uaAspAgOptionsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspAgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspAgTable_add(struct m3uaAspAgTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspAgTable table data set.
 * Adds a table row structure to the m3uaAspAgTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspAgTable_add(struct m3uaAspAgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspAgTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	header_complex_add_data(&m3uaAspAgTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspAgTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspAgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspAgTable_del(struct m3uaAspAgTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspAgTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspAgTable_del(struct m3uaAspAgTable_data *thedata)
{
	struct m3uaAspAgTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspAgTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspAgTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspAgTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspAgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspAgTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspAgTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspAgTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspAgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspAgTable_data *StorageTmp = m3uaAspAgTable_create();

	DEBUGMSGTL(("m3uaAspAgTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->m3uaAspAgProtocolVersion, &StorageTmp->m3uaAspAgProtocolVersionLen);
	if (StorageTmp->m3uaAspAgProtocolVersion == NULL) {
		config_perror("invalid specification for m3uaAspAgProtocolVersion");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspAgOptions, &StorageTmp->m3uaAspAgOptionsLen);
	if (StorageTmp->m3uaAspAgOptions == NULL) {
		config_perror("invalid specification for m3uaAspAgOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgRegistrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgAspIdPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgAspProtocolPayloadId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgMinOstreams, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgMaxIstreams, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT19, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT21, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT25A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT28A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT29A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT30A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgStatus, &tmpsize);
	m3uaAspAgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspAgTable", "done.\n"));
}

/*
 * store_m3uaAspAgTable(): store configuraiton file for m3uaAspAgTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspAgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspAgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspAgTable", "storing data...  "));
	refresh_m3uaAspAgTable();
	(void) tmpsize;
	for (hcindex = m3uaAspAgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspAgTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspAgTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->m3uaAspAgProtocolVersion, &StorageTmp->m3uaAspAgProtocolVersionLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspAgOptions, &StorageTmp->m3uaAspAgOptionsLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgRegistrationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgAspIdPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgAspProtocolPayloadId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgMinOstreams, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgMaxIstreams, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT7, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT19, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT21, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT25A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT28A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT29A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT30A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspAgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspSgTable_data *m3uaAspSgTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspSgTable table.
 * Creates a new m3uaAspSgTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspSgTable_data *
m3uaAspSgTable_create(void)
{
	struct m3uaAspSgTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspSgTable_data);

	DBUGMSGTL(("m3uaAspSgTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->m3uaAspSgMaxInitRetrans = 5;
		StorageNew->m3uaAspSgMaxPathRetrans = 10;
		StorageNew->m3uaAspSgTimerT1 = 80;
		StorageNew->m3uaAspSgTimerT2 = 140;
		StorageNew->m3uaAspSgTimerT3 = 80;
		StorageNew->m3uaAspSgTimerT4 = 80;
		StorageNew->m3uaAspSgTimerT5 = 80;
		StorageNew->m3uaAspSgTimerT5 = 80;
		StorageNew->m3uaAspSgTimerT31A = 1000;
		StorageNew->m3uaAspSgTimerT32A = 6000;
		StorageNew->m3uaAspSgTimerT33A = 6000;
		StorageNew->m3uaAspSgTimerT34A = 500;
		StorageNew->m3uaAspSgTimerT1T = 800;
		StorageNew->m3uaAspSgTimerT2T = 6000;
		StorageNew->m3uaAspSgStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("m3uaAspSgTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspSgTable_destroy(struct m3uaAspSgTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspSgTable_destroy(struct m3uaAspSgTable_data **thedata)
{
	struct m3uaAspSgTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspSgTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspSgName);
		StorageDel->m3uaAspSgNameLen = 0;
		SNMP_FREE(StorageDel->m3uaAspSgProcedurealStatus);
		StorageDel->m3uaAspSgProcedurealStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspSgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspSgTable_add(struct m3uaAspSgTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspSgTable table data set.
 * Adds a table row structure to the m3uaAspSgTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspSgTable_add(struct m3uaAspSgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspSgTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	/* m3uaAspSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSgIndex, sizeof(thedata->m3uaAspSgIndex));
	header_complex_add_data(&m3uaAspSgTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspSgTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspSgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspSgTable_del(struct m3uaAspSgTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspSgTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspSgTable_del(struct m3uaAspSgTable_data *thedata)
{
	struct m3uaAspSgTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspSgTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspSgTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspSgTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspSgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspSgTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspSgTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspSgTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspSgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspSgTable_data *StorageTmp = m3uaAspSgTable_create();

	DEBUGMSGTL(("m3uaAspSgTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSgName, &StorageTmp->m3uaAspSgNameLen);
	if (StorageTmp->m3uaAspSgName == NULL) {
		config_perror("invalid specification for m3uaAspSgName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspSgProcedurealStatus, &StorageTmp->m3uaAspSgProcedurealStatusLen);
	if (StorageTmp->m3uaAspSgProcedurealStatus == NULL) {
		config_perror("invalid specification for m3uaAspSgProcedurealStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgUsgageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgAspState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgMaxInitRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgMaxPathRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgMaxLifeTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT19A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT24, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT31A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT32A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT33A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT34A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT2T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgStatus, &tmpsize);
	m3uaAspSgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspSgTable", "done.\n"));
}

/*
 * store_m3uaAspSgTable(): store configuraiton file for m3uaAspSgTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspSgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspSgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspSgTable", "storing data...  "));
	refresh_m3uaAspSgTable();
	(void) tmpsize;
	for (hcindex = m3uaAspSgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspSgTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspSgTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSgName, &StorageTmp->m3uaAspSgNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspSgProcedurealStatus, &StorageTmp->m3uaAspSgProcedurealStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgUsgageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgAspState, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgMaxInitRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgMaxPathRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgMaxLifeTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT1, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT2, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT3, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT4, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT5, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT19A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT24, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT31A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT32A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT33A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT34A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT1T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT2T, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspSgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspSgpTable_data *m3uaAspSgpTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspSgpTable table.
 * Creates a new m3uaAspSgpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspSgpTable_data *
m3uaAspSgpTable_create(void)
{
	struct m3uaAspSgpTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspSgpTable_data);

	DBUGMSGTL(("m3uaAspSgpTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->m3uaAspSgpStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("m3uaAspSgpTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspSgpTable_destroy(struct m3uaAspSgpTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspSgpTable_destroy(struct m3uaAspSgpTable_data **thedata)
{
	struct m3uaAspSgpTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspSgpTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspSgpName);
		StorageDel->m3uaAspSgpNameLen = 0;
		SNMP_FREE(StorageDel->m3uaAspSgpProceduralStatus);
		StorageDel->m3uaAspSgpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->m3uaAspSgpPrimaryAddress);
		StorageDel->m3uaAspSgpPrimaryAddressLen = 0;
		SNMP_FREE(StorageDel->m3uaAspSgpHostName);
		StorageDel->m3uaAspSgpHostNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspSgpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspSgpTable_add(struct m3uaAspSgpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspSgpTable table data set.
 * Adds a table row structure to the m3uaAspSgpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspSgpTable_add(struct m3uaAspSgpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspSgpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	/* m3uaAspSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSgIndex, sizeof(thedata->m3uaAspSgIndex));
	/* m3uaAspSgpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSgpIndex, sizeof(thedata->m3uaAspSgpIndex));
	header_complex_add_data(&m3uaAspSgpTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspSgpTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspSgpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspSgpTable_del(struct m3uaAspSgpTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspSgpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspSgpTable_del(struct m3uaAspSgpTable_data *thedata)
{
	struct m3uaAspSgpTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspSgpTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspSgpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspSgpTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspSgpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspSgpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspSgpTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspSgpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspSgpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspSgpTable_data *StorageTmp = m3uaAspSgpTable_create();

	DEBUGMSGTL(("m3uaAspSgpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgpIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSgpName, &StorageTmp->m3uaAspSgpNameLen);
	if (StorageTmp->m3uaAspSgpName == NULL) {
		config_perror("invalid specification for m3uaAspSgpName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgpAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspSgpProceduralStatus, &StorageTmp->m3uaAspSgpProceduralStatusLen);
	if (StorageTmp->m3uaAspSgpProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspSgpProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgpUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgpAspState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSgpPrimaryAddress, &StorageTmp->m3uaAspSgpPrimaryAddressLen);
	if (StorageTmp->m3uaAspSgpPrimaryAddress == NULL) {
		config_perror("invalid specification for m3uaAspSgpPrimaryAddress");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSgpHostName, &StorageTmp->m3uaAspSgpHostNameLen);
	if (StorageTmp->m3uaAspSgpHostName == NULL) {
		config_perror("invalid specification for m3uaAspSgpHostName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgpStatus, &tmpsize);
	m3uaAspSgpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspSgpTable", "done.\n"));
}

/*
 * store_m3uaAspSgpTable(): store configuraiton file for m3uaAspSgpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspSgpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspSgpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspSgpTable", "storing data...  "));
	refresh_m3uaAspSgpTable();
	(void) tmpsize;
	for (hcindex = m3uaAspSgpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspSgpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspSgpTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgpIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSgpName, &StorageTmp->m3uaAspSgpNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgpAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspSgpProceduralStatus, &StorageTmp->m3uaAspSgpProceduralStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgpOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgpUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgpAspState, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSgpPrimaryAddress, &StorageTmp->m3uaAspSgpPrimaryAddressLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSgpHostName, &StorageTmp->m3uaAspSgpHostNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgpStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspSgpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspSpTable_data *m3uaAspSpTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspSpTable table.
 * Creates a new m3uaAspSpTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspSpTable_data *
m3uaAspSpTable_create(void)
{
	struct m3uaAspSpTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspSpTable_data);

	DBUGMSGTL(("m3uaAspSpTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->m3uaAspSpStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("m3uaAspSpTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspSpTable_destroy(struct m3uaAspSpTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspSpTable_destroy(struct m3uaAspSpTable_data **thedata)
{
	struct m3uaAspSpTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspSpTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspSpName);
		StorageDel->m3uaAspSpNameLen = 0;
		SNMP_FREE(StorageDel->m3uaAspSpAlarmStatus);
		StorageDel->m3uaAspSpAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->m3uaAspSpProceduralStatus);
		StorageDel->m3uaAspSpProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->m3uaAspSpAvailabiltyStatus);
		StorageDel->m3uaAspSpAvailabiltyStatusLen = 0;
		SNMP_FREE(StorageDel->m3uaAspSpPointCode);
		StorageDel->m3uaAspSpPointCodeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspSpTable_add(struct m3uaAspSpTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspSpTable table data set.
 * Adds a table row structure to the m3uaAspSpTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspSpTable_add(struct m3uaAspSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspSpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	header_complex_add_data(&m3uaAspSpTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspSpTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspSpTable_del(struct m3uaAspSpTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspSpTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspSpTable_del(struct m3uaAspSpTable_data *thedata)
{
	struct m3uaAspSpTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspSpTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspSpTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspSpTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspSpTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspSpTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspSpTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspSpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspSpTable_data *StorageTmp = m3uaAspSpTable_create();

	DEBUGMSGTL(("m3uaAspSpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSpName, &StorageTmp->m3uaAspSpNameLen);
	if (StorageTmp->m3uaAspSpName == NULL) {
		config_perror("invalid specification for m3uaAspSpName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspSpAlarmStatus, &StorageTmp->m3uaAspSpAlarmStatusLen);
	if (StorageTmp->m3uaAspSpAlarmStatus == NULL) {
		config_perror("invalid specification for m3uaAspSpAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspSpProceduralStatus, &StorageTmp->m3uaAspSpProceduralStatusLen);
	if (StorageTmp->m3uaAspSpProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspSpProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspSpAvailabiltyStatus, &StorageTmp->m3uaAspSpAvailabiltyStatusLen);
	if (StorageTmp->m3uaAspSpAvailabiltyStatus == NULL) {
		config_perror("invalid specification for m3uaAspSpAvailabiltyStatus");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSpPointCode, &StorageTmp->m3uaAspSpPointCodeLen);
	if (StorageTmp->m3uaAspSpPointCode == NULL) {
		config_perror("invalid specification for m3uaAspSpPointCode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT1R, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT18, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT20, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT22A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT23A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT24A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT26A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT27A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpStatus, &tmpsize);
	m3uaAspSpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspSpTable", "done.\n"));
}

/*
 * store_m3uaAspSpTable(): store configuraiton file for m3uaAspSpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspSpTable", "storing data...  "));
	refresh_m3uaAspSpTable();
	(void) tmpsize;
	for (hcindex = m3uaAspSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspSpTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspSpTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSpName, &StorageTmp->m3uaAspSpNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspSpAlarmStatus, &StorageTmp->m3uaAspSpAlarmStatusLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspSpProceduralStatus, &StorageTmp->m3uaAspSpProceduralStatusLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspSpAvailabiltyStatus, &StorageTmp->m3uaAspSpAvailabiltyStatusLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSpPointCode, &StorageTmp->m3uaAspSpPointCodeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT1R, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT18, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT20, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT22A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT23A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT24A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT26A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT27A, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspMtTable_data *m3uaAspMtTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspMtTable table.
 * Creates a new m3uaAspMtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspMtTable_data *
m3uaAspMtTable_create(void)
{
	struct m3uaAspMtTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspMtTable_data);

	DBUGMSGTL(("m3uaAspMtTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->m3uaAspMtStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("m3uaAspMtTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspMtTable_destroy(struct m3uaAspMtTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspMtTable_destroy(struct m3uaAspMtTable_data **thedata)
{
	struct m3uaAspMtTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspMtTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspMtName);
		StorageDel->m3uaAspMtNameLen = 0;
		SNMP_FREE(StorageDel->m3uaAspMtProceduralStatus);
		StorageDel->m3uaAspMtProceduralStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspMtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspMtTable_add(struct m3uaAspMtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspMtTable table data set.
 * Adds a table row structure to the m3uaAspMtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspMtTable_add(struct m3uaAspMtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspMtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspMtIndex */
	snmp_varlist_add_variable(&vars, NULL, 0,, (u_char *) thedata->m3uaAspMtIndex, thedata->m3uaAspMtIndex);
	header_complex_add_data(&m3uaAspMtTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspMtTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspMtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspMtTable_del(struct m3uaAspMtTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspMtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspMtTable_del(struct m3uaAspMtTable_data *thedata)
{
	struct m3uaAspMtTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspMtTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspMtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspMtTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspMtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspMtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspMtTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspMtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspMtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspMtTable_data *StorageTmp = m3uaAspMtTable_create();

	DEBUGMSGTL(("m3uaAspMtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspMtName, &StorageTmp->m3uaAspMtNameLen);
	if (StorageTmp->m3uaAspMtName == NULL) {
		config_perror("invalid specification for m3uaAspMtName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspMtAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspMtOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspMtProceduralStatus, &StorageTmp->m3uaAspMtProceduralStatusLen);
	if (StorageTmp->m3uaAspMtProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspMtProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspMtUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspMtAsState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspMtStatus, &tmpsize);
	m3uaAspMtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspMtTable", "done.\n"));
}

/*
 * store_m3uaAspMtTable(): store configuraiton file for m3uaAspMtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspMtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspMtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspMtTable", "storing data...  "));
	refresh_m3uaAspMtTable();
	(void) tmpsize;
	for (hcindex = m3uaAspMtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspMtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspMtTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspMtName, &StorageTmp->m3uaAspMtNameLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspMtAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspMtOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspMtProceduralStatus, &StorageTmp->m3uaAspMtProceduralStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspMtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspMtAsState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspMtStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspMtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspRsTable_data *m3uaAspRsTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspRsTable table.
 * Creates a new m3uaAspRsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspRsTable_data *
m3uaAspRsTable_create(void)
{
	struct m3uaAspRsTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspRsTable_data);

	DBUGMSGTL(("m3uaAspRsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->m3uaAspRsStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("m3uaAspRsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspRsTable_destroy(struct m3uaAspRsTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspRsTable_destroy(struct m3uaAspRsTable_data **thedata)
{
	struct m3uaAspRsTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspRsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspRsName);
		StorageDel->m3uaAspRsNameLen = 0;
		SNMP_FREE(StorageDel->m3uaAspRsRemotePointCode);
		StorageDel->m3uaAspRsRemotePointCodeLen = 0;
		SNMP_FREE(StorageDel->m3uaAspRsAlarmStatus);
		StorageDel->m3uaAspRsAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->m3uaAspRsProceduralStatus);
		StorageDel->m3uaAspRsProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->m3uaAspRsOptions);
		StorageDel->m3uaAspRsOptionsLen = 0;
		SNMP_FREE(StorageDel->m3uaAspRsAvailabilityStatus);
		StorageDel->m3uaAspRsAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspRsTable_add(struct m3uaAspRsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspRsTable table data set.
 * Adds a table row structure to the m3uaAspRsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspRsTable_add(struct m3uaAspRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspRsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspRsIndex, sizeof(thedata->m3uaAspRsIndex));
	header_complex_add_data(&m3uaAspRsTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspRsTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspRsTable_del(struct m3uaAspRsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspRsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspRsTable_del(struct m3uaAspRsTable_data *thedata)
{
	struct m3uaAspRsTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspRsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspRsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspRsTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspRsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspRsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspRsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspRsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspRsTable_data *StorageTmp = m3uaAspRsTable_create();

	DEBUGMSGTL(("m3uaAspRsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRsIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspRsName, &StorageTmp->m3uaAspRsNameLen);
	if (StorageTmp->m3uaAspRsName == NULL) {
		config_perror("invalid specification for m3uaAspRsName");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspRsRemotePointCode, &StorageTmp->m3uaAspRsRemotePointCodeLen);
	if (StorageTmp->m3uaAspRsRemotePointCode == NULL) {
		config_perror("invalid specification for m3uaAspRsRemotePointCode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsUsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRsAlarmStatus, &StorageTmp->m3uaAspRsAlarmStatusLen);
	if (StorageTmp->m3uaAspRsAlarmStatus == NULL) {
		config_perror("invalid specification for m3uaAspRsAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRsProceduralStatus, &StorageTmp->m3uaAspRsProceduralStatusLen);
	if (StorageTmp->m3uaAspRsProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspRsProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsTimerT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsTimerT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsTimerT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsTimerT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsTimerT18A, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRsOptions, &StorageTmp->m3uaAspRsOptionsLen);
	if (StorageTmp->m3uaAspRsOptions == NULL) {
		config_perror("invalid specification for m3uaAspRsOptions");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRsAvailabilityStatus, &StorageTmp->m3uaAspRsAvailabilityStatusLen);
	if (StorageTmp->m3uaAspRsAvailabilityStatus == NULL) {
		config_perror("invalid specification for m3uaAspRsAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsCongestionLevel, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsStatus, &tmpsize);
	m3uaAspRsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspRsTable", "done.\n"));
}

/*
 * store_m3uaAspRsTable(): store configuraiton file for m3uaAspRsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspRsTable", "storing data...  "));
	refresh_m3uaAspRsTable();
	(void) tmpsize;
	for (hcindex = m3uaAspRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspRsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspRsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRsIndex, &tmpsize);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspRsName, &StorageTmp->m3uaAspRsNameLen);
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspRsRemotePointCode, &StorageTmp->m3uaAspRsRemotePointCodeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRsAlarmStatus, &StorageTmp->m3uaAspRsAlarmStatusLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRsProceduralStatus, &StorageTmp->m3uaAspRsProceduralStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsTimerT8, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsTimerT11, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsTimerT15, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsTimerT16, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsTimerT18A, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRsOptions, &StorageTmp->m3uaAspRsOptionsLen);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRsAvailabilityStatus, &StorageTmp->m3uaAspRsAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsCongestionLevel, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspRlTable_data *m3uaAspRlTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspRlTable table.
 * Creates a new m3uaAspRlTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspRlTable_data *
m3uaAspRlTable_create(void)
{
	struct m3uaAspRlTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspRlTable_data);

	DBUGMSGTL(("m3uaAspRlTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("m3uaAspRlTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspRlTable_destroy(struct m3uaAspRlTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspRlTable_destroy(struct m3uaAspRlTable_data **thedata)
{
	struct m3uaAspRlTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspRlTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspRlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspRlTable_add(struct m3uaAspRlTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspRlTable table data set.
 * Adds a table row structure to the m3uaAspRlTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspRlTable_add(struct m3uaAspRlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspRlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspRsIndex, sizeof(thedata->m3uaAspRsIndex));
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	header_complex_add_data(&m3uaAspRlTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspRlTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspRlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspRlTable_del(struct m3uaAspRlTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspRlTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspRlTable_del(struct m3uaAspRlTable_data *thedata)
{
	struct m3uaAspRlTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspRlTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspRlTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspRlTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspRlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspRlTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspRlTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspRlTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspRlTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspRlTable_data *StorageTmp = m3uaAspRlTable_create();

	DEBUGMSGTL(("m3uaAspRlTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRsIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	m3uaAspRlTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspRlTable", "done.\n"));
}

/*
 * store_m3uaAspRlTable(): store configuraiton file for m3uaAspRlTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspRlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspRlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspRlTable", "storing data...  "));
	refresh_m3uaAspRlTable();
	(void) tmpsize;
	for (hcindex = m3uaAspRlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspRlTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspRlTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRsIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspRlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspRtTable_data *m3uaAspRtTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspRtTable table.
 * Creates a new m3uaAspRtTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspRtTable_data *
m3uaAspRtTable_create(void)
{
	struct m3uaAspRtTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspRtTable_data);

	DBUGMSGTL(("m3uaAspRtTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->m3uaAspRtTimerT6 = 80;
		StorageNew->m3uaAspRtTimerT10 = 6000;
		StorageNew->m3uaAspRtStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("m3uaAspRtTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspRtTable_destroy(struct m3uaAspRtTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspRtTable_destroy(struct m3uaAspRtTable_data **thedata)
{
	struct m3uaAspRtTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspRtTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspRtAvailabilityStatus);
		StorageDel->m3uaAspRtAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->m3uaAspRtProceduralStatus);
		StorageDel->m3uaAspRtProceduralStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspRtTable_add(struct m3uaAspRtTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspRtTable table data set.
 * Adds a table row structure to the m3uaAspRtTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspRtTable_add(struct m3uaAspRtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspRtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspRsIndex, sizeof(thedata->m3uaAspRsIndex));
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	/* m3uaAspSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSgIndex, sizeof(thedata->m3uaAspSgIndex));
	header_complex_add_data(&m3uaAspRtTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspRtTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspRtTable_del(struct m3uaAspRtTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspRtTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspRtTable_del(struct m3uaAspRtTable_data *thedata)
{
	struct m3uaAspRtTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspRtTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspRtTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspRtTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspRtTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspRtTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspRtTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspRtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspRtTable_data *StorageTmp = m3uaAspRtTable_create();

	DEBUGMSGTL(("m3uaAspRtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRsIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRtCost, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtTimerT10, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRtAvailabilityStatus, &StorageTmp->m3uaAspRtAvailabilityStatusLen);
	if (StorageTmp->m3uaAspRtAvailabilityStatus == NULL) {
		config_perror("invalid specification for m3uaAspRtAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtAdminstrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRtProceduralStatus, &StorageTmp->m3uaAspRtProceduralStatusLen);
	if (StorageTmp->m3uaAspRtProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspRtProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtStatus, &tmpsize);
	m3uaAspRtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspRtTable", "done.\n"));
}

/*
 * store_m3uaAspRtTable(): store configuraiton file for m3uaAspRtTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspRtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspRtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspRtTable", "storing data...  "));
	refresh_m3uaAspRtTable();
	(void) tmpsize;
	for (hcindex = m3uaAspRtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspRtTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspRtTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRsIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRtCost, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtTimerT6, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtTimerT10, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRtAvailabilityStatus, &StorageTmp->m3uaAspRtAvailabilityStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtAdminstrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRtProceduralStatus, &StorageTmp->m3uaAspRtProceduralStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspRcTable_data *m3uaAspRcTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspRcTable table.
 * Creates a new m3uaAspRcTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspRcTable_data *
m3uaAspRcTable_create(void)
{
	struct m3uaAspRcTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspRcTable_data);

	DBUGMSGTL(("m3uaAspRcTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */
		StorageNew->m3uaAspRcStatus = RS_NOTREADY;
	}
	DEBUGMSGTL(("m3uaAspRcTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspRcTable_destroy(struct m3uaAspRcTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspRcTable_destroy(struct m3uaAspRcTable_data **thedata)
{
	struct m3uaAspRcTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspRcTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspRcTrafficMode);
		StorageDel->m3uaAspRcTrafficModeLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspRcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspRcTable_add(struct m3uaAspRcTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspRcTable table data set.
 * Adds a table row structure to the m3uaAspRcTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspRcTable_add(struct m3uaAspRcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspRcTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspIndex, sizeof(thedata->m3uaAspIndex));
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspMtIndex */
	snmp_varlist_add_variable(&vars, NULL, 0,, (u_char *) thedata->m3uaAspMtIndex, thedata->m3uaAspMtIndex);
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	header_complex_add_data(&m3uaAspRcTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspRcTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspRcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspRcTable_del(struct m3uaAspRcTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspRcTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspRcTable_del(struct m3uaAspRcTable_data *thedata)
{
	struct m3uaAspRcTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspRcTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspRcTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspRcTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspRcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspRcTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspRcTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspRcTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspRcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspRcTable_data *StorageTmp = m3uaAspRcTable_create();

	DEBUGMSGTL(("m3uaAspRcTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRcValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRcRegstrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->m3uaAspRcTrafficMode, &StorageTmp->m3uaAspRcTrafficModeLen);
	if (StorageTmp->m3uaAspRcTrafficMode == NULL) {
		config_perror("invalid specification for m3uaAspRcTrafficMode");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRcStatus, &tmpsize);
	m3uaAspRcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspRcTable", "done.\n"));
}

/*
 * store_m3uaAspRcTable(): store configuraiton file for m3uaAspRcTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspRcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspRcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspRcTable", "storing data...  "));
	refresh_m3uaAspRcTable();
	(void) tmpsize;
	for (hcindex = m3uaAspRcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspRcTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspRcTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRcValue, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRcRegstrationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->m3uaAspRcTrafficMode, &StorageTmp->m3uaAspRcTrafficModeLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRcStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspRcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspAsTable_data *m3uaAspAsTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspAsTable table.
 * Creates a new m3uaAspAsTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspAsTable_data *
m3uaAspAsTable_create(void)
{
	struct m3uaAspAsTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspAsTable_data);

	DBUGMSGTL(("m3uaAspAsTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("m3uaAspAsTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspAsTable_destroy(struct m3uaAspAsTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspAsTable_destroy(struct m3uaAspAsTable_data **thedata)
{
	struct m3uaAspAsTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspAsTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspAsProceduralStatus);
		StorageDel->m3uaAspAsProceduralStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspAsTable_add(struct m3uaAspAsTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspAsTable table data set.
 * Adds a table row structure to the m3uaAspAsTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspAsTable_add(struct m3uaAspAsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspAsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspIndex, sizeof(thedata->m3uaAspIndex));
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspMtIndex */
	snmp_varlist_add_variable(&vars, NULL, 0,, (u_char *) thedata->m3uaAspMtIndex, thedata->m3uaAspMtIndex);
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	/* m3uaAspSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSgIndex, sizeof(thedata->m3uaAspSgIndex));
	header_complex_add_data(&m3uaAspAsTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspAsTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspAsTable_del(struct m3uaAspAsTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspAsTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspAsTable_del(struct m3uaAspAsTable_data *thedata)
{
	struct m3uaAspAsTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspAsTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspAsTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspAsTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspAsTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspAsTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspAsTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspAsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspAsTable_data *StorageTmp = m3uaAspAsTable_create();

	DEBUGMSGTL(("m3uaAspAsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAsAsState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspAsProceduralStatus, &StorageTmp->m3uaAspAsProceduralStatusLen);
	if (StorageTmp->m3uaAspAsProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspAsProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAsUsageState, &tmpsize);
	m3uaAspAsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspAsTable", "done.\n"));
}

/*
 * store_m3uaAspAsTable(): store configuraiton file for m3uaAspAsTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspAsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspAsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspAsTable", "storing data...  "));
	refresh_m3uaAspAsTable();
	(void) tmpsize;
	for (hcindex = m3uaAspAsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspAsTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspAsTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAsAsState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAsOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspAsProceduralStatus, &StorageTmp->m3uaAspAsProceduralStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAsUsageState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn struct m3uaAspAfTable_data *m3uaAspAfTable_create(void)
 * @brief create a fresh data structure representing a new row in the m3uaAspAfTable table.
 * Creates a new m3uaAspAfTable_data structure by allocating dynamic memory for the structure and
 * initializing the default values of columns in the table.  The row status object, if any, should
 * be set to RS_NOTREADY.
 */
struct m3uaAspAfTable_data *
m3uaAspAfTable_create(void)
{
	struct m3uaAspAfTable_data *StorageNew = SNMP_MALLOC_STRUCT(m3uaAspAfTable_data);

	DBUGMSGTL(("m3uaAspAfTable", "creating row...  "));
	if (StorageNew != NULL) {
		/* XXX: fill in default row values here into StorageNew */

	}
	DEBUGMSGTL(("m3uaAspAfTable", "done.\n"));
	return (StorageNew);
}

/**
 * @fn int m3uaAspAfTable_destroy(struct m3uaAspAfTable_data **thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Frees a table row that was previously removed from a table.  Note that the strings associated
 * with octet strings, object identifiers and bit strings still attached to the structure will also
 * be freed.  The pointer that was passed in  thedata will be set to NULL if it is not already
 * NULL.
 */
int
m3uaAspAfTable_destroy(struct m3uaAspAfTable_data **thedata)
{
	struct m3uaAspAfTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspAfTable", "deleting row...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaAspAfProceduralStatus);
		StorageDel->m3uaAspAfProceduralStatusLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaAspAfTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspAfTable_add(struct m3uaAspAfTable_data *thedata)
 * @param thedata the structure representing the new row in the table.
 * @brief adds a row to the m3uaAspAfTable table data set.
 * Adds a table row structure to the m3uaAspAfTable table.  Note that this function is necessary even
 * when the table rows are not peristent.  This function can be used within this MIB or other MIBs
 * by the agent to create rows within the table autonomously.
 */
int
m3uaAspAfTable_add(struct m3uaAspAfTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspAfTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspIndex, sizeof(thedata->m3uaAspIndex));
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspMtIndex */
	snmp_varlist_add_variable(&vars, NULL, 0,, (u_char *) thedata->m3uaAspMtIndex, thedata->m3uaAspMtIndex);
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	/* m3uaAspSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSgIndex, sizeof(thedata->m3uaAspSgIndex));
	/* m3uaAspSgpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaAspSgpIndex, sizeof(thedata->m3uaAspSgpIndex));
	header_complex_add_data(&m3uaAspAfTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspAfTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspAfTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn int m3uaAspAfTable_del(struct m3uaAspAfTable_data *thedata)
 * @brief delete a row structure from a table.
 * @param thedata pointer to the extracted or existing data structure in the table.
 * Deletes a table row structure from the m3uaAspAfTable table but does not free it.  Note that this
 * function is necessary even when the table rows are not persistent.  This function can be used
 * within this MIB or another MIB by the agent to delete rows from the table autonomously.  The data
 * structure may either be already extracted from the data set, or the structure may still exist in
 * the data set.  This function will extract the row from the table if it has not already been
 * performed by the caller.
 */
int
m3uaAspAfTable_del(struct m3uaAspAfTable_data *thedata)
{
	struct m3uaAspAfTable_data *StorageDel;

	DEBUGMSGTL(("m3uaAspAfTable", "deleting data...  "));
	if ((StorageDel = thedata) != NULL) {
		struct header_complex_index *hciptr;

		if ((hciptr = header_complex_find_entry(m3uaAspAfTableStorage, StorageDel)) != NULL)
			header_complex_extract_entry(&m3uaAspAfTableStorage, hciptr);
	}
	DEBUGMSGTL(("m3uaAspAfTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void parse_m3uaAspAfTable(const char *token, char *line)
 * @param token token used within the configuration file.
 * @param line line from configuration file matching the token.
 * @brief parse configuration file for m3uaAspAfTable entries.
 * This callback is called by UCD-SNMP when it prases a configuration file and finds a configuration
 * file line for the registsred token (in this case m3uaAspAfTable).  This routine is invoked by UCD-SNMP
 * to read the values of each row in the table from the configuration file.  Note that this
 * procedure may exist regardless of the persistence of the table.  If there are no configured
 * entries in the configuration table, this function will simply not be called.
 */
void
parse_m3uaAspAfTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspAfTable_data *StorageTmp = m3uaAspAfTable_create();

	DEBUGMSGTL(("m3uaAspAfTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	/* XXX: remove individual columns if not persistent */
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgpIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAfAsState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAfAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAfOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspAfProceduralStatus, &StorageTmp->m3uaAspAfProceduralStatusLen);
	if (StorageTmp->m3uaAspAfProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspAfProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAfUsageState, &tmpsize);
	m3uaAspAfTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspAfTable", "done.\n"));
}

/*
 * store_m3uaAspAfTable(): store configuraiton file for m3uaAspAfTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspAfTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspAfTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspAfTable", "storing data...  "));
	refresh_m3uaAspAfTable();
	(void) tmpsize;
	for (hcindex = m3uaAspAfTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspAfTable_data *) hcindex->data;
		/* XXX: comment entire section if row not persistent */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaAspAfTable ");
			cptr = line + strlen(line);
			/* XXX: remove individual columns if not persistent */
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgpIndex, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAfAsState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAfAdministrativeState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAfOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspAfProceduralStatus, &StorageTmp->m3uaAspAfProceduralStatusLen);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAfUsageState, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaAspAfTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * @fn void refresh_m3uaAspTable(void)
 * @brief refresh the scalar values of the m3uaAspTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspTable(void)
{
	if (m3uaAspTable_refresh == 0)
		return;
	m3uaAspTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspTable_row(struct m3uaAspTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspTable_row(struct m3uaAspTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspTable_request == sa_request)
		return;
	StorageTmp->m3uaAspTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPNAME:
		*write_method = write_m3uaAspName;
		*var_len = StorageTmp->m3uaAspNameLen;
		return (u_char *) StorageTmp->m3uaAspName;
	case M3UAASPNAME:
		*write_method = write_m3uaAspName;
		*var_len = StorageTmp->m3uaAspNameLen;
		return (u_char *) StorageTmp->m3uaAspName;
	case M3UAASPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspAdministrativeState);
		return (u_char *) &StorageTmp->m3uaAspAdministrativeState;
	case M3UAASPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspAdministrativeState);
		return (u_char *) &StorageTmp->m3uaAspAdministrativeState;
	case M3UAASPCAPABILITIES:
		*write_method = write_m3uaAspCapabilities;
		*var_len = StorageTmp->m3uaAspCapabilitiesLen;
		return (u_char *) StorageTmp->m3uaAspCapabilities;
	case M3UAASPIDPOLICY:
		*write_method = write_m3uaAspIdPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspIdPolicy);
		return (u_char *) &StorageTmp->m3uaAspIdPolicy;
	case M3UAASPREGISTRATIONPOLICY:
		*write_method = write_m3uaAspRegistrationPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspRegistrationPolicy);
		return (u_char *) &StorageTmp->m3uaAspRegistrationPolicy;
	case M3UAASPASSOCIATIONPOLICY:
		*write_method = write_m3uaAspAssociationPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspAssociationPolicy);
		return (u_char *) &StorageTmp->m3uaAspAssociationPolicy;
	case M3UAASPSTATUS:
		*write_method = write_m3uaAspStatus;
		*var_len = sizeof(StorageTmp->m3uaAspStatus);
		return (u_char *) &StorageTmp->m3uaAspStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspAgTable(void)
 * @brief refresh the scalar values of the m3uaAspAgTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspAgTable(void)
{
	if (m3uaAspAgTable_refresh == 0)
		return;
	m3uaAspAgTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspAgTable_row(struct m3uaAspAgTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspAgTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspAgTable_row(struct m3uaAspAgTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspAgTable_request == sa_request)
		return;
	StorageTmp->m3uaAspAgTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspAgTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspAgTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspAgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspAgTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspAgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspAgTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspAgTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPAGPROTOCOLVERSION:
		*write_method = write_m3uaAspAgProtocolVersion;
		*var_len = StorageTmp->m3uaAspAgProtocolVersionLen;
		return (u_char *) StorageTmp->m3uaAspAgProtocolVersion;
	case M3UAASPAGOPTIONS:
		*write_method = write_m3uaAspAgOptions;
		*var_len = StorageTmp->m3uaAspAgOptionsLen;
		return (u_char *) StorageTmp->m3uaAspAgOptions;
	case M3UAASPAGREGISTRATIONPOLICY:
		*write_method = write_m3uaAspAgRegistrationPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspAgRegistrationPolicy);
		return (u_char *) &StorageTmp->m3uaAspAgRegistrationPolicy;
	case M3UAASPAGASPIDPOLICY:
		*write_method = write_m3uaAspAgAspIdPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspAgAspIdPolicy);
		return (u_char *) &StorageTmp->m3uaAspAgAspIdPolicy;
	case M3UAASPAGASPPROTOCOLPAYLOADID:
		*write_method = write_m3uaAspAgAspProtocolPayloadId;
		*var_len = sizeof(StorageTmp->m3uaAspAgAspProtocolPayloadId);
		return (u_char *) &StorageTmp->m3uaAspAgAspProtocolPayloadId;
	case M3UAASPAGIPPORT:
		*write_method = write_m3uaAspAgIpPort;
		*var_len = StorageTmp->m3uaAspAgIpPort;
		return (u_char *) StorageTmp->m3uaAspAgIpPort;
	case M3UAASPAGMINOSTREAMS:
		*write_method = write_m3uaAspAgMinOstreams;
		*var_len = sizeof(StorageTmp->m3uaAspAgMinOstreams);
		return (u_char *) &StorageTmp->m3uaAspAgMinOstreams;
	case M3UAASPAGMAXISTREAMS:
		*write_method = write_m3uaAspAgMaxIstreams;
		*var_len = sizeof(StorageTmp->m3uaAspAgMaxIstreams);
		return (u_char *) &StorageTmp->m3uaAspAgMaxIstreams;
	case M3UAASPAGTIMERT7:
		*write_method = write_m3uaAspAgTimerT7;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT7);
		return (u_char *) &StorageTmp->m3uaAspAgTimerT7;
	case M3UAASPAGTIMERT19:
		*write_method = write_m3uaAspAgTimerT19;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT19);
		return (u_char *) &StorageTmp->m3uaAspAgTimerT19;
	case M3UAASPAGTIMERT21:
		*write_method = write_m3uaAspAgTimerT21;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT21);
		return (u_char *) &StorageTmp->m3uaAspAgTimerT21;
	case M3UAASPAGTIMERT25A:
		*write_method = write_m3uaAspAgTimerT25A;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT25A);
		return (u_char *) &StorageTmp->m3uaAspAgTimerT25A;
	case M3UAASPAGTIMERT28A:
		*write_method = write_m3uaAspAgTimerT28A;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT28A);
		return (u_char *) &StorageTmp->m3uaAspAgTimerT28A;
	case M3UAASPAGTIMERT29A:
		*write_method = write_m3uaAspAgTimerT29A;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT29A);
		return (u_char *) &StorageTmp->m3uaAspAgTimerT29A;
	case M3UAASPAGTIMERT30A:
		*write_method = write_m3uaAspAgTimerT30A;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT30A);
		return (u_char *) &StorageTmp->m3uaAspAgTimerT30A;
	case M3UAASPAGSTATUS:
		*write_method = write_m3uaAspAgStatus;
		*var_len = sizeof(StorageTmp->m3uaAspAgStatus);
		return (u_char *) &StorageTmp->m3uaAspAgStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspSgTable(void)
 * @brief refresh the scalar values of the m3uaAspSgTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspSgTable(void)
{
	if (m3uaAspSgTable_refresh == 0)
		return;
	m3uaAspSgTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspSgTable_row(struct m3uaAspSgTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspSgTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspSgTable_row(struct m3uaAspSgTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspSgTable_request == sa_request)
		return;
	StorageTmp->m3uaAspSgTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspSgTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspSgTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspSgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspSgTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspSgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspSgTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspSgTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPSGNAME:
		*write_method = write_m3uaAspSgName;
		*var_len = StorageTmp->m3uaAspSgNameLen;
		return (u_char *) StorageTmp->m3uaAspSgName;
	case M3UAASPSGADMINISTRATIVESTATE:
		*write_method = write_m3uaAspSgAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspSgAdministrativeState);
		return (u_char *) &StorageTmp->m3uaAspSgAdministrativeState;
	case M3UAASPSGOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgOperationalState);
		return (u_char *) &StorageTmp->m3uaAspSgOperationalState;
	case M3UAASPSGPROCEDUREALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspSgProcedurealStatusLen;
		return (u_char *) StorageTmp->m3uaAspSgProcedurealStatus;
	case M3UAASPSGUSGAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgUsgageState);
		return (u_char *) &StorageTmp->m3uaAspSgUsgageState;
	case M3UAASPSGASPSTATE:
		*write_method = write_m3uaAspSgAspState;
		*var_len = sizeof(StorageTmp->m3uaAspSgAspState);
		return (u_char *) &StorageTmp->m3uaAspSgAspState;
	case M3UAASPSGMAXINITRETRANS:
		*write_method = write_m3uaAspSgMaxInitRetrans;
		*var_len = sizeof(StorageTmp->m3uaAspSgMaxInitRetrans);
		return (u_char *) &StorageTmp->m3uaAspSgMaxInitRetrans;
	case M3UAASPSGMAXPATHRETRANS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgMaxPathRetrans);
		return (u_char *) &StorageTmp->m3uaAspSgMaxPathRetrans;
	case M3UAASPSGMAXLIFETIME:
		*write_method = write_m3uaAspSgMaxLifeTime;
		*var_len = sizeof(StorageTmp->m3uaAspSgMaxLifeTime);
		return (u_char *) &StorageTmp->m3uaAspSgMaxLifeTime;
	case M3UAASPSGTIMERT1:
		*write_method = write_m3uaAspSgTimerT1;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT1);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT1;
	case M3UAASPSGTIMERT2:
		*write_method = write_m3uaAspSgTimerT2;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT2);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT2;
	case M3UAASPSGTIMERT3:
		*write_method = write_m3uaAspSgTimerT3;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT3);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT3;
	case M3UAASPSGTIMERT4:
		*write_method = write_m3uaAspSgTimerT4;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT4);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT4;
	case M3UAASPSGTIMERT5:
		*write_method = write_m3uaAspSgTimerT5;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT5);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT5;
	case M3UAASPSGTIMERT5:
		*write_method = write_m3uaAspSgTimerT5;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT5);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT5;
	case M3UAASPSGTIMERT19A:
		*write_method = write_m3uaAspSgTimerT19A;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT19A);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT19A;
	case M3UAASPSGTIMERT24:
		*write_method = write_m3uaAspSgTimerT24;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT24);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT24;
	case M3UAASPSGTIMERT31A:
		*write_method = write_m3uaAspSgTimerT31A;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT31A);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT31A;
	case M3UAASPSGTIMERT32A:
		*write_method = write_m3uaAspSgTimerT32A;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT32A);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT32A;
	case M3UAASPSGTIMERT33A:
		*write_method = write_m3uaAspSgTimerT33A;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT33A);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT33A;
	case M3UAASPSGTIMERT34A:
		*write_method = write_m3uaAspSgTimerT34A;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT34A);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT34A;
	case M3UAASPSGTIMERT1T:
		*write_method = write_m3uaAspSgTimerT1T;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT1T);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT1T;
	case M3UAASPSGTIMERT2T:
		*write_method = write_m3uaAspSgTimerT2T;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT2T);
		return (u_char *) &StorageTmp->m3uaAspSgTimerT2T;
	case M3UAASPSGSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgStatus);
		return (u_char *) &StorageTmp->m3uaAspSgStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspSgpTable(void)
 * @brief refresh the scalar values of the m3uaAspSgpTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspSgpTable(void)
{
	if (m3uaAspSgpTable_refresh == 0)
		return;
	m3uaAspSgpTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspSgpTable_row(struct m3uaAspSgpTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspSgpTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspSgpTable_row(struct m3uaAspSgpTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspSgpTable_request == sa_request)
		return;
	StorageTmp->m3uaAspSgpTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspSgpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspSgpTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspSgpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspSgpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspSgpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspSgpTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspSgpTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPSGPNAME:
		*write_method = write_m3uaAspSgpName;
		*var_len = StorageTmp->m3uaAspSgpNameLen;
		return (u_char *) StorageTmp->m3uaAspSgpName;
	case M3UAASPSGPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspSgpAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspSgpAdministrativeState);
		return (u_char *) &StorageTmp->m3uaAspSgpAdministrativeState;
	case M3UAASPSGPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspSgpProceduralStatusLen;
		return (u_char *) StorageTmp->m3uaAspSgpProceduralStatus;
	case M3UAASPSGPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgpOperationalState);
		return (u_char *) &StorageTmp->m3uaAspSgpOperationalState;
	case M3UAASPSGPUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgpUsageState);
		return (u_char *) &StorageTmp->m3uaAspSgpUsageState;
	case M3UAASPSGPASPSTATE:
		*write_method = write_m3uaAspSgpAspState;
		*var_len = sizeof(StorageTmp->m3uaAspSgpAspState);
		return (u_char *) &StorageTmp->m3uaAspSgpAspState;
	case M3UAASPSGPPRIMARYADDRESS:
		*write_method = write_m3uaAspSgpPrimaryAddress;
		*var_len = StorageTmp->m3uaAspSgpPrimaryAddressLen;
		return (u_char *) StorageTmp->m3uaAspSgpPrimaryAddress;
	case M3UAASPSGPHOSTNAME:
		*write_method = write_m3uaAspSgpHostName;
		*var_len = StorageTmp->m3uaAspSgpHostNameLen;
		return (u_char *) StorageTmp->m3uaAspSgpHostName;
	case M3UAASPSGPSTATUS:
		*write_method = write_m3uaAspSgpStatus;
		*var_len = sizeof(StorageTmp->m3uaAspSgpStatus);
		return (u_char *) &StorageTmp->m3uaAspSgpStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspSpTable(void)
 * @brief refresh the scalar values of the m3uaAspSpTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspSpTable(void)
{
	if (m3uaAspSpTable_refresh == 0)
		return;
	m3uaAspSpTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspSpTable_row(struct m3uaAspSpTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspSpTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspSpTable_row(struct m3uaAspSpTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspSpTable_request == sa_request)
		return;
	StorageTmp->m3uaAspSpTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspSpTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspSpTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspSpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspSpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspSpTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspSpTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPSPNAME:
		*write_method = write_m3uaAspSpName;
		*var_len = StorageTmp->m3uaAspSpNameLen;
		return (u_char *) StorageTmp->m3uaAspSpName;
	case M3UAASPSPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSpOperationalState);
		return (u_char *) &StorageTmp->m3uaAspSpOperationalState;
	case M3UAASPSPUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSpUsageState);
		return (u_char *) &StorageTmp->m3uaAspSpUsageState;
	case M3UAASPSPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspSpAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspSpAdministrativeState);
		return (u_char *) &StorageTmp->m3uaAspSpAdministrativeState;
	case M3UAASPSPALARMSTATUS:
		*write_method = write_m3uaAspSpAlarmStatus;
		*var_len = StorageTmp->m3uaAspSpAlarmStatusLen;
		return (u_char *) StorageTmp->m3uaAspSpAlarmStatus;
	case M3UAASPSPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspSpProceduralStatusLen;
		return (u_char *) StorageTmp->m3uaAspSpProceduralStatus;
	case M3UAASPSPAVAILABILTYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspSpAvailabiltyStatusLen;
		return (u_char *) StorageTmp->m3uaAspSpAvailabiltyStatus;
	case M3UAASPSPPOINTCODE:
		*write_method = write_m3uaAspSpPointCode;
		*var_len = StorageTmp->m3uaAspSpPointCodeLen;
		return (u_char *) StorageTmp->m3uaAspSpPointCode;
	case M3UAASPSPTIMERT1R:
		*write_method = write_m3uaAspSpTimerT1R;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT1R);
		return (u_char *) &StorageTmp->m3uaAspSpTimerT1R;
	case M3UAASPSPTIMERT18:
		*write_method = write_m3uaAspSpTimerT18;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT18);
		return (u_char *) &StorageTmp->m3uaAspSpTimerT18;
	case M3UAASPSPTIMERT20:
		*write_method = write_m3uaAspSpTimerT20;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT20);
		return (u_char *) &StorageTmp->m3uaAspSpTimerT20;
	case M3UAASPSPTIMERT22A:
		*write_method = write_m3uaAspSpTimerT22A;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT22A);
		return (u_char *) &StorageTmp->m3uaAspSpTimerT22A;
	case M3UAASPSPTIMERT23A:
		*write_method = write_m3uaAspSpTimerT23A;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT23A);
		return (u_char *) &StorageTmp->m3uaAspSpTimerT23A;
	case M3UAASPSPTIMERT24A:
		*write_method = write_m3uaAspSpTimerT24A;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT24A);
		return (u_char *) &StorageTmp->m3uaAspSpTimerT24A;
	case M3UAASPSPTIMERT26A:
		*write_method = write_m3uaAspSpTimerT26A;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT26A);
		return (u_char *) &StorageTmp->m3uaAspSpTimerT26A;
	case M3UAASPSPTIMERT27A:
		*write_method = write_m3uaAspSpTimerT27A;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT27A);
		return (u_char *) &StorageTmp->m3uaAspSpTimerT27A;
	case M3UAASPSPSTATUS:
		*write_method = write_m3uaAspSpStatus;
		*var_len = sizeof(StorageTmp->m3uaAspSpStatus);
		return (u_char *) &StorageTmp->m3uaAspSpStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspMtTable(void)
 * @brief refresh the scalar values of the m3uaAspMtTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspMtTable(void)
{
	if (m3uaAspMtTable_refresh == 0)
		return;
	m3uaAspMtTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspMtTable_row(struct m3uaAspMtTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspMtTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspMtTable_row(struct m3uaAspMtTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspMtTable_request == sa_request)
		return;
	StorageTmp->m3uaAspMtTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspMtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspMtTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspMtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspMtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspMtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspMtTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspMtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspMtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPMTNAME:
		*write_method = write_m3uaAspMtName;
		*var_len = StorageTmp->m3uaAspMtNameLen;
		return (u_char *) StorageTmp->m3uaAspMtName;
	case M3UAASPMTADMINISTRATIVESTATE:
		*write_method = write_m3uaAspMtAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspMtAdministrativeState);
		return (u_char *) &StorageTmp->m3uaAspMtAdministrativeState;
	case M3UAASPMTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspMtOperationalState);
		return (u_char *) &StorageTmp->m3uaAspMtOperationalState;
	case M3UAASPMTPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspMtProceduralStatusLen;
		return (u_char *) StorageTmp->m3uaAspMtProceduralStatus;
	case M3UAASPMTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspMtUsageState);
		return (u_char *) &StorageTmp->m3uaAspMtUsageState;
	case M3UAASPMTASSTATE:
		*write_method = write_m3uaAspMtAsState;
		*var_len = sizeof(StorageTmp->m3uaAspMtAsState);
		return (u_char *) &StorageTmp->m3uaAspMtAsState;
	case M3UAASPMTSTATUS:
		*write_method = write_m3uaAspMtStatus;
		*var_len = sizeof(StorageTmp->m3uaAspMtStatus);
		return (u_char *) &StorageTmp->m3uaAspMtStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspRsTable(void)
 * @brief refresh the scalar values of the m3uaAspRsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspRsTable(void)
{
	if (m3uaAspRsTable_refresh == 0)
		return;
	m3uaAspRsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspRsTable_row(struct m3uaAspRsTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspRsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspRsTable_row(struct m3uaAspRsTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspRsTable_request == sa_request)
		return;
	StorageTmp->m3uaAspRsTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspRsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspRsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspRsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspRsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspRsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspRsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspRsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPRSNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRsNameLen;
		return (u_char *) StorageTmp->m3uaAspRsName;
	case M3UAASPRSREMOTEPOINTCODE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRsRemotePointCodeLen;
		return (u_char *) StorageTmp->m3uaAspRsRemotePointCode;
	case M3UAASPRSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsOperationalState);
		return (u_char *) &StorageTmp->m3uaAspRsOperationalState;
	case M3UAASPRSADMINISTRATIVESTATE:
		*write_method = write_m3uaAspRsAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspRsAdministrativeState);
		return (u_char *) &StorageTmp->m3uaAspRsAdministrativeState;
	case M3UAASPRSUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsUsageState);
		return (u_char *) &StorageTmp->m3uaAspRsUsageState;
	case M3UAASPRSALARMSTATUS:
		*write_method = write_m3uaAspRsAlarmStatus;
		*var_len = StorageTmp->m3uaAspRsAlarmStatusLen;
		return (u_char *) StorageTmp->m3uaAspRsAlarmStatus;
	case M3UAASPRSPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRsProceduralStatusLen;
		return (u_char *) StorageTmp->m3uaAspRsProceduralStatus;
	case M3UAASPRSTIMERT8:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsTimerT8);
		return (u_char *) &StorageTmp->m3uaAspRsTimerT8;
	case M3UAASPRSTIMERT11:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsTimerT11);
		return (u_char *) &StorageTmp->m3uaAspRsTimerT11;
	case M3UAASPRSTIMERT15:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsTimerT15);
		return (u_char *) &StorageTmp->m3uaAspRsTimerT15;
	case M3UAASPRSTIMERT16:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsTimerT16);
		return (u_char *) &StorageTmp->m3uaAspRsTimerT16;
	case M3UAASPRSTIMERT18A:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsTimerT18A);
		return (u_char *) &StorageTmp->m3uaAspRsTimerT18A;
	case M3UAASPRSOPTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRsOptionsLen;
		return (u_char *) StorageTmp->m3uaAspRsOptions;
	case M3UAASPRSAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRsAvailabilityStatusLen;
		return (u_char *) StorageTmp->m3uaAspRsAvailabilityStatus;
	case M3UAASPRSCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsCongestionLevel);
		return (u_char *) &StorageTmp->m3uaAspRsCongestionLevel;
	case M3UAASPRSSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsStatus);
		return (u_char *) &StorageTmp->m3uaAspRsStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspRlTable(void)
 * @brief refresh the scalar values of the m3uaAspRlTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspRlTable(void)
{
	if (m3uaAspRlTable_refresh == 0)
		return;
	m3uaAspRlTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspRlTable_row(struct m3uaAspRlTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspRlTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspRlTable_row(struct m3uaAspRlTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspRlTable_request == sa_request)
		return;
	StorageTmp->m3uaAspRlTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspRlTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspRlTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspRlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspRlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspRlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspRlTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspRlTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (u_char *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (u_char *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (u_char *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (u_char *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (u_char *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (u_char *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (u_char *) &StorageTmp->m3uaAspRlCost;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspRtTable(void)
 * @brief refresh the scalar values of the m3uaAspRtTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspRtTable(void)
{
	if (m3uaAspRtTable_refresh == 0)
		return;
	m3uaAspRtTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspRtTable_row(struct m3uaAspRtTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspRtTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspRtTable_row(struct m3uaAspRtTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspRtTable_request == sa_request)
		return;
	StorageTmp->m3uaAspRtTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspRtTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspRtTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspRtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspRtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspRtTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspRtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspRtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPRTCOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtCost);
		return (u_char *) &StorageTmp->m3uaAspRtCost;
	case M3UAASPRTTIMERT6:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtTimerT6);
		return (u_char *) &StorageTmp->m3uaAspRtTimerT6;
	case M3UAASPRTTIMERT10:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtTimerT10);
		return (u_char *) &StorageTmp->m3uaAspRtTimerT10;
	case M3UAASPRTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRtAvailabilityStatusLen;
		return (u_char *) StorageTmp->m3uaAspRtAvailabilityStatus;
	case M3UAASPRTADMINSTRATIVESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtAdminstrativeState);
		return (u_char *) &StorageTmp->m3uaAspRtAdminstrativeState;
	case M3UAASPRTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtOperationalState);
		return (u_char *) &StorageTmp->m3uaAspRtOperationalState;
	case M3UAASPRTPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRtProceduralStatusLen;
		return (u_char *) StorageTmp->m3uaAspRtProceduralStatus;
	case M3UAASPRTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtUsageState);
		return (u_char *) &StorageTmp->m3uaAspRtUsageState;
	case M3UAASPRTSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtStatus);
		return (u_char *) &StorageTmp->m3uaAspRtStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspRcTable(void)
 * @brief refresh the scalar values of the m3uaAspRcTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspRcTable(void)
{
	if (m3uaAspRcTable_refresh == 0)
		return;
	m3uaAspRcTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspRcTable_row(struct m3uaAspRcTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspRcTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspRcTable_row(struct m3uaAspRcTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspRcTable_request == sa_request)
		return;
	StorageTmp->m3uaAspRcTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspRcTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspRcTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspRcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspRcTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspRcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspRcTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspRcTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspRcTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPRCVALUE:
		*write_method = write_m3uaAspRcValue;
		*var_len = sizeof(StorageTmp->m3uaAspRcValue);
		return (u_char *) &StorageTmp->m3uaAspRcValue;
	case M3UAASPRCREGSTRATIONPOLICY:
		*write_method = write_m3uaAspRcRegstrationPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspRcRegstrationPolicy);
		return (u_char *) &StorageTmp->m3uaAspRcRegstrationPolicy;
	case M3UAASPRCTRAFFICMODE:
		*write_method = write_m3uaAspRcTrafficMode;
		*var_len = StorageTmp->m3uaAspRcTrafficModeLen;
		return (u_char *) StorageTmp->m3uaAspRcTrafficMode;
	case M3UAASPRCSTATUS:
		*write_method = write_m3uaAspRcStatus;
		*var_len = sizeof(StorageTmp->m3uaAspRcStatus);
		return (u_char *) &StorageTmp->m3uaAspRcStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspAsTable(void)
 * @brief refresh the scalar values of the m3uaAspAsTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspAsTable(void)
{
	if (m3uaAspAsTable_refresh == 0)
		return;
	m3uaAspAsTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspAsTable_row(struct m3uaAspAsTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspAsTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspAsTable_row(struct m3uaAspAsTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspAsTable_request == sa_request)
		return;
	StorageTmp->m3uaAspAsTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspAsTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspAsTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspAsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspAsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspAsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspAsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspAsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPASASSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAsAsState);
		return (u_char *) &StorageTmp->m3uaAspAsAsState;
	case M3UAASPASOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAsOperationalState);
		return (u_char *) &StorageTmp->m3uaAspAsOperationalState;
	case M3UAASPASPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspAsProceduralStatusLen;
		return (u_char *) StorageTmp->m3uaAspAsProceduralStatus;
	case M3UAASPASUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAsUsageState);
		return (u_char *) &StorageTmp->m3uaAspAsUsageState;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn void refresh_m3uaAspAfTable(void)
 * @brief refresh the scalar values of the m3uaAspAfTable.
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS subsystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaAspAfTable(void)
{
	if (m3uaAspAfTable_refresh == 0)
		return;
	m3uaAspAfTable_refresh = 0;
	/* XXX: Here, update the table as required... */
}

/**
 * @fn void refresh_m3uaAspAfTable_row(struct m3uaAspAfTable_data *StorageTmp)
 * @brief refresh the contents of the m3uaAspAfTable row.
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaAspAfTable_row(struct m3uaAspAfTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspAfTable_request == sa_request)
		return;
	StorageTmp->m3uaAspAfTable_request = sa_request;
}

/**
 * @fn u_char *var_m3uaAspAfTable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
 * @brief locate variables in m3uaAspAfTable.
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaAspMIB above.
 */
u_char *
var_m3uaAspAfTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspAfTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspAfTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspAfTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspAfTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspAfTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UAASPAFASSTATE:
		*write_method = write_m3uaAspAfAsState;
		*var_len = sizeof(StorageTmp->m3uaAspAfAsState);
		return (u_char *) &StorageTmp->m3uaAspAfAsState;
	case M3UAASPAFADMINISTRATIVESTATE:
		*write_method = write_m3uaAspAfAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspAfAdministrativeState);
		return (u_char *) &StorageTmp->m3uaAspAfAdministrativeState;
	case M3UAASPAFOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAfOperationalState);
		return (u_char *) &StorageTmp->m3uaAspAfOperationalState;
	case M3UAASPAFPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspAfProceduralStatusLen;
		return (u_char *) StorageTmp->m3uaAspAfProceduralStatus;
	case M3UAASPAFUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAfUsageState);
		return (u_char *) &StorageTmp->m3uaAspAfUsageState;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * @fn int write_m3uaAspName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspName;
		old_length = StorageTmp->m3uaAspNameLen;
		StorageTmp->m3uaAspName = string;
		StorageTmp->m3uaAspNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspName = old_value;
		StorageTmp->m3uaAspNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspName;
		old_length = StorageTmp->m3uaAspNameLen;
		StorageTmp->m3uaAspName = string;
		StorageTmp->m3uaAspNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspName = old_value;
		StorageTmp->m3uaAspNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPADMINISTRATIVESTATE_LOCKED:
		case M3UAASPADMINISTRATIVESTATE_UNLOCKED:
		case M3UAASPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAdministrativeState;
		StorageTmp->m3uaAspAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPADMINISTRATIVESTATE_LOCKED:
		case M3UAASPADMINISTRATIVESTATE_UNLOCKED:
		case M3UAASPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		switch (set_value) {
		case M3UAASPADMINISTRATIVESTATE_LOCKED:
		case M3UAASPADMINISTRATIVESTATE_UNLOCKED:
		case M3UAASPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAdministrativeState;
		StorageTmp->m3uaAspAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspCapabilities(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspCapabilities entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspCapabilities: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspCapabilities not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((9 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspCapabilities: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (9 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspCapabilities: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspCapabilities;
		old_length = StorageTmp->m3uaAspCapabilitiesLen;
		StorageTmp->m3uaAspCapabilities = string;
		StorageTmp->m3uaAspCapabilitiesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspCapabilities = old_value;
		StorageTmp->m3uaAspCapabilitiesLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspIdPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspIdPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspIdPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPIDPOLICY_UNKNOWN:
		case M3UAASPIDPOLICY_PERMITTED:
		case M3UAASPIDPOLICY_REQUIRED:
		case M3UAASPIDPOLICY_FORBIDDEN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspIdPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspIdPolicy;
		StorageTmp->m3uaAspIdPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspIdPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRegistrationPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRegistrationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPREGISTRATIONPOLICY_UNKNOWN:
		case M3UAASPREGISTRATIONPOLICY_FORBIDDEN:
		case M3UAASPREGISTRATIONPOLICY_PERMITTED:
		case M3UAASPREGISTRATIONPOLICY_REQUIRED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRegistrationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRegistrationPolicy;
		StorageTmp->m3uaAspRegistrationPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRegistrationPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAssociationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAssociationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAssociationPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAssociationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAssociationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAssociationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPASSOCIATIONPOLICY_UNKNOWN:
		case M3UAASPASSOCIATIONPOLICY_ALWAYS:
		case M3UAASPASSOCIATIONPOLICY_ONDEMAND:
		case M3UAASPASSOCIATIONPOLICY_OTHER:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAssociationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAssociationPolicy;
		StorageTmp->m3uaAspAssociationPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAssociationPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgProtocolVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgProtocolVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgProtocolVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgProtocolVersion: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgProtocolVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgProtocolVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgProtocolVersion;
		old_length = StorageTmp->m3uaAspAgProtocolVersionLen;
		StorageTmp->m3uaAspAgProtocolVersion = objid;
		StorageTmp->m3uaAspAgProtocolVersionLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgProtocolVersion = old_value;
		StorageTmp->m3uaAspAgProtocolVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgOptions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgOptions: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((9 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (9 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgOptions: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgOptions;
		old_length = StorageTmp->m3uaAspAgOptionsLen;
		StorageTmp->m3uaAspAgOptions = string;
		StorageTmp->m3uaAspAgOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgOptions = old_value;
		StorageTmp->m3uaAspAgOptionsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgRegistrationPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgRegistrationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPAGREGISTRATIONPOLICY_UNKNOWN:
		case M3UAASPAGREGISTRATIONPOLICY_FORBIDDEN:
		case M3UAASPAGREGISTRATIONPOLICY_PERMITTED:
		case M3UAASPAGREGISTRATIONPOLICY_REQUIRED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgRegistrationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgRegistrationPolicy;
		StorageTmp->m3uaAspAgRegistrationPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgRegistrationPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgAspIdPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgAspIdPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgAspIdPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPAGASPIDPOLICY_UNKNOWN:
		case M3UAASPAGASPIDPOLICY_PERMITTED:
		case M3UAASPAGASPIDPOLICY_REQUIRED:
		case M3UAASPAGASPIDPOLICY_FORBIDDEN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgAspIdPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgAspIdPolicy;
		StorageTmp->m3uaAspAgAspIdPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgAspIdPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgAspProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgAspProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgAspProtocolPayloadId entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgAspProtocolPayloadId: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgAspProtocolPayloadId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgAspProtocolPayloadId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..0 3..3 */
		if (set_value != 0 && set_value != 3) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgAspProtocolPayloadId: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgAspProtocolPayloadId;
		StorageTmp->m3uaAspAgAspProtocolPayloadId = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgAspProtocolPayloadId = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgIpPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgIpPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgIpPort entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgIpPort: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type !=) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgIpPort not \n");
			return SNMP_ERR_WRONGTYPE;
		}
		if () {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgIpPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2905 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in for you to use, and you have
				   just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgMinOstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgMinOstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgMinOstreams entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgMinOstreams: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgMinOstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgMinOstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 32 */
		/* Note: ranges 2..16384 */
		if ((2 > set_value || set_value > 16384)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgMinOstreams: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgMinOstreams;
		StorageTmp->m3uaAspAgMinOstreams = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgMinOstreams = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgMaxIstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgMaxIstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgMaxIstreams entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgMaxIstreams: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgMaxIstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgMaxIstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 2..16384 */
		if ((2 > set_value || set_value > 16384)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgMaxIstreams: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgMaxIstreams;
		StorageTmp->m3uaAspAgMaxIstreams = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgMaxIstreams = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgTimerT7(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT7: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT7: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgTimerT7;
		StorageTmp->m3uaAspAgTimerT7 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT7 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgTimerT19(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgTimerT19(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT19 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT19: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT19 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT19: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT19: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgTimerT19;
		StorageTmp->m3uaAspAgTimerT19 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT19 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgTimerT21(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgTimerT21(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT21 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT21: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT21 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT21: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT21: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgTimerT21;
		StorageTmp->m3uaAspAgTimerT21 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT21 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgTimerT25A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgTimerT25A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT25A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT25A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT25A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT25A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT25A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgTimerT25A;
		StorageTmp->m3uaAspAgTimerT25A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT25A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgTimerT28A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgTimerT28A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT28A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT28A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT28A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT28A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT28A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgTimerT28A;
		StorageTmp->m3uaAspAgTimerT28A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT28A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgTimerT29A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgTimerT29A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT29A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT29A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT29A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT29A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT29A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgTimerT29A;
		StorageTmp->m3uaAspAgTimerT29A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT29A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgTimerT30A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAgTimerT30A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT30A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspAgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT30A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT30A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT30A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT30A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAgTimerT30A;
		StorageTmp->m3uaAspAgTimerT30A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT30A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgName;
		old_length = StorageTmp->m3uaAspSgNameLen;
		StorageTmp->m3uaAspSgName = string;
		StorageTmp->m3uaAspSgNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgName = old_value;
		StorageTmp->m3uaAspSgNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case M3UAASPSGADMINISTRATIVESTATE_LOCKED:
		case M3UAASPSGADMINISTRATIVESTATE_UNLOCKED:
		case M3UAASPSGADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgAdministrativeState;
		StorageTmp->m3uaAspSgAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgAspState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgAspState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgAspState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgAspState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgAspState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgAspState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPSGASPSTATE_DOWN:
		case M3UAASPSGASPSTATE_INITIALIZING:
		case M3UAASPSGASPSTATE_TERMINATING:
		case M3UAASPSGASPSTATE_UP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgAspState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgAspState;
		StorageTmp->m3uaAspSgAspState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgAspState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgMaxInitRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgMaxInitRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgMaxInitRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgMaxInitRetrans: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgMaxInitRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgMaxInitRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgMaxInitRetrans;
		StorageTmp->m3uaAspSgMaxInitRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgMaxInitRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgMaxLifeTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgMaxLifeTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgMaxLifeTime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgMaxLifeTime: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgMaxLifeTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgMaxLifeTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgMaxLifeTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgMaxLifeTime;
		StorageTmp->m3uaAspSgMaxLifeTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgMaxLifeTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT1(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT1: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT1: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT1;
		StorageTmp->m3uaAspSgTimerT1 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT1 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT2(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT2: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 140 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT2: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT2;
		StorageTmp->m3uaAspSgTimerT2 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT2 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT3(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT3: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT3: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT3;
		StorageTmp->m3uaAspSgTimerT3 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT3 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT4(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT4: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT4: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT4;
		StorageTmp->m3uaAspSgTimerT4 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT4 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT5;
		StorageTmp->m3uaAspSgTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT5(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 80 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT5;
		StorageTmp->m3uaAspSgTimerT5 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT5 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT19A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT19A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT19A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT19A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT19A;
		StorageTmp->m3uaAspSgTimerT19A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT19A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT24(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT24(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT24 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT24: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT24 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT24: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT24: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT24;
		StorageTmp->m3uaAspSgTimerT24 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT24 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT31A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT31A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT31A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT31A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT31A;
		StorageTmp->m3uaAspSgTimerT31A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT31A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT32A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT32A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT32A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT32A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT32A;
		StorageTmp->m3uaAspSgTimerT32A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT32A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT33A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT33A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT33A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT33A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT33A;
		StorageTmp->m3uaAspSgTimerT33A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT33A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT34A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT34A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT34A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 500 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT34A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT34A;
		StorageTmp->m3uaAspSgTimerT34A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT34A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT1T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT1T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 800 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT1T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT1T;
		StorageTmp->m3uaAspSgTimerT1T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT1T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgTimerT2T(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT2T: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT2T: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgTimerT2T;
		StorageTmp->m3uaAspSgTimerT2T = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT2T = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgpName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgpName;
		old_length = StorageTmp->m3uaAspSgpNameLen;
		StorageTmp->m3uaAspSgpName = string;
		StorageTmp->m3uaAspSgpNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgpName = old_value;
		StorageTmp->m3uaAspSgpNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgpAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case M3UAASPSGPADMINISTRATIVESTATE_LOCKED:
		case M3UAASPSGPADMINISTRATIVESTATE_UNLOCKED:
		case M3UAASPSGPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgpAdministrativeState;
		StorageTmp->m3uaAspSgpAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgpAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgpAspState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgpAspState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgpAspState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpAspState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpAspState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpAspState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPSGPASPSTATE_DOWN:
		case M3UAASPSGPASPSTATE_INITIALIZING:
		case M3UAASPSGPASPSTATE_TERMINATING:
		case M3UAASPSGPASPSTATE_UP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpAspState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgpAspState;
		StorageTmp->m3uaAspSgpAspState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgpAspState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgpPrimaryAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgpPrimaryAddress(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgpPrimaryAddress entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpPrimaryAddress: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpPrimaryAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpPrimaryAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgpPrimaryAddress;
		old_length = StorageTmp->m3uaAspSgpPrimaryAddressLen;
		StorageTmp->m3uaAspSgpPrimaryAddress = string;
		StorageTmp->m3uaAspSgpPrimaryAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgpPrimaryAddress = old_value;
		StorageTmp->m3uaAspSgpPrimaryAddressLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgpHostName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSgpHostName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgpHostName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSgpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpHostName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpHostName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..255 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 255))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpHostName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSgpHostName;
		old_length = StorageTmp->m3uaAspSgpHostNameLen;
		StorageTmp->m3uaAspSgpHostName = string;
		StorageTmp->m3uaAspSgpHostNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgpHostName = old_value;
		StorageTmp->m3uaAspSgpHostNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpName;
		old_length = StorageTmp->m3uaAspSpNameLen;
		StorageTmp->m3uaAspSpName = string;
		StorageTmp->m3uaAspSpNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpName = old_value;
		StorageTmp->m3uaAspSpNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPSPADMINISTRATIVESTATE_LOCKED:
		case M3UAASPSPADMINISTRATIVESTATE_UNLOCKED:
		case M3UAASPSPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpAdministrativeState;
		StorageTmp->m3uaAspSpAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpAlarmStatus;
		old_length = StorageTmp->m3uaAspSpAlarmStatusLen;
		StorageTmp->m3uaAspSpAlarmStatus = string;
		StorageTmp->m3uaAspSpAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpAlarmStatus = old_value;
		StorageTmp->m3uaAspSpAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpPointCode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpPointCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpPointCode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 4..4 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || (var_val_len != 4)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpPointCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpPointCode;
		old_length = StorageTmp->m3uaAspSpPointCodeLen;
		StorageTmp->m3uaAspSpPointCode = string;
		StorageTmp->m3uaAspSpPointCodeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpPointCode = old_value;
		StorageTmp->m3uaAspSpPointCodeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpTimerT1R(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpTimerT1R(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT1R entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT1R: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT1R not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT1R: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT1R: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpTimerT1R;
		StorageTmp->m3uaAspSpTimerT1R = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT1R = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpTimerT18(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpTimerT18(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT18 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT18: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT18 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT18: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT18: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpTimerT18;
		StorageTmp->m3uaAspSpTimerT18 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT18 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpTimerT20(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpTimerT20(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT20 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT20: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT20 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT20: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT20: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpTimerT20;
		StorageTmp->m3uaAspSpTimerT20 = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT20 = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpTimerT22A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpTimerT22A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT22A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT22A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT22A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT22A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT22A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpTimerT22A;
		StorageTmp->m3uaAspSpTimerT22A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT22A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpTimerT23A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpTimerT23A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT23A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT23A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT23A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT23A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT23A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpTimerT23A;
		StorageTmp->m3uaAspSpTimerT23A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT23A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpTimerT24A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpTimerT24A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT24A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT24A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT24A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT24A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT24A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpTimerT24A;
		StorageTmp->m3uaAspSpTimerT24A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT24A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpTimerT26A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpTimerT26A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT26A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT26A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT26A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT26A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT26A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpTimerT26A;
		StorageTmp->m3uaAspSpTimerT26A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT26A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpTimerT27A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspSpTimerT27A(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT27A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspSpStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT27A: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT27A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT27A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT27A: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspSpTimerT27A;
		StorageTmp->m3uaAspSpTimerT27A = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT27A = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspMtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspMtName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspMtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspMtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspMtTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspMtStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtName: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspMtName;
		old_length = StorageTmp->m3uaAspMtNameLen;
		StorageTmp->m3uaAspMtName = string;
		StorageTmp->m3uaAspMtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspMtName = old_value;
		StorageTmp->m3uaAspMtNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspMtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspMtAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspMtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspMtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspMtTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspMtStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case M3UAASPMTADMINISTRATIVESTATE_LOCKED:
		case M3UAASPMTADMINISTRATIVESTATE_UNLOCKED:
		case M3UAASPMTADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspMtAdministrativeState;
		StorageTmp->m3uaAspMtAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspMtAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspMtAsState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspMtAsState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspMtTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspMtAsState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspMtTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspMtStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtAsState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtAsState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtAsState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case M3UAASPMTASSTATE_DOWN:
		case M3UAASPMTASSTATE_INITIALIZING:
		case M3UAASPMTASSTATE_TERMINATING:
		case M3UAASPMTASSTATE_INACTIVE:
		case M3UAASPMTASSTATE_ACTIVATING:
		case M3UAASPMTASSTATE_DEACTIVATING:
		case M3UAASPMTASSTATE_ACTIVE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtAsState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspMtAsState;
		StorageTmp->m3uaAspMtAsState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspMtAsState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRsAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRsTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspRsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsAdministrativeState: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPRSADMINISTRATIVESTATE_LOCKED:
		case M3UAASPRSADMINISTRATIVESTATE_UNLOCKED:
		case M3UAASPRSADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRsAdministrativeState;
		StorageTmp->m3uaAspRsAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRsAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRsAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaAspRsTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRsTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspRsStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsAlarmStatus: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (2 > var_val_len || var_val_len > SPRINT_MAX_LEN || var_val_len != ((4 >> 3) + 2)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len < 1 || *var_val != (8 - (4 & 0x07))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsAlarmStatus: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRsAlarmStatus;
		old_length = StorageTmp->m3uaAspRsAlarmStatusLen;
		StorageTmp->m3uaAspRsAlarmStatus = string;
		StorageTmp->m3uaAspRsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRsAlarmStatus = old_value;
		StorageTmp->m3uaAspRsAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRlCost(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRcValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRcValue(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static ulong old_value;
	struct m3uaAspRcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRcValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRcTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspRcStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcValue: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcValue not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRcValue;
		StorageTmp->m3uaAspRcValue = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRcValue = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRcRegstrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRcRegstrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspRcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRcRegstrationPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRcTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspRcStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcRegstrationPolicy: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcRegstrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcRegstrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPRCREGSTRATIONPOLICY_UNKNOWN:
		case M3UAASPRCREGSTRATIONPOLICY_FORBIDDEN:
		case M3UAASPRCREGSTRATIONPOLICY_PERMITTED:
		case M3UAASPRCREGSTRATIONPOLICY_REQUIRED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcRegstrationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRcRegstrationPolicy;
		StorageTmp->m3uaAspRcRegstrationPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRcRegstrationPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRcTrafficMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspRcTrafficMode(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct m3uaAspRcTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRcTrafficMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRcTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (statP == NULL) {
			/* have row but no column */
			switch (StorageTmp->m3uaAspRcStatus) {
			case RS_ACTIVE:
				/* cannot create non-existent column while active */
				snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcTrafficMode: but column non-existent\n");
				return SNMP_ERR_INCONSISTENTVALUE;
			case RS_NOTINSERVICE:
			case RS_NOTREADY:
				/* assume column can be created */
				break;
			}
		}
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcTrafficMode not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcTrafficMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspRcTrafficMode;
		old_length = StorageTmp->m3uaAspRcTrafficModeLen;
		StorageTmp->m3uaAspRcTrafficMode = objid;
		StorageTmp->m3uaAspRcTrafficModeLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRcTrafficMode = old_value;
		StorageTmp->m3uaAspRcTrafficModeLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAfAsState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAfAsState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAfTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAfAsState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAfTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAfAsState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAfAsState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPAFASSTATE_DOWN:
		case M3UAASPAFASSTATE_INITIALIZING:
		case M3UAASPAFASSTATE_TERMINATING:
		case M3UAASPAFASSTATE_INACTIVE:
		case M3UAASPAFASSTATE_ACTIVATING:
		case M3UAASPAFASSTATE_DEACTIVATING:
		case M3UAASPAFASSTATE_ACTIVE:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAfAsState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAfAsState;
		StorageTmp->m3uaAspAfAsState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAfAsState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAfAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Table row and column write routine.
 */
int
write_m3uaAspAfAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static long old_value;
	struct m3uaAspAfTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAfAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAfTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAfAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAfAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		switch (set_value) {
		case M3UAASPAFADMINISTRATIVESTATE_LOCKED:
		case M3UAASPAFADMINISTRATIVESTATE_UNLOCKED:
		case M3UAASPAFADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAfAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaAspAfAdministrativeState;
		StorageTmp->m3uaAspAfAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAfAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_m3uaAspStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaAspTable_data *StorageTmp = NULL;
	static struct m3uaAspTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaAspStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaAspTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaAspTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaAspIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaAspTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = m3uaAspTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaAspIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaAspTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaAspTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaAspStatus;
			StorageTmp->m3uaAspStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				m3uaAspTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			m3uaAspTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaAspStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaAspTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaAspTable_destroy(&StorageDel);
			/* m3uaAspTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspAgStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_m3uaAspAgStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static struct m3uaAspAgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspAgTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspAgTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaAspAgStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaAspAgTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaAspAgTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaAspAgIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaAspAgTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = m3uaAspAgTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaAspAgIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaAspAgTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaAspAgTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaAspAgStatus;
			StorageTmp->m3uaAspAgStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				m3uaAspAgTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			m3uaAspAgTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaAspAgStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaAspAgTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspAgStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspAgStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaAspAgTable_destroy(&StorageDel);
			/* m3uaAspAgTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_m3uaAspSgStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static struct m3uaAspSgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspSgTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspSgTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaAspSgStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaAspSgTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaAspSgTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaAspAgIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspSgIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaAspSgTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = m3uaAspSgTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaAspAgIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspSgIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaAspSgTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaAspSgTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaAspSgStatus;
			StorageTmp->m3uaAspSgStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				m3uaAspSgTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			m3uaAspSgTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaAspSgStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaAspSgTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspSgStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspSgStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaAspSgTable_destroy(&StorageDel);
			/* m3uaAspSgTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSgpStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_m3uaAspSgpStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	static struct m3uaAspSgpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspSgpTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspSgpTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaAspSgpStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaAspSgpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaAspSgpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaAspAgIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspSgIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspSgpIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaAspSgpTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = m3uaAspSgpTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaAspAgIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspSgIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspSgpIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaAspSgpTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaAspSgpTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaAspSgpStatus;
			StorageTmp->m3uaAspSgpStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				m3uaAspSgpTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			m3uaAspSgpTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaAspSgpStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaAspSgpTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspSgpStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspSgpStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaAspSgpTable_destroy(&StorageDel);
			/* m3uaAspSgpTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspSpStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_m3uaAspSpStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static struct m3uaAspSpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspSpTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspSpTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaAspSpStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaAspSpTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaAspSpTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaAspSpIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaAspSpTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = m3uaAspSpTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaAspSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaAspSpTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaAspSpTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaAspSpStatus;
			StorageTmp->m3uaAspSpStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				m3uaAspSpTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			m3uaAspSpTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaAspSpStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaAspSpTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspSpStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspSpStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaAspSpTable_destroy(&StorageDel);
			/* m3uaAspSpTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspMtStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_m3uaAspMtStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaAspMtTable_data *StorageTmp = NULL;
	static struct m3uaAspMtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspMtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(m3uaAspMtTableStorage, NULL, &name[sizeof(m3uaAspMtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaAspMtStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaAspMtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaAspMtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaAspSpIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspMtIndex */
			snmp_varlist_add_variable(&vars, NULL, 0,, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaAspMtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = m3uaAspMtTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaAspSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaAspMtTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaAspMtTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaAspMtStatus;
			StorageTmp->m3uaAspMtStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				m3uaAspMtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			m3uaAspMtTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaAspMtStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaAspMtTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspMtStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspMtStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaAspMtTable_destroy(&StorageDel);
			/* m3uaAspMtTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRsStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_m3uaAspRsStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaAspRsTable_data *StorageTmp = NULL;
	static struct m3uaAspRsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspRsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(m3uaAspRsTableStorage, NULL, &name[sizeof(m3uaAspRsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaAspRsStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaAspRsTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaAspRsTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaAspSpIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspRsIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaAspRsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = m3uaAspRsTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaAspSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspRsIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaAspRsTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaAspRsTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaAspRsStatus;
			StorageTmp->m3uaAspRsStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				m3uaAspRsTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			m3uaAspRsTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaAspRsStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaAspRsTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspRsStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspRsStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaAspRsTable_destroy(&StorageDel);
			/* m3uaAspRsTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRtStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_m3uaAspRtStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaAspRtTable_data *StorageTmp = NULL;
	static struct m3uaAspRtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspRtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(m3uaAspRtTableStorage, NULL, &name[sizeof(m3uaAspRtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRtStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRtStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaAspRtStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaAspRtTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaAspRtTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaAspSpIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspRsIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspAgIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspSgIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaAspRtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = m3uaAspRtTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaAspSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspRsIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspAgIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspSgIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaAspRtTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaAspRtTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaAspRtStatus;
			StorageTmp->m3uaAspRtStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				m3uaAspRtTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			m3uaAspRtTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaAspRtStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaAspRtTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspRtStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspRtStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaAspRtTable_destroy(&StorageDel);
			/* m3uaAspRtTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

/**
 * @fn int write_m3uaAspRcStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
 * @param action the stage of the SET operation.
 * @param var_val pointer to the varbind value.
 * @param var_val_type the ASN type.
 * @param var_val_len the length of the varbind value.
 * @param statP static pointer.
 * @param name the varbind OID.
 * @param name_len number of elements in OID.
 * @brief Row status write routine.
 */
int
write_m3uaAspRcStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaAspRcTable_data *StorageTmp = NULL;
	static struct m3uaAspRcTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspRcTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;

	StorageTmp = header_complex(m3uaAspRcTableStorage, NULL, &name[sizeof(m3uaAspRcTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcStatus: bad value\n");
		return SNMP_ERR_WRONGVALUE;
	}
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaAspRcStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaAspRcTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaAspRcTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaAspIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspSpIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			/* m3uaAspMtIndex */
			snmp_varlist_add_variable(&vars, NULL, 0,, NULL, 0);
			/* m3uaAspAgIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaAspRcTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = m3uaAspRcTable_create()) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaAspIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			vp = vp->next_variable;
			StorageNew->m3uaAspAgIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaAspRcTable_destroy(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaAspRcTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaAspRcStatus;
			StorageTmp->m3uaAspRcStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				StorageDel = StorageTmp;
				m3uaAspRcTable_del(StorageDel);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			m3uaAspRcTable_del(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaAspRcStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaAspRcTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspRcStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaAspRcStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaAspRcTable_destroy(&StorageDel);
			/* m3uaAspRcTable_destroy() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
