/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "m3uaAspMIB_simple.h"

/* 
 * m3uaAspMIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid m3uaAspMIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311 };

/* 
 * variable7 m3uaAspMIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the m3uaAspMIB_simple mib section 
 */

struct variable7 m3uaAspMIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   M3UAASPNEXTINDEX      1
	{M3UAASPNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaAspMIB, 4, {1, 2, 1, 1}},
#define   M3UAASPNAME           6
	{M3UAASPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 2}},
#define   M3UAASPNAME           7
	{M3UAASPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 2}},
#define   M3UAASPADMINISTRATIVESTATE  8
	{M3UAASPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 3}},
#define   M3UAASPADMINISTRATIVESTATE  9
	{M3UAASPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 3}},
#define   M3UAASPCAPABILITIES   10
	{M3UAASPCAPABILITIES, ASN_BIT_STR, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 4}},
#define   M3UAASPIDPOLICY       11
	{M3UAASPIDPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 5}},
#define   M3UAASPREGISTRATIONPOLICY  12
	{M3UAASPREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 6}},
#define   M3UAASPASSOCIATIONPOLICY  13
	{M3UAASPASSOCIATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 7}},
#define   M3UAASPSTATUS         14
	{M3UAASPSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 8}},
#define   M3UAASPAGNEXTINDEX    15
	{M3UAASPAGNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaAspMIB, 4, {1, 2, 2, 1}},
#define   M3UAASPAGPROTOCOLVERSION  19
	{M3UAASPAGPROTOCOLVERSION, ASN_OBJECT_ID, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 2}},
#define   M3UAASPAGOPTIONS      20
	{M3UAASPAGOPTIONS, ASN_BIT_STR, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 3}},
#define   M3UAASPAGREGISTRATIONPOLICY  21
	{M3UAASPAGREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 4}},
#define   M3UAASPAGASPIDPOLICY  22
	{M3UAASPAGASPIDPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 5}},
#define   M3UAASPAGASPPROTOCOLPAYLOADID  23
	{M3UAASPAGASPPROTOCOLPAYLOADID, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 6}},
#define   M3UAASPAGIPPORT       24
	{M3UAASPAGIPPORT,, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 7}},
#define   M3UAASPAGMINOSTREAMS  25
	{M3UAASPAGMINOSTREAMS, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 8}},
#define   M3UAASPAGMAXISTREAMS  26
	{M3UAASPAGMAXISTREAMS, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 9}},
#define   M3UAASPAGTIMERT7      27
	{M3UAASPAGTIMERT7, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 10}},
#define   M3UAASPAGTIMERT19     28
	{M3UAASPAGTIMERT19, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 11}},
#define   M3UAASPAGTIMERT21     29
	{M3UAASPAGTIMERT21, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 12}},
#define   M3UAASPAGTIMERT25A    30
	{M3UAASPAGTIMERT25A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 13}},
#define   M3UAASPAGTIMERT28A    31
	{M3UAASPAGTIMERT28A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 14}},
#define   M3UAASPAGTIMERT29A    32
	{M3UAASPAGTIMERT29A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 15}},
#define   M3UAASPAGTIMERT30A    33
	{M3UAASPAGTIMERT30A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 16}},
#define   M3UAASPAGSTATUS       34
	{M3UAASPAGSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 17}},
#define   M3UAASPSGNAME         39
	{M3UAASPSGNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 2}},
#define   M3UAASPSGADMINISTRATIVESTATE  40
	{M3UAASPSGADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 3}},
#define   M3UAASPSGOPERATIONALSTATE  41
	{M3UAASPSGOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 4}},
#define   M3UAASPSGPROCEDUREALSTATUS  42
	{M3UAASPSGPROCEDUREALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 5}},
#define   M3UAASPSGUSGAGESTATE  43
	{M3UAASPSGUSGAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 6}},
#define   M3UAASPSGASPSTATE     44
	{M3UAASPSGASPSTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 7}},
#define   M3UAASPSGMAXINITRETRANS  45
	{M3UAASPSGMAXINITRETRANS, ASN_UNSIGNED, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 8}},
#define   M3UAASPSGMAXPATHRETRANS  46
	{M3UAASPSGMAXPATHRETRANS, ASN_UNSIGNED, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 9}},
#define   M3UAASPSGMAXLIFETIME  47
	{M3UAASPSGMAXLIFETIME, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 10}},
#define   M3UAASPSGTIMERT1      48
	{M3UAASPSGTIMERT1, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 11}},
#define   M3UAASPSGTIMERT2      49
	{M3UAASPSGTIMERT2, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 12}},
#define   M3UAASPSGTIMERT3      50
	{M3UAASPSGTIMERT3, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 13}},
#define   M3UAASPSGTIMERT4      51
	{M3UAASPSGTIMERT4, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 14}},
#define   M3UAASPSGTIMERT5      52
	{M3UAASPSGTIMERT5, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 15}},
#define   M3UAASPSGTIMERT5      53
	{M3UAASPSGTIMERT5, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 15}},
#define   M3UAASPSGTIMERT19A    54
	{M3UAASPSGTIMERT19A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 16}},
#define   M3UAASPSGTIMERT24     55
	{M3UAASPSGTIMERT24, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 17}},
#define   M3UAASPSGTIMERT31A    56
	{M3UAASPSGTIMERT31A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 18}},
#define   M3UAASPSGTIMERT32A    57
	{M3UAASPSGTIMERT32A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 19}},
#define   M3UAASPSGTIMERT33A    58
	{M3UAASPSGTIMERT33A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 20}},
#define   M3UAASPSGTIMERT34A    59
	{M3UAASPSGTIMERT34A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 21}},
#define   M3UAASPSGTIMERT1T     60
	{M3UAASPSGTIMERT1T, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 22}},
#define   M3UAASPSGTIMERT2T     61
	{M3UAASPSGTIMERT2T, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 23}},
#define   M3UAASPSGSTATUS       62
	{M3UAASPSGSTATUS, ASN_INTEGER, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 24}},
#define   M3UAASPSGPNAME        68
	{M3UAASPSGPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 2}},
#define   M3UAASPSGPADMINISTRATIVESTATE  69
	{M3UAASPSGPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 3}},
#define   M3UAASPSGPPROCEDURALSTATUS  70
	{M3UAASPSGPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 4}},
#define   M3UAASPSGPOPERATIONALSTATE  71
	{M3UAASPSGPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 5}},
#define   M3UAASPSGPUSAGESTATE  72
	{M3UAASPSGPUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 6}},
#define   M3UAASPSGPASPSTATE    73
	{M3UAASPSGPASPSTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 7}},
#define   M3UAASPSGPPRIMARYADDRESS  74
	{M3UAASPSGPPRIMARYADDRESS, ASN_OCTET_STR, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 8}},
#define   M3UAASPSGPHOSTNAME    75
	{M3UAASPSGPHOSTNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 9}},
#define   M3UAASPSGPSTATUS      76
	{M3UAASPSGPSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 10}},
#define   M3UAASPSPNEXTINDEX    77
	{M3UAASPSPNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaAspMIB, 4, {1, 2, 5, 1}},
#define   M3UAASPSPNAME         81
	{M3UAASPSPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 2}},
#define   M3UAASPSPOPERATIONALSTATE  82
	{M3UAASPSPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 3}},
#define   M3UAASPSPUSAGESTATE   83
	{M3UAASPSPUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 4}},
#define   M3UAASPSPADMINISTRATIVESTATE  84
	{M3UAASPSPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 5}},
#define   M3UAASPSPALARMSTATUS  85
	{M3UAASPSPALARMSTATUS, ASN_BIT_STR, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 6}},
#define   M3UAASPSPPROCEDURALSTATUS  86
	{M3UAASPSPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 7}},
#define   M3UAASPSPAVAILABILTYSTATUS  87
	{M3UAASPSPAVAILABILTYSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 8}},
#define   M3UAASPSPPOINTCODE    88
	{M3UAASPSPPOINTCODE, ASN_OCTET_STR, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 9}},
#define   M3UAASPSPTIMERT1R     89
	{M3UAASPSPTIMERT1R, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 10}},
#define   M3UAASPSPTIMERT18     90
	{M3UAASPSPTIMERT18, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 11}},
#define   M3UAASPSPTIMERT20     91
	{M3UAASPSPTIMERT20, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 12}},
#define   M3UAASPSPTIMERT22A    92
	{M3UAASPSPTIMERT22A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 13}},
#define   M3UAASPSPTIMERT23A    93
	{M3UAASPSPTIMERT23A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 14}},
#define   M3UAASPSPTIMERT24A    94
	{M3UAASPSPTIMERT24A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 15}},
#define   M3UAASPSPTIMERT26A    95
	{M3UAASPSPTIMERT26A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 16}},
#define   M3UAASPSPTIMERT27A    96
	{M3UAASPSPTIMERT27A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 17}},
#define   M3UAASPSPSTATUS       97
	{M3UAASPSPSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 18}},
#define   M3UAASPMTNAME         102
	{M3UAASPMTNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 2}},
#define   M3UAASPMTADMINISTRATIVESTATE  103
	{M3UAASPMTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 3}},
#define   M3UAASPMTOPERATIONALSTATE  104
	{M3UAASPMTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 4}},
#define   M3UAASPMTPROCEDURALSTATUS  105
	{M3UAASPMTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 5}},
#define   M3UAASPMTUSAGESTATE   106
	{M3UAASPMTUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 6}},
#define   M3UAASPMTASSTATE      107
	{M3UAASPMTASSTATE, ASN_INTEGER, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 7}},
#define   M3UAASPMTSTATUS       108
	{M3UAASPMTSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 8}},
#define   M3UAASPRSNAME         113
	{M3UAASPRSNAME, ASN_OCTET_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 2}},
#define   M3UAASPRSREMOTEPOINTCODE  114
	{M3UAASPRSREMOTEPOINTCODE, ASN_OCTET_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 3}},
#define   M3UAASPRSOPERATIONALSTATE  115
	{M3UAASPRSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 4}},
#define   M3UAASPRSADMINISTRATIVESTATE  116
	{M3UAASPRSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 5}},
#define   M3UAASPRSUSAGESTATE   117
	{M3UAASPRSUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 6}},
#define   M3UAASPRSALARMSTATUS  118
	{M3UAASPRSALARMSTATUS, ASN_BIT_STR, RWRITE, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 7}},
#define   M3UAASPRSPROCEDURALSTATUS  119
	{M3UAASPRSPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 8}},
#define   M3UAASPRSTIMERT8      120
	{M3UAASPRSTIMERT8, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 9}},
#define   M3UAASPRSTIMERT11     121
	{M3UAASPRSTIMERT11, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 10}},
#define   M3UAASPRSTIMERT15     122
	{M3UAASPRSTIMERT15, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 11}},
#define   M3UAASPRSTIMERT16     123
	{M3UAASPRSTIMERT16, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 12}},
#define   M3UAASPRSTIMERT18A    124
	{M3UAASPRSTIMERT18A, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 13}},
#define   M3UAASPRSOPTIONS      125
	{M3UAASPRSOPTIONS, ASN_BIT_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 14}},
#define   M3UAASPRSAVAILABILITYSTATUS  126
	{M3UAASPRSAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 15}},
#define   M3UAASPRSCONGESTIONLEVEL  127
	{M3UAASPRSCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 16}},
#define   M3UAASPRSSTATUS       128
	{M3UAASPRSSTATUS, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 17}},
#define   M3UAASPRLCOST         134
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         135
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         136
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         137
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         138
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         139
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         140
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRTCOST         147
	{M3UAASPRTCOST, ASN_UNSIGNED, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 1}},
#define   M3UAASPRTTIMERT6      148
	{M3UAASPRTTIMERT6, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 2}},
#define   M3UAASPRTTIMERT10     149
	{M3UAASPRTTIMERT10, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 3}},
#define   M3UAASPRTAVAILABILITYSTATUS  150
	{M3UAASPRTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 4}},
#define   M3UAASPRTADMINSTRATIVESTATE  151
	{M3UAASPRTADMINSTRATIVESTATE, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 5}},
#define   M3UAASPRTOPERATIONALSTATE  152
	{M3UAASPRTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 6}},
#define   M3UAASPRTPROCEDURALSTATUS  153
	{M3UAASPRTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 7}},
#define   M3UAASPRTUSAGESTATE   154
	{M3UAASPRTUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 8}},
#define   M3UAASPRTSTATUS       155
	{M3UAASPRTSTATUS, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 9}},
#define   M3UAASPRCVALUE        162
	{M3UAASPRCVALUE, ASN_UNSIGNED, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 1}},
#define   M3UAASPRCREGSTRATIONPOLICY  163
	{M3UAASPRCREGSTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 3}},
#define   M3UAASPRCTRAFFICMODE  164
	{M3UAASPRCTRAFFICMODE, ASN_OBJECT_ID, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 4}},
#define   M3UAASPRCSTATUS       165
	{M3UAASPRCSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 5}},
#define   M3UAASPASASSTATE      173
	{M3UAASPASASSTATE, ASN_INTEGER, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 1}},
#define   M3UAASPASOPERATIONALSTATE  174
	{M3UAASPASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 2}},
#define   M3UAASPASPROCEDURALSTATUS  175
	{M3UAASPASPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 3}},
#define   M3UAASPASUSAGESTATE   176
	{M3UAASPASUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 4}},
#define   M3UAASPAFASSTATE      185
	{M3UAASPAFASSTATE, ASN_INTEGER, RWRITE, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 1}},
#define   M3UAASPAFADMINISTRATIVESTATE  186
	{M3UAASPAFADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 2}},
#define   M3UAASPAFOPERATIONALSTATE  187
	{M3UAASPAFOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 3}},
#define   M3UAASPAFPROCEDURALSTATUS  188
	{M3UAASPAFPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 4}},
#define   M3UAASPAFUSAGESTATE   189
	{M3UAASPAFUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 5}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_m3uaAspMIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_m3uaAspMIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("m3uaAspMIB_simple", m3uaAspMIB_simple_variables, variable7, m3uaAspMIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_m3uaAspMIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_m3uaAspMIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPNAME:
		*write_method = write_m3uaAspName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPNAME:
		*write_method = write_m3uaAspName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPCAPABILITIES:
		*write_method = write_m3uaAspCapabilities;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPIDPOLICY:
		*write_method = write_m3uaAspIdPolicy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPREGISTRATIONPOLICY:
		*write_method = write_m3uaAspRegistrationPolicy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPASSOCIATIONPOLICY:
		*write_method = write_m3uaAspAssociationPolicy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSTATUS:
		*write_method = write_m3uaAspStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspAgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspAgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPAGPROTOCOLVERSION:
		*write_method = write_m3uaAspAgProtocolVersion;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case M3UAASPAGOPTIONS:
		*write_method = write_m3uaAspAgOptions;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPAGREGISTRATIONPOLICY:
		*write_method = write_m3uaAspAgRegistrationPolicy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGASPIDPOLICY:
		*write_method = write_m3uaAspAgAspIdPolicy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGASPPROTOCOLPAYLOADID:
		*write_method = write_m3uaAspAgAspProtocolPayloadId;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGIPPORT:
		*write_method = write_m3uaAspAgIpPort;

	case M3UAASPAGMINOSTREAMS:
		*write_method = write_m3uaAspAgMinOstreams;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGMAXISTREAMS:
		*write_method = write_m3uaAspAgMaxIstreams;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGTIMERT7:
		*write_method = write_m3uaAspAgTimerT7;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGTIMERT19:
		*write_method = write_m3uaAspAgTimerT19;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGTIMERT21:
		*write_method = write_m3uaAspAgTimerT21;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGTIMERT25A:
		*write_method = write_m3uaAspAgTimerT25A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGTIMERT28A:
		*write_method = write_m3uaAspAgTimerT28A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGTIMERT29A:
		*write_method = write_m3uaAspAgTimerT29A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGTIMERT30A:
		*write_method = write_m3uaAspAgTimerT30A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAGSTATUS:
		*write_method = write_m3uaAspAgStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspSgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspSgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPSGNAME:
		*write_method = write_m3uaAspSgName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSGADMINISTRATIVESTATE:
		*write_method = write_m3uaAspSgAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGPROCEDUREALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSGUSGAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGASPSTATE:
		*write_method = write_m3uaAspSgAspState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGMAXINITRETRANS:
		*write_method = write_m3uaAspSgMaxInitRetrans;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M3UAASPSGMAXPATHRETRANS:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M3UAASPSGMAXLIFETIME:
		*write_method = write_m3uaAspSgMaxLifeTime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT1:
		*write_method = write_m3uaAspSgTimerT1;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT2:
		*write_method = write_m3uaAspSgTimerT2;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT3:
		*write_method = write_m3uaAspSgTimerT3;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT4:
		*write_method = write_m3uaAspSgTimerT4;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT5:
		*write_method = write_m3uaAspSgTimerT5;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT5:
		*write_method = write_m3uaAspSgTimerT5;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT19A:
		*write_method = write_m3uaAspSgTimerT19A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT24:
		*write_method = write_m3uaAspSgTimerT24;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT31A:
		*write_method = write_m3uaAspSgTimerT31A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT32A:
		*write_method = write_m3uaAspSgTimerT32A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT33A:
		*write_method = write_m3uaAspSgTimerT33A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT34A:
		*write_method = write_m3uaAspSgTimerT34A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT1T:
		*write_method = write_m3uaAspSgTimerT1T;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGTIMERT2T:
		*write_method = write_m3uaAspSgTimerT2T;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspSgpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspSgpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPSGPNAME:
		*write_method = write_m3uaAspSgpName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSGPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspSgpAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGPPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSGPOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGPUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGPASPSTATE:
		*write_method = write_m3uaAspSgpAspState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSGPPRIMARYADDRESS:
		*write_method = write_m3uaAspSgpPrimaryAddress;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSGPHOSTNAME:
		*write_method = write_m3uaAspSgpHostName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSGPSTATUS:
		*write_method = write_m3uaAspSgpStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspSpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPSPNAME:
		*write_method = write_m3uaAspSpName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSPOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspSpAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPALARMSTATUS:
		*write_method = write_m3uaAspSpAlarmStatus;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSPPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSPAVAILABILTYSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSPPOINTCODE:
		*write_method = write_m3uaAspSpPointCode;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPSPTIMERT1R:
		*write_method = write_m3uaAspSpTimerT1R;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPTIMERT18:
		*write_method = write_m3uaAspSpTimerT18;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPTIMERT20:
		*write_method = write_m3uaAspSpTimerT20;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPTIMERT22A:
		*write_method = write_m3uaAspSpTimerT22A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPTIMERT23A:
		*write_method = write_m3uaAspSpTimerT23A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPTIMERT24A:
		*write_method = write_m3uaAspSpTimerT24A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPTIMERT26A:
		*write_method = write_m3uaAspSpTimerT26A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPTIMERT27A:
		*write_method = write_m3uaAspSpTimerT27A;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPSPSTATUS:
		*write_method = write_m3uaAspSpStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspMtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspMtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPMTNAME:
		*write_method = write_m3uaAspMtName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPMTADMINISTRATIVESTATE:
		*write_method = write_m3uaAspMtAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPMTOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPMTPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPMTUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPMTASSTATE:
		*write_method = write_m3uaAspMtAsState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPMTSTATUS:
		*write_method = write_m3uaAspMtStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspRsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPRSNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPRSREMOTEPOINTCODE:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPRSOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRSADMINISTRATIVESTATE:
		*write_method = write_m3uaAspRsAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRSUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRSALARMSTATUS:
		*write_method = write_m3uaAspRsAlarmStatus;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPRSPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPRSTIMERT8:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRSTIMERT11:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRSTIMERT15:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRSTIMERT16:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRSTIMERT18A:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRSOPTIONS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPRSAVAILABILITYSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPRSCONGESTIONLEVEL:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRSSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspRlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspRlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspRtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPRTCOST:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M3UAASPRTTIMERT6:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRTTIMERT10:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRTAVAILABILITYSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPRTADMINSTRATIVESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRTOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRTPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPRTUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRTSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspRcTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspRcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPRCVALUE:
		*write_method = write_m3uaAspRcValue;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M3UAASPRCREGSTRATIONPOLICY:
		*write_method = write_m3uaAspRcRegstrationPolicy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPRCTRAFFICMODE:
		*write_method = write_m3uaAspRcTrafficMode;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case M3UAASPRCSTATUS:
		*write_method = write_m3uaAspRcStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspAsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPASASSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPASOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPASPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPASUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m3uaAspAfTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB_simple above.
 */
unsigned char *
var_m3uaAspAfTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M3UAASPAFASSTATE:
		*write_method = write_m3uaAspAfAsState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAFADMINISTRATIVESTATE:
		*write_method = write_m3uaAspAfAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAFOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M3UAASPAFPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M3UAASPAFUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_m3uaAspName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m3uaAspName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m3uaAspName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspCapabilities(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to m3uaAspCapabilities not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspCapabilities: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspIdPolicy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspIdPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRegistrationPolicy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAssociationPolicy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAssociationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAssociationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgProtocolVersion(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to m3uaAspAgProtocolVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to m3uaAspAgProtocolVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgOptions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to m3uaAspAgOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspAgOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgRegistrationPolicy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgAspIdPolicy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgAspIdPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgAspProtocolPayloadId(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgAspProtocolPayloadId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgAspProtocolPayloadId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgIpPort(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{

	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type !=) {
			fprintf(stderr, "write to m3uaAspAgIpPort not \n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof()) {
			fprintf(stderr, "write to m3uaAspAgIpPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		= ()var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgMinOstreams(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgMinOstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgMinOstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgMaxIstreams(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgMaxIstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgMaxIstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT7(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT19(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgTimerT19 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgTimerT19: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT21(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgTimerT21 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgTimerT21: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT25A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgTimerT25A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgTimerT25A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT28A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgTimerT28A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgTimerT28A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT29A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgTimerT29A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgTimerT29A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT30A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgTimerT30A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgTimerT30A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAgStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAgStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m3uaAspSgName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspSgName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgAspState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgAspState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgAspState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgMaxInitRetrans(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m3uaAspSgMaxInitRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m3uaAspSgMaxInitRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgMaxLifeTime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgMaxLifeTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgMaxLifeTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT3(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT4(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT4: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT5(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT5(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT5: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT19A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT19A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT24(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT24 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT24: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT31A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT31A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT32A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT32A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT33A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT33A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT34A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT34A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT1T(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT1T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT2T(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgTimerT2T: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m3uaAspSgpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspSgpName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgpAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpAspState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgpAspState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgpAspState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpPrimaryAddress(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m3uaAspSgpPrimaryAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspSgpPrimaryAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpHostName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m3uaAspSgpHostName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspSgpHostName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSgpStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSgpStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m3uaAspSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspSpName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSpAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpAlarmStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to m3uaAspSpAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspSpAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpPointCode(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m3uaAspSpPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspSpPointCode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT1R(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSpTimerT1R not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSpTimerT1R: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT18(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSpTimerT18 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSpTimerT18: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT20(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSpTimerT20 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSpTimerT20: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT22A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSpTimerT22A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSpTimerT22A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT23A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSpTimerT23A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSpTimerT23A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT24A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSpTimerT24A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSpTimerT24A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT26A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSpTimerT26A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSpTimerT26A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT27A(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSpTimerT27A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSpTimerT27A: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspSpStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspSpStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspMtName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m3uaAspMtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspMtName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspMtAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspMtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspMtAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspMtAsState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspMtAsState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspMtAsState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspMtStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspMtStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspMtStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRsAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspRsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspRsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRsAlarmStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to m3uaAspRsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m3uaAspRsAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m3uaAspRlCost: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRcValue(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m3uaAspRcValue not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m3uaAspRcValue: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRcRegstrationPolicy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspRcRegstrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspRcRegstrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRcTrafficMode(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to m3uaAspRcTrafficMode not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to m3uaAspRcTrafficMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRcStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspRcStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspRcStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAfAsState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAfAsState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAfAsState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAfAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m3uaAspAfAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m3uaAspAfAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
