# mib2c.storage.conf:
#
#  This is a special mib2c.conf file that assumes that you want to do
#  all storage of information locally rather than pulling the
#  information from another source outside the agent (EG, the
#  kernel).  To accomplish this, it defines a structure for the
#  storage of tables and assumes you want to use the header_complex
#  functions for retrieving and storing that data in a local data
#  store.  It even writes a .conf file parser for you and sets you up
#  for being able to do persistant storage fairly simply.
#
#  In short:  it trys to do almost all of the work for you...  Almost...

#
# Define types of data by mib type, and translate into needed C code.
#

# We need to get some extra stuff into the variable declarations
# before sourcing the main mib2c.vartypes.conf file below.
type:		OCTETSTR
storage:	    uint8_t *${name};
storage:	    int ${name}Len;
varlencheck:	    var_val_len > SPRINT_MAX_LEN
varlenread:	StorageTmp->${name}Len = tmpsize;
varlenstore:	tmpsize = StorageTmp->${name}Len;
vartest:	  if (StorageTmp->${name} == NULL) {
vartest:	    config_perror(\"invalid specification for ${name}\");
vartest:	    return;
vartest:	  }
vartest:
reserve2:	  if ((string = malloc(var_val_len)) == NULL)
reserve2:	    return SNMP_ERR_RESOURCEUNAVAILABLE;
reserve2:	  memcpy((void *)string, (void *)var_val, var_val_len);
free:		  SNMP_FREE(string);
action:	             old_value = StorageTmp->$name;
action:	             old_length = StorageTmp->${name}Len;
action:	             StorageTmp->$name = string;
action:	             StorageTmp->${name}Len = var_val_len;
undo:	             StorageTmp->${name} = old_value;
undo:	             StorageTmp->${name}Len = old_length;
commit:		     SNMP_FREE(old_value);
commit:		     old_length = 0;
commit:		     string = NULL;
deletevar:	  SNMP_FREE(StorageDel->${name});
deletevar:	  StorageDel->${name}Len = 0;
sizeofstart:
sizeofend:	Len
tmpvar:		uint8_t *
varname:	    string
varinit:	  static size_t old_length = 0;
varinit:	  static uint8_t *string = NULL;
casttmp:	strdup((uint8_t *) old_value);
action2:	     memdup((void *) &StorageNew->$name, vp->val.string, vp->val_len);
action2:	     StorageNew->${name}Len = vp->val_len;
action3:	     StorageNew->${name} = strdup(\"$mib->{defaultValue}\");
action3:	     StorageNew->${name}Len = strlen(\"$mib->{defaultValue}\");\n
#
type:		INTEGER
storage:	    int32_t    $name;
varlencheck:	    var_val_len > sizeof(int32_t)
storageret:	&
sizeofstart:	sizeof(
sizeofend:	)
tmpvar:		int32_t
varname:	    set_value
varinit:	  long set_value = *((long *) var_val);
action:	             old_value = StorageTmp->$name;
action:	             StorageTmp->${name} = set_value;
undo:	             StorageTmp->${name} = old_value;
casttmp:	old_value;
action2:	     StorageNew->$name = *vp->val.integer;
action3:	     StorageNew->${name} = $mib->{defaultValue};\n
#
type:		UNSIGNED32
storage:	    uint32_t    $name;
varlencheck:	    var_val_len > sizeof(uint32_t)
storageret:	&
sizeofstart:	sizeof(
sizeofend:	)
tmpvar:		uint32_t
varname:	    set_value
varinit:	  ulong set_value = *((ulong *) var_val);
action:	             old_value = StorageTmp->$name;
action:	             StorageTmp->${name} = set_value;
undo:	             StorageTmp->${name} = old_value;
casttmp:	old_value;
action2:	     StorageNew->$name = *vp->val.integer;
action3:	     StorageNew->${name} = $mib->{defaultValue};\n
#
type:		OBJECTID
storage:	    oid     *$name;
storage:	    int   ${name}Len;
varsize:	    * sizeof(oid)
varlencheck:	    MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)
varlenread:	StorageTmp->${name}Len = tmpsize;
varlenstore:	tmpsize = StorageTmp->${name}Len;
vartest:	  if (StorageTmp->${name} == NULL) {
vartest:	    config_perror(\"invalid specification for ${name}\");
vartest:	    return;
vartest:	  }
vartest:
reserve2:	  if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
reserve2:	    return SNMP_ERR_RESOURCEUNAVAILABLE;
free:		  SNMP_FREE(objid);
action:	             old_value = StorageTmp->$name;
action:	             old_length = StorageTmp->${name}Len;
action:	             StorageTmp->$name = objid;
action:	             StorageTmp->${name}Len = var_val_len/sizeof(oid);
undo:	             StorageTmp->${name} = old_value;
undo:	             StorageTmp->${name}Len = old_length;
commit:		     SNMP_FREE(old_value);
commit:		     old_length = 0;
commit:		     objid = NULL;
deletevar:	  SNMP_FREE(StorageDel->${name});
deletevar:	  StorageDel->${name}Len = 0;
sizeofstart:
sizeofend:	Len
tmpvar:		oid *
varname:	    objid
varinit:	  static size_t old_length = 0;
varinit:	  static oid *objid = NULL;
casttmp:	(oid *) old_value;
freetmp:	SNMP_FREE(old_value);
action2:	     memdup((void *) &StorageNew->$name, (uint8_t *)vp->val.oid, vp->val_len);
action2:	     StorageNew->${name}Len = vp->val_len/sizeof(oid);
action3:	     /* StorageNew->${name} = $mib->{defaultValue}; */\n
#
type:		COUNTER64
storage:	    struct counter64 $name;
varlencheck:	    var_val_len > sizeof(uint64_t)
storageret:	&
sizeofstart:	sizeof(
sizeofend:	)
tmpvar:		struct counter64
varname:	    c64
varinit:	struct counter64 c64 = *((struct counter64 *) var_val);
action:	             old_value = StorageTmp->$name;
action:	             StorageTmp->${name} = c64;
undo:	             StorageTmp->${name} = old_value;
casttmp:	old_value;
action2:	     StorageNew->$name = *vp->val.counter64;
action3:	     StorageNew->${name} = 0;\n

############################################################################
# source variable typing information:
include: mib2c.vartypes.conf

# Begin code template section
############################################################################
# variable statemnts used in a couple of places below
############################################################################
type:	code-varInits
code:	  /* variables we may use later */
code:	  static long long_ret;
code:	  static ulong ulong_ret;
code:	  static uint8_t string[SPRINT_MAX_LEN];
code:	  static oid objid[MAX_OID_LEN];
code:	  static struct counter64 c64;

############################################################################
# The .h file
############################################################################
type:	code-dot-h
code:	#ifndef __LOCAL_${MIBNAME}_H__
code:	#define __LOCAL_${MIBNAME}_H__
code:	/*
code:	 * This file was generated by mib2c and is intended for use as a mib module
code:	 * for the ucd-snmp snmpd agent.
code:	 */
code:	/* our storage structure(s) */
code:	struct ${mibName}_data { uint ${mibName}_request; $variables{'code-structure-mib'}{'processed'} };
code:	$variables{'code-structure-per-table'}{'processed'}
code:	/* storage declarations */
code:	extern struct ${mibName}_data *${mibName}Storage;
code:	$variables{'code-structure-storage-declaration'}{'processed'}
code:	/* enum definitions from the covered mib sections */
code:	$variables{'code-enums'}{'processed'}
code:	/* function prototypes */
code:	void   init_$mibName(void);
code:	void   deinit_$mibName(void);
code:	int term_$mibName(int majorID, int minorID, void *serverarg, void *clientarg);
code:	FindVarMethod var_$mibName;
code:	void parse_$mibName(const char *, char *);
code:	SNMPCallback store_$mibName;
code:	void refresh_$mibName(void);
code:	$variables{'code-var-table-decl'}{'processed'}
code:	$variables{'code-write-func-decl'}{'processed'}
code:	#endif /* __LOCAL_${MIBNAME}_H__ */

#
# Table refresh variable declarations.
#
type:		code-refresh-decl
processtable:	code-refresh-decl
code:	volatile int ${vtable}_refresh = 1;
#
# Structure definition line.
#
type:		code-structure-mib
process:	code-structure-mib
skipif:		$vroutine ne $mibName
code:	" . eval ("\"$variables{$mib->{'type'}}{'storage'}\"") . "

#
# Structure definition, one per table
#
type:		code-structure-per-table
processtable:	code-structure-per-table
code:	struct ${vtable}_data { uint ${vtable}_request; uint ${vtable}_refs; $variables{$vtable}{'code-structure'}{'processed'} };

#
# Structure storage arrays, one per table
#
type:		code-structure-storage
processtable:	code-structure-storage
code:	struct header_complex_index *${vtable}Storage = NULL;

#
# Strucutre storage declarations, one per table
#
type:		code-structure-storage-declaration
processtable:	code-structure-storage-declaration
code:	extern struct header_complex_index *${vtable}Storage;

#
# Structure definition line.
#
type:	code-structure
process: code-structure
code:	" . eval ("\"$variables{$mib->{'type'}}{'storage'}\"") . "
#$variables{$i}{'code'}\""evalstr(
#
# ENUM definitions
#
type:		code-enums
process:	code-enums
skipif: $mib->{'textualConvention'} eq "RowStatus" || $mib->{'textualConvention'} eq "StorageType"
code:	" . eval{ my ($i, $x); foreach $i (sort {$mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}} keys(%{$mib->{'enums'}})) { $x .= sprintf("#define %-40s %d\n","${NAME}_" . uc($i),$mib->{'enums'}{$i}); } $x =~ s/-/_/g; $x; } . "\n

############################################################################
# The .c file, top
############################################################################
type:	code-main-part
code:	/* This file was generated by mib2c and is intended for use as
code:	   a mib module for the ucd-snmp snmpd agent. */
code:	#include <ucd-snmp/ucd-snmp-config.h>
code:	#include <ucd-snmp/ucd-snmp-includes.h>
code:	#include <ucd-snmp/ucd-snmp-agent-includes.h>
code:	#include <ucd-snmp/callback.h>
code:	#include <ucd-snmp/snmp-tc.h>
code:	#include <ucd-snmp/default_store.h>
code:	#include <ucd-snmp/snmp_alarm.h>
code:	/* The following header files are mangled in most recent net-snmp releases so
code:	 * the versions from UCD-SNMP 4.2.5 are included here.  */
code:	#if defined HAVE_LIBNETSNMP
code:	#else  /* defined HAVE_LIBNETSNMP */
code:	#endif /* defined HAVE_LIBNETSNMP */
code:	/* These are messed up on both. */
code:	#include \"ds_agent.h\"
code:	#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
code:	#include <ucd-snmp/util_funcs.h>
code:	/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
code:	int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
code:	#else  /* HAVE_UCD_SNMP_UTIL_FUNCS_H */
code:	#include \"util_funcs.h\"
code:	#endif /* HAVE_UCD_SNMP_UTIL_FUNCS_H */
code:	#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
code:	#include <ucd-snmp/header_complex.h>
code:	#else  /* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
code:	#include \"header_complex.h\"
code:	#endif /* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
code:	/* This one is the other way around: it is just fine for net-snmp, but
code:	 * ucd-snmp does not provide the header file at all.  */
code:	#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
code:	#include <ucd-snmp/mib_modules.h>
code:	#else  /* HAVE_UCD_SNMP_MIB_MODULES_H */
code:	#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
code:	#include <net-snmp/agent/mib_modules.h>
code:	#else  /* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
code:	#include \"mib_modules.h\"
code:	#endif /* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
code:	#endif /* HAVE_UCD_SNMP_MIB_MODULES_H */
code:	#include <stdint.h>
code:	#include <signal.h>
code:	#include <sys/stat.h>		/* for struct stat, fstat() */
code:	#include <sys/types.h>
code:	#include <unistd.h>
code:	#include <stdlib.h>
code:	#include <pwd.h>		/* for getpwuid() getpwnam() */
code:	#include <grp.h>		/* for getgrgid() getgrnam() */
code:	#include <libgen.h>		/* for basename() */
code:	#include <fcntl.h>		/* for O_CREAT */
code:	#include <sys/sysctl.h>		/* for sysctl */
code:	#include <errno.h>
code:	#include <string.h>
code:	#ifdef _GNU_SOURCE
code:	#include <getopt.h>
code:	#endif
code:	#include \"$outputName.h\"
code:	extern const char sa_program[];
code:	#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
code:	#if !defined MODULE
code:	extern int sa_dump;			/* default packet dump */
code:	extern int sa_debug;			/* default no debug */
code:	extern int sa_nomead;			/* default daemon mode */
code:	extern int sa_output;			/* default normal output */
code:	extern int sa_agentx;			/* default agentx mode */
code:	extern int sa_alarms;			/* default application alarms */
code:	extern int sa_fclose;			/* default close files between requests */
code:	extern int sa_logaddr;			/* log addresses */
code:	extern int sa_logfillog;		/* log to sa_logfile */
code:	extern int sa_logstderr;		/* log to standard error */
code:	extern int sa_logstdout;		/* log to standard output */
code:	extern int sa_logsyslog;		/* log to system logs */
code:	extern int sa_logcallog;		/* log to callback logs */
code:	extern int sa_appendlog;		/* append to log file without truncating */
code:	extern char sa_logfile[256];
code:	extern char sa_pidfile[256];
code:	extern char sa_sysctlf[256];
code:	/* file stream for log file */
code:	extern FILE *stdlog;
code:	/* file descriptor for MIB use */
code:	extern int sa_fd;
code:	/* indication to reread MIB configuration */
code:	extern int sa_changed;
code:	/* indications that statistics, the mib or its tables need to be refreshed */
code:	extern int sa_stats_refresh;
code:	#endif /* !defined MODULE */
code:	/* request number for per-request actions */
code:	extern int sa_request;
code:	volatile int ${mibName}_refresh = 1;
code:	$variables{'code-refresh-decl'}{'processed'}
code:	/*
code:	 * ${mibName}_variables_oid: object identifier for $mibName
code:	 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
code:	 * suffix appearing in the variable below.
code:	 */
code:	oid ${mibName}_variables_oid[] = { $commaoid };
code:	$variables{'code-write-rowstatus-oid'}{'processed'}
code:	/*
code:	 * variable$varlen ${mibName}_variables: tree for $mibName
code:	 * This variable defines function callbacks and type return information for the $mibName mib section
code:	 */
code:	struct variable$varlen ${mibName}_variables[] = {
code:	        /* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
code:	        $variables{'variable-structure-info'}{'processed'}
code:	};
code:	/* (L = length of the oidsuffix) */
code:	struct ${mibName}_data *${mibName}Storage = NULL;
code:	/* global storage of our data, saved in and configured by header_complex() */
code:	$variables{'code-structure-storage'}{'processed'}
code:	/*
code:	 * init_$mibName(): Initialization routine.
code:	 * This is called when the agent starts up.  At a minimum, registration of your variables should
code:	 * take place here.
code:	 */
code:	void
code:	init_$mibName(void)
code:	{
code:	        DEBUGMSGTL((\"$mibName\", \"initializing...  \"));
code:	        /* register ourselves with the agent to handle our mib tree */
code:	        REGISTER_MIB(\"$mibName\", ${mibName}_variables, variable$varlen, ${mibName}_variables_oid);
code:	        snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_$mibName, NULL);
code:	        /* register our config handler(s) to deal with registrations */
code:	        snmpd_register_config_handler(\"$mibName\", parse_$mibName, NULL, \"HELP STRING\");
code:	        $variables{'code-parser-registration'}{'processed'}
code:	        /* we need to be called back later to store our data */
code:	        snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_$mibName, NULL);
code:	        $variables{'code-store-registration'}{'processed'}
code:	        /* place any other initialization junk you need here */
code:	        DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	/*
code:	 * deinit_$mibName(): Deinitialization routine.
code:	 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
code:	 * should take place here.
code:	 */
code:	void
code:	deinit_$mibName(void)
code:	{
code:	        DEBUGMSGTL((\"$mibName\", \"deinitializating...  \"));
code:	        unregister_mib(${mibName}_variables_oid, sizeof(${mibName}_variables_oid)/sizeof(oid));
code:	        snmpd_unregister_config_handler(\"$mibName\");
code:	        $variables{'code-parser-deregistration'}{'processed'}
code:	        /* place any other de-initialization junk you need here */
code:	        DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	int
code:	term_$mibName(int majorID, int minorID, void *serverarg, void *clientarg)
code:	{
code:	        deinit_$mibName();
code:	        return 0;
code:	}
code:	/*
code:	 * ${mibName}_add(): adds a structure node for scalars
code:	 */
code:	int
code:	${mibName}_add(struct ${mibName}_data *thedata)
code:	{
code:	        DEBUGMSGTL((\"$mibName\", \"adding data...  \"));
code:	        ${mibName}Storage = thedata;
code:	        DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	        return SNMPERR_SUCCESS;
code:	}
code:	/*
code:	 * parse_${mibName}(): parses .conf file entries needed to configure the mib.
code:	 */
code:	void
code:	parse_${mibName}(const char *token, char *line)
code:	{
code:	        size_t tmpsize;
code:	        struct ${mibName}_data *StorageTmp = SNMP_MALLOC_STRUCT(${mibName}_data);
code:	        DEBUGMSGTL((\"$mibName\", \"parsing config...  \"));
code:	        if (StorageTmp == NULL) {
code:	                config_perror(\"malloc failure\");
code:	                return;
code:	        }
code:	        $variables{'code-config-scalar'}{'processed'}
code:	        ${mibName}_add(StorageTmp);
code:	        (void) tmpsize;
code:	        DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	}
code:	/*
code:	 * store_${mibName}(): stores .conf file entries needed to configure the mib.
code:	 */
code:	int
code:	store_$mibName(int majorID, int minorID, void *serverarg, void *clientarg)
code:	{
code:	        char line[SNMP_MAXBUF];
code:	        char *cptr;
code:	        size_t tmpsize;
code:	        struct ${mibName}_data *StorageTmp;
code:	        DEBUGMSGTL((\"$mibName\", \"storing data...  \"));
code:	        refresh_${mibName}();
code:	        if ((StorageTmp = ${mibName}Storage) == NULL) {
code:	                DEBUGMSGTL((\"$mibName\", \"error.\\n\"));
code:	                return SNMPERR_GENERR;
code:	        }
code:	        (void) tmpsize;
code:	        /* XXX: if (StorageTmp->${mibName}StorageType == ST_NONVOLATILE) */
code:	        {
code:	                memset(line,0,sizeof(line));
code:	                strcat(line, \"$mibName \");
code:	                cptr = line + strlen(line);
code:	                $variables{$mibName}{'code-persistent-sections'}{'processed'}
code:	                snmpd_store_config(line);
code:	        }
code:	        DEBUGMSGTL((\"$mibName\", \"done.\\n\"));
code:	        return SNMPERR_SUCCESS;
code:	}
code:	/**
code:	 * refresh_$mibName: refresh $mibName scalars
code:	 *
code:	 * Normally, the values retrieved from the operating system are cached.  When the agent receives a
code:	 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
code:	 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
code:	 * tables from the STREAMS susbystem.  This function is used when the agent starts for the first
code:	 * time, or after a SIGPOLL has been received (and a scalar has been requested).
code:	 */
code:	void
code:	refresh_$mibName(void)
code:	{
code:	        if (${mibName}Storage == NULL) {
code:	                struct ${mibName}_data *StorageNew;
code:	                if ((StorageNew = SNMP_MALLOC_STRUCT(${mibName}_data)) == NULL)
code:	                        return;
code:	                /* Update scalar defaults as required here... */
code:	                $variables{$mibName}{'code-default-values'}{'processed'} ${mibName}Storage = StorageNew;
code:	                ${mibName}_refresh = 1;
code:	        }
code:	        if (${mibName}_refresh == 0)
code:	                return;
code:	        ${mibName}_refresh = 0;
code:	        /* Update scalars as required here... */
code:	}
code:	/*
code:	 * var_$mibName(): locate variables in $mibName
code:	 *
code:	 * This function is called every time the agent gets a request for a scalar variable that might be
code:	 * found within your mib section registered above.  It is up to you to do the right thing and return
code:	 * the correct value.  You should also correct the value of \"var_len\" if necessary.
code:	 *
code:	 * Please see the documentation for more information about writing module extensions, and check out
code:	 * the examples in the examples and mibII directories.
code:	 */
code:	u_char *
code:	var_$mibName(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
code:	{
code:	        struct ${mibName}_data *StorageTmp;
code:	        if (header_generic(vp,name,length,exact,var_len,write_method) == MATCH_FAILED)
code:	                return NULL;
code:	        /* Refresh the MIB values if required. */
code:	        refresh_$mibName();
code:	        if ((StorageTmp = ${mibName}Storage) == NULL)
code:	                return NULL;
code:	        /* This is where we do the value assignments for the mib results. */
code:	        switch(vp->magic) {
code:	                $variables{$mibName}{'code-case-statements'}{'processed'}
code:	        default:
code:	                ERROR_MSG(\"\");
code:	        }
code:	        return NULL;
code:	}
code:	$variables{'code-parser'}{'processed'}
code:	$variables{'code-var_table'}{'processed'}
code:	$variables{'code-write-func'}{'processed'}
code:	$variables{'code-write-scalar-func'}{'processed'}
code:	$variables{'code-write-rowstatus'}{'processed'}

############################################################################
# var_ function for tables, which is handled specially and used above
#
#   Note: $vtable is set to the table name in the processtable loop.
############################################################################

#
# header file defs first
#
type:		code-var-table-decl
processtable:	code-var-table-decl
code:	FindVarMethod var_$vtable;
code:	int ${vtable}_add(struct ${vtable}_data *);
code:	int ${vtable}_del(struct ${vtable}_data **);
code:	void parse_$vtable(const char *, char *);
code:	SNMPCallback store_$vtable;
code:	void refresh_$vtable(void);

#
# .conf Store Code per table
#
type:		code-store-registration
processtable:	code-store-registration
code:	  snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA,
code:		  store_$vtable, NULL);
#
# .conf Parser Code per table
#
type:		code-parser-registration
processtable:	code-parser-registration
code:	  snmpd_register_config_handler(\"$vtable\", parse_$vtable, NULL,
code:	                                \"HELP STRING\");
#
# .conf Parser Code per table
#
type:		code-parser-deregistration
processtable:	code-parser-deregistration
code:	  snmpd_unregister_config_handler(\"$vtable\");


type:		code-varlist-add
process:	code-varlist-add
skipif:		$variables{$vroutine}{$name}{'isanindex'} != 1
code:	        /* $name */
code:	        snmp_varlist_add_variable(&vars, NULL, 0, $variables{$mib->{type}}{asnType}, (u_char *) $variables{$mib->{type}}{'storageret'}thedata->$name, $variables{$mib->{type}}{'sizeofstart'}thedata->$name$variables{$mib->{type}}{'sizeofend'});\n 

type:		code-parser
processtable:	code-parser
code:	/*
code:	 * ${vtable}_add(): adds a structure node to our data set
code:	 */
code:	int
code:	${vtable}_add(struct ${vtable}_data *thedata)
code:	{
code:	        struct variable_list *vars = NULL;
code:	        DEBUGMSGTL((\"$vtable\", \"adding data...  \"));
code:	        /* add the index variables to the varbind list, which is used by header_complex to index the data */
code:	        $variables{$vtable}{'code-varlist-add'}{'processed'} header_complex_add_data(&${vtable}Storage, vars, thedata);
code:	        DEBUGMSGTL((\"$vtable\",\"registered an entry\\n\"));
code:	        DEBUGMSGTL((\"$vtable\", \"done.\\n\"));
code:	        return SNMPERR_SUCCESS;
code:	}
code:	/*
code:	 * ${vtable}_del(): delete a structure
code:	 */
code:	int
code:	${vtable}_del(struct ${vtable}_data **thedata)
code:	{
code:	        struct ${vtable}_data *StorageDel;
code:	        DEBUGMSGTL((\"$vtable\", \"deleting data...  \"));
code:	        if ((StorageDel = *thedata) != NULL) {
code:	                $variables{$vtable}{'code-delete-values'}{'processed'}
code:	                SNMP_FREE(StorageDel);
code:	                *thedata = StorageDel;
code:	        }
code:	        DEBUGMSGTL((\"$vtable\", \"done.\\n\"));
code:	        return SNMPERR_SUCCESS;
code:	}
code:	/*
code:	 * parse_$vtable(): parse configuration file for $vtable
code:	 * parses .conf file entries needed to configure the mib.
code:	 */
code:	void
code:	parse_$vtable(const char *token, char *line)
code:	{
code:	        size_t tmpsize;
code:	        struct ${vtable}_data *StorageTmp = SNMP_MALLOC_STRUCT(${vtable}_data);
code:	        DEBUGMSGTL((\"$vtable\", \"parsing config...  \"));
code:	        if (StorageTmp == NULL) {
code:	                config_perror(\"malloc failure\");
code:	                return;
code:	        }
code:	        $variables{$vtable}{'code-parser-sections'}{'processed'}
code:	        ${vtable}_add(StorageTmp);
code:	        (void) tmpsize;
code:	        DEBUGMSGTL((\"$vtable\", \"done.\\n\"));
code:	}
code:	/*
code:	 * store_$vtable(): store configuraiton file for $vtable
code:	 * stores .conf file entries needed to configure the mib.
code:	 */
code:	int
code:	store_$vtable(int majorID, int minorID, void *serverarg, void *clientarg)
code:	{
code:	        char line[SNMP_MAXBUF];
code:	        char *cptr;
code:	        size_t tmpsize;
code:	        struct ${vtable}_data *StorageTmp;
code:	        struct header_complex_index *hcindex;
code:	        DEBUGMSGTL((\"$vtable\", \"storing data...  \"));
code:	        refresh_${vtable}();
code:	        (void) tmpsize;
code:	        for(hcindex=${vtable}Storage; hcindex != NULL; hcindex = hcindex->next) {
code:	                StorageTmp = (struct ${vtable}_data *) hcindex->data;
code:	                /* XXX: if (StorageTmp->${vtable}StorageType == ST_NONVOLATILE) */
code:	                {
code:	                        memset(line,0,sizeof(line));
code:	                        strcat(line, \"$vtable \");
code:	                        cptr = line + strlen(line);
code:	                        $variables{$vtable}{'code-persistent-sections'}{'processed'}
code:	                        snmpd_store_config(line);
code:	                }
code:	        }
code:	        DEBUGMSGTL((\"$vtable\", \"done.\\n\"));
code:	        return SNMPERR_SUCCESS;
code:	}

# individual sections for the parser
type:		code-parser-sections
process:	code-parser-sections
skipif:			$mib->{'label'} =~ /(Entry|Table)$/
code:	  line = read_config_read_data($variables{$mib->{type}}{asnType}, line, &StorageTmp->$name, &tmpsize); " . eval ("\"$variables{$mib->{type}}{varlenread}\"") . " " . eval ("\"$variables{$mib->{type}}{vartest}\"") . "

#
# .conf persistent save Code per table
#
type:		code-persistent-sections
process:	code-persistent-sections
skipif:			$mib->{'label'} =~ /(Entry|Table)$/
code:	    " . eval ("\"$variables{$mib->{type}}{varlenstore}\"") . " cptr = read_config_store_data($variables{$mib->{type}}{asnType}, cptr, &StorageTmp->$name, &tmpsize);

#
# Code code per table
#
type:		code-var_table
processtable:	code-var_table
code:	/**
code:	 * refresh_$vtable(): refresh $vtable
code:	 *
code:	 * Normally the values retrieved from the operating system are cached.  When the agent receives a
code:	 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
code:	 * indicates to the agent that the cache has been invalidated and that it should reread tables from
code:	 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
code:	 * SIGPOLL has been received (and a row or column has been requested).
code:	 */
code:	void
code:	refresh_$vtable(void)
code:	{
code:	        if (${vtable}_refresh == 0)
code:	                return;
code:	        ${vtable}_refresh = 0;
code:	        /* Here, update the table as required... */
code:	}
code:	/**
code:	 * refresh_${vtable}_row(): refresh $vtable row
code:	 *
code:	 * Normally the values retrieved from the operating system are cached.  However, if a row contains
code:	 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
code:	 * may be necessary to refresh the row on some other basis, but normally only once per request.
code:	 */
code:	void
code:	refresh_${vtable}_row(struct ${vtable}_data *StorageTmp)
code:	{
code:	        if (StorageTmp->${vtable}_request == sa_request)
code:	                return;
code:	        StorageTmp->${vtable}_request = sa_request;
code:	}
code:	/*
code:	 * var_$vtable(): locate variables in $vtable
code:	 * Handle this table separately from the scalar value case.  The workings of this are basically the
code:	 * same as for var_$mibName above.
code:	 */
code:	u_char *
code:	var_$vtable(struct variable *vp, oid *name, size_t *length, int exact, size_t *var_len, WriteMethod **write_method)
code:	{
code:	        struct ${vtable}_data *StorageTmp = NULL;
code:	        DEBUGMSGTL((\"$mibName\", \"var_$vtable: Entering...  \\n\"));
code:	        /* Make sure that the storage data does not need to be refreshed before checking the header. */
code:	        refresh_$vtable();
code:	        /* This assumes you have registered all your data properly with header_complex_add() somewhere before this. */
code:	        if ((StorageTmp = header_complex(${vtable}Storage, vp,name,length, exact, var_len,write_method)) == NULL)
code:	                return NULL;
code:	        refresh_${vtable}_row(StorageTmp);
code:	        /* This is where we do the value assignments for the mib results. */
code:	        switch(vp->magic) {
code:	                $variables{$vtable}{'code-case-statements'}{'processed'}
code:	        default:
code:	                ERROR_MSG(\"\");
code:	        }
code:	        return NULL;
code:	}


############################################################################
# case statement sections
############################################################################
type:		code-case-statements
process:	code-case-statements
skipif:		$mib->{'access'} =~ /NoAccess/ || ( $variables{$vroutine}{$name}{'isanindex'} == 1 && $variables{$vroutine}{$name}{'ismyindex'} != 1 )
code:		    case $NAME:
code:		        " . (($mib->{'access'} =~ /ReadWrite|WriteOnly|Create/) ? "*write_method = write_$mib->{label};" : "*write_method = NULL; /* read-only */") . "
code:		        *var_len = $variables{$mib->{'type'}}{'sizeofstart'}StorageTmp->$mib->{label}$variables{$mib->{'type'}}{'sizeofend'};
code:		        return (u_char *) $variables{$mib->{'type'}}{'storageret'}StorageTmp->$mib->{label};

############################################################################
# storage structure information
############################################################################
type:		variable-structure-info
process:	variable-structure-info
skipif:		$mib->{'access'} =~ /NoAccess/ || $variables{$name}{'myoid'} != 1
code:		" . sprintf("#define   %-20s  ($count %% 256)", $NAME) . "
code:		" . sprintf("  { %-20s, %-14s, %-6.6s, %s, %d, { %s } },", $NAME, $variables{$mib->{'type'}}{'asnType'}, $accessToUCD{$mib->{'access'}}, "var_$vroutine", $depth-1, $subid) . "

############################################################################
# write function definition, also appended to the end of the .c file.
############################################################################
#
# Header info: declare write functions for set processing
#
type:		code-write-func-decl
process:	code-write-func-decl
skipif:		$mib->{'access'} !~ /Write|Create/
code:		WriteMethod write_$name;
#
#
#
type:		code-delete-scalar
process:	code-delete-scalar
skipif:		$vroutine ne $mibName
code:		$variables{$mib->{type}}{deletevar}
#
#
#
type:		code-config-scalar
process:	code-config-scalar
skipif:		$vroutine ne $mibName || $mib->{'access'} =~ /NoAccess/ || $variables{$vroutine}{$name}{'asanindex'} == 1
code:		line = read_config_read_data($variables{$mib->{type}}{asnType}, line, &StorageTmp->$name, &tmpsize); " . eval ("\"$variables{$mib->{type}}{varlenread}\"") . " " . eval ("\"$variables{$mib->{type}}{vartest}\"") . "
#
#
#
type:		code-write-length-check-variable
process:	code-write-length-check-variable
skipif:		$mib->{type} !~ /OCTETSTR|OBJECTID|BITS/
code:		" . eval{ my ($e, $x); foreach $e (@{$mib->{'ranges'}}) { $x .= " $e->{low}..$e->{high}"; } unless ($x eq "") { $x = "\n /* Note: ranges $x */"; } $x; } . " if ($variables{$mib->{'type'}}{varlencheck}" . eval { my ($e, $x, $s); foreach $e (@{$mib->{'ranges'}}) { $x .= $s; if ($e->{low} == $e->{high}) { $x .= "var_val_len != $e->{low} $variables{$mib->{type}}{varsize}"; } else { $x .= "($e->{low} $variables{$mib->{type}}{varsize} > var_val_len || var_val_len > $e->{high} $variables{$mib->{type}}{varsize})"; } $s = "&&"; } unless ($x eq "") { $x = "||($x)"; } $x; } . ") {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad length\\n\");
code:			return SNMP_ERR_WRONGLENGTH;
code:		}
#
type:		code-write-length-check-fixed
process:	code-write-length-check-fixed
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/
code:		if ($variables{$mib->{'type'}}{varlencheck}) {
code:			snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad length\\n\");
code:			return SNMP_ERR_WRONGLENGTH;
code:		}
#
type:		code-write-value-check-range
process:	code-write-value-check-range
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/ || !scalar @{$mib->{'ranges'}}
code:		" . eval{ my ($e, $x); foreach $e (@{$mib->{'ranges'}}) { $x .= " $e->{low}..$e->{high}"; } unless ($x eq "") { $x = "\n /* Note: ranges $x */"; } $x; } . eval { my ($e, $x, $s); foreach $e (@{$mib->{'ranges'}}) { $x .= $s; if ($e->{low} == $e->{high}) { $x .= "$variables{$mib->{type}}{varname} != $e->{low}"; } else { $x .= "($e->{low} > $variables{$mib->{type}}{varname} || $variables{$mib->{type}}{varname} > $e->{high})"; } $s = "&&"; } unless ($x eq "") { $x = "\n if ($x) { snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\"); return SNMP_ERR_WRONGVALUE; }"; } $x; } . "
#
type:		code-write-value-check-enum
process:	code-write-value-check-enum
skipif:		$mib->{type} =~ /OCTETSTR|OBJECTID|BITS/ || !scalar keys(%{$mib->{'enums'}})
code:		" . eval { my ($i, $x); foreach $i (sort {$mib->{'enums'}{$a} <=> $mib->{'enums'}{$b}} keys(%{$mib->{'enums'}})) { $x .= sprintf("case %-40s:\n","${NAME}_" . uc($i)); } $x =~ s/-/_/g; unless ($x eq "") { $x = "\n switch($variables{$mib->{type}}{varname}) { $x break; default: snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name: bad value\\n\"); return SNMP_ERR_WRONGVALUE; }"; } $x; } . "
#
type:		code-write-value-check-bits
process:	code-write-value-check-bits
skipif:		$mib->{type} ne "BITS" || !scalar keys(%{$mib->{'enums'}})
code:		\n /* XXX: check bits */
#
# C code
#
type:		code-write-scalar-func
process:	code-write-scalar-func
skipif:		$vroutine ne $mibName || $mib->{'access'} !~ /Write|Create/
code:	int
code:	write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	{
code:	        static $variables{$mib->{'type'}}{tmpvar} old_value;
code:	        struct ${vroutine}_data *StorageTmp = NULL;
code:	        $variables{$mib->{type}}{varinit}
code:	        DEBUGMSGTL((\"$mibName\", \"write_$name entering action=%d...  \\n\", action));
code:	        if ((StorageTmp = ${vroutine}Storage) == NULL)
code:	                return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */
code:	        switch ( action ) {
code:	        case RESERVE1:
code:	                if (var_val_type != $variables{$mib->{'type'}}{asnType}){
code:	                        snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name not $variables{$mib->{'type'}}{asnType}\\n\");
code:	                        return SNMP_ERR_WRONGTYPE;
code:	                } " . $variables{$vroutine}{$name}{'code-write-length-check-variable'}{'processed'} . $variables{$vroutine}{$name}{'code-write-length-check-fixed'}{'processed'} . (defined $mib->{'defaultValue'} ? "\n /* Note: default value $mib->{'defaultValue'} */" : "") . $variables{$vroutine}{$name}{'code-write-value-check-range'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-enum'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-bits'}{'processed'} . "
code:	                break;
code:	        case RESERVE2: /* memory reseveration, final preparation... */ ".eval ("\"$variables{$mib->{type}}{reserve2}\"")."
code:	                break;
code:	        case FREE: /* Release any resources that have been allocated */ ".eval ("\"$variables{$mib->{type}}{free}\"")."
code:	                break;
code:	        case ACTION: /* The variable has been stored in $variables{$mib->{'type'}}{varname} for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */ ".eval ("\"$variables{$mib->{type}}{action}\"")."
code:	                break;
code:	        case UNDO: /* Back out any changes made in the ACTION case */ ".eval ("\"$variables{$mib->{type}}{undo}\"")."
code:	                break;
code:	        case COMMIT: /* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */ ".eval ("\"$variables{$mib->{'type'}}{'commit'}\"")."
code:	                break;
code:	        }
code:	        return SNMP_ERR_NOERROR;
code:	}
#
# C code
#
type:		code-write-func
process:	code-write-func
skipif:		$vroutine eq $mibName || $mib->{'textualConvention'} eq "RowStatus" || $mib->{'access'} !~ /Write|Create/
code:	int
code:	write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	{
code:	        static $variables{$mib->{'type'}}{tmpvar} old_value;
code:	        struct ${vroutine}_data *StorageTmp = NULL;
code:	        size_t newlen=name_len - (sizeof(${mibName}_variables_oid)/sizeof(oid) + $depth - 1);
code:	        $variables{$mib->{type}}{varinit}
code:	        DEBUGMSGTL((\"$mibName\", \"write_$name entering action=%d...  \\n\", action));
code:	        if ((StorageTmp = header_complex(${vroutine}Storage, NULL, &name[sizeof(${mibName}_variables_oid)/sizeof(oid) + $depth - 1], &newlen, 1, NULL, NULL)) == NULL)
code:	                return SNMP_ERR_NOSUCHNAME; /* remove if you support creation here */
code:	        switch ( action ) {
code:	        case RESERVE1:
code:	                if (var_val_type != $variables{$mib->{'type'}}{asnType}){
code:	                        snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name not $variables{$mib->{'type'}}{asnType}\\n\");
code:	                        return SNMP_ERR_WRONGTYPE;
code:	                } " . $variables{$vroutine}{$name}{'code-write-length-check-variable'}{'processed'} . $variables{$vroutine}{$name}{'code-write-length-check-fixed'}{'processed'} . (defined $mib->{'defaultValue'} ? "\n /* Note: default value $mib->{'defaultValue'} */" : "") . $variables{$vroutine}{$name}{'code-write-value-check-range'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-enum'}{'processed'} . $variables{$vroutine}{$name}{'code-write-value-check-bits'}{'processed'} . "
code:	                break;
code:	        case RESERVE2: /* memory reseveration, final preparation... */ ".eval ("\"$variables{$mib->{type}}{reserve2}\"")."
code:	                break;
code:	        case FREE: /* Release any resources that have been allocated */ ".eval ("\"$variables{$mib->{type}}{free}\"")."
code:	                break;
code:	        case ACTION: /* The variable has been stored in $variables{$mib->{'type'}}{varname} for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */ ".eval ("\"$variables{$mib->{type}}{action}\"")."
code:	                break;
code:	        case UNDO: /* Back out any changes made in the ACTION case */ ".eval ("\"$variables{$mib->{type}}{undo}\"")."
code:	                break;
code:	        case COMMIT: /* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */ ".eval ("\"$variables{$mib->{'type'}}{'commit'}\"")."
code:	                break;
code:	        }
code:	        return SNMP_ERR_NOERROR;
code:	}
############################################################################
# copy memory from varlist
############################################################################
type:		code-varlist-copy
process:	code-varlist-copy
skipif:		$variables{$vroutine}{$name}{'isanindex'} != 1
code:	            ".eval("\"$variables{$mib->{type}}{action2}\"")."
code:	            vp = vp->next_variable;
############################################################################
# fill out default values in row
############################################################################
type:		code-default-values
process:	code-default-values
skipif:		!$mib->{'defaultValue'}
code:		".eval("\"$variables{$mib->{type}}{action3}\"")."
############################################################################
# delete values from a row
############################################################################
type:		code-delete-values
process:	code-delete-values
skipif:		!($mib->{type} eq "OCTETSTR" || $mib->{type} eq "OBJECTID" || $mib->{type} eq "BITS")
code:		".eval("\"$variables{$mib->{type}}{deletevar}\"")."
############################################################################
# add null pointers to a varlist; value to be parsed later
############################################################################
type:		code-varlist-add-null
process:	code-varlist-add-null
skipif:		$variables{$vroutine}{$name}{'isanindex'} != 1
code:	        /* $name */
code:	        snmp_varlist_add_variable(&vars, NULL, 0, $variables{$mib->{'type'}}{asnType}, NULL, 0);\n 
############################################################################
# write function definition for a RowStatus object,
#   - allows for creation/deletion.
############################################################################
#
# Header info: declare write functions for set processing
#
type:		code-write-rowstatus-decl
process:	code-write-rowstatus-decl
skipif:		$mib->{'textualConvention'} ne "RowStatus"
code:		WriteMethod write_$name;
#
#
#
type:		code-write-rowstatus-oid
process:	code-write-rowstatus-oid
skipif:		$mib->{'textualConvention'} ne "RowStatus"
code:		oid ${vroutine}_variables_oid[] = { " .( stripone dotstocomma $mib->{'objectID'} ). " };
#
# code
#
type:		code-write-rowstatus
process:	code-write-rowstatus
skipif:		$mib->{'textualConvention'} ne "RowStatus"
code:	int
code:	write_$name(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid *name, size_t name_len)
code:	{
code:	        struct ${vroutine}_data *StorageTmp = NULL;
code:	        static struct ${vroutine}_data *StorageNew, *StorageDel;
code:	        size_t newlen=name_len - (sizeof(${vroutine}_variables_oid)/sizeof(oid) + 3 - 1);
code:	        static int old_value;
code:	        int set_value;
code:	        static struct variable_list *vars, *vp;
code:	        struct header_complex_index *hciptr;
code:	        StorageTmp = header_complex(${vroutine}Storage, NULL, &name[sizeof(${vroutine}_variables_oid)/sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
code:	        if (var_val_type != ASN_INTEGER || var_val == NULL) {
code:	                snmp_log(MY_FACILITY(LOG_NOTICE), \"write to $name not ASN_INTEGER\\n\");
code:	                return SNMP_ERR_WRONGTYPE;
code:	        }
code:	        set_value = *((long *) var_val);
code:	        /* check legal range, and notReady is reserved for us, not a user */
code:	        if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
code:	                return SNMP_ERR_INCONSISTENTVALUE;
code:	        switch ( action ) {
code:	        case RESERVE1:
code:	                /* stage one: test validity */
code:	                switch (set_value) {
code:	                case RS_CREATEANDGO:
code:	                case RS_CREATEANDWAIT:
code:	                        if (StorageTmp != NULL)
code:	                                /* cannot create existing row */
code:	                                return SNMP_ERR_INCONSISTENTVALUE;
code:	                        break;
code:	                case RS_ACTIVE:
code:	                case RS_NOTINSERVICE:
code:	                        if (StorageTmp == NULL)
code:	                                /* cannot change state of non-existent row */
code:	                                return SNMP_ERR_INCONSISTENTVALUE;
code:	                        if (StorageTmp->$name == RS_NOTREADY)
code:	                                /* cannot change state of row that is not ready */
code:	                                return SNMP_ERR_INCONSISTENTVALUE;
code:	                        /* XXX: interaction with row storage type needed */
code:	                        if (set_value == RS_NOTINSERVICE && StorageTmp->${vroutine}_refs > 0)
code:	                                /* row is busy and cannot be moved to the RS_NOTINSERVICE state */
code:	                                return SNMP_ERR_INCONSISTENTVALUE;
code:	                        break;
code:	                case RS_DESTROY:
code:	                        /* destroying existent or non-existent row is ok */
code:	                        if (StorageTmp == NULL)
code:	                                break;
code:	                        /* XXX: interaction with row storage type needed */
code:	                        if (StorageTmp->${vroutine}_refs > 0)
code:	                                /* row is busy and cannot be deleted */
code:	                                return SNMP_ERR_INCONSISTENTVALUE;
code:	                        break;
code:	                case RS_NOTREADY:
code:	                        /* management station cannot set this, only agent can */
code:	                default:
code:	                        return SNMP_ERR_INCONSISTENTVALUE;
code:	                }
code:	                break;
code:	        case RESERVE2:
code:	                /* memory reseveration, final preparation... */
code:	                switch (set_value) {
code:	                case RS_CREATEANDGO:
code:	                case RS_CREATEANDWAIT:
code:	                        /* creation */
code:	                        vars = NULL;
code:	                        $variables{$vroutine}{'code-varlist-add-null'}{'processed'} if (header_complex_parse_oid(&(name[sizeof(${vroutine}_variables_oid)/sizeof(oid)+2]), newlen, vars) != SNMPERR_SUCCESS) {
code:	                                /* XXX: free, zero vars */
code:	                                return SNMP_ERR_INCONSISTENTNAME;
code:	                        }
code:	                        vp = vars;
code:	                        if ((StorageNew = SNMP_MALLOC_STRUCT(${vroutine}_data)) == NULL) {
code:	                                /* XXX: free, zero vars */
code:	                                return SNMP_ERR_RESOURCEUNAVAILABLE;
code:	                        }
code:	                        $variables{$vroutine}{'code-varlist-copy'}{'processed'}
code:	                        /* XXX: fill in default row values here into StorageNew */
code:	                        $variables{$vroutine}{'code-default-values'}{'processed'} StorageNew->$name = RS_NOTREADY;
code:	                        /* XXX: free, zero vars, no longer needed? */
code:	                        break;
code:	                }
code:	                break;
code:	        case FREE:
code:	                /* Release any resources that have been allocated */
code:	                switch (set_value) {
code:	                case RS_CREATEANDGO:
code:	                case RS_CREATEANDWAIT:
code:	                        /* creation */
code:	                        ${vroutine}_del(&StorageNew);
code:	                        /* XXX: free, zero vars */
code:	                        break;
code:	                }
code:	                break;
code:	        case ACTION:
code:	                /* The variable has been stored in set_value for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
code:	                switch (set_value) {
code:	                case RS_CREATEANDGO:
code:	                case RS_CREATEANDWAIT:
code:	                        /* row creation, so add it */
code:	                        ${vroutine}_add(StorageNew);
code:	                        break;
code:	                case RS_ACTIVE:
code:	                case RS_NOTINSERVICE:
code:	                        /* set the flag? */
code:	                        old_value = StorageTmp->$name;
code:	                        StorageTmp->$name = set_value;
code:	                        break;
code:	                case RS_DESTROY:
code:	                        /* destroy */
code:	                        if (StorageTmp != NULL) {
code:	                                /* exists, extract it for now */
code:	                                hciptr = header_complex_find_entry(${vroutine}Storage, StorageTmp);
code:	                                StorageDel = header_complex_extract_entry(&${vroutine}Storage, hciptr);
code:	                        } else {
code:	                                StorageDel = NULL;
code:	                        }
code:	                        break;
code:	                }
code:	                break;
code:	        case UNDO:
code:	                /* Back out any changes made in the ACTION case */
code:	                switch (set_value) {
code:	                case RS_CREATEANDGO:
code:	                case RS_CREATEANDWAIT:
code:	                        /* row creation, so remove it again */
code:	                        hciptr = header_complex_find_entry(${vroutine}Storage, StorageNew);
code:	                        header_complex_extract_entry(&${vroutine}Storage, hciptr);
code:	                        break;
code:	                case RS_ACTIVE:
code:	                case RS_NOTINSERVICE:
code:	                        /* restore state */
code:	                        StorageTmp->$name = old_value;
code:	                        break;
code:	                case RS_DESTROY:
code:	                        /* row deletion, so add it again */
code:	                        ${vroutine}_add(StorageDel);
code:	                        break;
code:	                }
code:	                break;
code:	        case COMMIT:
code:	                /* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
code:	                switch (set_value) {
code:	                case RS_CREATEANDGO:
code:	                        /* row creation, set final state */
code:	                        /* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
code:	                        StorageTmp->$name = RS_ACTIVE;
code:	                        break;
code:	                case RS_CREATEANDWAIT:
code:	                        /* row creation, set final state */
code:	                        /* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
code:	                        StorageTmp->$name = RS_NOTINSERVICE;
code:	                        break;
code:	                case RS_ACTIVE:
code:	                case RS_NOTINSERVICE:
code:	                        /* state change already performed */
code:	                        break;
code:	                case RS_DESTROY:
code:	                        /* row deletion, free it its dead */
code:	                        ${vroutine}_del(&StorageDel);
code:	                        /* ${vroutine}_del() can handle NULL pointers. */
code:	                        break;
code:	                }
code:	                break;
code:	        }
code:	        return SNMP_ERR_NOERROR;
code:	}
