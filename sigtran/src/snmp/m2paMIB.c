/*****************************************************************************

 @(#) $RCSfile: m2paMIB.c,v $ $Name: OpenSS7-0_9_2 $($Revision: 0.9.2.1 $) $Date: 2008-12-27 10:01:52 $

 -----------------------------------------------------------------------------

 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2008-12-27 10:01:52 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: m2paMIB.c,v $
 Revision 0.9.2.1  2008-12-27 10:01:52  brian
 - updated mibs and stubs

 *****************************************************************************/

#ident "@(#) $RCSfile: m2paMIB.c,v $ $Name: OpenSS7-0_9_2 $($Revision: 0.9.2.1 $) $Date: 2008-12-27 10:01:52 $"

static char const ident[] = "$RCSfile: m2paMIB.c,v $ $Name: OpenSS7-0_9_2 $($Revision: 0.9.2.1 $) $Date: 2008-12-27 10:01:52 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "m2paMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int m2paMIB_refresh = 1;
volatile int m2paProtocolProfileTable_refresh = 1;

/*
 * m2paMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid m2paMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 202 };
oid m2paProtocolProfileTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 202, 1, 1, 1, 1, 1 };

/*
 * variable7 m2paMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the m2paMIB mib section
 */
struct variable7 m2paMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   M2PAN1                (4 % 256)
	{M2PAN1, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 2}},
#define   M2PAPROVING           (5 % 256)
	{M2PAPROVING, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 3}},
#define   M2PAMANAGEMENTPROVINGSTATE  (6 % 256)
	{M2PAMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 4}},
#define   M2PALOOPDELAYLOWER    (7 % 256)
	{M2PALOOPDELAYLOWER, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 5}},
#define   M2PALOOPDELAYUPPER    (8 % 256)
	{M2PALOOPDELAYUPPER, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 6}},
#define   M2PATRANSMISSIONRATEINTERVALLOWER  (9 % 256)
	{M2PATRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 7}},
#define   M2PATRANSMISSIONRATEINTERVALUPPER  (10 % 256)
	{M2PATRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 8}},
#define   M2PASCTPNODELAY       (11 % 256)
	{M2PASCTPNODELAY, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 9}},
#define   M2PASCTPMAXSEG        (12 % 256)
	{M2PASCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 10}},
#define   M2PASCTPHEARTBEATITVL  (13 % 256)
	{M2PASCTPHEARTBEATITVL, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 11}},
#define   M2PASCTPHEARTBEAT     (14 % 256)
	{M2PASCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 12}},
#define   M2PASCTPRTOINITIAL    (15 % 256)
	{M2PASCTPRTOINITIAL, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 13}},
#define   M2PASCTPRTOMIN        (16 % 256)
	{M2PASCTPRTOMIN, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 14}},
#define   M2PASCTPRTOMAX        (17 % 256)
	{M2PASCTPRTOMAX, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 15}},
#define   M2PASCTPPATHMAXRETRANS  (18 % 256)
	{M2PASCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 16}},
#define   M2PASCTPCOOKIELIFE    (19 % 256)
	{M2PASCTPCOOKIELIFE, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 17}},
#define   M2PASCTPCOOKIEINC     (20 % 256)
	{M2PASCTPCOOKIEINC, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 18}},
#define   M2PASCTPMAXINITRETRIES  (21 % 256)
	{M2PASCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 19}},
#define   M2PASCTPMAXBURST      (22 % 256)
	{M2PASCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 20}},
#define   M2PASCTPASSOCMAXRETRANS  (23 % 256)
	{M2PASCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 21}},
#define   M2PASCTPSACKDELAY     (24 % 256)
	{M2PASCTPSACKDELAY, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 22}},
#define   M2PASCTPLIFETIME      (25 % 256)
	{M2PASCTPLIFETIME, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 23}},
#define   M2PATIMERT1           (26 % 256)
	{M2PATIMERT1, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 24}},
#define   M2PATIMERT2           (27 % 256)
	{M2PATIMERT2, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 25}},
#define   M2PATIMERT2L          (28 % 256)
	{M2PATIMERT2L, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 26}},
#define   M2PATIMERT2H          (29 % 256)
	{M2PATIMERT2H, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 27}},
#define   M2PATIMERT3           (30 % 256)
	{M2PATIMERT3, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 28}},
#define   M2PATIMERT4N          (31 % 256)
	{M2PATIMERT4N, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 29}},
#define   M2PATIMERT4E          (32 % 256)
	{M2PATIMERT4E, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 30}},
#define   M2PATIMERT6           (33 % 256)
	{M2PATIMERT6, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 31}},
#define   M2PATIMERT7           (34 % 256)
	{M2PATIMERT7, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 32}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL1MESSAGES  (35 % 256)
	{M2PATRANSCONGTHRESHOLDABATEMENTL1MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 33}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL1OCTETS  (36 % 256)
	{M2PATRANSCONGTHRESHOLDABATEMENTL1OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 34}},
#define   M2PATRANSCONGTHRESHOLDONSETL1MESSAGES  (37 % 256)
	{M2PATRANSCONGTHRESHOLDONSETL1MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 35}},
#define   M2PATRANSCONGTHRESHOLDONSETL1OCTETS  (38 % 256)
	{M2PATRANSCONGTHRESHOLDONSETL1OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 36}},
#define   M2PAPROVINGATTEMPTS   (39 % 256)
	{M2PAPROVINGATTEMPTS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 37}},
#define   M2PANUMBEROFTHRESHOLDLEVELS  (40 % 256)
	{M2PANUMBEROFTHRESHOLDLEVELS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 38}},
#define   M2PACONGESTIONCOUNTING  (41 % 256)
	{M2PACONGESTIONCOUNTING, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 39}},
#define   M2PACONGESTIONREPORTINGBASEOBJECT  (42 % 256)
	{M2PACONGESTIONREPORTINGBASEOBJECT, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 40}},
#define   M2PATIMERTX           (43 % 256)
	{M2PATIMERTX, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 41}},
#define   M2PATIMERTY           (44 % 256)
	{M2PATIMERTY, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 42}},
#define   M2PANUMBEROFCONGESTIONSTATES  (45 % 256)
	{M2PANUMBEROFCONGESTIONSTATES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 43}},
#define   M2PAINITIALLEVELOFCONGESTION  (46 % 256)
	{M2PAINITIALLEVELOFCONGESTION, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 44}},
#define   M2PARECEIVECONGESTIONTHRESHOLDABATEMENT  (47 % 256)
	{M2PARECEIVECONGESTIONTHRESHOLDABATEMENT, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 45}},
#define   M2PARECEIVECONGESTIONTHRESHOLDONSET  (48 % 256)
	{M2PARECEIVECONGESTIONTHRESHOLDONSET, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 46}},
#define   M2PARECEIVECONGESTIONTHRESHOLDDISCARD  (49 % 256)
	{M2PARECEIVECONGESTIONTHRESHOLDDISCARD, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 47}},
#define   M2PAPROTOCOLPROFILENAME  (50 % 256)
	{M2PAPROTOCOLPROFILENAME, ASN_OCTET_STR, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 48}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL2MESSAGES  (51 % 256)
	{M2PATRANSCONGTHRESHOLDABATEMENTL2MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 49}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL2OCTETS  (52 % 256)
	{M2PATRANSCONGTHRESHOLDABATEMENTL2OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 50}},
#define   M2PATRANSCONGTHRESHOLDONSETL2MESSAGES  (53 % 256)
	{M2PATRANSCONGTHRESHOLDONSETL2MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 51}},
#define   M2PATRANSCONGTHRESHOLDONSETL2OCTETS  (54 % 256)
	{M2PATRANSCONGTHRESHOLDONSETL2OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 52}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL3MESSAGES  (55 % 256)
	{M2PATRANSCONGTHRESHOLDABATEMENTL3MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 53}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL3OCTETS  (56 % 256)
	{M2PATRANSCONGTHRESHOLDABATEMENTL3OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 54}},
#define   M2PATRANSCONGTHRESHOLDONSETL3MESSAGES  (57 % 256)
	{M2PATRANSCONGTHRESHOLDONSETL3MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 55}},
#define   M2PATRANSCONGTHRESHOLDONSETL3OCTETS  (58 % 256)
	{M2PATRANSCONGTHRESHOLDONSETL3OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 56}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL1MESSAGES  (59 % 256)
	{M2PATRANSCONGTHRESHOLDDISCARDL1MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 57}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL1OCTETS  (60 % 256)
	{M2PATRANSCONGTHRESHOLDDISCARDL1OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 58}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL2MESSAGES  (61 % 256)
	{M2PATRANSCONGTHRESHOLDDISCARDL2MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 59}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL2OCTETS  (62 % 256)
	{M2PATRANSCONGTHRESHOLDDISCARDL2OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 60}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL3MESSAGES  (63 % 256)
	{M2PATRANSCONGTHRESHOLDDISCARDL3MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 61}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL3OCTETS  (64 % 256)
	{M2PATRANSCONGTHRESHOLDDISCARDL3OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 62}},
#define   M2PAPROTOCOLPROFILEROWSTATUS  (65 % 256)
	{M2PAPROTOCOLPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 63}},
#define   M2PADEFAULTSCTPNODELAY  (66 % 256)
	{M2PADEFAULTSCTPNODELAY, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 1}},
#define   M2PADEFAULTSCTPMAXSEG  (67 % 256)
	{M2PADEFAULTSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_m2paMIB, 3, {1, 2, 2}},
#define   M2PADEFAULTSCTPHEARTBEATITVL  (68 % 256)
	{M2PADEFAULTSCTPHEARTBEATITVL, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 3}},
#define   M2PADEFAULTSCTPHEARTBEAT  (69 % 256)
	{M2PADEFAULTSCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 4}},
#define   M2PADEFAULTSCTPRTOINITIAL  (70 % 256)
	{M2PADEFAULTSCTPRTOINITIAL, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 5}},
#define   M2PADEFAULTSCTPRTOMIN  (71 % 256)
	{M2PADEFAULTSCTPRTOMIN, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 6}},
#define   M2PADEFAULTSCTPRTOMAX  (72 % 256)
	{M2PADEFAULTSCTPRTOMAX, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 7}},
#define   M2PADEFAULTSCTPPATHMAXRETRANS  (73 % 256)
	{M2PADEFAULTSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_m2paMIB, 3, {1, 2, 8}},
#define   M2PADEFAULTSCTPCOOKIELIFE  (74 % 256)
	{M2PADEFAULTSCTPCOOKIELIFE, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 9}},
#define   M2PADEFAULTSCTPCOOKIEINC  (75 % 256)
	{M2PADEFAULTSCTPCOOKIEINC, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 10}},
#define   M2PADEFAULTSCTPMAXINITRETRIES  (76 % 256)
	{M2PADEFAULTSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_m2paMIB, 3, {1, 2, 11}},
#define   M2PADEFAULTSCTPMAXBURST  (77 % 256)
	{M2PADEFAULTSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_m2paMIB, 3, {1, 2, 12}},
#define   M2PADEFAULTSCTPASSOCMAXRETRANS  (78 % 256)
	{M2PADEFAULTSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_m2paMIB, 3, {1, 2, 13}},
#define   M2PADEFAULTSCTPSACKDELAY  (79 % 256)
	{M2PADEFAULTSCTPSACKDELAY, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 14}},
#define   M2PADEFAULTSCTPLIFETIME  (80 % 256)
	{M2PADEFAULTSCTPLIFETIME, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 15}},

};

/*    (L = length of the oidsuffix) */
struct m2paMIB_data *m2paMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *m2paProtocolProfileTableStorage = NULL;

/*
 * init_m2paMIB():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_m2paMIB(void)
{
	DEBUGMSGTL(("m2paMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("m2paMIB", m2paMIB_variables, variable7, m2paMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_m2paMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("m2paMIB", parse_m2paMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("m2paProtocolProfileTable", parse_m2paProtocolProfileTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m2paMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m2paProtocolProfileTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("m2paMIB", "done.\n"));
}

/*
 * deinit_m2paMIB():
 *   Deinitialization routine.  This is called before the agent is unloaded.
 *   At a minimum, deregistration of your variables should take place here.
 */
void
deinit_m2paMIB(void)
{
	DEBUGMSGTL(("m2paMIB", "deinitializating...  "));
	unregister_mib(m2paMIB_variables_oid, sizeof(m2paMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("m2paMIB");
	snmpd_unregister_config_handler("m2paProtocolProfileTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("m2paMIB", "done.\n"));
}

int
term_m2paMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_m2paMIB();
	return 0;
}

/*
 * m2paMIB_add(): adds a structure node for scalars
 */
int
m2paMIB_add(struct m2paMIB_data *thedata)
{
	DEBUGMSGTL(("m2paMIB", "adding data...  "));
	m2paMIBStorage = thedata;
	DEBUGMSGTL(("m2paMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m2paMIB():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m2paMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct m2paMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(m2paMIB_data);

	DEBUGMSGTL(("m2paMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paDefaultSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paDefaultSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paDefaultSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paDefaultSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paDefaultSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paDefaultSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paDefaultSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paDefaultSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paDefaultSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paDefaultSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paDefaultSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paDefaultSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paDefaultSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paDefaultSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paDefaultSctpLifetime, &tmpsize);

	m2paMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m2paMIB", "done.\n"));
}

/*
 * store_m2paMIB():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m2paMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m2paMIB_data *StorageTmp;

	DEBUGMSGTL(("m2paMIB", "storing data...  "));
	refresh_m2paMIB();
	if ((StorageTmp = m2paMIBStorage) == NULL) {
		DEBUGMSGTL(("m2paMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->m2paMIBStorageType == ST_NONVOLATILE) { */
	memset(line, 0, sizeof(line));
	strcat(line, "m2paMIB ");
	cptr = line + strlen(line);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paDefaultSctpNoDelay, &tmpsize);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paDefaultSctpMaxseg, &tmpsize);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paDefaultSctpHeartbeatItvl, &tmpsize);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paDefaultSctpHeartbeat, &tmpsize);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paDefaultSctpRtoInitial, &tmpsize);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paDefaultSctpRtoMin, &tmpsize);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paDefaultSctpRtoMax, &tmpsize);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paDefaultSctpPathMaxRetrans, &tmpsize);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paDefaultSctpCookieLife, &tmpsize);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paDefaultSctpCookieInc, &tmpsize);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paDefaultSctpMaxInitRetries, &tmpsize);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paDefaultSctpMaxBurst, &tmpsize);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paDefaultSctpAssocMaxRetrans, &tmpsize);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paDefaultSctpSackDelay, &tmpsize);
	cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paDefaultSctpLifetime, &tmpsize);

	snmpd_store_config(line);
	/* } */
	DEBUGMSGTL(("m2paMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_m2paMIB: refresh m2paMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread scalars and tables from the STREAMS susbystem.  This function
 * is used when the agent starts for the first time, or after a SIGPOLL
 * has been received (and a scalar has been requested).
 */
void
refresh_m2paMIB(void)
{
	if (m2paMIBStorage == NULL) {
		struct m2paMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(m2paMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */
		StorageNew->m2paDefaultSctpNoDelay = true;
		StorageNew->m2paDefaultSctpMaxseg = 65536;
		StorageNew->m2paDefaultSctpHeartbeatItvl = 6000;
		StorageNew->m2paDefaultSctpRtoInitial = 300;
		StorageNew->m2paDefaultSctpRtoMin = 100;
		StorageNew->m2paDefaultSctpRtoMax = 6000;
		StorageNew->m2paDefaultSctpPathMaxRetrans = 5;
		StorageNew->m2paDefaultSctpCookieLife = 6000;
		StorageNew->m2paDefaultSctpCookieInc = 100;
		StorageNew->m2paDefaultSctpMaxInitRetries = 8;
		StorageNew->m2paDefaultSctpMaxBurst = 4;
		StorageNew->m2paDefaultSctpAssocMaxRetrans = 10;
		StorageNew->m2paDefaultSctpSackDelay = 20;

		m2paMIBStorage = StorageNew;
		m2paMIB_refresh = 1;
	}
	if (m2paMIB_refresh == 0)
		return;
	m2paMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_m2paMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
uint8_t *
var_m2paMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m2paMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_m2paMIB();
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M2PADEFAULTSCTPNODELAY:
		*write_method = write_m2paDefaultSctpNoDelay;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpNoDelay);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpNoDelay;
	case M2PADEFAULTSCTPMAXSEG:
		*write_method = write_m2paDefaultSctpMaxseg;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpMaxseg);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpMaxseg;
	case M2PADEFAULTSCTPHEARTBEATITVL:
		*write_method = write_m2paDefaultSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpHeartbeatItvl);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpHeartbeatItvl;
	case M2PADEFAULTSCTPHEARTBEAT:
		*write_method = write_m2paDefaultSctpHeartbeat;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpHeartbeat);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpHeartbeat;
	case M2PADEFAULTSCTPRTOINITIAL:
		*write_method = write_m2paDefaultSctpRtoInitial;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpRtoInitial);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpRtoInitial;
	case M2PADEFAULTSCTPRTOMIN:
		*write_method = write_m2paDefaultSctpRtoMin;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpRtoMin);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpRtoMin;
	case M2PADEFAULTSCTPRTOMAX:
		*write_method = write_m2paDefaultSctpRtoMax;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpRtoMax);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpRtoMax;
	case M2PADEFAULTSCTPPATHMAXRETRANS:
		*write_method = write_m2paDefaultSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpPathMaxRetrans);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpPathMaxRetrans;
	case M2PADEFAULTSCTPCOOKIELIFE:
		*write_method = write_m2paDefaultSctpCookieLife;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpCookieLife);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpCookieLife;
	case M2PADEFAULTSCTPCOOKIEINC:
		*write_method = write_m2paDefaultSctpCookieInc;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpCookieInc);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpCookieInc;
	case M2PADEFAULTSCTPMAXINITRETRIES:
		*write_method = write_m2paDefaultSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpMaxInitRetries);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpMaxInitRetries;
	case M2PADEFAULTSCTPMAXBURST:
		*write_method = write_m2paDefaultSctpMaxBurst;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpMaxBurst);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpMaxBurst;
	case M2PADEFAULTSCTPASSOCMAXRETRANS:
		*write_method = write_m2paDefaultSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpAssocMaxRetrans);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpAssocMaxRetrans;
	case M2PADEFAULTSCTPSACKDELAY:
		*write_method = write_m2paDefaultSctpSackDelay;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpSackDelay);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpSackDelay;
	case M2PADEFAULTSCTPLIFETIME:
		*write_method = write_m2paDefaultSctpLifetime;
		*var_len = sizeof(StorageTmp->m2paDefaultSctpLifetime);
		return (uint8_t *) &StorageTmp->m2paDefaultSctpLifetime;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * m2paProtocolProfileTable_add(): adds a structure node to our data set
 */
int
m2paProtocolProfileTable_add(struct m2paProtocolProfileTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m2paProtocolProfileTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m2paProtocolProfileId */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, (uint8_t *) thedata->m2paProtocolProfileId, thedata->m2paProtocolProfileIdLen);

	header_complex_add_data(&m2paProtocolProfileTableStorage, vars, thedata);
	DEBUGMSGTL(("m2paProtocolProfileTable", "registered an entry\n"));
	DEBUGMSGTL(("m2paProtocolProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m2paProtocolProfileTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m2paProtocolProfileTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m2paProtocolProfileTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m2paProtocolProfileTable_data);

	DEBUGMSGTL(("m2paProtocolProfileTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m2paProtocolProfileId, &tmpsize);
	StorageTmp->m2paProtocolProfileIdLen = tmpsize;
	if (StorageTmp->m2paProtocolProfileId == NULL) {
		config_perror("invalid specification for m2paProtocolProfileId");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paN1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paProving, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paManagementProvingState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paLoopDelayLower, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paLoopDelayUpper, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransmissionRateIntervalLower, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransmissionRateIntervalUpper, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paSctpNoDelay, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paSctpMaxseg, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paSctpHeartbeatItvl, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paSctpHeartbeat, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paSctpRtoInitial, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paSctpRtoMin, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paSctpRtoMax, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paSctpPathMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paSctpCookieLife, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paSctpCookieInc, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paSctpMaxInitRetries, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paSctpMaxBurst, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paSctpAssocMaxRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paSctpSackDelay, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paSctpLifetime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerT2L, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerT2H, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerT4N, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerT4E, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerT7, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdAbatementL1Messages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdAbatementL1Octets, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdOnsetL1Messages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdOnsetL1Octets, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paProvingAttempts, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paNumberOfThresholdLevels, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paCongestionCounting, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paCongestionReportingBaseObject, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerTx, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paTimerTy, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paNumberOfCongestionStates, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paInitialLevelOfCongestion, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paReceiveCongestionThresholdAbatement, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paReceiveCongestionThresholdOnset, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paReceiveCongestionThresholdDiscard, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m2paProtocolProfileName, &tmpsize);
	StorageTmp->m2paProtocolProfileNameLen = tmpsize;
	if (StorageTmp->m2paProtocolProfileName == NULL) {
		config_perror("invalid specification for m2paProtocolProfileName");
		return;
	}

	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdAbatementL2Messages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdAbatementL2Octets, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdOnsetL2Messages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdOnsetL2Octets, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdAbatementL3Messages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdAbatementL3Octets, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdOnsetL3Messages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdOnsetL3Octets, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdDiscardL1Messages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdDiscardL1Octets, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdDiscardL2Messages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdDiscardL2Octets, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdDiscardL3Messages, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m2paTransCongThresholdDiscardL3Octets, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m2paProtocolProfileRowStatus, &tmpsize);

	m2paProtocolProfileTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m2paProtocolProfileTable", "done.\n"));
}

/*
 * store_m2paProtocolProfileTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m2paProtocolProfileTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m2paProtocolProfileTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m2paProtocolProfileTable", "storing data...  "));
	refresh_m2paProtocolProfileTable();
	(void) tmpsize;
	for (hcindex = m2paProtocolProfileTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m2paProtocolProfileTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m2paProtocolProfileTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m2paProtocolProfileTable ");
		cptr = line + strlen(line);
		tmpsize = StorageTmp->m2paProtocolProfileIdLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m2paProtocolProfileId, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paN1, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paProving, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paManagementProvingState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paLoopDelayLower, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paLoopDelayUpper, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransmissionRateIntervalLower, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransmissionRateIntervalUpper, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paSctpNoDelay, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paSctpMaxseg, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paSctpHeartbeatItvl, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paSctpHeartbeat, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paSctpRtoInitial, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paSctpRtoMin, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paSctpRtoMax, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paSctpPathMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paSctpCookieLife, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paSctpCookieInc, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paSctpMaxInitRetries, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paSctpMaxBurst, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paSctpAssocMaxRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paSctpSackDelay, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paSctpLifetime, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerT1, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerT2, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerT2L, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerT2H, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerT3, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerT4N, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerT4E, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerT6, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerT7, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdAbatementL1Messages, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdAbatementL1Octets, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdOnsetL1Messages, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdOnsetL1Octets, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paProvingAttempts, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paNumberOfThresholdLevels, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paCongestionCounting, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paCongestionReportingBaseObject, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerTx, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paTimerTy, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paNumberOfCongestionStates, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paInitialLevelOfCongestion, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paReceiveCongestionThresholdAbatement, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paReceiveCongestionThresholdOnset, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paReceiveCongestionThresholdDiscard, &tmpsize);
		tmpsize = StorageTmp->m2paProtocolProfileNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m2paProtocolProfileName, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdAbatementL2Messages, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdAbatementL2Octets, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdOnsetL2Messages, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdOnsetL2Octets, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdAbatementL3Messages, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdAbatementL3Octets, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdOnsetL3Messages, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdOnsetL3Octets, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdDiscardL1Messages, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdDiscardL1Octets, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdDiscardL2Messages, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdDiscardL2Octets, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdDiscardL3Messages, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m2paTransCongThresholdDiscardL3Octets, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m2paProtocolProfileRowStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m2paProtocolProfileTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_m2paProtocolProfileTable(): refresh m2paProtocolProfileTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m2paProtocolProfileTable(void)
{
	if (m2paProtocolProfileTable_refresh == 0)
		return;
	m2paProtocolProfileTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m2paProtocolProfileTable_row(): refresh m2paProtocolProfileTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m2paProtocolProfileTable_row(struct m2paProtocolProfileTable_data *StorageTmp)
{
	if (StorageTmp->m2paProtocolProfileTable_request == sa_request)
		return;
	StorageTmp->m2paProtocolProfileTable_request = sa_request;
}

/*
 * var_m2paProtocolProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2paMIB above.
 */
uint8_t *
var_m2paProtocolProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m2paMIB", "var_m2paProtocolProfileTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m2paProtocolProfileTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m2paProtocolProfileTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M2PAN1:
		*write_method = write_m2paN1;
		*var_len = sizeof(StorageTmp->m2paN1);
		return (uint8_t *) &StorageTmp->m2paN1;
	case M2PAPROVING:
		*write_method = write_m2paProving;
		*var_len = sizeof(StorageTmp->m2paProving);
		return (uint8_t *) &StorageTmp->m2paProving;
	case M2PAMANAGEMENTPROVINGSTATE:
		*write_method = write_m2paManagementProvingState;
		*var_len = sizeof(StorageTmp->m2paManagementProvingState);
		return (uint8_t *) &StorageTmp->m2paManagementProvingState;
	case M2PALOOPDELAYLOWER:
		*write_method = write_m2paLoopDelayLower;
		*var_len = sizeof(StorageTmp->m2paLoopDelayLower);
		return (uint8_t *) &StorageTmp->m2paLoopDelayLower;
	case M2PALOOPDELAYUPPER:
		*write_method = write_m2paLoopDelayUpper;
		*var_len = sizeof(StorageTmp->m2paLoopDelayUpper);
		return (uint8_t *) &StorageTmp->m2paLoopDelayUpper;
	case M2PATRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_m2paTransmissionRateIntervalLower;
		*var_len = sizeof(StorageTmp->m2paTransmissionRateIntervalLower);
		return (uint8_t *) &StorageTmp->m2paTransmissionRateIntervalLower;
	case M2PATRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_m2paTransmissionRateIntervalUpper;
		*var_len = sizeof(StorageTmp->m2paTransmissionRateIntervalUpper);
		return (uint8_t *) &StorageTmp->m2paTransmissionRateIntervalUpper;
	case M2PASCTPNODELAY:
		*write_method = write_m2paSctpNoDelay;
		*var_len = sizeof(StorageTmp->m2paSctpNoDelay);
		return (uint8_t *) &StorageTmp->m2paSctpNoDelay;
	case M2PASCTPMAXSEG:
		*write_method = write_m2paSctpMaxseg;
		*var_len = sizeof(StorageTmp->m2paSctpMaxseg);
		return (uint8_t *) &StorageTmp->m2paSctpMaxseg;
	case M2PASCTPHEARTBEATITVL:
		*write_method = write_m2paSctpHeartbeatItvl;
		*var_len = sizeof(StorageTmp->m2paSctpHeartbeatItvl);
		return (uint8_t *) &StorageTmp->m2paSctpHeartbeatItvl;
	case M2PASCTPHEARTBEAT:
		*write_method = write_m2paSctpHeartbeat;
		*var_len = sizeof(StorageTmp->m2paSctpHeartbeat);
		return (uint8_t *) &StorageTmp->m2paSctpHeartbeat;
	case M2PASCTPRTOINITIAL:
		*write_method = write_m2paSctpRtoInitial;
		*var_len = sizeof(StorageTmp->m2paSctpRtoInitial);
		return (uint8_t *) &StorageTmp->m2paSctpRtoInitial;
	case M2PASCTPRTOMIN:
		*write_method = write_m2paSctpRtoMin;
		*var_len = sizeof(StorageTmp->m2paSctpRtoMin);
		return (uint8_t *) &StorageTmp->m2paSctpRtoMin;
	case M2PASCTPRTOMAX:
		*write_method = write_m2paSctpRtoMax;
		*var_len = sizeof(StorageTmp->m2paSctpRtoMax);
		return (uint8_t *) &StorageTmp->m2paSctpRtoMax;
	case M2PASCTPPATHMAXRETRANS:
		*write_method = write_m2paSctpPathMaxRetrans;
		*var_len = sizeof(StorageTmp->m2paSctpPathMaxRetrans);
		return (uint8_t *) &StorageTmp->m2paSctpPathMaxRetrans;
	case M2PASCTPCOOKIELIFE:
		*write_method = write_m2paSctpCookieLife;
		*var_len = sizeof(StorageTmp->m2paSctpCookieLife);
		return (uint8_t *) &StorageTmp->m2paSctpCookieLife;
	case M2PASCTPCOOKIEINC:
		*write_method = write_m2paSctpCookieInc;
		*var_len = sizeof(StorageTmp->m2paSctpCookieInc);
		return (uint8_t *) &StorageTmp->m2paSctpCookieInc;
	case M2PASCTPMAXINITRETRIES:
		*write_method = write_m2paSctpMaxInitRetries;
		*var_len = sizeof(StorageTmp->m2paSctpMaxInitRetries);
		return (uint8_t *) &StorageTmp->m2paSctpMaxInitRetries;
	case M2PASCTPMAXBURST:
		*write_method = write_m2paSctpMaxBurst;
		*var_len = sizeof(StorageTmp->m2paSctpMaxBurst);
		return (uint8_t *) &StorageTmp->m2paSctpMaxBurst;
	case M2PASCTPASSOCMAXRETRANS:
		*write_method = write_m2paSctpAssocMaxRetrans;
		*var_len = sizeof(StorageTmp->m2paSctpAssocMaxRetrans);
		return (uint8_t *) &StorageTmp->m2paSctpAssocMaxRetrans;
	case M2PASCTPSACKDELAY:
		*write_method = write_m2paSctpSackDelay;
		*var_len = sizeof(StorageTmp->m2paSctpSackDelay);
		return (uint8_t *) &StorageTmp->m2paSctpSackDelay;
	case M2PASCTPLIFETIME:
		*write_method = write_m2paSctpLifetime;
		*var_len = sizeof(StorageTmp->m2paSctpLifetime);
		return (uint8_t *) &StorageTmp->m2paSctpLifetime;
	case M2PATIMERT1:
		*write_method = write_m2paTimerT1;
		*var_len = sizeof(StorageTmp->m2paTimerT1);
		return (uint8_t *) &StorageTmp->m2paTimerT1;
	case M2PATIMERT2:
		*write_method = write_m2paTimerT2;
		*var_len = sizeof(StorageTmp->m2paTimerT2);
		return (uint8_t *) &StorageTmp->m2paTimerT2;
	case M2PATIMERT2L:
		*write_method = write_m2paTimerT2L;
		*var_len = sizeof(StorageTmp->m2paTimerT2L);
		return (uint8_t *) &StorageTmp->m2paTimerT2L;
	case M2PATIMERT2H:
		*write_method = write_m2paTimerT2H;
		*var_len = sizeof(StorageTmp->m2paTimerT2H);
		return (uint8_t *) &StorageTmp->m2paTimerT2H;
	case M2PATIMERT3:
		*write_method = write_m2paTimerT3;
		*var_len = sizeof(StorageTmp->m2paTimerT3);
		return (uint8_t *) &StorageTmp->m2paTimerT3;
	case M2PATIMERT4N:
		*write_method = write_m2paTimerT4N;
		*var_len = sizeof(StorageTmp->m2paTimerT4N);
		return (uint8_t *) &StorageTmp->m2paTimerT4N;
	case M2PATIMERT4E:
		*write_method = write_m2paTimerT4E;
		*var_len = sizeof(StorageTmp->m2paTimerT4E);
		return (uint8_t *) &StorageTmp->m2paTimerT4E;
	case M2PATIMERT6:
		*write_method = write_m2paTimerT6;
		*var_len = sizeof(StorageTmp->m2paTimerT6);
		return (uint8_t *) &StorageTmp->m2paTimerT6;
	case M2PATIMERT7:
		*write_method = write_m2paTimerT7;
		*var_len = sizeof(StorageTmp->m2paTimerT7);
		return (uint8_t *) &StorageTmp->m2paTimerT7;
	case M2PATRANSCONGTHRESHOLDABATEMENTL1MESSAGES:
		*write_method = write_m2paTransCongThresholdAbatementL1Messages;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdAbatementL1Messages);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdAbatementL1Messages;
	case M2PATRANSCONGTHRESHOLDABATEMENTL1OCTETS:
		*write_method = write_m2paTransCongThresholdAbatementL1Octets;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdAbatementL1Octets);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdAbatementL1Octets;
	case M2PATRANSCONGTHRESHOLDONSETL1MESSAGES:
		*write_method = write_m2paTransCongThresholdOnsetL1Messages;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdOnsetL1Messages);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdOnsetL1Messages;
	case M2PATRANSCONGTHRESHOLDONSETL1OCTETS:
		*write_method = write_m2paTransCongThresholdOnsetL1Octets;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdOnsetL1Octets);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdOnsetL1Octets;
	case M2PAPROVINGATTEMPTS:
		*write_method = write_m2paProvingAttempts;
		*var_len = sizeof(StorageTmp->m2paProvingAttempts);
		return (uint8_t *) &StorageTmp->m2paProvingAttempts;
	case M2PANUMBEROFTHRESHOLDLEVELS:
		*write_method = write_m2paNumberOfThresholdLevels;
		*var_len = sizeof(StorageTmp->m2paNumberOfThresholdLevels);
		return (uint8_t *) &StorageTmp->m2paNumberOfThresholdLevels;
	case M2PACONGESTIONCOUNTING:
		*write_method = write_m2paCongestionCounting;
		*var_len = sizeof(StorageTmp->m2paCongestionCounting);
		return (uint8_t *) &StorageTmp->m2paCongestionCounting;
	case M2PACONGESTIONREPORTINGBASEOBJECT:
		*write_method = write_m2paCongestionReportingBaseObject;
		*var_len = sizeof(StorageTmp->m2paCongestionReportingBaseObject);
		return (uint8_t *) &StorageTmp->m2paCongestionReportingBaseObject;
	case M2PATIMERTX:
		*write_method = write_m2paTimerTx;
		*var_len = sizeof(StorageTmp->m2paTimerTx);
		return (uint8_t *) &StorageTmp->m2paTimerTx;
	case M2PATIMERTY:
		*write_method = write_m2paTimerTy;
		*var_len = sizeof(StorageTmp->m2paTimerTy);
		return (uint8_t *) &StorageTmp->m2paTimerTy;
	case M2PANUMBEROFCONGESTIONSTATES:
		*write_method = write_m2paNumberOfCongestionStates;
		*var_len = sizeof(StorageTmp->m2paNumberOfCongestionStates);
		return (uint8_t *) &StorageTmp->m2paNumberOfCongestionStates;
	case M2PAINITIALLEVELOFCONGESTION:
		*write_method = write_m2paInitialLevelOfCongestion;
		*var_len = sizeof(StorageTmp->m2paInitialLevelOfCongestion);
		return (uint8_t *) &StorageTmp->m2paInitialLevelOfCongestion;
	case M2PARECEIVECONGESTIONTHRESHOLDABATEMENT:
		*write_method = write_m2paReceiveCongestionThresholdAbatement;
		*var_len = sizeof(StorageTmp->m2paReceiveCongestionThresholdAbatement);
		return (uint8_t *) &StorageTmp->m2paReceiveCongestionThresholdAbatement;
	case M2PARECEIVECONGESTIONTHRESHOLDONSET:
		*write_method = write_m2paReceiveCongestionThresholdOnset;
		*var_len = sizeof(StorageTmp->m2paReceiveCongestionThresholdOnset);
		return (uint8_t *) &StorageTmp->m2paReceiveCongestionThresholdOnset;
	case M2PARECEIVECONGESTIONTHRESHOLDDISCARD:
		*write_method = write_m2paReceiveCongestionThresholdDiscard;
		*var_len = sizeof(StorageTmp->m2paReceiveCongestionThresholdDiscard);
		return (uint8_t *) &StorageTmp->m2paReceiveCongestionThresholdDiscard;
	case M2PAPROTOCOLPROFILENAME:
		*write_method = write_m2paProtocolProfileName;
		*var_len = StorageTmp->m2paProtocolProfileNameLen;
		return (uint8_t *) StorageTmp->m2paProtocolProfileName;
	case M2PATRANSCONGTHRESHOLDABATEMENTL2MESSAGES:
		*write_method = write_m2paTransCongThresholdAbatementL2Messages;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdAbatementL2Messages);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdAbatementL2Messages;
	case M2PATRANSCONGTHRESHOLDABATEMENTL2OCTETS:
		*write_method = write_m2paTransCongThresholdAbatementL2Octets;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdAbatementL2Octets);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdAbatementL2Octets;
	case M2PATRANSCONGTHRESHOLDONSETL2MESSAGES:
		*write_method = write_m2paTransCongThresholdOnsetL2Messages;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdOnsetL2Messages);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdOnsetL2Messages;
	case M2PATRANSCONGTHRESHOLDONSETL2OCTETS:
		*write_method = write_m2paTransCongThresholdOnsetL2Octets;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdOnsetL2Octets);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdOnsetL2Octets;
	case M2PATRANSCONGTHRESHOLDABATEMENTL3MESSAGES:
		*write_method = write_m2paTransCongThresholdAbatementL3Messages;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdAbatementL3Messages);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdAbatementL3Messages;
	case M2PATRANSCONGTHRESHOLDABATEMENTL3OCTETS:
		*write_method = write_m2paTransCongThresholdAbatementL3Octets;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdAbatementL3Octets);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdAbatementL3Octets;
	case M2PATRANSCONGTHRESHOLDONSETL3MESSAGES:
		*write_method = write_m2paTransCongThresholdOnsetL3Messages;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdOnsetL3Messages);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdOnsetL3Messages;
	case M2PATRANSCONGTHRESHOLDONSETL3OCTETS:
		*write_method = write_m2paTransCongThresholdOnsetL3Octets;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdOnsetL3Octets);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdOnsetL3Octets;
	case M2PATRANSCONGTHRESHOLDDISCARDL1MESSAGES:
		*write_method = write_m2paTransCongThresholdDiscardL1Messages;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdDiscardL1Messages);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdDiscardL1Messages;
	case M2PATRANSCONGTHRESHOLDDISCARDL1OCTETS:
		*write_method = write_m2paTransCongThresholdDiscardL1Octets;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdDiscardL1Octets);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdDiscardL1Octets;
	case M2PATRANSCONGTHRESHOLDDISCARDL2MESSAGES:
		*write_method = write_m2paTransCongThresholdDiscardL2Messages;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdDiscardL2Messages);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdDiscardL2Messages;
	case M2PATRANSCONGTHRESHOLDDISCARDL2OCTETS:
		*write_method = write_m2paTransCongThresholdDiscardL2Octets;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdDiscardL2Octets);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdDiscardL2Octets;
	case M2PATRANSCONGTHRESHOLDDISCARDL3MESSAGES:
		*write_method = write_m2paTransCongThresholdDiscardL3Messages;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdDiscardL3Messages);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdDiscardL3Messages;
	case M2PATRANSCONGTHRESHOLDDISCARDL3OCTETS:
		*write_method = write_m2paTransCongThresholdDiscardL3Octets;
		*var_len = sizeof(StorageTmp->m2paTransCongThresholdDiscardL3Octets);
		return (uint8_t *) &StorageTmp->m2paTransCongThresholdDiscardL3Octets;
	case M2PAPROTOCOLPROFILEROWSTATUS:
		*write_method = write_m2paProtocolProfileRowStatus;
		*var_len = sizeof(StorageTmp->m2paProtocolProfileRowStatus);
		return (uint8_t *) &StorageTmp->m2paProtocolProfileRowStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_m2paN1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paN1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paN1;
		StorageTmp->m2paN1 = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paN1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paProving(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paProving entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paProving not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paProving;
		StorageTmp->m2paProving = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paProving = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paManagementProvingState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paManagementProvingState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paManagementProvingState;
		StorageTmp->m2paManagementProvingState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paManagementProvingState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paLoopDelayLower(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paLoopDelayLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paLoopDelayLower not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paLoopDelayLower;
		StorageTmp->m2paLoopDelayLower = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paLoopDelayLower = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paLoopDelayUpper(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paLoopDelayUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paLoopDelayUpper not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paLoopDelayUpper;
		StorageTmp->m2paLoopDelayUpper = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paLoopDelayUpper = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransmissionRateIntervalLower(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransmissionRateIntervalLower entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransmissionRateIntervalLower;
		StorageTmp->m2paTransmissionRateIntervalLower = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransmissionRateIntervalLower = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransmissionRateIntervalUpper(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransmissionRateIntervalUpper entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransmissionRateIntervalUpper;
		StorageTmp->m2paTransmissionRateIntervalUpper = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransmissionRateIntervalUpper = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpNoDelay(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpNoDelay;
		StorageTmp->m2paSctpNoDelay = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpNoDelay = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpMaxseg(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpMaxseg;
		StorageTmp->m2paSctpMaxseg = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpMaxseg = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpHeartbeatItvl(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpHeartbeatItvl not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpHeartbeatItvl;
		StorageTmp->m2paSctpHeartbeatItvl = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpHeartbeatItvl = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpHeartbeat(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpHeartbeat;
		StorageTmp->m2paSctpHeartbeat = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpHeartbeat = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpRtoInitial(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpRtoInitial not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpRtoInitial;
		StorageTmp->m2paSctpRtoInitial = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpRtoInitial = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpRtoMin(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpRtoMin;
		StorageTmp->m2paSctpRtoMin = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpRtoMin = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpRtoMax(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpRtoMax not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpRtoMax;
		StorageTmp->m2paSctpRtoMax = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpRtoMax = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpPathMaxRetrans(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpPathMaxRetrans;
		StorageTmp->m2paSctpPathMaxRetrans = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpPathMaxRetrans = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpCookieLife(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpCookieLife not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpCookieLife;
		StorageTmp->m2paSctpCookieLife = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpCookieLife = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpCookieInc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpCookieInc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpCookieInc;
		StorageTmp->m2paSctpCookieInc = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpCookieInc = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpMaxInitRetries(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpMaxInitRetries;
		StorageTmp->m2paSctpMaxInitRetries = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpMaxInitRetries = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpMaxBurst(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpMaxBurst;
		StorageTmp->m2paSctpMaxBurst = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpMaxBurst = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpAssocMaxRetrans(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpAssocMaxRetrans;
		StorageTmp->m2paSctpAssocMaxRetrans = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpAssocMaxRetrans = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpSackDelay(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpSackDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpSackDelay;
		StorageTmp->m2paSctpSackDelay = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpSackDelay = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpLifetime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paSctpLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paSctpLifetime;
		StorageTmp->m2paSctpLifetime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paSctpLifetime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerT1;
		StorageTmp->m2paTimerT1 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerT1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerT2;
		StorageTmp->m2paTimerT2 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerT2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT2L(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerT2L entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerT2L not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerT2L;
		StorageTmp->m2paTimerT2L = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerT2L = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT2H(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerT2H entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerT2H not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerT2H;
		StorageTmp->m2paTimerT2H = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerT2H = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT3(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerT3;
		StorageTmp->m2paTimerT3 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerT3 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT4N(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerT4N entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerT4N not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerT4N;
		StorageTmp->m2paTimerT4N = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerT4N = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT4E(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerT4E entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerT4E not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerT4E;
		StorageTmp->m2paTimerT4E = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerT4E = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT6(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerT6 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerT6;
		StorageTmp->m2paTimerT6 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerT6 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT7(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerT7;
		StorageTmp->m2paTimerT7 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerT7 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL1Messages(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdAbatementL1Messages entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdAbatementL1Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdAbatementL1Messages;
		StorageTmp->m2paTransCongThresholdAbatementL1Messages = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdAbatementL1Messages = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL1Octets(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdAbatementL1Octets entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdAbatementL1Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdAbatementL1Octets;
		StorageTmp->m2paTransCongThresholdAbatementL1Octets = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdAbatementL1Octets = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL1Messages(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdOnsetL1Messages entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdOnsetL1Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdOnsetL1Messages;
		StorageTmp->m2paTransCongThresholdOnsetL1Messages = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdOnsetL1Messages = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL1Octets(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdOnsetL1Octets entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdOnsetL1Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdOnsetL1Octets;
		StorageTmp->m2paTransCongThresholdOnsetL1Octets = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdOnsetL1Octets = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paProvingAttempts(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paProvingAttempts entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paProvingAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paProvingAttempts;
		StorageTmp->m2paProvingAttempts = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paProvingAttempts = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paNumberOfThresholdLevels(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paNumberOfThresholdLevels entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paNumberOfThresholdLevels not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paNumberOfThresholdLevels;
		StorageTmp->m2paNumberOfThresholdLevels = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paNumberOfThresholdLevels = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paCongestionCounting(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paCongestionCounting entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paCongestionCounting not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paCongestionCounting;
		StorageTmp->m2paCongestionCounting = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paCongestionCounting = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paCongestionReportingBaseObject(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paCongestionReportingBaseObject entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paCongestionReportingBaseObject not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paCongestionReportingBaseObject;
		StorageTmp->m2paCongestionReportingBaseObject = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paCongestionReportingBaseObject = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerTx(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerTx entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerTx not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerTx;
		StorageTmp->m2paTimerTx = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerTx = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerTy(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTimerTy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTimerTy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTimerTy;
		StorageTmp->m2paTimerTy = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTimerTy = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paNumberOfCongestionStates(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paNumberOfCongestionStates entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paNumberOfCongestionStates not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paNumberOfCongestionStates;
		StorageTmp->m2paNumberOfCongestionStates = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paNumberOfCongestionStates = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paInitialLevelOfCongestion(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paInitialLevelOfCongestion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paInitialLevelOfCongestion not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paInitialLevelOfCongestion;
		StorageTmp->m2paInitialLevelOfCongestion = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paInitialLevelOfCongestion = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paReceiveCongestionThresholdAbatement(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paReceiveCongestionThresholdAbatement entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paReceiveCongestionThresholdAbatement not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paReceiveCongestionThresholdAbatement;
		StorageTmp->m2paReceiveCongestionThresholdAbatement = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paReceiveCongestionThresholdAbatement = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paReceiveCongestionThresholdOnset(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paReceiveCongestionThresholdOnset entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paReceiveCongestionThresholdOnset not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paReceiveCongestionThresholdOnset;
		StorageTmp->m2paReceiveCongestionThresholdOnset = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paReceiveCongestionThresholdOnset = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paReceiveCongestionThresholdDiscard(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paReceiveCongestionThresholdDiscard entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paReceiveCongestionThresholdDiscard not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paReceiveCongestionThresholdDiscard;
		StorageTmp->m2paReceiveCongestionThresholdDiscard = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paReceiveCongestionThresholdDiscard = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paProtocolProfileName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paProtocolProfileName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paProtocolProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paProtocolProfileName;
		tmplen = StorageTmp->m2paProtocolProfileNameLen;
		memdup((void *) &StorageTmp->m2paProtocolProfileName, var_val, var_val_len);
		StorageTmp->m2paProtocolProfileNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m2paProtocolProfileName);
		StorageTmp->m2paProtocolProfileName = tmpvar;
		StorageTmp->m2paProtocolProfileNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL2Messages(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdAbatementL2Messages entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdAbatementL2Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdAbatementL2Messages;
		StorageTmp->m2paTransCongThresholdAbatementL2Messages = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdAbatementL2Messages = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL2Octets(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdAbatementL2Octets entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdAbatementL2Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdAbatementL2Octets;
		StorageTmp->m2paTransCongThresholdAbatementL2Octets = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdAbatementL2Octets = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL2Messages(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdOnsetL2Messages entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdOnsetL2Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdOnsetL2Messages;
		StorageTmp->m2paTransCongThresholdOnsetL2Messages = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdOnsetL2Messages = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL2Octets(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdOnsetL2Octets entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdOnsetL2Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdOnsetL2Octets;
		StorageTmp->m2paTransCongThresholdOnsetL2Octets = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdOnsetL2Octets = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL3Messages(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdAbatementL3Messages entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdAbatementL3Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdAbatementL3Messages;
		StorageTmp->m2paTransCongThresholdAbatementL3Messages = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdAbatementL3Messages = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL3Octets(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdAbatementL3Octets entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdAbatementL3Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdAbatementL3Octets;
		StorageTmp->m2paTransCongThresholdAbatementL3Octets = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdAbatementL3Octets = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL3Messages(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdOnsetL3Messages entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdOnsetL3Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdOnsetL3Messages;
		StorageTmp->m2paTransCongThresholdOnsetL3Messages = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdOnsetL3Messages = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL3Octets(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdOnsetL3Octets entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdOnsetL3Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdOnsetL3Octets;
		StorageTmp->m2paTransCongThresholdOnsetL3Octets = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdOnsetL3Octets = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL1Messages(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdDiscardL1Messages entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdDiscardL1Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdDiscardL1Messages;
		StorageTmp->m2paTransCongThresholdDiscardL1Messages = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdDiscardL1Messages = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL1Octets(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdDiscardL1Octets entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdDiscardL1Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdDiscardL1Octets;
		StorageTmp->m2paTransCongThresholdDiscardL1Octets = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdDiscardL1Octets = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL2Messages(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdDiscardL2Messages entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdDiscardL2Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdDiscardL2Messages;
		StorageTmp->m2paTransCongThresholdDiscardL2Messages = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdDiscardL2Messages = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL2Octets(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdDiscardL2Octets entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdDiscardL2Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdDiscardL2Octets;
		StorageTmp->m2paTransCongThresholdDiscardL2Octets = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdDiscardL2Octets = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL3Messages(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdDiscardL3Messages entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdDiscardL3Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdDiscardL3Messages;
		StorageTmp->m2paTransCongThresholdDiscardL3Messages = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdDiscardL3Messages = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL3Octets(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paTransCongThresholdDiscardL3Octets entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paTransCongThresholdDiscardL3Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paTransCongThresholdDiscardL3Octets;
		StorageTmp->m2paTransCongThresholdDiscardL3Octets = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paTransCongThresholdDiscardL3Octets = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpNoDelay(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpNoDelay entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value true */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpNoDelay;
		StorageTmp->m2paDefaultSctpNoDelay = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpNoDelay = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpMaxseg(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpMaxseg entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 65536 */
		/* Note: ranges 1..65536 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpMaxseg;
		StorageTmp->m2paDefaultSctpMaxseg = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpMaxseg = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpHeartbeatItvl(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpHeartbeatItvl entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpHeartbeatItvl not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpHeartbeatItvl;
		StorageTmp->m2paDefaultSctpHeartbeatItvl = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpHeartbeatItvl = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpHeartbeat(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpHeartbeat entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: no default */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpHeartbeat;
		StorageTmp->m2paDefaultSctpHeartbeat = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpHeartbeat = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpRtoInitial(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpRtoInitial entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpRtoInitial not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 300 */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpRtoInitial;
		StorageTmp->m2paDefaultSctpRtoInitial = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpRtoInitial = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpRtoMin(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpRtoMin;
		StorageTmp->m2paDefaultSctpRtoMin = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpRtoMin = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpRtoMax(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpRtoMax entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpRtoMax not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpRtoMax;
		StorageTmp->m2paDefaultSctpRtoMax = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpRtoMax = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpPathMaxRetrans(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpPathMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 5 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpPathMaxRetrans;
		StorageTmp->m2paDefaultSctpPathMaxRetrans = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpPathMaxRetrans = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpCookieLife(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpCookieLife entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpCookieLife not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 6000 */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpCookieLife;
		StorageTmp->m2paDefaultSctpCookieLife = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpCookieLife = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpCookieInc(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpCookieInc entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpCookieInc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 100 */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpCookieInc;
		StorageTmp->m2paDefaultSctpCookieInc = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpCookieInc = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpMaxInitRetries(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpMaxInitRetries entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 8 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpMaxInitRetries;
		StorageTmp->m2paDefaultSctpMaxInitRetries = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpMaxInitRetries = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpMaxBurst(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpMaxBurst entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 4 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpMaxBurst;
		StorageTmp->m2paDefaultSctpMaxBurst = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpMaxBurst = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpAssocMaxRetrans(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpAssocMaxRetrans entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 10 */
		/* Note: ranges (none) */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpAssocMaxRetrans;
		StorageTmp->m2paDefaultSctpAssocMaxRetrans = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpAssocMaxRetrans = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpSackDelay(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpSackDelay entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpSackDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 20 */
		/* Note: ranges 0..50 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpSackDelay;
		StorageTmp->m2paDefaultSctpSackDelay = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpSackDelay = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpLifetime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m2paMIB_data *StorageTmp = NULL;
	static size_t tmplen;

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m2paMIB", "write_m2paDefaultSctpLifetime entering action=%d...  \n", action));
	if ((StorageTmp = m2paMIBStorage) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paDefaultSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		/* Note: ranges 0..2147483647 */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m2paDefaultSctpLifetime;
		StorageTmp->m2paDefaultSctpLifetime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m2paDefaultSctpLifetime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paProtocolProfileRowStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct m2paProtocolProfileTable_data *StorageTmp = NULL;
	static struct m2paProtocolProfileTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m2paProtocolProfileTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m2paProtocolProfileTableStorage, NULL, &name[sizeof(m2paProtocolProfileTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m2paProtocolProfileRowStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_OCTET_STR, NULL, 0);	/* m2paProtocolProfileId 
												 */

			if (header_complex_parse_oid(&(name[sizeof(m2paProtocolProfileTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(m2paProtocolProfileTable_data);
			memdup((void *) &StorageNew->m2paProtocolProfileId, vp->val.string, vp->val_len);
			StorageNew->m2paProtocolProfileIdLen = vp->val_len;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->m2paN1 = 1000;
			StorageNew->m2paProving = true;
			StorageNew->m2paSctpSackDelay = 20;
			StorageNew->m2paReceiveCongestionThresholdAbatement = 3;
			StorageNew->m2paReceiveCongestionThresholdOnset = 6;
			StorageNew->m2paReceiveCongestionThresholdDiscard = 9;

			StorageNew->m2paProtocolProfileRowStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				m2paProtocolProfileTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->m2paProtocolProfileRowStatus;
			StorageTmp->m2paProtocolProfileRowStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(m2paProtocolProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m2paProtocolProfileTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m2paProtocolProfileTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m2paProtocolProfileTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			m2paProtocolProfileTable_add(StorageDel);
		} else {
			StorageTmp->m2paProtocolProfileRowStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->m2paProtocolProfileRowStatus == RS_CREATEANDGO) {
				StorageTmp->m2paProtocolProfileRowStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->m2paProtocolProfileRowStatus == RS_CREATEANDWAIT) {
				StorageTmp->m2paProtocolProfileRowStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
