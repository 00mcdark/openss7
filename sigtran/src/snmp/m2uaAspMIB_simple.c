/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "m2uaAspMIB_simple.h"

/* 
 * m2uaAspMIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid m2uaAspMIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 221 };

/* 
 * variable7 m2uaAspMIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the m2uaAspMIB_simple mib section 
 */

struct variable7 m2uaAspMIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   M2UAASPADMINISTRATIVESTATE  4
	{M2UAASPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaAspTable, 6, {1, 1, 1, 1, 1, 2}},
#define   M2UAASPOPERATIONALSTATE  5
	{M2UAASPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaAspTable, 6, {1, 1, 1, 1, 1, 3}},
#define   M2UAASPPROCEDURALSTATUS  6
	{M2UAASPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m2uaAspTable, 6, {1, 1, 1, 1, 1, 4}},
#define   M2UAASPUSAGESTATE     7
	{M2UAASPUSAGESTATE, ASN_INTEGER, RONLY, var_m2uaAspTable, 6, {1, 1, 1, 1, 1, 5}},
#define   M2UAASPASPSTATE       8
	{M2UAASPASPSTATE, ASN_INTEGER, RWRITE, var_m2uaAspTable, 6, {1, 1, 1, 1, 1, 6}},
#define   M2UAASPCAPABLITIES    9
	{M2UAASPCAPABLITIES, ASN_BIT_STR, RWRITE, var_m2uaAspTable, 6, {1, 1, 1, 1, 1, 7}},
#define   M2UAASPREGISTRATIONPOLICY  10
	{M2UAASPREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m2uaAspTable, 6, {1, 1, 1, 1, 1, 8}},
#define   M2UAASPNAME           11
	{M2UAASPNAME, ASN_OCTET_STR, RWRITE, var_m2uaAspTable, 6, {1, 1, 1, 1, 1, 9}},
#define   M2UAASPROWSTATUS      12
	{M2UAASPROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaAspTable, 6, {1, 1, 1, 1, 1, 10}},
#define   M2UASGNAME            16
	{M2UASGNAME, ASN_OCTET_STR, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 2}},
#define   M2UASGADMINISTRATIVESTATE  17
	{M2UASGADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 3}},
#define   M2UASGOPERATIONALSTATE  18
	{M2UASGOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 4}},
#define   M2UASGPROCEDURALSTATUS  19
	{M2UASGPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 5}},
#define   M2UASGSTANDBYSTATUS   20
	{M2UASGSTANDBYSTATUS, ASN_INTEGER, RONLY, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 6}},
#define   M2UASGPRIMARYSG       21
	{M2UASGPRIMARYSG, ASN_UNSIGNED, RONLY, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 7}},
#define   M2UASGASPSTATE        22
	{M2UASGASPSTATE, ASN_INTEGER, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 8}},
#define   M2UASGUSAGESTATE      23
	{M2UASGUSAGESTATE, ASN_INTEGER, RONLY, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 9}},
#define   M2UASGVERSION         24
	{M2UASGVERSION, ASN_INTEGER, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 10}},
#define   M2UASGOPTIONS         25
	{M2UASGOPTIONS, ASN_BIT_STR, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 11}},
#define   M2UASGREGISTRATIONPOLICY  26
	{M2UASGREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 12}},
#define   M2UASGPROTOCOLPAYLOADID  27
	{M2UASGPROTOCOLPAYLOADID, ASN_INTEGER, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 13}},
#define   M2UASGIPPORT          28
	{M2UASGIPPORT, ASN_INTEGER, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 14}},
#define   M2UASGPRIMARYIPADDRESS  29
	{M2UASGPRIMARYIPADDRESS, ASN_IPADDRESS, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 15}},
#define   M2UASGMINOSTREAMS     30
	{M2UASGMINOSTREAMS, ASN_INTEGER, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 16}},
#define   M2UASGMAXISTREAMS     31
	{M2UASGMAXISTREAMS, ASN_INTEGER, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 17}},
#define   M2UASGROWSTATUS       32
	{M2UASGROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaSgTable, 6, {1, 1, 2, 1, 1, 18}},
#define   M2UAASPSGADMINSTRATIVESTATE  37
	{M2UAASPSGADMINSTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 1}},
#define   M2UAASPSGOPERATIONALSTATE  38
	{M2UAASPSGOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 2}},
#define   M2UAASPSGPROCEDURALSTATUS  39
	{M2UAASPSGPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 3}},
#define   M2UAASPSGUSAGESTATE   40
	{M2UAASPSGUSAGESTATE, ASN_INTEGER, RONLY, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 4}},
#define   M2UAASPSGOPERATIONALSTATE  41
	{M2UAASPSGOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 5}},
#define   M2UAASPSGAVAILABILITYSTATUS  42
	{M2UAASPSGAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 6}},
#define   M2UAASPSGASPSTATE     43
	{M2UAASPSGASPSTATE, ASN_INTEGER, RWRITE, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 7}},
#define   M2UAASPSGASPIDPOLICY  44
	{M2UAASPSGASPIDPOLICY, ASN_INTEGER, RWRITE, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 8}},
#define   M2UAASPSGASPID        45
	{M2UAASPSGASPID, ASN_UNSIGNED, RWRITE, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 9}},
#define   M2UAASPSGASSOCIATIONPOLICY  46
	{M2UAASPSGASSOCIATIONPOLICY, ASN_INTEGER, RWRITE, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 10}},
#define   M2UAASPSGIPPORT       47
	{M2UAASPSGIPPORT, ASN_INTEGER, RWRITE, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 11}},
#define   M2UAASPSGPRIMARYIPADDRESS  48
	{M2UAASPSGPRIMARYIPADDRESS, ASN_IPADDRESS, RWRITE, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 12}},
#define   M2UAASPSGROWSTATUS    49
	{M2UAASPSGROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaAspSgTable, 6, {1, 1, 3, 1, 1, 13}},
#define   M2UAASNAME            53
	{M2UAASNAME, ASN_OCTET_STR, RWRITE, var_m2uaAsTable, 6, {1, 1, 4, 1, 1, 2}},
#define   M2UAASTRAFFICMODE     54
	{M2UAASTRAFFICMODE, ASN_OBJECT_ID, RWRITE, var_m2uaAsTable, 6, {1, 1, 4, 1, 1, 3}},
#define   M2UAASADMINISTRATIVESTATE  55
	{M2UAASADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaAsTable, 6, {1, 1, 4, 1, 1, 4}},
#define   M2UAASOPERATIONALSTATE  56
	{M2UAASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaAsTable, 6, {1, 1, 4, 1, 1, 5}},
#define   M2UAASPROCEDURALSTATUS  57
	{M2UAASPROCEDURALSTATUS, ASN_BIT_STR, RWRITE, var_m2uaAsTable, 6, {1, 1, 4, 1, 1, 6}},
#define   M2UAASUSAGESTATE      58
	{M2UAASUSAGESTATE, ASN_INTEGER, RWRITE, var_m2uaAsTable, 6, {1, 1, 4, 1, 1, 7}},
#define   M2UAASASSTATE         59
	{M2UAASASSTATE, ASN_INTEGER, RWRITE, var_m2uaAsTable, 6, {1, 1, 4, 1, 1, 8}},
#define   M2UAASROWSTATUS       60
	{M2UAASROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaAsTable, 6, {1, 1, 4, 1, 1, 9}},
#define   M2UAIFASINDEX         64
	{M2UAIFASINDEX, ASN_UNSIGNED, RWRITE, var_m2uaIfTable, 6, {1, 1, 5, 1, 1, 2}},
#define   M2UAIFIDENTIFIER      65
	{M2UAIFIDENTIFIER, ASN_OCTET_STR, RWRITE, var_m2uaIfTable, 6, {1, 1, 5, 1, 1, 3}},
#define   M2UAIFNAME            66
	{M2UAIFNAME, ASN_OCTET_STR, RWRITE, var_m2uaIfTable, 6, {1, 1, 5, 1, 1, 4}},
#define   M2UAIFROWSTATUS       67
	{M2UAIFROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaIfTable, 6, {1, 1, 5, 1, 1, 5}},
#define   M2UASGASORDERING      76
	{M2UASGASORDERING, ASN_UNSIGNED, RWRITE, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 1}},
#define   M2UASGASADMINISTRATIVESTATE  77
	{M2UASGASADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 2}},
#define   M2UASGASOPERATIONALSTATE  78
	{M2UASGASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 3}},
#define   M2UASGASPROCEDURALSTATUS  79
	{M2UASGASPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 4}},
#define   M2UASGASUSAGESTATE    80
	{M2UASGASUSAGESTATE, ASN_INTEGER, RONLY, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 5}},
#define   M2UASGASOPERATIONALSTATE  81
	{M2UASGASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 6}},
#define   M2UASGASAVAILABILITYSTATUS  82
	{M2UASGASAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 7}},
#define   M2UASGASSTANDBYSTATUS  83
	{M2UASGASSTANDBYSTATUS, ASN_INTEGER, RONLY, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 8}},
#define   M2UASGASPRIMARYSG     84
	{M2UASGASPRIMARYSG, ASN_UNSIGNED, RONLY, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 9}},
#define   M2UASGASASSTATE       85
	{M2UASGASASSTATE, ASN_INTEGER, RONLY, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 10}},
#define   M2UASGASROWSTATUS     86
	{M2UASGASROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaSgAsTable, 6, {1, 1, 7, 1, 1, 11}},
#define   M2UAASPASADMINISTRATIVESTATE  91
	{M2UAASPASADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaAspAsTable, 6, {1, 1, 8, 1, 1, 1}},
#define   M2UAASPASOPERATIONALSTATE  92
	{M2UAASPASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaAspAsTable, 6, {1, 1, 8, 1, 1, 2}},
#define   M2UAASPASPROCEDURALSTATUS  93
	{M2UAASPASPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m2uaAspAsTable, 6, {1, 1, 8, 1, 1, 3}},
#define   M2UAASPASUSAGESTATE   94
	{M2UAASPASUSAGESTATE, ASN_INTEGER, RONLY, var_m2uaAspAsTable, 6, {1, 1, 8, 1, 1, 4}},
#define   M2UAASPASASSTATE      95
	{M2UAASPASASSTATE, ASN_INTEGER, RWRITE, var_m2uaAspAsTable, 6, {1, 1, 8, 1, 1, 5}},
#define   M2UAASPASROWSTATUS    96
	{M2UAASPASROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaAspAsTable, 6, {1, 1, 8, 1, 1, 6}},
#define   M2UAASPSGASADMINISTRATIVESTATE  102
	{M2UAASPSGASADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaAspSgAsTable, 6, {1, 1, 9, 1, 1, 1}},
#define   M2UAASPSGASOPERATIONALSTATE  103
	{M2UAASPSGASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaAspSgAsTable, 6, {1, 1, 9, 1, 1, 2}},
#define   M2UAASPSGASPROCEDURALSTATUS  104
	{M2UAASPSGASPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m2uaAspSgAsTable, 6, {1, 1, 9, 1, 1, 3}},
#define   M2UAASPSGASUSAGESTATE  105
	{M2UAASPSGASUSAGESTATE, ASN_INTEGER, RONLY, var_m2uaAspSgAsTable, 6, {1, 1, 9, 1, 1, 4}},
#define   M2UAASPSGASSTANDBYSTATUS  106
	{M2UAASPSGASSTANDBYSTATUS, ASN_INTEGER, RONLY, var_m2uaAspSgAsTable, 6, {1, 1, 9, 1, 1, 5}},
#define   M2UAASPSGASROWSTATUS  107
	{M2UAASPSGASROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaAspSgAsTable, 6, {1, 1, 9, 1, 1, 6}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_m2uaAspMIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_m2uaAspMIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("m2uaAspMIB_simple", m2uaAspMIB_simple_variables, variable7, m2uaAspMIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_m2uaAspMIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_m2uaAspMIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaAspTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaAspMIB_simple above.
 */
unsigned char *
var_m2uaAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UAASPADMINISTRATIVESTATE:
		*write_method = write_m2uaAspAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASPUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPASPSTATE:
		*write_method = write_m2uaAspAspState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPCAPABLITIES:
		*write_method = write_m2uaAspCapablities;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASPREGISTRATIONPOLICY:
		*write_method = write_m2uaAspRegistrationPolicy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPNAME:
		*write_method = write_m2uaAspName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASPROWSTATUS:
		*write_method = write_m2uaAspRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaSgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaAspMIB_simple above.
 */
unsigned char *
var_m2uaSgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UASGNAME:
		*write_method = write_m2uaSgName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UASGADMINISTRATIVESTATE:
		*write_method = write_m2uaSgAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UASGSTANDBYSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGPRIMARYSG:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UASGASPSTATE:
		*write_method = write_m2uaSgAspState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGVERSION:
		*write_method = write_m2uaSgVersion;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGOPTIONS:
		*write_method = write_m2uaSgOptions;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UASGREGISTRATIONPOLICY:
		*write_method = write_m2uaSgRegistrationPolicy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGPROTOCOLPAYLOADID:
		*write_method = write_m2uaSgProtocolPayloadId;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGIPPORT:
		*write_method = write_m2uaSgIpPort;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGPRIMARYIPADDRESS:
		*write_method = write_m2uaSgPrimaryIpAddress;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UASGMINOSTREAMS:
		*write_method = write_m2uaSgMinOstreams;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGMAXISTREAMS:
		*write_method = write_m2uaSgMaxIstreams;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGROWSTATUS:
		*write_method = write_m2uaSgRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaAspSgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaAspMIB_simple above.
 */
unsigned char *
var_m2uaAspSgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UAASPSGADMINSTRATIVESTATE:
		*write_method = write_m2uaAspSgAdminstrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASPSGUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGAVAILABILITYSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASPSGASPSTATE:
		*write_method = write_m2uaAspSgAspState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGASPIDPOLICY:
		*write_method = write_m2uaAspSgAspIdPolicy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGASPID:
		*write_method = write_m2uaAspSgAspId;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UAASPSGASSOCIATIONPOLICY:
		*write_method = write_m2uaAspSgAssociationPolicy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGIPPORT:
		*write_method = write_m2uaAspSgIpPort;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGPRIMARYIPADDRESS:
		*write_method = write_m2uaAspSgPrimaryIpAddress;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASPSGROWSTATUS:
		*write_method = write_m2uaAspSgRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaAsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaAspMIB_simple above.
 */
unsigned char *
var_m2uaAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UAASNAME:
		*write_method = write_m2uaAsName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASTRAFFICMODE:
		*write_method = write_m2uaAsTrafficMode;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case M2UAASADMINISTRATIVESTATE:
		*write_method = write_m2uaAsAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPROCEDURALSTATUS:
		*write_method = write_m2uaAsProceduralStatus;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASUSAGESTATE:
		*write_method = write_m2uaAsUsageState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASASSTATE:
		*write_method = write_m2uaAsAsState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASROWSTATUS:
		*write_method = write_m2uaAsRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaIfTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaAspMIB_simple above.
 */
unsigned char *
var_m2uaIfTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UAIFASINDEX:
		*write_method = write_m2uaIfAsIndex;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UAIFIDENTIFIER:
		*write_method = write_m2uaIfIdentifier;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAIFNAME:
		*write_method = write_m2uaIfName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAIFROWSTATUS:
		*write_method = write_m2uaIfRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaAsIfTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaAspMIB_simple above.
 */
unsigned char *
var_m2uaAsIfTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaSgAsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaAspMIB_simple above.
 */
unsigned char *
var_m2uaSgAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UASGASORDERING:
		*write_method = write_m2uaSgAsOrdering;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UASGASADMINISTRATIVESTATE:
		*write_method = write_m2uaSgAsAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UASGASUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASAVAILABILITYSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UASGASSTANDBYSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASPRIMARYSG:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UASGASASSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASROWSTATUS:
		*write_method = write_m2uaSgAsRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaAspAsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaAspMIB_simple above.
 */
unsigned char *
var_m2uaAspAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UAASPASADMINISTRATIVESTATE:
		*write_method = write_m2uaAspAsAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPASOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPASPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASPASUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPASASSTATE:
		*write_method = write_m2uaAspAsAsState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPASROWSTATUS:
		*write_method = write_m2uaAspAsRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaAspSgAsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaAspMIB_simple above.
 */
unsigned char *
var_m2uaAspSgAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UAASPSGASADMINISTRATIVESTATE:
		*write_method = write_m2uaAspSgAsAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGASOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGASPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASPSGASUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGASSTANDBYSTATUS:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGASROWSTATUS:
		*write_method = write_m2uaAspSgAsRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_m2uaAspAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspAspState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspAspState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspAspState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspCapablities(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to m2uaAspCapablities not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaAspCapablities: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspRegistrationPolicy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m2uaAspName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaAspName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m2uaSgName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaSgName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAspState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAspState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAspState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgVersion(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgVersion not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgOptions(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to m2uaSgOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaSgOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgRegistrationPolicy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgProtocolPayloadId(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgProtocolPayloadId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgProtocolPayloadId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgIpPort(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgIpPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgIpPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgPrimaryIpAddress(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_IPADDRESS) {
			fprintf(stderr, "write to m2uaSgPrimaryIpAddress not ASN_IPADDRESS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaSgPrimaryIpAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgMinOstreams(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgMinOstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgMinOstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgMaxIstreams(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgMaxIstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgMaxIstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgAdminstrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspSgAdminstrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspSgAdminstrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgAspState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspSgAspState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspSgAspState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgAspIdPolicy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspSgAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspSgAspIdPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgAspId(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaAspSgAspId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaAspSgAspId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgAssociationPolicy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspSgAssociationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspSgAssociationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgIpPort(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspSgIpPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspSgIpPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgPrimaryIpAddress(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_IPADDRESS) {
			fprintf(stderr, "write to m2uaAspSgPrimaryIpAddress not ASN_IPADDRESS\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaAspSgPrimaryIpAddress: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspSgRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspSgRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAsName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m2uaAsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaAsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAsTrafficMode(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to m2uaAsTrafficMode not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to m2uaAsTrafficMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAsAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAsProceduralStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			fprintf(stderr, "write to m2uaAsProceduralStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaAsProceduralStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAsUsageState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAsUsageState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAsUsageState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAsAsState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAsAsState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAsAsState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAsRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAsRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAsRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfAsIndex(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaIfAsIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaIfAsIndex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfIdentifier(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m2uaIfIdentifier not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaIfIdentifier: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m2uaIfName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaIfName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaIfRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaIfRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAsOrdering(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaSgAsOrdering not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaSgAsOrdering: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAsAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAsRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAsRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAsRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspAsAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspAsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspAsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspAsAsState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspAsAsState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspAsAsState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspAsRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspAsRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspAsRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgAsAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspSgAsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspSgAsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgAsRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspSgAsRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspSgAsRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
