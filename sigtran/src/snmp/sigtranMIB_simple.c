/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "sigtranMIB_simple.h"

/* 
 * sigtranMIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid sigtranMIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 15 };

/* 
 * variable7 sigtranMIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the sigtranMIB_simple mib section 
 */

struct variable7 sigtranMIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   SIGTRANSCTPPROFILENEXTINDEX  1
	{SIGTRANSCTPPROFILENEXTINDEX, ASN_UNSIGNED, RONLY, var_sigtranMIB, 4, {1, 2, 1, 1}},
#define   SIGTRANSCTPPROFILENAME  5
	{SIGTRANSCTPPROFILENAME, ASN_OCTET_STR, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 2}},
#define   SIGTRANSCTPPROFILENODELAY  6
	{SIGTRANSCTPPROFILENODELAY, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 3}},
#define   SIGTRANSCTPPAYLOADPROTOCOLID  7
	{SIGTRANSCTPPAYLOADPROTOCOLID, ASN_UNSIGNED, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 4}},
#define   SIGTRANSCTPLIFETIME   8
	{SIGTRANSCTPLIFETIME, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 5}},
#define   SIGTRANSCTPPROFILECSUMTYPE  9
	{SIGTRANSCTPPROFILECSUMTYPE, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 6}},
#define   SIGTRANSCTPPROFILEMACTYPE  10
	{SIGTRANSCTPPROFILEMACTYPE, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 7}},
#define   SIGTRANSCTPPROFILEVALIDCOOKIELIFE  11
	{SIGTRANSCTPPROFILEVALIDCOOKIELIFE, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 8}},
#define   SIGTRANSCTPPROFILECOOKIEINC  12
	{SIGTRANSCTPPROFILECOOKIEINC, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 9}},
#define   SIGTRANSCTPPROFILEMAXISTREAMS  13
	{SIGTRANSCTPPROFILEMAXISTREAMS, ASN_UNSIGNED, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 10}},
#define   SIGTRANSCTPPROFILEREQOSTREAMS  14
	{SIGTRANSCTPPROFILEREQOSTREAMS, ASN_UNSIGNED, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 11}},
#define   SIGTRANSCTPECN        15
	{SIGTRANSCTPECN, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 12}},
#define   SIGTRANSCTPADAPTATIONLAYERINFO  16
	{SIGTRANSCTPADAPTATIONLAYERINFO, ASN_UNSIGNED, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 13}},
#define   SIGTRANSCTPPROFILEMAXINITRETRIES  17
	{SIGTRANSCTPPROFILEMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 14}},
#define   SIGTRANSCTPPROFILEMAXBURST  18
	{SIGTRANSCTPPROFILEMAXBURST, ASN_UNSIGNED, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 15}},
#define   SIGTRANSCTPPROFILEASSOCMAXRETRANS  19
	{SIGTRANSCTPPROFILEASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 16}},
#define   SIGTRANSCTPPROFILEMAXSACKDELAY  20
	{SIGTRANSCTPPROFILEMAXSACKDELAY, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 17}},
#define   SIGTRANSCTPPROFILERTOMIN  21
	{SIGTRANSCTPPROFILERTOMIN, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 18}},
#define   SIGTRANSCTPPROFILERTOINITIAL  22
	{SIGTRANSCTPPROFILERTOINITIAL, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 19}},
#define   SIGTRANSCTPPROFILERTOMAX  23
	{SIGTRANSCTPPROFILERTOMAX, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 20}},
#define   SIGTRANSCTPPROFILEPATHMAXRETRANS  24
	{SIGTRANSCTPPROFILEPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 21}},
#define   SIGTRANSCTPPROFILEHEARTBEATITVL  25
	{SIGTRANSCTPPROFILEHEARTBEATITVL, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 22}},
#define   SIGTRANSCTPPROFILESTATUS  26
	{SIGTRANSCTPPROFILESTATUS, ASN_INTEGER, RWRITE, var_sigtranSctpProfileTable, 6, {1, 2, 1, 2, 1, 23}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_sigtranMIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_sigtranMIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("sigtranMIB_simple", sigtranMIB_simple_variables, variable7, sigtranMIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_sigtranMIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_sigtranMIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_sigtranSctpProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_sigtranMIB_simple above.
 */
unsigned char *
var_sigtranSctpProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case SIGTRANSCTPPROFILENAME:
		*write_method = write_sigtranSctpProfileName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case SIGTRANSCTPPROFILENODELAY:
		*write_method = write_sigtranSctpProfileNodelay;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPAYLOADPROTOCOLID:
		*write_method = write_sigtranSctpPayloadProtocolId;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case SIGTRANSCTPLIFETIME:
		*write_method = write_sigtranSctpLifetime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPROFILECSUMTYPE:
		*write_method = write_sigtranSctpProfileCsumType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPROFILEMACTYPE:
		*write_method = write_sigtranSctpProfileMacType;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPROFILEVALIDCOOKIELIFE:
		*write_method = write_sigtranSctpProfileValidCookieLife;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPROFILECOOKIEINC:
		*write_method = write_sigtranSctpProfileCookieInc;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPROFILEMAXISTREAMS:
		*write_method = write_sigtranSctpProfileMaxIstreams;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case SIGTRANSCTPPROFILEREQOSTREAMS:
		*write_method = write_sigtranSctpProfileReqOstreams;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case SIGTRANSCTPECN:
		*write_method = write_sigtranSctpEcn;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPADAPTATIONLAYERINFO:
		*write_method = write_sigtranSctpAdaptationLayerInfo;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case SIGTRANSCTPPROFILEMAXINITRETRIES:
		*write_method = write_sigtranSctpProfileMaxInitRetries;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case SIGTRANSCTPPROFILEMAXBURST:
		*write_method = write_sigtranSctpProfileMaxBurst;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case SIGTRANSCTPPROFILEASSOCMAXRETRANS:
		*write_method = write_sigtranSctpProfileAssocMaxRetrans;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case SIGTRANSCTPPROFILEMAXSACKDELAY:
		*write_method = write_sigtranSctpProfileMaxSackDelay;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPROFILERTOMIN:
		*write_method = write_sigtranSctpProfileRtoMin;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPROFILERTOINITIAL:
		*write_method = write_sigtranSctpProfileRtoInitial;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPROFILERTOMAX:
		*write_method = write_sigtranSctpProfileRtoMax;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPROFILEPATHMAXRETRANS:
		*write_method = write_sigtranSctpProfilePathMaxRetrans;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case SIGTRANSCTPPROFILEHEARTBEATITVL:
		*write_method = write_sigtranSctpProfileHeartbeatItvl;
		long_ret = 0;
		return (u_char *) &long_ret;
	case SIGTRANSCTPPROFILESTATUS:
		*write_method = write_sigtranSctpProfileStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_sigtranSctpProfileName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to sigtranSctpProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to sigtranSctpProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileNodelay(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileNodelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileNodelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpPayloadProtocolId(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to sigtranSctpPayloadProtocolId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to sigtranSctpPayloadProtocolId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileCsumType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileCsumType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileCsumType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileMacType(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileMacType not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileMacType: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileValidCookieLife(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileValidCookieLife not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileValidCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileCookieInc(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileCookieInc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileMaxIstreams(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to sigtranSctpProfileMaxIstreams not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileMaxIstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileReqOstreams(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to sigtranSctpProfileReqOstreams not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileReqOstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpEcn(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpEcn not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpEcn: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpAdaptationLayerInfo(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to sigtranSctpAdaptationLayerInfo not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to sigtranSctpAdaptationLayerInfo: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileMaxInitRetries(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to sigtranSctpProfileMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileMaxBurst(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to sigtranSctpProfileMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileAssocMaxRetrans(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to sigtranSctpProfileAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileMaxSackDelay(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileMaxSackDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileMaxSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileRtoMin(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileRtoInitial(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileRtoInitial not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileRtoMax(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileRtoMax not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfilePathMaxRetrans(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to sigtranSctpProfilePathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to sigtranSctpProfilePathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileHeartbeatItvl(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileHeartbeatItvl not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_sigtranSctpProfileStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to sigtranSctpProfileStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to sigtranSctpProfileStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
