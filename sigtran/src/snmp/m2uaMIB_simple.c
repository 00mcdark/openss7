/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "m2uaMIB_simple.h"

/* 
 * m2uaMIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid m2uaMIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 222 };

/* 
 * variable7 m2uaMIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the m2uaMIB_simple mib section 
 */

struct variable7 m2uaMIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   M2UAASNEXTINDEX       1
	{M2UAASNEXTINDEX, ASN_UNSIGNED, RONLY, var_m2uaMIB, 5, {1, 2, 1, 1, 1}},
#define   M2UAASNAME            2
	{M2UAASNAME, ASN_OCTET_STR, RWRITE, var_m2uaAsTable, 7, {1, 2, 1, 1, 2, 1, 2}},
#define   M2UAASADMINISTRATIVESTATE  3
	{M2UAASADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaAsTable, 7, {1, 2, 1, 1, 2, 1, 3}},
#define   M2UAASOPERATIONALSTATE  4
	{M2UAASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaAsTable, 7, {1, 2, 1, 1, 2, 1, 4}},
#define   M2UAASPROCEDURALSTATUS  5
	{M2UAASPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m2uaAsTable, 7, {1, 2, 1, 1, 2, 1, 5}},
#define   M2UAASUSAGESTATE      6
	{M2UAASUSAGESTATE, ASN_INTEGER, RONLY, var_m2uaAsTable, 7, {1, 2, 1, 1, 2, 1, 6}},
#define   M2UAASSTATUS          7
	{M2UAASSTATUS, ASN_INTEGER, RWRITE, var_m2uaAsTable, 7, {1, 2, 1, 1, 2, 1, 7}},
#define   M2UAIFNEXTINDEX       8
	{M2UAIFNEXTINDEX, ASN_UNSIGNED, RONLY, var_m2uaMIB, 5, {1, 2, 1, 2, 1}},
#define   M2UAIFNAME            9
	{M2UAIFNAME, ASN_OCTET_STR, RWRITE, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 2}},
#define   M2UAIFASINDEX         10
	{M2UAIFASINDEX, ASN_UNSIGNED, RWRITE, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 3}},
#define   M2UAIFIDNUM           11
	{M2UAIFIDNUM, ASN_INTEGER, RWRITE, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 4}},
#define   M2UAIFIDNAME          12
	{M2UAIFIDNAME, ASN_OCTET_STR, RWRITE, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 5}},
#define   M2UAIFADMINISTRATIVESTATE  13
	{M2UAIFADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 6}},
#define   M2UAIFOPERATIONALSTATE  14
	{M2UAIFOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 7}},
#define   M2UAIFPROCEDURALSTATUS  15
	{M2UAIFPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 8}},
#define   M2UAIFUSAGESTATE      16
	{M2UAIFUSAGESTATE, ASN_INTEGER, RONLY, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 9}},
#define   M2UAIFEQUIPMENT       17
	{M2UAIFEQUIPMENT, ASN_OBJECT_ID, RWRITE, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 10}},
#define   M2UAIFMAXSIFSIZE      18
	{M2UAIFMAXSIFSIZE, ASN_INTEGER, RWRITE, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 11}},
#define   M2UAIFTRANSMISSIONRATE  19
	{M2UAIFTRANSMISSIONRATE, ASN_INTEGER, RWRITE, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 12}},
#define   M2UAIFCIC             20
	{M2UAIFCIC, ASN_INTEGER, RWRITE, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 13}},
#define   M2UAIFROWSTATUS       21
	{M2UAIFROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaIfTable, 7, {1, 2, 1, 2, 2, 1, 14}},
#define   M2UAASPNEXTINDEX      22
	{M2UAASPNEXTINDEX, ASN_UNSIGNED, RONLY, var_m2uaMIB, 5, {1, 2, 2, 1, 1}},
#define   M2UAASPINDEX          23
	{M2UAASPINDEX, ASN_UNSIGNED, RONLY, var_m2uaAspTable, 7, {1, 2, 2, 1, 2, 1, 1}},
#define   M2UAASPNAME           24
	{M2UAASPNAME, ASN_OCTET_STR, RONLY, var_m2uaAspTable, 7, {1, 2, 2, 1, 2, 1, 2}},
#define   M2UASGINDEX           25
	{M2UASGINDEX, ASN_UNSIGNED, RWRITE, var_m2uaAspTable, 7, {1, 2, 2, 1, 2, 1, 3}},
#define   M2UAASPADMINISTRATIVESTATE  26
	{M2UAASPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaAspTable, 7, {1, 2, 2, 1, 2, 1, 4}},
#define   M2UAASPOPERATIONALSTATE  27
	{M2UAASPOPERATIONALSTATE, ASN_INTEGER, RWRITE, var_m2uaAspTable, 7, {1, 2, 2, 1, 2, 1, 5}},
#define   M2UAASPUSAGESTATE     28
	{M2UAASPUSAGESTATE, ASN_INTEGER, RONLY, var_m2uaAspTable, 7, {1, 2, 2, 1, 2, 1, 6}},
#define   M2UAASPPROCEDURALSTATUS  29
	{M2UAASPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m2uaAspTable, 7, {1, 2, 2, 1, 2, 1, 7}},
#define   M2UAASPSTATE          30
	{M2UAASPSTATE, ASN_INTEGER, RONLY, var_m2uaAspTable, 7, {1, 2, 2, 1, 2, 1, 8}},
#define   M2UAASPROWSTATUS      31
	{M2UAASPROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaAspTable, 7, {1, 2, 2, 1, 2, 1, 9}},
#define   M2UAASPINDEX          32
	{M2UAASPINDEX, ASN_UNSIGNED, RONLY, var_m2uaAspSgTable, 7, {1, 2, 2, 1, 2, 1, 1}},
#define   M2UASGINDEX           33
	{M2UASGINDEX, ASN_UNSIGNED, RWRITE, var_m2uaAspSgTable, 7, {1, 2, 2, 1, 2, 1, 3}},
#define   M2UAASPSGASPID        34
	{M2UAASPSGASPID, ASN_UNSIGNED, RWRITE, var_m2uaAspSgTable, 7, {1, 2, 2, 2, 1, 1, 1}},
#define   M2UAASPSGASPPORT      35
	{M2UAASPSGASPPORT, ASN_INTEGER, RWRITE, var_m2uaAspSgTable, 7, {1, 2, 2, 2, 1, 1, 2}},
#define   M2UAASPSGASPSTATE     36
	{M2UAASPSGASPSTATE, ASN_INTEGER, RONLY, var_m2uaAspSgTable, 7, {1, 2, 2, 2, 1, 1, 3}},
#define   M2UAASPSGADMINISTRATIVESTATE  37
	{M2UAASPSGADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaAspSgTable, 7, {1, 2, 2, 2, 1, 1, 4}},
#define   M2UASGNEXTINDEX       38
	{M2UASGNEXTINDEX, ASN_UNSIGNED, RONLY, var_m2uaMIB, 5, {1, 2, 3, 1, 1}},
#define   M2UASGINDEX           39
	{M2UASGINDEX, ASN_UNSIGNED, RONLY, var_m2uaSgTable, 7, {1, 2, 3, 1, 2, 1, 1}},
#define   M2UASGNAME            40
	{M2UASGNAME, ASN_OCTET_STR, RWRITE, var_m2uaSgTable, 7, {1, 2, 3, 1, 2, 1, 2}},
#define   M2UASGROWSTATUS       41
	{M2UASGROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaSgTable, 7, {1, 2, 3, 1, 2, 1, 3}},
#define   M2UASGINDEX           42
	{M2UASGINDEX, ASN_UNSIGNED, RWRITE, var_m2uaSgAspTable, 7, {1, 2, 2, 1, 2, 1, 3}},
#define   M2UAASPINDEX          43
	{M2UAASPINDEX, ASN_UNSIGNED, RONLY, var_m2uaSgAspTable, 7, {1, 2, 2, 1, 2, 1, 1}},
#define   M2UASGASPID           44
	{M2UASGASPID, ASN_UNSIGNED, RWRITE, var_m2uaSgAspTable, 7, {1, 2, 3, 2, 1, 1, 1}},
#define   M2UASGASPPORT         45
	{M2UASGASPPORT, ASN_INTEGER, RWRITE, var_m2uaSgAspTable, 7, {1, 2, 3, 2, 1, 1, 2}},
#define   M2UASGASPSTATE        46
	{M2UASGASPSTATE, ASN_INTEGER, RONLY, var_m2uaSgAspTable, 7, {1, 2, 3, 2, 1, 1, 3}},
#define   M2UASGASPADMINISTRATIVESTATE  47
	{M2UASGASPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaSgAspTable, 7, {1, 2, 3, 2, 1, 1, 4}},
#define   M2UASGASPOPERATIONALSTATE  48
	{M2UASGASPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaSgAspTable, 7, {1, 2, 3, 2, 1, 1, 5}},
#define   M2UASGINDEX           49
	{M2UASGINDEX, ASN_UNSIGNED, RWRITE, var_m2uaSgAspAsTable, 7, {1, 2, 2, 1, 2, 1, 3}},
#define   M2UAASPINDEX          50
	{M2UAASPINDEX, ASN_UNSIGNED, RONLY, var_m2uaSgAspAsTable, 7, {1, 2, 2, 1, 2, 1, 1}},
#define   M2UASGASPASREGISTRATIONREQUIRED  51
	{M2UASGASPASREGISTRATIONREQUIRED, ASN_INTEGER, RWRITE, var_m2uaSgAspAsTable, 7, {1, 2, 3, 3, 1, 1, 1}},
#define   M2UASGASPASSTATE      52
	{M2UASGASPASSTATE, ASN_INTEGER, RONLY, var_m2uaSgAspAsTable, 7, {1, 2, 3, 3, 1, 1, 2}},
#define   M2UASGASPASADMINISTRATIVESTATE  53
	{M2UASGASPASADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaSgAspAsTable, 7, {1, 2, 3, 3, 1, 1, 3}},
#define   M2UASGASPASOPERATIONALSTATE  54
	{M2UASGASPASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaSgAspAsTable, 7, {1, 2, 3, 3, 1, 1, 4}},
#define   M2UASGINDEX           55
	{M2UASGINDEX, ASN_UNSIGNED, RWRITE, var_m2uaSgAsTable, 7, {1, 2, 2, 1, 2, 1, 3}},
#define   M2UASGASTRAFFICMODE   56
	{M2UASGASTRAFFICMODE, ASN_OBJECT_ID, RWRITE, var_m2uaSgAsTable, 7, {1, 2, 3, 4, 1, 1, 1}},
#define   M2UASGASSTATE         57
	{M2UASGASSTATE, ASN_INTEGER, RWRITE, var_m2uaSgAsTable, 7, {1, 2, 3, 4, 1, 1, 2}},
#define   M2UASGASADMINISTRATIVESTATE  58
	{M2UASGASADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m2uaSgAsTable, 7, {1, 2, 3, 4, 1, 1, 3}},
#define   M2UASGASOPERATIONALSTATE  59
	{M2UASGASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m2uaSgAsTable, 7, {1, 2, 3, 4, 1, 1, 4}},
#define   M2UASGASROWSTATUS     60
	{M2UASGASROWSTATUS, ASN_INTEGER, RWRITE, var_m2uaSgAsTable, 7, {1, 2, 3, 4, 1, 1, 5}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_m2uaMIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_m2uaMIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("m2uaMIB_simple", m2uaMIB_simple_variables, variable7, m2uaMIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_m2uaMIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_m2uaMIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaAsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaMIB_simple above.
 */
unsigned char *
var_m2uaAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UAASNAME:
		*write_method = write_m2uaAsName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASADMINISTRATIVESTATE:
		*write_method = write_m2uaAsAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASSTATUS:
		*write_method = write_m2uaAsStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaIfTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaMIB_simple above.
 */
unsigned char *
var_m2uaIfTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UAIFNAME:
		*write_method = write_m2uaIfName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAIFASINDEX:
		*write_method = write_m2uaIfAsIndex;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UAIFIDNUM:
		*write_method = write_m2uaIfIdNum;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAIFIDNAME:
		*write_method = write_m2uaIfIdName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAIFADMINISTRATIVESTATE:
		*write_method = write_m2uaIfAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAIFOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAIFPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAIFUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAIFEQUIPMENT:
		*write_method = write_m2uaIfEquipment;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case M2UAIFMAXSIFSIZE:
		*write_method = write_m2uaIfMaxSifSize;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAIFTRANSMISSIONRATE:
		*write_method = write_m2uaIfTransmissionRate;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAIFCIC:
		*write_method = write_m2uaIfCic;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAIFROWSTATUS:
		*write_method = write_m2uaIfRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaAsIfTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaMIB_simple above.
 */
unsigned char *
var_m2uaAsIfTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaAspTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaMIB_simple above.
 */
unsigned char *
var_m2uaAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UAASPINDEX:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UAASPNAME:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UASGINDEX:
		*write_method = write_m2uaSgIndex;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UAASPADMINISTRATIVESTATE:
		*write_method = write_m2uaAspAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPOPERATIONALSTATE:
		*write_method = write_m2uaAspOperationalState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPUSAGESTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPPROCEDURALSTATUS:

		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UAASPSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPROWSTATUS:
		*write_method = write_m2uaAspRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaAspSgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaMIB_simple above.
 */
unsigned char *
var_m2uaAspSgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UAASPINDEX:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UASGINDEX:
		*write_method = write_m2uaSgIndex;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UAASPSGASPID:
		*write_method = write_m2uaAspSgAspId;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UAASPSGASPPORT:
		*write_method = write_m2uaAspSgAspPort;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGASPSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UAASPSGADMINISTRATIVESTATE:
		*write_method = write_m2uaAspSgAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaSgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaMIB_simple above.
 */
unsigned char *
var_m2uaSgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UASGINDEX:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UASGNAME:
		*write_method = write_m2uaSgName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2UASGROWSTATUS:
		*write_method = write_m2uaSgRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaSgAspTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaMIB_simple above.
 */
unsigned char *
var_m2uaSgAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UASGINDEX:
		*write_method = write_m2uaSgIndex;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UAASPINDEX:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UASGASPID:
		*write_method = write_m2uaSgAspId;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UASGASPPORT:
		*write_method = write_m2uaSgAspPort;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASPSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASPADMINISTRATIVESTATE:
		*write_method = write_m2uaSgAspAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASPOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaSgAspAsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaMIB_simple above.
 */
unsigned char *
var_m2uaSgAspAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UASGINDEX:
		*write_method = write_m2uaSgIndex;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UAASPINDEX:

		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UASGASPASREGISTRATIONREQUIRED:
		*write_method = write_m2uaSgAspAsRegistrationRequired;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASPASSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASPASADMINISTRATIVESTATE:
		*write_method = write_m2uaSgAspAsAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASPASOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2uaSgAsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2uaMIB_simple above.
 */
unsigned char *
var_m2uaSgAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2UASGINDEX:
		*write_method = write_m2uaSgIndex;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2UASGASTRAFFICMODE:
		*write_method = write_m2uaSgAsTrafficMode;
		objid[0] = 0;
		objid[1] = 0;
		*var_len = 2 * sizeof(oid);
		return (u_char *) objid;
	case M2UASGASSTATE:
		*write_method = write_m2uaSgAsState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASADMINISTRATIVESTATE:
		*write_method = write_m2uaSgAsAdministrativeState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASOPERATIONALSTATE:

		long_ret = 0;
		return (u_char *) &long_ret;
	case M2UASGASROWSTATUS:
		*write_method = write_m2uaSgAsRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_m2uaAsName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m2uaAsName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaAsName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAsAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAsStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAsStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAsStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m2uaIfName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaIfName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfAsIndex(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaIfAsIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaIfAsIndex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfIdNum(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaIfIdNum not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaIfIdNum: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfIdName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m2uaIfIdName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaIfIdName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaIfAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaIfAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfEquipment(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to m2uaIfEquipment not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to m2uaIfEquipment: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfMaxSifSize(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaIfMaxSifSize not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaIfMaxSifSize: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfTransmissionRate(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaIfTransmissionRate not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaIfTransmissionRate: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfCic(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaIfCic not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaIfCic: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaIfRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaIfRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaIfRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgIndex(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaSgIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaSgIndex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspOperationalState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspOperationalState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspOperationalState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgIndex(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaSgIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaSgIndex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgAspId(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaAspSgAspId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaAspSgAspId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgAspPort(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspSgAspPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspSgAspPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaAspSgAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaAspSgAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaAspSgAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m2uaSgName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2uaSgName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgIndex(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaSgIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaSgIndex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAspId(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaSgAspId not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaSgAspId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAspPort(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAspPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAspPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAspAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAspAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAspAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgIndex(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaSgIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaSgIndex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAspAsRegistrationRequired(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAspAsRegistrationRequired not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAspAsRegistrationRequired: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAspAsAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAspAsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAspAsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgIndex(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2uaSgIndex not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2uaSgIndex: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAsTrafficMode(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static oid *objid;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			fprintf(stderr, "write to m2uaSgAsTrafficMode not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(objid)) {
			fprintf(stderr, "write to m2uaSgAsTrafficMode: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		objid = (oid *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in objid for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAsState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAsState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAsState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAsAdministrativeState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAsAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2uaSgAsRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2uaSgAsRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2uaSgAsRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been asked to do something with it.  Note that anything done here must be reversable in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
