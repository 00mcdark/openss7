/*****************************************************************************

 @(#) $RCSfile: m3uaAspMIB.c,v $ $Name: OpenSS7-0_9_2 $($Revision: 0.9.2.1 $) $Date: 2008-12-27 10:01:52 $

 -----------------------------------------------------------------------------

 Copyright (c) 2001-2008  OpenSS7 Corporation <http://www.openss7.com/>
 Copyright (c) 1997-2000  Brian F. G. Bidulock <bidulock@openss7.org>

 All Rights Reserved.

 This program is free software: you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation, version 3 of the license.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
 details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>, or
 write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 02139, USA.

 -----------------------------------------------------------------------------

 U.S. GOVERNMENT RESTRICTED RIGHTS.  If you are licensing this Software on
 behalf of the U.S. Government ("Government"), the following provisions apply
 to you.  If the Software is supplied by the Department of Defense ("DoD"), it
 is classified as "Commercial Computer Software" under paragraph 252.227-7014
 of the DoD Supplement to the Federal Acquisition Regulations ("DFARS") (or any
 successor regulations) and the Government is acquiring only the license rights
 granted herein (the license rights customarily provided to non-Government
 users).  If the Software is supplied to any unit or agency of the Government
 other than DoD, it is classified as "Restricted Computer Software" and the
 Government's rights in the Software are defined in paragraph 52.227-19 of the
 Federal Acquisition Regulations ("FAR") (or any successor regulations) or, in
 the cases of NASA, in paragraph 18.52.227-86 of the NASA Supplement to the FAR
 (or any successor regulations).

 -----------------------------------------------------------------------------

 Commercial licensing and support of this software is available from OpenSS7
 Corporation at a fee.  See http://www.openss7.com/

 -----------------------------------------------------------------------------

 Last Modified $Date: 2008-12-27 10:01:52 $ by $Author: brian $

 -----------------------------------------------------------------------------

 $Log: m3uaAspMIB.c,v $
 Revision 0.9.2.1  2008-12-27 10:01:52  brian
 - updated mibs and stubs

 *****************************************************************************/

#ident "@(#) $RCSfile: m3uaAspMIB.c,v $ $Name: OpenSS7-0_9_2 $($Revision: 0.9.2.1 $) $Date: 2008-12-27 10:01:52 $"

static char const ident[] = "$RCSfile: m3uaAspMIB.c,v $ $Name: OpenSS7-0_9_2 $($Revision: 0.9.2.1 $) $Date: 2008-12-27 10:01:52 $";

/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "m3uaAspMIB.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int m3uaAspMIB_refresh = 1;
volatile int m3uaAspTable_refresh = 1;
volatile int m3uaAspAgTable_refresh = 1;
volatile int m3uaAspSgTable_refresh = 1;
volatile int m3uaAspSgpTable_refresh = 1;
volatile int m3uaAspSpTable_refresh = 1;
volatile int m3uaAspMtTable_refresh = 1;
volatile int m3uaAspRsTable_refresh = 1;
volatile int m3uaAspRlTable_refresh = 1;
volatile int m3uaAspRtTable_refresh = 1;
volatile int m3uaAspRcTable_refresh = 1;
volatile int m3uaAspAsTable_refresh = 1;
volatile int m3uaAspAfTable_refresh = 1;

/*
 * m3uaAspMIB_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */
oid m3uaAspMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311 };
oid m3uaAspTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 1, 2, 1 };
oid m3uaAspAgTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 2, 2, 1 };
oid m3uaAspSgTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 3, 1, 1 };
oid m3uaAspSgpTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 4, 1, 1 };
oid m3uaAspSpTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 5, 2, 1 };
oid m3uaAspMtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 6, 1, 1 };
oid m3uaAspRsTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 7, 1, 1 };
oid m3uaAspRtTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 9, 1, 1 };
oid m3uaAspRcTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 311, 1, 2, 10, 1, 1 };

/*
 * variable7 m3uaAspMIB_variables:
 *   this variable defines function callbacks and type return information
 *   for the m3uaAspMIB mib section
 */
struct variable7 m3uaAspMIB_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   M3UAASPNEXTINDEX      (1 % 256)
	{M3UAASPNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaAspMIB, 4, {1, 2, 1, 1}},
#define   M3UAASPNAME           (6 % 256)
	{M3UAASPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 2}},
#define   M3UAASPNAME           (7 % 256)
	{M3UAASPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 2}},
#define   M3UAASPADMINISTRATIVESTATE  (8 % 256)
	{M3UAASPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 3}},
#define   M3UAASPADMINISTRATIVESTATE  (9 % 256)
	{M3UAASPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 3}},
#define   M3UAASPCAPABILITIES   (10 % 256)
	{M3UAASPCAPABILITIES, ASN_BIT_STR, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 4}},
#define   M3UAASPIDPOLICY       (11 % 256)
	{M3UAASPIDPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 5}},
#define   M3UAASPREGISTRATIONPOLICY  (12 % 256)
	{M3UAASPREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 6}},
#define   M3UAASPASSOCIATIONPOLICY  (13 % 256)
	{M3UAASPASSOCIATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 7}},
#define   M3UAASPSTATUS         (14 % 256)
	{M3UAASPSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspTable, 6, {1, 2, 1, 2, 1, 8}},
#define   M3UAASPAGNEXTINDEX    (15 % 256)
	{M3UAASPAGNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaAspMIB, 4, {1, 2, 2, 1}},
#define   M3UAASPAGPROTOCOLVERSION  (19 % 256)
	{M3UAASPAGPROTOCOLVERSION, ASN_OBJECT_ID, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 2}},
#define   M3UAASPAGOPTIONS      (20 % 256)
	{M3UAASPAGOPTIONS, ASN_BIT_STR, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 3}},
#define   M3UAASPAGREGISTRATIONPOLICY  (21 % 256)
	{M3UAASPAGREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 4}},
#define   M3UAASPAGASPIDPOLICY  (22 % 256)
	{M3UAASPAGASPIDPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 5}},
#define   M3UAASPAGASPPROTOCOLPAYLOADID  (23 % 256)
	{M3UAASPAGASPPROTOCOLPAYLOADID, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 6}},
#define   M3UAASPAGIPPORT       (24 % 256)
	{M3UAASPAGIPPORT,, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 7}},
#define   M3UAASPAGMINOSTREAMS  (25 % 256)
	{M3UAASPAGMINOSTREAMS, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 8}},
#define   M3UAASPAGMAXISTREAMS  (26 % 256)
	{M3UAASPAGMAXISTREAMS, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 9}},
#define   M3UAASPAGTIMERT7      (27 % 256)
	{M3UAASPAGTIMERT7, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 10}},
#define   M3UAASPAGTIMERT19     (28 % 256)
	{M3UAASPAGTIMERT19, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 11}},
#define   M3UAASPAGTIMERT21     (29 % 256)
	{M3UAASPAGTIMERT21, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 12}},
#define   M3UAASPAGTIMERT25A    (30 % 256)
	{M3UAASPAGTIMERT25A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 13}},
#define   M3UAASPAGTIMERT28A    (31 % 256)
	{M3UAASPAGTIMERT28A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 14}},
#define   M3UAASPAGTIMERT29A    (32 % 256)
	{M3UAASPAGTIMERT29A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 15}},
#define   M3UAASPAGTIMERT30A    (33 % 256)
	{M3UAASPAGTIMERT30A, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 16}},
#define   M3UAASPAGSTATUS       (34 % 256)
	{M3UAASPAGSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspAgTable, 6, {1, 2, 2, 2, 1, 17}},
#define   M3UAASPSGNAME         (39 % 256)
	{M3UAASPSGNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 2}},
#define   M3UAASPSGADMINISTRATIVESTATE  (40 % 256)
	{M3UAASPSGADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 3}},
#define   M3UAASPSGOPERATIONALSTATE  (41 % 256)
	{M3UAASPSGOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 4}},
#define   M3UAASPSGPROCEDUREALSTATUS  (42 % 256)
	{M3UAASPSGPROCEDUREALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 5}},
#define   M3UAASPSGUSGAGESTATE  (43 % 256)
	{M3UAASPSGUSGAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 6}},
#define   M3UAASPSGASPSTATE     (44 % 256)
	{M3UAASPSGASPSTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 7}},
#define   M3UAASPSGMAXINITRETRANS  (45 % 256)
	{M3UAASPSGMAXINITRETRANS, ASN_UNSIGNED, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 8}},
#define   M3UAASPSGMAXPATHRETRANS  (46 % 256)
	{M3UAASPSGMAXPATHRETRANS, ASN_UNSIGNED, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 9}},
#define   M3UAASPSGMAXLIFETIME  (47 % 256)
	{M3UAASPSGMAXLIFETIME, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 10}},
#define   M3UAASPSGTIMERT1      (48 % 256)
	{M3UAASPSGTIMERT1, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 11}},
#define   M3UAASPSGTIMERT2      (49 % 256)
	{M3UAASPSGTIMERT2, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 12}},
#define   M3UAASPSGTIMERT3      (50 % 256)
	{M3UAASPSGTIMERT3, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 13}},
#define   M3UAASPSGTIMERT4      (51 % 256)
	{M3UAASPSGTIMERT4, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 14}},
#define   M3UAASPSGTIMERT5      (52 % 256)
	{M3UAASPSGTIMERT5, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 15}},
#define   M3UAASPSGTIMERT5      (53 % 256)
	{M3UAASPSGTIMERT5, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 15}},
#define   M3UAASPSGTIMERT19A    (54 % 256)
	{M3UAASPSGTIMERT19A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 16}},
#define   M3UAASPSGTIMERT24     (55 % 256)
	{M3UAASPSGTIMERT24, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 17}},
#define   M3UAASPSGTIMERT31A    (56 % 256)
	{M3UAASPSGTIMERT31A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 18}},
#define   M3UAASPSGTIMERT32A    (57 % 256)
	{M3UAASPSGTIMERT32A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 19}},
#define   M3UAASPSGTIMERT33A    (58 % 256)
	{M3UAASPSGTIMERT33A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 20}},
#define   M3UAASPSGTIMERT34A    (59 % 256)
	{M3UAASPSGTIMERT34A, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 21}},
#define   M3UAASPSGTIMERT1T     (60 % 256)
	{M3UAASPSGTIMERT1T, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 22}},
#define   M3UAASPSGTIMERT2T     (61 % 256)
	{M3UAASPSGTIMERT2T, ASN_INTEGER, RWRITE, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 23}},
#define   M3UAASPSGSTATUS       (62 % 256)
	{M3UAASPSGSTATUS, ASN_INTEGER, RONLY, var_m3uaAspSgTable, 6, {1, 2, 3, 1, 1, 24}},
#define   M3UAASPSGPNAME        (68 % 256)
	{M3UAASPSGPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 2}},
#define   M3UAASPSGPADMINISTRATIVESTATE  (69 % 256)
	{M3UAASPSGPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 3}},
#define   M3UAASPSGPPROCEDURALSTATUS  (70 % 256)
	{M3UAASPSGPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 4}},
#define   M3UAASPSGPOPERATIONALSTATE  (71 % 256)
	{M3UAASPSGPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 5}},
#define   M3UAASPSGPUSAGESTATE  (72 % 256)
	{M3UAASPSGPUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 6}},
#define   M3UAASPSGPASPSTATE    (73 % 256)
	{M3UAASPSGPASPSTATE, ASN_INTEGER, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 7}},
#define   M3UAASPSGPPRIMARYADDRESS  (74 % 256)
	{M3UAASPSGPPRIMARYADDRESS, ASN_OCTET_STR, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 8}},
#define   M3UAASPSGPHOSTNAME    (75 % 256)
	{M3UAASPSGPHOSTNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 9}},
#define   M3UAASPSGPSTATUS      (76 % 256)
	{M3UAASPSGPSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspSgpTable, 6, {1, 2, 4, 1, 1, 10}},
#define   M3UAASPSPNEXTINDEX    (77 % 256)
	{M3UAASPSPNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaAspMIB, 4, {1, 2, 5, 1}},
#define   M3UAASPSPNAME         (81 % 256)
	{M3UAASPSPNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 2}},
#define   M3UAASPSPOPERATIONALSTATE  (82 % 256)
	{M3UAASPSPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 3}},
#define   M3UAASPSPUSAGESTATE   (83 % 256)
	{M3UAASPSPUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 4}},
#define   M3UAASPSPADMINISTRATIVESTATE  (84 % 256)
	{M3UAASPSPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 5}},
#define   M3UAASPSPALARMSTATUS  (85 % 256)
	{M3UAASPSPALARMSTATUS, ASN_BIT_STR, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 6}},
#define   M3UAASPSPPROCEDURALSTATUS  (86 % 256)
	{M3UAASPSPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 7}},
#define   M3UAASPSPAVAILABILTYSTATUS  (87 % 256)
	{M3UAASPSPAVAILABILTYSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 8}},
#define   M3UAASPSPPOINTCODE    (88 % 256)
	{M3UAASPSPPOINTCODE, ASN_OCTET_STR, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 9}},
#define   M3UAASPSPTIMERT1R     (89 % 256)
	{M3UAASPSPTIMERT1R, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 10}},
#define   M3UAASPSPTIMERT18     (90 % 256)
	{M3UAASPSPTIMERT18, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 11}},
#define   M3UAASPSPTIMERT20     (91 % 256)
	{M3UAASPSPTIMERT20, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 12}},
#define   M3UAASPSPTIMERT22A    (92 % 256)
	{M3UAASPSPTIMERT22A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 13}},
#define   M3UAASPSPTIMERT23A    (93 % 256)
	{M3UAASPSPTIMERT23A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 14}},
#define   M3UAASPSPTIMERT24A    (94 % 256)
	{M3UAASPSPTIMERT24A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 15}},
#define   M3UAASPSPTIMERT26A    (95 % 256)
	{M3UAASPSPTIMERT26A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 16}},
#define   M3UAASPSPTIMERT27A    (96 % 256)
	{M3UAASPSPTIMERT27A, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 17}},
#define   M3UAASPSPSTATUS       (97 % 256)
	{M3UAASPSPSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspSpTable, 6, {1, 2, 5, 2, 1, 18}},
#define   M3UAASPMTNAME         (102 % 256)
	{M3UAASPMTNAME, ASN_OCTET_STR, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 2}},
#define   M3UAASPMTADMINISTRATIVESTATE  (103 % 256)
	{M3UAASPMTADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 3}},
#define   M3UAASPMTOPERATIONALSTATE  (104 % 256)
	{M3UAASPMTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 4}},
#define   M3UAASPMTPROCEDURALSTATUS  (105 % 256)
	{M3UAASPMTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 5}},
#define   M3UAASPMTUSAGESTATE   (106 % 256)
	{M3UAASPMTUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 6}},
#define   M3UAASPMTASSTATE      (107 % 256)
	{M3UAASPMTASSTATE, ASN_INTEGER, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 7}},
#define   M3UAASPMTSTATUS       (108 % 256)
	{M3UAASPMTSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspMtTable, 6, {1, 2, 6, 1, 1, 8}},
#define   M3UAASPRSNAME         (113 % 256)
	{M3UAASPRSNAME, ASN_OCTET_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 2}},
#define   M3UAASPRSREMOTEPOINTCODE  (114 % 256)
	{M3UAASPRSREMOTEPOINTCODE, ASN_OCTET_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 3}},
#define   M3UAASPRSOPERATIONALSTATE  (115 % 256)
	{M3UAASPRSOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 4}},
#define   M3UAASPRSADMINISTRATIVESTATE  (116 % 256)
	{M3UAASPRSADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 5}},
#define   M3UAASPRSUSAGESTATE   (117 % 256)
	{M3UAASPRSUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 6}},
#define   M3UAASPRSALARMSTATUS  (118 % 256)
	{M3UAASPRSALARMSTATUS, ASN_BIT_STR, RWRITE, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 7}},
#define   M3UAASPRSPROCEDURALSTATUS  (119 % 256)
	{M3UAASPRSPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 8}},
#define   M3UAASPRSTIMERT8      (120 % 256)
	{M3UAASPRSTIMERT8, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 9}},
#define   M3UAASPRSTIMERT11     (121 % 256)
	{M3UAASPRSTIMERT11, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 10}},
#define   M3UAASPRSTIMERT15     (122 % 256)
	{M3UAASPRSTIMERT15, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 11}},
#define   M3UAASPRSTIMERT16     (123 % 256)
	{M3UAASPRSTIMERT16, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 12}},
#define   M3UAASPRSTIMERT18A    (124 % 256)
	{M3UAASPRSTIMERT18A, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 13}},
#define   M3UAASPRSOPTIONS      (125 % 256)
	{M3UAASPRSOPTIONS, ASN_BIT_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 14}},
#define   M3UAASPRSAVAILABILITYSTATUS  (126 % 256)
	{M3UAASPRSAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 15}},
#define   M3UAASPRSCONGESTIONLEVEL  (127 % 256)
	{M3UAASPRSCONGESTIONLEVEL, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 16}},
#define   M3UAASPRSSTATUS       (128 % 256)
	{M3UAASPRSSTATUS, ASN_INTEGER, RONLY, var_m3uaAspRsTable, 6, {1, 2, 7, 1, 1, 17}},
#define   M3UAASPRLCOST         (134 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (135 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (136 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (137 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (138 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (139 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRLCOST         (140 % 256)
	{M3UAASPRLCOST, ASN_UNSIGNED, RWRITE, var_m3uaAspRlTable, 6, {1, 2, 8, 1, 1, 1}},
#define   M3UAASPRTCOST         (147 % 256)
	{M3UAASPRTCOST, ASN_UNSIGNED, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 1}},
#define   M3UAASPRTTIMERT6      (148 % 256)
	{M3UAASPRTTIMERT6, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 2}},
#define   M3UAASPRTTIMERT10     (149 % 256)
	{M3UAASPRTTIMERT10, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 3}},
#define   M3UAASPRTAVAILABILITYSTATUS  (150 % 256)
	{M3UAASPRTAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 4}},
#define   M3UAASPRTADMINSTRATIVESTATE  (151 % 256)
	{M3UAASPRTADMINSTRATIVESTATE, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 5}},
#define   M3UAASPRTOPERATIONALSTATE  (152 % 256)
	{M3UAASPRTOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 6}},
#define   M3UAASPRTPROCEDURALSTATUS  (153 % 256)
	{M3UAASPRTPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 7}},
#define   M3UAASPRTUSAGESTATE   (154 % 256)
	{M3UAASPRTUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 8}},
#define   M3UAASPRTSTATUS       (155 % 256)
	{M3UAASPRTSTATUS, ASN_INTEGER, RONLY, var_m3uaAspRtTable, 6, {1, 2, 9, 1, 1, 9}},
#define   M3UAASPRCVALUE        (162 % 256)
	{M3UAASPRCVALUE, ASN_UNSIGNED, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 1}},
#define   M3UAASPRCREGSTRATIONPOLICY  (163 % 256)
	{M3UAASPRCREGSTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 3}},
#define   M3UAASPRCTRAFFICMODE  (164 % 256)
	{M3UAASPRCTRAFFICMODE, ASN_OBJECT_ID, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 4}},
#define   M3UAASPRCSTATUS       (165 % 256)
	{M3UAASPRCSTATUS, ASN_INTEGER, RWRITE, var_m3uaAspRcTable, 6, {1, 2, 10, 1, 1, 5}},
#define   M3UAASPASASSTATE      (173 % 256)
	{M3UAASPASASSTATE, ASN_INTEGER, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 1}},
#define   M3UAASPASOPERATIONALSTATE  (174 % 256)
	{M3UAASPASOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 2}},
#define   M3UAASPASPROCEDURALSTATUS  (175 % 256)
	{M3UAASPASPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 3}},
#define   M3UAASPASUSAGESTATE   (176 % 256)
	{M3UAASPASUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspAsTable, 6, {1, 2, 11, 1, 1, 4}},
#define   M3UAASPAFASSTATE      (185 % 256)
	{M3UAASPAFASSTATE, ASN_INTEGER, RWRITE, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 1}},
#define   M3UAASPAFADMINISTRATIVESTATE  (186 % 256)
	{M3UAASPAFADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 2}},
#define   M3UAASPAFOPERATIONALSTATE  (187 % 256)
	{M3UAASPAFOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 3}},
#define   M3UAASPAFPROCEDURALSTATUS  (188 % 256)
	{M3UAASPAFPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 4}},
#define   M3UAASPAFUSAGESTATE   (189 % 256)
	{M3UAASPAFUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaAspAfTable, 6, {1, 2, 12, 1, 1, 5}},

};

/*    (L = length of the oidsuffix) */
struct m3uaAspMIB_data *m3uaAspMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *m3uaAspTableStorage = NULL;
struct header_complex_index *m3uaAspAgTableStorage = NULL;
struct header_complex_index *m3uaAspSgTableStorage = NULL;
struct header_complex_index *m3uaAspSgpTableStorage = NULL;
struct header_complex_index *m3uaAspSpTableStorage = NULL;
struct header_complex_index *m3uaAspMtTableStorage = NULL;
struct header_complex_index *m3uaAspRsTableStorage = NULL;
struct header_complex_index *m3uaAspRlTableStorage = NULL;
struct header_complex_index *m3uaAspRtTableStorage = NULL;
struct header_complex_index *m3uaAspRcTableStorage = NULL;
struct header_complex_index *m3uaAspAsTableStorage = NULL;
struct header_complex_index *m3uaAspAfTableStorage = NULL;

/*
 * init_m3uaAspMIB():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_m3uaAspMIB(void)
{
	DEBUGMSGTL(("m3uaAspMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("m3uaAspMIB", m3uaAspMIB_variables, variable7, m3uaAspMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_m3uaAspMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("m3uaAspMIB", parse_m3uaAspMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspTable", parse_m3uaAspTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspAgTable", parse_m3uaAspAgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspSgTable", parse_m3uaAspSgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspSgpTable", parse_m3uaAspSgpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspSpTable", parse_m3uaAspSpTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspMtTable", parse_m3uaAspMtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspRsTable", parse_m3uaAspRsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspRlTable", parse_m3uaAspRlTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspRtTable", parse_m3uaAspRtTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspRcTable", parse_m3uaAspRcTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspAsTable", parse_m3uaAspAsTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaAspAfTable", parse_m3uaAspAfTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspAgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspSgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspSgpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspSpTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspMtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspRsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspRlTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspRtTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspRcTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspAsTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaAspAfTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
}

/*
 * deinit_m3uaAspMIB():
 *   Deinitialization routine.  This is called before the agent is unloaded.
 *   At a minimum, deregistration of your variables should take place here.
 */
void
deinit_m3uaAspMIB(void)
{
	DEBUGMSGTL(("m3uaAspMIB", "deinitializating...  "));
	unregister_mib(m3uaAspMIB_variables_oid, sizeof(m3uaAspMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("m3uaAspMIB");
	snmpd_unregister_config_handler("m3uaAspTable");
	snmpd_unregister_config_handler("m3uaAspAgTable");
	snmpd_unregister_config_handler("m3uaAspSgTable");
	snmpd_unregister_config_handler("m3uaAspSgpTable");
	snmpd_unregister_config_handler("m3uaAspSpTable");
	snmpd_unregister_config_handler("m3uaAspMtTable");
	snmpd_unregister_config_handler("m3uaAspRsTable");
	snmpd_unregister_config_handler("m3uaAspRlTable");
	snmpd_unregister_config_handler("m3uaAspRtTable");
	snmpd_unregister_config_handler("m3uaAspRcTable");
	snmpd_unregister_config_handler("m3uaAspAsTable");
	snmpd_unregister_config_handler("m3uaAspAfTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
}

int
term_m3uaAspMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_m3uaAspMIB();
	return 0;
}

/*
 * m3uaAspMIB_add(): adds a structure node for scalars
 */
int
m3uaAspMIB_add(struct m3uaAspMIB_data *thedata)
{
	DEBUGMSGTL(("m3uaAspMIB", "adding data...  "));
	m3uaAspMIBStorage = thedata;
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspMIB():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspMIB_data);

	DEBUGMSGTL(("m3uaAspMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspNextIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgNextIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpNextIndex, &tmpsize);

	m3uaAspMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
}

/*
 * store_m3uaAspMIB():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspMIB_data *StorageTmp;

	DEBUGMSGTL(("m3uaAspMIB", "storing data...  "));
	refresh_m3uaAspMIB();
	if ((StorageTmp = m3uaAspMIBStorage) == NULL) {
		DEBUGMSGTL(("m3uaAspMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->m3uaAspMIBStorageType == ST_NONVOLATILE) { */
	memset(line, 0, sizeof(line));
	strcat(line, "m3uaAspMIB ");
	cptr = line + strlen(line);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspNextIndex, &tmpsize);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgNextIndex, &tmpsize);
	cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpNextIndex, &tmpsize);

	snmpd_store_config(line);
	/* } */
	DEBUGMSGTL(("m3uaAspMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_m3uaAspMIB: refresh m3uaAspMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread scalars and tables from the STREAMS susbystem.  This function
 * is used when the agent starts for the first time, or after a SIGPOLL
 * has been received (and a scalar has been requested).
 */
void
refresh_m3uaAspMIB(void)
{
	if (m3uaAspMIBStorage == NULL) {
		struct m3uaAspMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(m3uaAspMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */

		m3uaAspMIBStorage = StorageNew;
		m3uaAspMIB_refresh = 1;
	}
	if (m3uaAspMIB_refresh == 0)
		return;
	m3uaAspMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_m3uaAspMIB():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
uint8_t *
var_m3uaAspMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_m3uaAspMIB();
	if ((StorageTmp = m3uaAspMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPNEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspNextIndex);
		return (uint8_t *) &StorageTmp->m3uaAspNextIndex;
	case M3UAASPAGNEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAgNextIndex);
		return (uint8_t *) &StorageTmp->m3uaAspAgNextIndex;
	case M3UAASPSPNEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSpNextIndex);
		return (uint8_t *) &StorageTmp->m3uaAspSpNextIndex;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * m3uaAspTable_add(): adds a structure node to our data set
 */
int
m3uaAspTable_add(struct m3uaAspTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspIndex, sizeof(thedata->m3uaAspIndex));
	/* m3uaAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspIndex, sizeof(thedata->m3uaAspIndex));

	header_complex_add_data(&m3uaAspTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspTable_data);

	DEBUGMSGTL(("m3uaAspTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspName, &tmpsize);
	StorageTmp->m3uaAspNameLen = tmpsize;
	if (StorageTmp->m3uaAspName == NULL) {
		config_perror("invalid specification for m3uaAspName");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspName, &tmpsize);
	StorageTmp->m3uaAspNameLen = tmpsize;
	if (StorageTmp->m3uaAspName == NULL) {
		config_perror("invalid specification for m3uaAspName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspCapabilities, &tmpsize);
	StorageTmp->m3uaAspCapabilitiesLen = tmpsize;
	if (StorageTmp->m3uaAspCapabilities == NULL) {
		config_perror("invalid specification for m3uaAspCapabilities");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspIdPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRegistrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAssociationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspStatus, &tmpsize);

	m3uaAspTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspTable", "done.\n"));
}

/*
 * store_m3uaAspTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspTable", "storing data...  "));
	refresh_m3uaAspTable();
	(void) tmpsize;
	for (hcindex = m3uaAspTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspIndex, &tmpsize);
		tmpsize = StorageTmp->m3uaAspNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspName, &tmpsize);
		tmpsize = StorageTmp->m3uaAspNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAdministrativeState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAdministrativeState, &tmpsize);
		tmpsize = StorageTmp->m3uaAspCapabilitiesLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspCapabilities, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspIdPolicy, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRegistrationPolicy, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAssociationPolicy, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspAgTable_add(): adds a structure node to our data set
 */
int
m3uaAspAgTable_add(struct m3uaAspAgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspAgTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));

	header_complex_add_data(&m3uaAspAgTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspAgTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspAgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspAgTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspAgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspAgTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspAgTable_data);

	DEBUGMSGTL(("m3uaAspAgTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->m3uaAspAgProtocolVersion, &tmpsize);
	StorageTmp->m3uaAspAgProtocolVersionLen = tmpsize;
	if (StorageTmp->m3uaAspAgProtocolVersion == NULL) {
		config_perror("invalid specification for m3uaAspAgProtocolVersion");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspAgOptions, &tmpsize);
	StorageTmp->m3uaAspAgOptionsLen = tmpsize;
	if (StorageTmp->m3uaAspAgOptions == NULL) {
		config_perror("invalid specification for m3uaAspAgOptions");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgRegistrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgAspIdPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgAspProtocolPayloadId, &tmpsize);
	line = read_config_read_data(, line, &StorageTmp->m3uaAspAgIpPort, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgMinOstreams, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgMaxIstreams, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT7, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT19, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT21, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT25A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT28A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT29A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgTimerT30A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAgStatus, &tmpsize);

	m3uaAspAgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspAgTable", "done.\n"));
}

/*
 * store_m3uaAspAgTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspAgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspAgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspAgTable", "storing data...  "));
	refresh_m3uaAspAgTable();
	(void) tmpsize;
	for (hcindex = m3uaAspAgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspAgTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspAgTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspAgTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
		tmpsize = StorageTmp->m3uaAspAgProtocolVersionLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->m3uaAspAgProtocolVersion, &tmpsize);
		tmpsize = StorageTmp->m3uaAspAgOptionsLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspAgOptions, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgRegistrationPolicy, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgAspIdPolicy, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgAspProtocolPayloadId, &tmpsize);
		cptr = read_config_store_data(, cptr, &StorageTmp->m3uaAspAgIpPort, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgMinOstreams, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgMaxIstreams, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT7, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT19, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT21, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT25A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT28A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT29A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgTimerT30A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAgStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspAgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspSgTable_add(): adds a structure node to our data set
 */
int
m3uaAspSgTable_add(struct m3uaAspSgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspSgTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	/* m3uaAspSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSgIndex, sizeof(thedata->m3uaAspSgIndex));

	header_complex_add_data(&m3uaAspSgTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspSgTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspSgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspSgTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspSgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspSgTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspSgTable_data);

	DEBUGMSGTL(("m3uaAspSgTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSgName, &tmpsize);
	StorageTmp->m3uaAspSgNameLen = tmpsize;
	if (StorageTmp->m3uaAspSgName == NULL) {
		config_perror("invalid specification for m3uaAspSgName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspSgProcedurealStatus, &tmpsize);
	StorageTmp->m3uaAspSgProcedurealStatusLen = tmpsize;
	if (StorageTmp->m3uaAspSgProcedurealStatus == NULL) {
		config_perror("invalid specification for m3uaAspSgProcedurealStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgUsgageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgAspState, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgMaxInitRetrans, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgMaxPathRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgMaxLifeTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT1, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT2, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT3, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT4, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT5, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT19A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT24, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT31A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT32A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT33A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT34A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT1T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgTimerT2T, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgStatus, &tmpsize);

	m3uaAspSgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspSgTable", "done.\n"));
}

/*
 * store_m3uaAspSgTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspSgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspSgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspSgTable", "storing data...  "));
	refresh_m3uaAspSgTable();
	(void) tmpsize;
	for (hcindex = m3uaAspSgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspSgTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspSgTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspSgTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgIndex, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSgNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSgName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgAdministrativeState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgOperationalState, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSgProcedurealStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspSgProcedurealStatus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgUsgageState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgAspState, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgMaxInitRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgMaxPathRetrans, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgMaxLifeTime, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT1, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT2, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT3, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT4, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT5, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT5, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT19A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT24, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT31A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT32A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT33A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT34A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT1T, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgTimerT2T, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspSgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspSgpTable_add(): adds a structure node to our data set
 */
int
m3uaAspSgpTable_add(struct m3uaAspSgpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspSgpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	/* m3uaAspSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSgIndex, sizeof(thedata->m3uaAspSgIndex));
	/* m3uaAspSgpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSgpIndex, sizeof(thedata->m3uaAspSgpIndex));

	header_complex_add_data(&m3uaAspSgpTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspSgpTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspSgpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspSgpTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspSgpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspSgpTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspSgpTable_data);

	DEBUGMSGTL(("m3uaAspSgpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgpIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSgpName, &tmpsize);
	StorageTmp->m3uaAspSgpNameLen = tmpsize;
	if (StorageTmp->m3uaAspSgpName == NULL) {
		config_perror("invalid specification for m3uaAspSgpName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgpAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspSgpProceduralStatus, &tmpsize);
	StorageTmp->m3uaAspSgpProceduralStatusLen = tmpsize;
	if (StorageTmp->m3uaAspSgpProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspSgpProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgpUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgpAspState, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSgpPrimaryAddress, &tmpsize);
	StorageTmp->m3uaAspSgpPrimaryAddressLen = tmpsize;
	if (StorageTmp->m3uaAspSgpPrimaryAddress == NULL) {
		config_perror("invalid specification for m3uaAspSgpPrimaryAddress");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSgpHostName, &tmpsize);
	StorageTmp->m3uaAspSgpHostNameLen = tmpsize;
	if (StorageTmp->m3uaAspSgpHostName == NULL) {
		config_perror("invalid specification for m3uaAspSgpHostName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSgpStatus, &tmpsize);

	m3uaAspSgpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspSgpTable", "done.\n"));
}

/*
 * store_m3uaAspSgpTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspSgpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspSgpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspSgpTable", "storing data...  "));
	refresh_m3uaAspSgpTable();
	(void) tmpsize;
	for (hcindex = m3uaAspSgpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspSgpTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspSgpTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspSgpTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgpIndex, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSgpNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSgpName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgpAdministrativeState, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSgpProceduralStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspSgpProceduralStatus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgpOperationalState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgpUsageState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgpAspState, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSgpPrimaryAddressLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSgpPrimaryAddress, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSgpHostNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSgpHostName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSgpStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspSgpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspSpTable_add(): adds a structure node to our data set
 */
int
m3uaAspSpTable_add(struct m3uaAspSpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspSpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));

	header_complex_add_data(&m3uaAspSpTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspSpTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspSpTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspSpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspSpTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspSpTable_data);

	DEBUGMSGTL(("m3uaAspSpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSpName, &tmpsize);
	StorageTmp->m3uaAspSpNameLen = tmpsize;
	if (StorageTmp->m3uaAspSpName == NULL) {
		config_perror("invalid specification for m3uaAspSpName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspSpAlarmStatus, &tmpsize);
	StorageTmp->m3uaAspSpAlarmStatusLen = tmpsize;
	if (StorageTmp->m3uaAspSpAlarmStatus == NULL) {
		config_perror("invalid specification for m3uaAspSpAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspSpProceduralStatus, &tmpsize);
	StorageTmp->m3uaAspSpProceduralStatusLen = tmpsize;
	if (StorageTmp->m3uaAspSpProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspSpProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspSpAvailabiltyStatus, &tmpsize);
	StorageTmp->m3uaAspSpAvailabiltyStatusLen = tmpsize;
	if (StorageTmp->m3uaAspSpAvailabiltyStatus == NULL) {
		config_perror("invalid specification for m3uaAspSpAvailabiltyStatus");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspSpPointCode, &tmpsize);
	StorageTmp->m3uaAspSpPointCodeLen = tmpsize;
	if (StorageTmp->m3uaAspSpPointCode == NULL) {
		config_perror("invalid specification for m3uaAspSpPointCode");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT1R, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT18, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT20, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT22A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT23A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT24A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT26A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpTimerT27A, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspSpStatus, &tmpsize);

	m3uaAspSpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspSpTable", "done.\n"));
}

/*
 * store_m3uaAspSpTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspSpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspSpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspSpTable", "storing data...  "));
	refresh_m3uaAspSpTable();
	(void) tmpsize;
	for (hcindex = m3uaAspSpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspSpTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspSpTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspSpTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSpNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSpName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpOperationalState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpUsageState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpAdministrativeState, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSpAlarmStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspSpAlarmStatus, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSpProceduralStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspSpProceduralStatus, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSpAvailabiltyStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspSpAvailabiltyStatus, &tmpsize);
		tmpsize = StorageTmp->m3uaAspSpPointCodeLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspSpPointCode, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT1R, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT18, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT20, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT22A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT23A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT24A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT26A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpTimerT27A, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspSpStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspSpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspMtTable_add(): adds a structure node to our data set
 */
int
m3uaAspMtTable_add(struct m3uaAspMtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspMtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspMtIndex */
	snmp_varlist_add_variable(&vars, NULL, 0,, (uint8_t *) thedata->m3uaAspMtIndex, thedata->m3uaAspMtIndex);

	header_complex_add_data(&m3uaAspMtTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspMtTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspMtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspMtTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspMtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspMtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspMtTable_data);

	DEBUGMSGTL(("m3uaAspMtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(, line, &StorageTmp->m3uaAspMtIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspMtName, &tmpsize);
	StorageTmp->m3uaAspMtNameLen = tmpsize;
	if (StorageTmp->m3uaAspMtName == NULL) {
		config_perror("invalid specification for m3uaAspMtName");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspMtAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspMtOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspMtProceduralStatus, &tmpsize);
	StorageTmp->m3uaAspMtProceduralStatusLen = tmpsize;
	if (StorageTmp->m3uaAspMtProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspMtProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspMtUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspMtAsState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspMtStatus, &tmpsize);

	m3uaAspMtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspMtTable", "done.\n"));
}

/*
 * store_m3uaAspMtTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspMtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspMtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspMtTable", "storing data...  "));
	refresh_m3uaAspMtTable();
	(void) tmpsize;
	for (hcindex = m3uaAspMtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspMtTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspMtTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspMtTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
		cptr = read_config_store_data(, cptr, &StorageTmp->m3uaAspMtIndex, &tmpsize);
		tmpsize = StorageTmp->m3uaAspMtNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspMtName, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspMtAdministrativeState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspMtOperationalState, &tmpsize);
		tmpsize = StorageTmp->m3uaAspMtProceduralStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspMtProceduralStatus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspMtUsageState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspMtAsState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspMtStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspMtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspRsTable_add(): adds a structure node to our data set
 */
int
m3uaAspRsTable_add(struct m3uaAspRsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspRsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspRsIndex, sizeof(thedata->m3uaAspRsIndex));

	header_complex_add_data(&m3uaAspRsTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspRsTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspRsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspRsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspRsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspRsTable_data);

	DEBUGMSGTL(("m3uaAspRsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRsIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspRsName, &tmpsize);
	StorageTmp->m3uaAspRsNameLen = tmpsize;
	if (StorageTmp->m3uaAspRsName == NULL) {
		config_perror("invalid specification for m3uaAspRsName");
		return;
	}

	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaAspRsRemotePointCode, &tmpsize);
	StorageTmp->m3uaAspRsRemotePointCodeLen = tmpsize;
	if (StorageTmp->m3uaAspRsRemotePointCode == NULL) {
		config_perror("invalid specification for m3uaAspRsRemotePointCode");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsUsageState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRsAlarmStatus, &tmpsize);
	StorageTmp->m3uaAspRsAlarmStatusLen = tmpsize;
	if (StorageTmp->m3uaAspRsAlarmStatus == NULL) {
		config_perror("invalid specification for m3uaAspRsAlarmStatus");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRsProceduralStatus, &tmpsize);
	StorageTmp->m3uaAspRsProceduralStatusLen = tmpsize;
	if (StorageTmp->m3uaAspRsProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspRsProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsTimerT8, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsTimerT11, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsTimerT15, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsTimerT16, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsTimerT18A, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRsOptions, &tmpsize);
	StorageTmp->m3uaAspRsOptionsLen = tmpsize;
	if (StorageTmp->m3uaAspRsOptions == NULL) {
		config_perror("invalid specification for m3uaAspRsOptions");
		return;
	}

	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRsAvailabilityStatus, &tmpsize);
	StorageTmp->m3uaAspRsAvailabilityStatusLen = tmpsize;
	if (StorageTmp->m3uaAspRsAvailabilityStatus == NULL) {
		config_perror("invalid specification for m3uaAspRsAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsCongestionLevel, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRsStatus, &tmpsize);

	m3uaAspRsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspRsTable", "done.\n"));
}

/*
 * store_m3uaAspRsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspRsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspRsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspRsTable", "storing data...  "));
	refresh_m3uaAspRsTable();
	(void) tmpsize;
	for (hcindex = m3uaAspRsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspRsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspRsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspRsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRsIndex, &tmpsize);
		tmpsize = StorageTmp->m3uaAspRsNameLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspRsName, &tmpsize);
		tmpsize = StorageTmp->m3uaAspRsRemotePointCodeLen;
		cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaAspRsRemotePointCode, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsOperationalState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsAdministrativeState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsUsageState, &tmpsize);
		tmpsize = StorageTmp->m3uaAspRsAlarmStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRsAlarmStatus, &tmpsize);
		tmpsize = StorageTmp->m3uaAspRsProceduralStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRsProceduralStatus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsTimerT8, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsTimerT11, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsTimerT15, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsTimerT16, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsTimerT18A, &tmpsize);
		tmpsize = StorageTmp->m3uaAspRsOptionsLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRsOptions, &tmpsize);
		tmpsize = StorageTmp->m3uaAspRsAvailabilityStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRsAvailabilityStatus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsCongestionLevel, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRsStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspRsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspRlTable_add(): adds a structure node to our data set
 */
int
m3uaAspRlTable_add(struct m3uaAspRlTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspRlTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspRsIndex, sizeof(thedata->m3uaAspRsIndex));
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));

	header_complex_add_data(&m3uaAspRlTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspRlTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspRlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspRlTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspRlTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspRlTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspRlTable_data);

	DEBUGMSGTL(("m3uaAspRlTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRsIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRlCost, &tmpsize);

	m3uaAspRlTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspRlTable", "done.\n"));
}

/*
 * store_m3uaAspRlTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspRlTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspRlTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspRlTable", "storing data...  "));
	refresh_m3uaAspRlTable();
	(void) tmpsize;
	for (hcindex = m3uaAspRlTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspRlTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspRlTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspRlTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRsIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRlCost, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspRlTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspRtTable_add(): adds a structure node to our data set
 */
int
m3uaAspRtTable_add(struct m3uaAspRtTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspRtTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspRsIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspRsIndex, sizeof(thedata->m3uaAspRsIndex));
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	/* m3uaAspSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSgIndex, sizeof(thedata->m3uaAspSgIndex));

	header_complex_add_data(&m3uaAspRtTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspRtTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspRtTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspRtTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspRtTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspRtTable_data);

	DEBUGMSGTL(("m3uaAspRtTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRsIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRtCost, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtTimerT6, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtTimerT10, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRtAvailabilityStatus, &tmpsize);
	StorageTmp->m3uaAspRtAvailabilityStatusLen = tmpsize;
	if (StorageTmp->m3uaAspRtAvailabilityStatus == NULL) {
		config_perror("invalid specification for m3uaAspRtAvailabilityStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtAdminstrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspRtProceduralStatus, &tmpsize);
	StorageTmp->m3uaAspRtProceduralStatusLen = tmpsize;
	if (StorageTmp->m3uaAspRtProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspRtProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRtStatus, &tmpsize);

	m3uaAspRtTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspRtTable", "done.\n"));
}

/*
 * store_m3uaAspRtTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspRtTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspRtTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspRtTable", "storing data...  "));
	refresh_m3uaAspRtTable();
	(void) tmpsize;
	for (hcindex = m3uaAspRtTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspRtTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspRtTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspRtTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRsIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRtCost, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtTimerT6, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtTimerT10, &tmpsize);
		tmpsize = StorageTmp->m3uaAspRtAvailabilityStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRtAvailabilityStatus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtAdminstrativeState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtOperationalState, &tmpsize);
		tmpsize = StorageTmp->m3uaAspRtProceduralStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspRtProceduralStatus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtUsageState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRtStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspRtTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspRcTable_add(): adds a structure node to our data set
 */
int
m3uaAspRcTable_add(struct m3uaAspRcTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspRcTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspIndex, sizeof(thedata->m3uaAspIndex));
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspMtIndex */
	snmp_varlist_add_variable(&vars, NULL, 0,, (uint8_t *) thedata->m3uaAspMtIndex, thedata->m3uaAspMtIndex);
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));

	header_complex_add_data(&m3uaAspRcTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspRcTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspRcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspRcTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspRcTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspRcTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspRcTable_data);

	DEBUGMSGTL(("m3uaAspRcTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(, line, &StorageTmp->m3uaAspMtIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspRcValue, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRcRegstrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->m3uaAspRcTrafficMode, &tmpsize);
	StorageTmp->m3uaAspRcTrafficModeLen = tmpsize;
	if (StorageTmp->m3uaAspRcTrafficMode == NULL) {
		config_perror("invalid specification for m3uaAspRcTrafficMode");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspRcStatus, &tmpsize);

	m3uaAspRcTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspRcTable", "done.\n"));
}

/*
 * store_m3uaAspRcTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspRcTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspRcTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspRcTable", "storing data...  "));
	refresh_m3uaAspRcTable();
	(void) tmpsize;
	for (hcindex = m3uaAspRcTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspRcTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspRcTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspRcTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
		cptr = read_config_store_data(, cptr, &StorageTmp->m3uaAspMtIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspRcValue, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRcRegstrationPolicy, &tmpsize);
		tmpsize = StorageTmp->m3uaAspRcTrafficModeLen;
		cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->m3uaAspRcTrafficMode, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspRcStatus, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspRcTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspAsTable_add(): adds a structure node to our data set
 */
int
m3uaAspAsTable_add(struct m3uaAspAsTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspAsTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspIndex, sizeof(thedata->m3uaAspIndex));
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspMtIndex */
	snmp_varlist_add_variable(&vars, NULL, 0,, (uint8_t *) thedata->m3uaAspMtIndex, thedata->m3uaAspMtIndex);
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	/* m3uaAspSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSgIndex, sizeof(thedata->m3uaAspSgIndex));

	header_complex_add_data(&m3uaAspAsTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspAsTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspAsTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspAsTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspAsTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspAsTable_data);

	DEBUGMSGTL(("m3uaAspAsTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(, line, &StorageTmp->m3uaAspMtIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAsAsState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAsOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspAsProceduralStatus, &tmpsize);
	StorageTmp->m3uaAspAsProceduralStatusLen = tmpsize;
	if (StorageTmp->m3uaAspAsProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspAsProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAsUsageState, &tmpsize);

	m3uaAspAsTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspAsTable", "done.\n"));
}

/*
 * store_m3uaAspAsTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspAsTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspAsTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspAsTable", "storing data...  "));
	refresh_m3uaAspAsTable();
	(void) tmpsize;
	for (hcindex = m3uaAspAsTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspAsTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspAsTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspAsTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
		cptr = read_config_store_data(, cptr, &StorageTmp->m3uaAspMtIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAsAsState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAsOperationalState, &tmpsize);
		tmpsize = StorageTmp->m3uaAspAsProceduralStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspAsProceduralStatus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAsUsageState, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspAsTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaAspAfTable_add(): adds a structure node to our data set
 */
int
m3uaAspAfTable_add(struct m3uaAspAfTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaAspAfTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspIndex, sizeof(thedata->m3uaAspIndex));
	/* m3uaAspSpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSpIndex, sizeof(thedata->m3uaAspSpIndex));
	/* m3uaAspMtIndex */
	snmp_varlist_add_variable(&vars, NULL, 0,, (uint8_t *) thedata->m3uaAspMtIndex, thedata->m3uaAspMtIndex);
	/* m3uaAspAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspAgIndex, sizeof(thedata->m3uaAspAgIndex));
	/* m3uaAspSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSgIndex, sizeof(thedata->m3uaAspSgIndex));
	/* m3uaAspSgpIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (uint8_t *) &thedata->m3uaAspSgpIndex, sizeof(thedata->m3uaAspSgpIndex));

	header_complex_add_data(&m3uaAspAfTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaAspAfTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaAspAfTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaAspAfTable():
 *   parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaAspAfTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaAspAfTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaAspAfTable_data);

	DEBUGMSGTL(("m3uaAspAfTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSpIndex, &tmpsize);
	line = read_config_read_data(, line, &StorageTmp->m3uaAspMtIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaAspSgpIndex, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAfAsState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAfAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAfOperationalState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaAspAfProceduralStatus, &tmpsize);
	StorageTmp->m3uaAspAfProceduralStatusLen = tmpsize;
	if (StorageTmp->m3uaAspAfProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaAspAfProceduralStatus");
		return;
	}

	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaAspAfUsageState, &tmpsize);

	m3uaAspAfTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaAspAfTable", "done.\n"));
}

/*
 * store_m3uaAspAfTable():
 *   stores .conf file entries needed to configure the mib.
 */
int
store_m3uaAspAfTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaAspAfTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaAspAfTable", "storing data...  "));
	refresh_m3uaAspAfTable();
	(void) tmpsize;
	for (hcindex = m3uaAspAfTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaAspAfTable_data *) hcindex->data;
/*   XXX:  if (StorageTmp->m3uaAspAfTableStorageType == ST_NONVOLATILE) { */
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaAspAfTable ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSpIndex, &tmpsize);
		cptr = read_config_store_data(, cptr, &StorageTmp->m3uaAspMtIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspAgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaAspSgpIndex, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAfAsState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAfAdministrativeState, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAfOperationalState, &tmpsize);
		tmpsize = StorageTmp->m3uaAspAfProceduralStatusLen;
		cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaAspAfProceduralStatus, &tmpsize);
		cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaAspAfUsageState, &tmpsize);

		snmpd_store_config(line);
/*   } */
	}
	DEBUGMSGTL(("m3uaAspAfTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_m3uaAspTable(): refresh m3uaAspTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspTable(void)
{
	if (m3uaAspTable_refresh == 0)
		return;
	m3uaAspTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspTable_row(): refresh m3uaAspTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspTable_row(struct m3uaAspTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspTable_request == sa_request)
		return;
	StorageTmp->m3uaAspTable_request = sa_request;
}

/*
 * var_m3uaAspTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPNAME:
		*write_method = write_m3uaAspName;
		*var_len = StorageTmp->m3uaAspNameLen;
		return (uint8_t *) StorageTmp->m3uaAspName;
	case M3UAASPNAME:
		*write_method = write_m3uaAspName;
		*var_len = StorageTmp->m3uaAspNameLen;
		return (uint8_t *) StorageTmp->m3uaAspName;
	case M3UAASPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspAdministrativeState);
		return (uint8_t *) &StorageTmp->m3uaAspAdministrativeState;
	case M3UAASPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspAdministrativeState);
		return (uint8_t *) &StorageTmp->m3uaAspAdministrativeState;
	case M3UAASPCAPABILITIES:
		*write_method = write_m3uaAspCapabilities;
		*var_len = StorageTmp->m3uaAspCapabilitiesLen;
		return (uint8_t *) StorageTmp->m3uaAspCapabilities;
	case M3UAASPIDPOLICY:
		*write_method = write_m3uaAspIdPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspIdPolicy);
		return (uint8_t *) &StorageTmp->m3uaAspIdPolicy;
	case M3UAASPREGISTRATIONPOLICY:
		*write_method = write_m3uaAspRegistrationPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspRegistrationPolicy);
		return (uint8_t *) &StorageTmp->m3uaAspRegistrationPolicy;
	case M3UAASPASSOCIATIONPOLICY:
		*write_method = write_m3uaAspAssociationPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspAssociationPolicy);
		return (uint8_t *) &StorageTmp->m3uaAspAssociationPolicy;
	case M3UAASPSTATUS:
		*write_method = write_m3uaAspStatus;
		*var_len = sizeof(StorageTmp->m3uaAspStatus);
		return (uint8_t *) &StorageTmp->m3uaAspStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspAgTable(): refresh m3uaAspAgTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspAgTable(void)
{
	if (m3uaAspAgTable_refresh == 0)
		return;
	m3uaAspAgTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspAgTable_row(): refresh m3uaAspAgTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspAgTable_row(struct m3uaAspAgTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspAgTable_request == sa_request)
		return;
	StorageTmp->m3uaAspAgTable_request = sa_request;
}

/*
 * var_m3uaAspAgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspAgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspAgTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspAgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspAgTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspAgTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPAGPROTOCOLVERSION:
		*write_method = write_m3uaAspAgProtocolVersion;
		*var_len = StorageTmp->m3uaAspAgProtocolVersionLen;
		return (uint8_t *) StorageTmp->m3uaAspAgProtocolVersion;
	case M3UAASPAGOPTIONS:
		*write_method = write_m3uaAspAgOptions;
		*var_len = StorageTmp->m3uaAspAgOptionsLen;
		return (uint8_t *) StorageTmp->m3uaAspAgOptions;
	case M3UAASPAGREGISTRATIONPOLICY:
		*write_method = write_m3uaAspAgRegistrationPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspAgRegistrationPolicy);
		return (uint8_t *) &StorageTmp->m3uaAspAgRegistrationPolicy;
	case M3UAASPAGASPIDPOLICY:
		*write_method = write_m3uaAspAgAspIdPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspAgAspIdPolicy);
		return (uint8_t *) &StorageTmp->m3uaAspAgAspIdPolicy;
	case M3UAASPAGASPPROTOCOLPAYLOADID:
		*write_method = write_m3uaAspAgAspProtocolPayloadId;
		*var_len = sizeof(StorageTmp->m3uaAspAgAspProtocolPayloadId);
		return (uint8_t *) &StorageTmp->m3uaAspAgAspProtocolPayloadId;
	case M3UAASPAGIPPORT:
		*write_method = write_m3uaAspAgIpPort;
		*var_len = StorageTmp->m3uaAspAgIpPort;
		return (uint8_t *) StorageTmp->m3uaAspAgIpPort;
	case M3UAASPAGMINOSTREAMS:
		*write_method = write_m3uaAspAgMinOstreams;
		*var_len = sizeof(StorageTmp->m3uaAspAgMinOstreams);
		return (uint8_t *) &StorageTmp->m3uaAspAgMinOstreams;
	case M3UAASPAGMAXISTREAMS:
		*write_method = write_m3uaAspAgMaxIstreams;
		*var_len = sizeof(StorageTmp->m3uaAspAgMaxIstreams);
		return (uint8_t *) &StorageTmp->m3uaAspAgMaxIstreams;
	case M3UAASPAGTIMERT7:
		*write_method = write_m3uaAspAgTimerT7;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT7);
		return (uint8_t *) &StorageTmp->m3uaAspAgTimerT7;
	case M3UAASPAGTIMERT19:
		*write_method = write_m3uaAspAgTimerT19;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT19);
		return (uint8_t *) &StorageTmp->m3uaAspAgTimerT19;
	case M3UAASPAGTIMERT21:
		*write_method = write_m3uaAspAgTimerT21;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT21);
		return (uint8_t *) &StorageTmp->m3uaAspAgTimerT21;
	case M3UAASPAGTIMERT25A:
		*write_method = write_m3uaAspAgTimerT25A;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT25A);
		return (uint8_t *) &StorageTmp->m3uaAspAgTimerT25A;
	case M3UAASPAGTIMERT28A:
		*write_method = write_m3uaAspAgTimerT28A;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT28A);
		return (uint8_t *) &StorageTmp->m3uaAspAgTimerT28A;
	case M3UAASPAGTIMERT29A:
		*write_method = write_m3uaAspAgTimerT29A;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT29A);
		return (uint8_t *) &StorageTmp->m3uaAspAgTimerT29A;
	case M3UAASPAGTIMERT30A:
		*write_method = write_m3uaAspAgTimerT30A;
		*var_len = sizeof(StorageTmp->m3uaAspAgTimerT30A);
		return (uint8_t *) &StorageTmp->m3uaAspAgTimerT30A;
	case M3UAASPAGSTATUS:
		*write_method = write_m3uaAspAgStatus;
		*var_len = sizeof(StorageTmp->m3uaAspAgStatus);
		return (uint8_t *) &StorageTmp->m3uaAspAgStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspSgTable(): refresh m3uaAspSgTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspSgTable(void)
{
	if (m3uaAspSgTable_refresh == 0)
		return;
	m3uaAspSgTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspSgTable_row(): refresh m3uaAspSgTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspSgTable_row(struct m3uaAspSgTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspSgTable_request == sa_request)
		return;
	StorageTmp->m3uaAspSgTable_request = sa_request;
}

/*
 * var_m3uaAspSgTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspSgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspSgTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspSgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspSgTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspSgTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPSGNAME:
		*write_method = write_m3uaAspSgName;
		*var_len = StorageTmp->m3uaAspSgNameLen;
		return (uint8_t *) StorageTmp->m3uaAspSgName;
	case M3UAASPSGADMINISTRATIVESTATE:
		*write_method = write_m3uaAspSgAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspSgAdministrativeState);
		return (uint8_t *) &StorageTmp->m3uaAspSgAdministrativeState;
	case M3UAASPSGOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgOperationalState);
		return (uint8_t *) &StorageTmp->m3uaAspSgOperationalState;
	case M3UAASPSGPROCEDUREALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspSgProcedurealStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspSgProcedurealStatus;
	case M3UAASPSGUSGAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgUsgageState);
		return (uint8_t *) &StorageTmp->m3uaAspSgUsgageState;
	case M3UAASPSGASPSTATE:
		*write_method = write_m3uaAspSgAspState;
		*var_len = sizeof(StorageTmp->m3uaAspSgAspState);
		return (uint8_t *) &StorageTmp->m3uaAspSgAspState;
	case M3UAASPSGMAXINITRETRANS:
		*write_method = write_m3uaAspSgMaxInitRetrans;
		*var_len = sizeof(StorageTmp->m3uaAspSgMaxInitRetrans);
		return (uint8_t *) &StorageTmp->m3uaAspSgMaxInitRetrans;
	case M3UAASPSGMAXPATHRETRANS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgMaxPathRetrans);
		return (uint8_t *) &StorageTmp->m3uaAspSgMaxPathRetrans;
	case M3UAASPSGMAXLIFETIME:
		*write_method = write_m3uaAspSgMaxLifeTime;
		*var_len = sizeof(StorageTmp->m3uaAspSgMaxLifeTime);
		return (uint8_t *) &StorageTmp->m3uaAspSgMaxLifeTime;
	case M3UAASPSGTIMERT1:
		*write_method = write_m3uaAspSgTimerT1;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT1);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT1;
	case M3UAASPSGTIMERT2:
		*write_method = write_m3uaAspSgTimerT2;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT2);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT2;
	case M3UAASPSGTIMERT3:
		*write_method = write_m3uaAspSgTimerT3;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT3);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT3;
	case M3UAASPSGTIMERT4:
		*write_method = write_m3uaAspSgTimerT4;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT4);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT4;
	case M3UAASPSGTIMERT5:
		*write_method = write_m3uaAspSgTimerT5;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT5);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT5;
	case M3UAASPSGTIMERT5:
		*write_method = write_m3uaAspSgTimerT5;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT5);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT5;
	case M3UAASPSGTIMERT19A:
		*write_method = write_m3uaAspSgTimerT19A;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT19A);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT19A;
	case M3UAASPSGTIMERT24:
		*write_method = write_m3uaAspSgTimerT24;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT24);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT24;
	case M3UAASPSGTIMERT31A:
		*write_method = write_m3uaAspSgTimerT31A;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT31A);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT31A;
	case M3UAASPSGTIMERT32A:
		*write_method = write_m3uaAspSgTimerT32A;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT32A);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT32A;
	case M3UAASPSGTIMERT33A:
		*write_method = write_m3uaAspSgTimerT33A;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT33A);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT33A;
	case M3UAASPSGTIMERT34A:
		*write_method = write_m3uaAspSgTimerT34A;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT34A);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT34A;
	case M3UAASPSGTIMERT1T:
		*write_method = write_m3uaAspSgTimerT1T;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT1T);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT1T;
	case M3UAASPSGTIMERT2T:
		*write_method = write_m3uaAspSgTimerT2T;
		*var_len = sizeof(StorageTmp->m3uaAspSgTimerT2T);
		return (uint8_t *) &StorageTmp->m3uaAspSgTimerT2T;
	case M3UAASPSGSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgStatus);
		return (uint8_t *) &StorageTmp->m3uaAspSgStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspSgpTable(): refresh m3uaAspSgpTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspSgpTable(void)
{
	if (m3uaAspSgpTable_refresh == 0)
		return;
	m3uaAspSgpTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspSgpTable_row(): refresh m3uaAspSgpTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspSgpTable_row(struct m3uaAspSgpTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspSgpTable_request == sa_request)
		return;
	StorageTmp->m3uaAspSgpTable_request = sa_request;
}

/*
 * var_m3uaAspSgpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspSgpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspSgpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspSgpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspSgpTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspSgpTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPSGPNAME:
		*write_method = write_m3uaAspSgpName;
		*var_len = StorageTmp->m3uaAspSgpNameLen;
		return (uint8_t *) StorageTmp->m3uaAspSgpName;
	case M3UAASPSGPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspSgpAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspSgpAdministrativeState);
		return (uint8_t *) &StorageTmp->m3uaAspSgpAdministrativeState;
	case M3UAASPSGPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspSgpProceduralStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspSgpProceduralStatus;
	case M3UAASPSGPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgpOperationalState);
		return (uint8_t *) &StorageTmp->m3uaAspSgpOperationalState;
	case M3UAASPSGPUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSgpUsageState);
		return (uint8_t *) &StorageTmp->m3uaAspSgpUsageState;
	case M3UAASPSGPASPSTATE:
		*write_method = write_m3uaAspSgpAspState;
		*var_len = sizeof(StorageTmp->m3uaAspSgpAspState);
		return (uint8_t *) &StorageTmp->m3uaAspSgpAspState;
	case M3UAASPSGPPRIMARYADDRESS:
		*write_method = write_m3uaAspSgpPrimaryAddress;
		*var_len = StorageTmp->m3uaAspSgpPrimaryAddressLen;
		return (uint8_t *) StorageTmp->m3uaAspSgpPrimaryAddress;
	case M3UAASPSGPHOSTNAME:
		*write_method = write_m3uaAspSgpHostName;
		*var_len = StorageTmp->m3uaAspSgpHostNameLen;
		return (uint8_t *) StorageTmp->m3uaAspSgpHostName;
	case M3UAASPSGPSTATUS:
		*write_method = write_m3uaAspSgpStatus;
		*var_len = sizeof(StorageTmp->m3uaAspSgpStatus);
		return (uint8_t *) &StorageTmp->m3uaAspSgpStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspSpTable(): refresh m3uaAspSpTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspSpTable(void)
{
	if (m3uaAspSpTable_refresh == 0)
		return;
	m3uaAspSpTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspSpTable_row(): refresh m3uaAspSpTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspSpTable_row(struct m3uaAspSpTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspSpTable_request == sa_request)
		return;
	StorageTmp->m3uaAspSpTable_request = sa_request;
}

/*
 * var_m3uaAspSpTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspSpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspSpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspSpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspSpTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspSpTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPSPNAME:
		*write_method = write_m3uaAspSpName;
		*var_len = StorageTmp->m3uaAspSpNameLen;
		return (uint8_t *) StorageTmp->m3uaAspSpName;
	case M3UAASPSPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSpOperationalState);
		return (uint8_t *) &StorageTmp->m3uaAspSpOperationalState;
	case M3UAASPSPUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspSpUsageState);
		return (uint8_t *) &StorageTmp->m3uaAspSpUsageState;
	case M3UAASPSPADMINISTRATIVESTATE:
		*write_method = write_m3uaAspSpAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspSpAdministrativeState);
		return (uint8_t *) &StorageTmp->m3uaAspSpAdministrativeState;
	case M3UAASPSPALARMSTATUS:
		*write_method = write_m3uaAspSpAlarmStatus;
		*var_len = StorageTmp->m3uaAspSpAlarmStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspSpAlarmStatus;
	case M3UAASPSPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspSpProceduralStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspSpProceduralStatus;
	case M3UAASPSPAVAILABILTYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspSpAvailabiltyStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspSpAvailabiltyStatus;
	case M3UAASPSPPOINTCODE:
		*write_method = write_m3uaAspSpPointCode;
		*var_len = StorageTmp->m3uaAspSpPointCodeLen;
		return (uint8_t *) StorageTmp->m3uaAspSpPointCode;
	case M3UAASPSPTIMERT1R:
		*write_method = write_m3uaAspSpTimerT1R;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT1R);
		return (uint8_t *) &StorageTmp->m3uaAspSpTimerT1R;
	case M3UAASPSPTIMERT18:
		*write_method = write_m3uaAspSpTimerT18;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT18);
		return (uint8_t *) &StorageTmp->m3uaAspSpTimerT18;
	case M3UAASPSPTIMERT20:
		*write_method = write_m3uaAspSpTimerT20;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT20);
		return (uint8_t *) &StorageTmp->m3uaAspSpTimerT20;
	case M3UAASPSPTIMERT22A:
		*write_method = write_m3uaAspSpTimerT22A;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT22A);
		return (uint8_t *) &StorageTmp->m3uaAspSpTimerT22A;
	case M3UAASPSPTIMERT23A:
		*write_method = write_m3uaAspSpTimerT23A;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT23A);
		return (uint8_t *) &StorageTmp->m3uaAspSpTimerT23A;
	case M3UAASPSPTIMERT24A:
		*write_method = write_m3uaAspSpTimerT24A;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT24A);
		return (uint8_t *) &StorageTmp->m3uaAspSpTimerT24A;
	case M3UAASPSPTIMERT26A:
		*write_method = write_m3uaAspSpTimerT26A;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT26A);
		return (uint8_t *) &StorageTmp->m3uaAspSpTimerT26A;
	case M3UAASPSPTIMERT27A:
		*write_method = write_m3uaAspSpTimerT27A;
		*var_len = sizeof(StorageTmp->m3uaAspSpTimerT27A);
		return (uint8_t *) &StorageTmp->m3uaAspSpTimerT27A;
	case M3UAASPSPSTATUS:
		*write_method = write_m3uaAspSpStatus;
		*var_len = sizeof(StorageTmp->m3uaAspSpStatus);
		return (uint8_t *) &StorageTmp->m3uaAspSpStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspMtTable(): refresh m3uaAspMtTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspMtTable(void)
{
	if (m3uaAspMtTable_refresh == 0)
		return;
	m3uaAspMtTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspMtTable_row(): refresh m3uaAspMtTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspMtTable_row(struct m3uaAspMtTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspMtTable_request == sa_request)
		return;
	StorageTmp->m3uaAspMtTable_request = sa_request;
}

/*
 * var_m3uaAspMtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspMtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspMtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspMtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspMtTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspMtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspMtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPMTNAME:
		*write_method = write_m3uaAspMtName;
		*var_len = StorageTmp->m3uaAspMtNameLen;
		return (uint8_t *) StorageTmp->m3uaAspMtName;
	case M3UAASPMTADMINISTRATIVESTATE:
		*write_method = write_m3uaAspMtAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspMtAdministrativeState);
		return (uint8_t *) &StorageTmp->m3uaAspMtAdministrativeState;
	case M3UAASPMTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspMtOperationalState);
		return (uint8_t *) &StorageTmp->m3uaAspMtOperationalState;
	case M3UAASPMTPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspMtProceduralStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspMtProceduralStatus;
	case M3UAASPMTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspMtUsageState);
		return (uint8_t *) &StorageTmp->m3uaAspMtUsageState;
	case M3UAASPMTASSTATE:
		*write_method = write_m3uaAspMtAsState;
		*var_len = sizeof(StorageTmp->m3uaAspMtAsState);
		return (uint8_t *) &StorageTmp->m3uaAspMtAsState;
	case M3UAASPMTSTATUS:
		*write_method = write_m3uaAspMtStatus;
		*var_len = sizeof(StorageTmp->m3uaAspMtStatus);
		return (uint8_t *) &StorageTmp->m3uaAspMtStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspRsTable(): refresh m3uaAspRsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspRsTable(void)
{
	if (m3uaAspRsTable_refresh == 0)
		return;
	m3uaAspRsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspRsTable_row(): refresh m3uaAspRsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspRsTable_row(struct m3uaAspRsTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspRsTable_request == sa_request)
		return;
	StorageTmp->m3uaAspRsTable_request = sa_request;
}

/*
 * var_m3uaAspRsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspRsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspRsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspRsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspRsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspRsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspRsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPRSNAME:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRsNameLen;
		return (uint8_t *) StorageTmp->m3uaAspRsName;
	case M3UAASPRSREMOTEPOINTCODE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRsRemotePointCodeLen;
		return (uint8_t *) StorageTmp->m3uaAspRsRemotePointCode;
	case M3UAASPRSOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsOperationalState);
		return (uint8_t *) &StorageTmp->m3uaAspRsOperationalState;
	case M3UAASPRSADMINISTRATIVESTATE:
		*write_method = write_m3uaAspRsAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspRsAdministrativeState);
		return (uint8_t *) &StorageTmp->m3uaAspRsAdministrativeState;
	case M3UAASPRSUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsUsageState);
		return (uint8_t *) &StorageTmp->m3uaAspRsUsageState;
	case M3UAASPRSALARMSTATUS:
		*write_method = write_m3uaAspRsAlarmStatus;
		*var_len = StorageTmp->m3uaAspRsAlarmStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspRsAlarmStatus;
	case M3UAASPRSPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRsProceduralStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspRsProceduralStatus;
	case M3UAASPRSTIMERT8:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsTimerT8);
		return (uint8_t *) &StorageTmp->m3uaAspRsTimerT8;
	case M3UAASPRSTIMERT11:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsTimerT11);
		return (uint8_t *) &StorageTmp->m3uaAspRsTimerT11;
	case M3UAASPRSTIMERT15:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsTimerT15);
		return (uint8_t *) &StorageTmp->m3uaAspRsTimerT15;
	case M3UAASPRSTIMERT16:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsTimerT16);
		return (uint8_t *) &StorageTmp->m3uaAspRsTimerT16;
	case M3UAASPRSTIMERT18A:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsTimerT18A);
		return (uint8_t *) &StorageTmp->m3uaAspRsTimerT18A;
	case M3UAASPRSOPTIONS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRsOptionsLen;
		return (uint8_t *) StorageTmp->m3uaAspRsOptions;
	case M3UAASPRSAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRsAvailabilityStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspRsAvailabilityStatus;
	case M3UAASPRSCONGESTIONLEVEL:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsCongestionLevel);
		return (uint8_t *) &StorageTmp->m3uaAspRsCongestionLevel;
	case M3UAASPRSSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRsStatus);
		return (uint8_t *) &StorageTmp->m3uaAspRsStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspRlTable(): refresh m3uaAspRlTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspRlTable(void)
{
	if (m3uaAspRlTable_refresh == 0)
		return;
	m3uaAspRlTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspRlTable_row(): refresh m3uaAspRlTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspRlTable_row(struct m3uaAspRlTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspRlTable_request == sa_request)
		return;
	StorageTmp->m3uaAspRlTable_request = sa_request;
}

/*
 * var_m3uaAspRlTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspRlTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspRlTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspRlTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspRlTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspRlTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (uint8_t *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (uint8_t *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (uint8_t *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (uint8_t *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (uint8_t *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (uint8_t *) &StorageTmp->m3uaAspRlCost;
	case M3UAASPRLCOST:
		*write_method = write_m3uaAspRlCost;
		*var_len = sizeof(StorageTmp->m3uaAspRlCost);
		return (uint8_t *) &StorageTmp->m3uaAspRlCost;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspRtTable(): refresh m3uaAspRtTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspRtTable(void)
{
	if (m3uaAspRtTable_refresh == 0)
		return;
	m3uaAspRtTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspRtTable_row(): refresh m3uaAspRtTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspRtTable_row(struct m3uaAspRtTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspRtTable_request == sa_request)
		return;
	StorageTmp->m3uaAspRtTable_request = sa_request;
}

/*
 * var_m3uaAspRtTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspRtTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspRtTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspRtTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspRtTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspRtTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspRtTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPRTCOST:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtCost);
		return (uint8_t *) &StorageTmp->m3uaAspRtCost;
	case M3UAASPRTTIMERT6:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtTimerT6);
		return (uint8_t *) &StorageTmp->m3uaAspRtTimerT6;
	case M3UAASPRTTIMERT10:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtTimerT10);
		return (uint8_t *) &StorageTmp->m3uaAspRtTimerT10;
	case M3UAASPRTAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRtAvailabilityStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspRtAvailabilityStatus;
	case M3UAASPRTADMINSTRATIVESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtAdminstrativeState);
		return (uint8_t *) &StorageTmp->m3uaAspRtAdminstrativeState;
	case M3UAASPRTOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtOperationalState);
		return (uint8_t *) &StorageTmp->m3uaAspRtOperationalState;
	case M3UAASPRTPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspRtProceduralStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspRtProceduralStatus;
	case M3UAASPRTUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtUsageState);
		return (uint8_t *) &StorageTmp->m3uaAspRtUsageState;
	case M3UAASPRTSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspRtStatus);
		return (uint8_t *) &StorageTmp->m3uaAspRtStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspRcTable(): refresh m3uaAspRcTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspRcTable(void)
{
	if (m3uaAspRcTable_refresh == 0)
		return;
	m3uaAspRcTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspRcTable_row(): refresh m3uaAspRcTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspRcTable_row(struct m3uaAspRcTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspRcTable_request == sa_request)
		return;
	StorageTmp->m3uaAspRcTable_request = sa_request;
}

/*
 * var_m3uaAspRcTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspRcTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspRcTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspRcTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspRcTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspRcTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspRcTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPRCVALUE:
		*write_method = write_m3uaAspRcValue;
		*var_len = sizeof(StorageTmp->m3uaAspRcValue);
		return (uint8_t *) &StorageTmp->m3uaAspRcValue;
	case M3UAASPRCREGSTRATIONPOLICY:
		*write_method = write_m3uaAspRcRegstrationPolicy;
		*var_len = sizeof(StorageTmp->m3uaAspRcRegstrationPolicy);
		return (uint8_t *) &StorageTmp->m3uaAspRcRegstrationPolicy;
	case M3UAASPRCTRAFFICMODE:
		*write_method = write_m3uaAspRcTrafficMode;
		*var_len = StorageTmp->m3uaAspRcTrafficModeLen;
		return (uint8_t *) StorageTmp->m3uaAspRcTrafficMode;
	case M3UAASPRCSTATUS:
		*write_method = write_m3uaAspRcStatus;
		*var_len = sizeof(StorageTmp->m3uaAspRcStatus);
		return (uint8_t *) &StorageTmp->m3uaAspRcStatus;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspAsTable(): refresh m3uaAspAsTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspAsTable(void)
{
	if (m3uaAspAsTable_refresh == 0)
		return;
	m3uaAspAsTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspAsTable_row(): refresh m3uaAspAsTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspAsTable_row(struct m3uaAspAsTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspAsTable_request == sa_request)
		return;
	StorageTmp->m3uaAspAsTable_request = sa_request;
}

/*
 * var_m3uaAspAsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspAsTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspAsTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspAsTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspAsTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspAsTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspAsTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPASASSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAsAsState);
		return (uint8_t *) &StorageTmp->m3uaAspAsAsState;
	case M3UAASPASOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAsOperationalState);
		return (uint8_t *) &StorageTmp->m3uaAspAsOperationalState;
	case M3UAASPASPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspAsProceduralStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspAsProceduralStatus;
	case M3UAASPASUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAsUsageState);
		return (uint8_t *) &StorageTmp->m3uaAspAsUsageState;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaAspAfTable(): refresh m3uaAspAfTable
 *
 * Normally the values retrieved from the operating system are cached.
 * When the agent receives a SIGPOLL from an open STREAMS configuration
 * or administrative driver Stream, the STREAMS subsystem indicates to
 * the agent that the cache has been invalidated and that it should
 * reread tables from the STREAMS subsystem.  This function is used when
 * the agent start for the first time, or after a SIGPOLL has been
 * received (and a row or column has been requested).
 */
void
refresh_m3uaAspAfTable(void)
{
	if (m3uaAspAfTable_refresh == 0)
		return;
	m3uaAspAfTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaAspAfTable_row(): refresh m3uaAspAfTable row
 *
 * Normally the values retrieved from the operating system are cached.
 * However, if a row contains temporal values, such as statistics
 * counters, gauges, timestamps, or other transient columns, it may be
 * necessary to refresh the row on some other basis, but normally only
 * once per request.
 */
void
refresh_m3uaAspAfTable_row(struct m3uaAspAfTable_data *StorageTmp)
{
	if (StorageTmp->m3uaAspAfTable_request == sa_request)
		return;
	StorageTmp->m3uaAspAfTable_request = sa_request;
}

/*
 * var_m3uaAspAfTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m3uaAspMIB above.
 */
uint8_t *
var_m3uaAspAfTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaAspAfTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaAspMIB", "var_m3uaAspAfTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaAspAfTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaAspAfTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaAspAfTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	case M3UAASPAFASSTATE:
		*write_method = write_m3uaAspAfAsState;
		*var_len = sizeof(StorageTmp->m3uaAspAfAsState);
		return (uint8_t *) &StorageTmp->m3uaAspAfAsState;
	case M3UAASPAFADMINISTRATIVESTATE:
		*write_method = write_m3uaAspAfAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaAspAfAdministrativeState);
		return (uint8_t *) &StorageTmp->m3uaAspAfAdministrativeState;
	case M3UAASPAFOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAfOperationalState);
		return (uint8_t *) &StorageTmp->m3uaAspAfOperationalState;
	case M3UAASPAFPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaAspAfProceduralStatusLen;
		return (uint8_t *) StorageTmp->m3uaAspAfProceduralStatus;
	case M3UAASPAFUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaAspAfUsageState);
		return (uint8_t *) &StorageTmp->m3uaAspAfUsageState;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_m3uaAspName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspName;
		tmplen = StorageTmp->m3uaAspNameLen;
		memdup((void *) &StorageTmp->m3uaAspName, var_val, var_val_len);
		StorageTmp->m3uaAspNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspName);
		StorageTmp->m3uaAspName = tmpvar;
		StorageTmp->m3uaAspNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspName;
		tmplen = StorageTmp->m3uaAspNameLen;
		memdup((void *) &StorageTmp->m3uaAspName, var_val, var_val_len);
		StorageTmp->m3uaAspNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspName);
		StorageTmp->m3uaAspName = tmpvar;
		StorageTmp->m3uaAspNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAdministrativeState;
		StorageTmp->m3uaAspAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAdministrativeState;
		StorageTmp->m3uaAspAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspCapabilities(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspCapabilities entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspCapabilities not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspCapabilities;
		tmplen = StorageTmp->m3uaAspCapabilitiesLen;
		memdup((void *) &StorageTmp->m3uaAspCapabilities, var_val, var_val_len);
		StorageTmp->m3uaAspCapabilitiesLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspCapabilities);
		StorageTmp->m3uaAspCapabilities = tmpvar;
		StorageTmp->m3uaAspCapabilitiesLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspIdPolicy(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspIdPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspIdPolicy;
		StorageTmp->m3uaAspIdPolicy = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspIdPolicy = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRegistrationPolicy(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRegistrationPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRegistrationPolicy;
		StorageTmp->m3uaAspRegistrationPolicy = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRegistrationPolicy = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAssociationPolicy(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAssociationPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAssociationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAssociationPolicy;
		StorageTmp->m3uaAspAssociationPolicy = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAssociationPolicy = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgProtocolVersion(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgProtocolVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgProtocolVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgProtocolVersion;
		tmplen = StorageTmp->m3uaAspAgProtocolVersionLen;
		memdup((void *) &StorageTmp->m3uaAspAgProtocolVersion, var_val, var_val_len);
		StorageTmp->m3uaAspAgProtocolVersionLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspAgProtocolVersion);
		StorageTmp->m3uaAspAgProtocolVersion = tmpvar;
		StorageTmp->m3uaAspAgProtocolVersionLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgOptions(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgOptions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgOptions;
		tmplen = StorageTmp->m3uaAspAgOptionsLen;
		memdup((void *) &StorageTmp->m3uaAspAgOptions, var_val, var_val_len);
		StorageTmp->m3uaAspAgOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspAgOptions);
		StorageTmp->m3uaAspAgOptions = tmpvar;
		StorageTmp->m3uaAspAgOptionsLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgRegistrationPolicy(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgRegistrationPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgRegistrationPolicy;
		StorageTmp->m3uaAspAgRegistrationPolicy = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgRegistrationPolicy = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgAspIdPolicy(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgAspIdPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgAspIdPolicy;
		StorageTmp->m3uaAspAgAspIdPolicy = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgAspIdPolicy = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgAspProtocolPayloadId(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgAspProtocolPayloadId entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgAspProtocolPayloadId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgAspProtocolPayloadId;
		StorageTmp->m3uaAspAgAspProtocolPayloadId = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgAspProtocolPayloadId = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgIpPort(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgIpPort entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type !=) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgIpPort not \n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in for you to use, and you have
				   just been asked to do something with it.  Note that anything
				   done here must be reversable in the UNDO case */

		break;
	case UNDO:		/* Back out any changes made in the ACTION case */

		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgMinOstreams(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgMinOstreams entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgMinOstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgMinOstreams;
		StorageTmp->m3uaAspAgMinOstreams = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgMinOstreams = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgMaxIstreams(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgMaxIstreams entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgMaxIstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgMaxIstreams;
		StorageTmp->m3uaAspAgMaxIstreams = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgMaxIstreams = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT7(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT7 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgTimerT7;
		StorageTmp->m3uaAspAgTimerT7 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT7 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT19(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT19 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT19 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgTimerT19;
		StorageTmp->m3uaAspAgTimerT19 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT19 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT21(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT21 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT21 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgTimerT21;
		StorageTmp->m3uaAspAgTimerT21 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT21 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT25A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT25A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT25A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgTimerT25A;
		StorageTmp->m3uaAspAgTimerT25A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT25A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT28A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT28A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT28A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgTimerT28A;
		StorageTmp->m3uaAspAgTimerT28A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT28A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT29A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT29A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT29A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgTimerT29A;
		StorageTmp->m3uaAspAgTimerT29A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT29A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgTimerT30A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAgTimerT30A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgTimerT30A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAgTimerT30A;
		StorageTmp->m3uaAspAgTimerT30A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAgTimerT30A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgName;
		tmplen = StorageTmp->m3uaAspSgNameLen;
		memdup((void *) &StorageTmp->m3uaAspSgName, var_val, var_val_len);
		StorageTmp->m3uaAspSgNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspSgName);
		StorageTmp->m3uaAspSgName = tmpvar;
		StorageTmp->m3uaAspSgNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgAdministrativeState;
		StorageTmp->m3uaAspSgAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgAspState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgAspState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgAspState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgAspState;
		StorageTmp->m3uaAspSgAspState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgAspState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgMaxInitRetrans(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgMaxInitRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgMaxInitRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgMaxInitRetrans;
		StorageTmp->m3uaAspSgMaxInitRetrans = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgMaxInitRetrans = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgMaxLifeTime(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgMaxLifeTime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgMaxLifeTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgMaxLifeTime;
		StorageTmp->m3uaAspSgMaxLifeTime = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgMaxLifeTime = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT1(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT1 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT1;
		StorageTmp->m3uaAspSgTimerT1 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT1 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT2(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT2 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT2;
		StorageTmp->m3uaAspSgTimerT2 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT2 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT3(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT3 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT3;
		StorageTmp->m3uaAspSgTimerT3 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT3 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT4(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT4 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT4 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT4;
		StorageTmp->m3uaAspSgTimerT4 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT4 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT5(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT5;
		StorageTmp->m3uaAspSgTimerT5 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT5 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT5(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT5 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT5 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT5;
		StorageTmp->m3uaAspSgTimerT5 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT5 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT19A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT19A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT19A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT19A;
		StorageTmp->m3uaAspSgTimerT19A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT19A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT24(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT24 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT24 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT24;
		StorageTmp->m3uaAspSgTimerT24 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT24 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT31A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT31A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT31A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT31A;
		StorageTmp->m3uaAspSgTimerT31A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT31A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT32A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT32A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT32A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT32A;
		StorageTmp->m3uaAspSgTimerT32A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT32A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT33A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT33A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT33A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT33A;
		StorageTmp->m3uaAspSgTimerT33A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT33A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT34A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT34A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT34A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT34A;
		StorageTmp->m3uaAspSgTimerT34A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT34A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT1T(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT1T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT1T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT1T;
		StorageTmp->m3uaAspSgTimerT1T = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT1T = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgTimerT2T(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgTimerT2T entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgTimerT2T not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgTimerT2T;
		StorageTmp->m3uaAspSgTimerT2T = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgTimerT2T = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgpName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgpName;
		tmplen = StorageTmp->m3uaAspSgpNameLen;
		memdup((void *) &StorageTmp->m3uaAspSgpName, var_val, var_val_len);
		StorageTmp->m3uaAspSgpNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspSgpName);
		StorageTmp->m3uaAspSgpName = tmpvar;
		StorageTmp->m3uaAspSgpNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgpAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgpAdministrativeState;
		StorageTmp->m3uaAspSgpAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgpAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpAspState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgpAspState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpAspState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgpAspState;
		StorageTmp->m3uaAspSgpAspState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSgpAspState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpPrimaryAddress(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgpPrimaryAddress entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpPrimaryAddress not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgpPrimaryAddress;
		tmplen = StorageTmp->m3uaAspSgpPrimaryAddressLen;
		memdup((void *) &StorageTmp->m3uaAspSgpPrimaryAddress, var_val, var_val_len);
		StorageTmp->m3uaAspSgpPrimaryAddressLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspSgpPrimaryAddress);
		StorageTmp->m3uaAspSgpPrimaryAddress = tmpvar;
		StorageTmp->m3uaAspSgpPrimaryAddressLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpHostName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSgpHostName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpHostName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSgpHostName;
		tmplen = StorageTmp->m3uaAspSgpHostNameLen;
		memdup((void *) &StorageTmp->m3uaAspSgpHostName, var_val, var_val_len);
		StorageTmp->m3uaAspSgpHostNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspSgpHostName);
		StorageTmp->m3uaAspSgpHostName = tmpvar;
		StorageTmp->m3uaAspSgpHostNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpName;
		tmplen = StorageTmp->m3uaAspSpNameLen;
		memdup((void *) &StorageTmp->m3uaAspSpName, var_val, var_val_len);
		StorageTmp->m3uaAspSpNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspSpName);
		StorageTmp->m3uaAspSpName = tmpvar;
		StorageTmp->m3uaAspSpNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpAdministrativeState;
		StorageTmp->m3uaAspSpAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpAlarmStatus;
		tmplen = StorageTmp->m3uaAspSpAlarmStatusLen;
		memdup((void *) &StorageTmp->m3uaAspSpAlarmStatus, var_val, var_val_len);
		StorageTmp->m3uaAspSpAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspSpAlarmStatus);
		StorageTmp->m3uaAspSpAlarmStatus = tmpvar;
		StorageTmp->m3uaAspSpAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpPointCode(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpPointCode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpPointCode not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpPointCode;
		tmplen = StorageTmp->m3uaAspSpPointCodeLen;
		memdup((void *) &StorageTmp->m3uaAspSpPointCode, var_val, var_val_len);
		StorageTmp->m3uaAspSpPointCodeLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspSpPointCode);
		StorageTmp->m3uaAspSpPointCode = tmpvar;
		StorageTmp->m3uaAspSpPointCodeLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT1R(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT1R entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT1R not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpTimerT1R;
		StorageTmp->m3uaAspSpTimerT1R = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT1R = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT18(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT18 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT18 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpTimerT18;
		StorageTmp->m3uaAspSpTimerT18 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT18 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT20(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT20 entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT20 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpTimerT20;
		StorageTmp->m3uaAspSpTimerT20 = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT20 = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT22A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT22A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT22A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpTimerT22A;
		StorageTmp->m3uaAspSpTimerT22A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT22A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT23A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT23A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT23A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpTimerT23A;
		StorageTmp->m3uaAspSpTimerT23A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT23A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT24A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT24A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT24A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpTimerT24A;
		StorageTmp->m3uaAspSpTimerT24A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT24A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT26A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT26A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT26A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpTimerT26A;
		StorageTmp->m3uaAspSpTimerT26A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT26A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpTimerT27A(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspSpTimerT27A entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpTimerT27A not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspSpTimerT27A;
		StorageTmp->m3uaAspSpTimerT27A = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspSpTimerT27A = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspMtName(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspMtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspMtName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspMtTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspMtName;
		tmplen = StorageTmp->m3uaAspMtNameLen;
		memdup((void *) &StorageTmp->m3uaAspMtName, var_val, var_val_len);
		StorageTmp->m3uaAspMtNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspMtName);
		StorageTmp->m3uaAspMtName = tmpvar;
		StorageTmp->m3uaAspMtNameLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspMtAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspMtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspMtAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspMtTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspMtAdministrativeState;
		StorageTmp->m3uaAspMtAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspMtAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspMtAsState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspMtTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspMtAsState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspMtTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtAsState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspMtAsState;
		StorageTmp->m3uaAspMtAsState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspMtAsState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRsAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRsAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRsTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRsAdministrativeState;
		StorageTmp->m3uaAspRsAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRsAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRsAlarmStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static char *tmpvar;
	struct m3uaAspRsTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRsAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRsTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRsAlarmStatus;
		tmplen = StorageTmp->m3uaAspRsAlarmStatusLen;
		memdup((void *) &StorageTmp->m3uaAspRsAlarmStatus, var_val, var_val_len);
		StorageTmp->m3uaAspRsAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspRsAlarmStatus);
		StorageTmp->m3uaAspRsAlarmStatus = tmpvar;
		StorageTmp->m3uaAspRsAlarmStatusLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRlCost(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m3uaAspRlTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRlCost entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRlTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRlCost not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRlCost;
		StorageTmp->m3uaAspRlCost = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRlCost = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRcValue(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static uint32_t tmpvar;
	struct m3uaAspRcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRcValue entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRcTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcValue not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in ulong_ret for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRcValue;
		StorageTmp->m3uaAspRcValue = *((ulong *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRcValue = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRcRegstrationPolicy(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspRcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRcRegstrationPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRcTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcRegstrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRcRegstrationPolicy;
		StorageTmp->m3uaAspRcRegstrationPolicy = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspRcRegstrationPolicy = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRcTrafficMode(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static oid *tmpvar;
	struct m3uaAspRcTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspRcTrafficMode entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspRcTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcTrafficMode not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspRcTrafficMode;
		tmplen = StorageTmp->m3uaAspRcTrafficModeLen;
		memdup((void *) &StorageTmp->m3uaAspRcTrafficMode, var_val, var_val_len);
		StorageTmp->m3uaAspRcTrafficModeLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		SNMP_FREE(StorageTmp->m3uaAspRcTrafficMode);
		StorageTmp->m3uaAspRcTrafficMode = tmpvar;
		StorageTmp->m3uaAspRcTrafficModeLen = tmplen;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(tmpvar);
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAfAsState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAfTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAfAsState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAfTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAfAsState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAfAsState;
		StorageTmp->m3uaAspAfAsState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAfAsState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAfAdministrativeState(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	static int32_t tmpvar;
	struct m3uaAspAfTable_data *StorageTmp = NULL;
	static size_t tmplen;
	size_t newlen = name_len - (sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1);

	(void) tmplen;		/* not always used */
	DEBUGMSGTL(("m3uaAspMIB", "write_m3uaAspAfAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaAspAfTableStorage, NULL, &name[sizeof(m3uaAspMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAfAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in long_ret for you to use, and you 
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		tmpvar = StorageTmp->m3uaAspAfAdministrativeState;
		StorageTmp->m3uaAspAfAdministrativeState = *((long *) var_val);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaAspAfAdministrativeState = tmpvar;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */

		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct m3uaAspTable_data *StorageTmp = NULL;
	static struct m3uaAspTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaAspTableStorage, NULL, &name[sizeof(m3uaAspTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(m3uaAspTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(m3uaAspTable_data);
			StorageNew->m3uaAspIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->m3uaAspStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				m3uaAspTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->m3uaAspStatus;
			StorageTmp->m3uaAspStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(m3uaAspTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaAspTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			m3uaAspTable_add(StorageDel);
		} else {
			StorageTmp->m3uaAspStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->m3uaAspStatus == RS_CREATEANDGO) {
				StorageTmp->m3uaAspStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->m3uaAspStatus == RS_CREATEANDWAIT) {
				StorageTmp->m3uaAspStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspAgStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct m3uaAspAgTable_data *StorageTmp = NULL;
	static struct m3uaAspAgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspAgTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaAspAgTableStorage, NULL, &name[sizeof(m3uaAspAgTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspAgStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspAgIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(m3uaAspAgTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(m3uaAspAgTable_data);
			StorageNew->m3uaAspAgIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->m3uaAspAgMinOstreams = 32;

			StorageNew->m3uaAspAgStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				m3uaAspAgTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->m3uaAspAgStatus;
			StorageTmp->m3uaAspAgStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(m3uaAspAgTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspAgTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaAspAgTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspAgTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			m3uaAspAgTable_add(StorageDel);
		} else {
			StorageTmp->m3uaAspAgStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->m3uaAspAgStatus == RS_CREATEANDGO) {
				StorageTmp->m3uaAspAgStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->m3uaAspAgStatus == RS_CREATEANDWAIT) {
				StorageTmp->m3uaAspAgStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct m3uaAspSgTable_data *StorageTmp = NULL;
	static struct m3uaAspSgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspSgTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaAspSgTableStorage, NULL, &name[sizeof(m3uaAspSgTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspAgIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspSgIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(m3uaAspSgTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(m3uaAspSgTable_data);
			StorageNew->m3uaAspAgIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspSgIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->m3uaAspSgAdministrativeState = locked(0);
			StorageNew->m3uaAspSgOperationalState = disabled(0);
			StorageNew->m3uaAspSgUsgageState = idle(0);
			StorageNew->m3uaAspSgMaxInitRetrans = 5;
			StorageNew->m3uaAspSgMaxPathRetrans = 10;
			StorageNew->m3uaAspSgTimerT1 = 80;
			StorageNew->m3uaAspSgTimerT2 = 140;
			StorageNew->m3uaAspSgTimerT3 = 80;
			StorageNew->m3uaAspSgTimerT4 = 80;
			StorageNew->m3uaAspSgTimerT5 = 80;
			StorageNew->m3uaAspSgTimerT5 = 80;
			StorageNew->m3uaAspSgTimerT31A = 1000;
			StorageNew->m3uaAspSgTimerT32A = 6000;
			StorageNew->m3uaAspSgTimerT33A = 6000;
			StorageNew->m3uaAspSgTimerT34A = 500;
			StorageNew->m3uaAspSgTimerT1T = 800;
			StorageNew->m3uaAspSgTimerT2T = 6000;

			StorageNew->m3uaAspSgStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				m3uaAspSgTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->m3uaAspSgStatus;
			StorageTmp->m3uaAspSgStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(m3uaAspSgTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspSgTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaAspSgTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspSgTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			m3uaAspSgTable_add(StorageDel);
		} else {
			StorageTmp->m3uaAspSgStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->m3uaAspSgStatus == RS_CREATEANDGO) {
				StorageTmp->m3uaAspSgStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->m3uaAspSgStatus == RS_CREATEANDWAIT) {
				StorageTmp->m3uaAspSgStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSgpStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct m3uaAspSgpTable_data *StorageTmp = NULL;
	static struct m3uaAspSgpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspSgpTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaAspSgpTableStorage, NULL, &name[sizeof(m3uaAspSgpTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSgpStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspAgIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspSgIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspSgpIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(m3uaAspSgpTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(m3uaAspSgpTable_data);
			StorageNew->m3uaAspAgIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspSgIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspSgpIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->m3uaAspSgpAdministrativeState = locked(0);
			StorageNew->m3uaAspSgpOperationalState = disabled(0);
			StorageNew->m3uaAspSgpUsageState = idle(0);

			StorageNew->m3uaAspSgpStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				m3uaAspSgpTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->m3uaAspSgpStatus;
			StorageTmp->m3uaAspSgpStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(m3uaAspSgpTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspSgpTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaAspSgpTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspSgpTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			m3uaAspSgpTable_add(StorageDel);
		} else {
			StorageTmp->m3uaAspSgpStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->m3uaAspSgpStatus == RS_CREATEANDGO) {
				StorageTmp->m3uaAspSgpStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->m3uaAspSgpStatus == RS_CREATEANDWAIT) {
				StorageTmp->m3uaAspSgpStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspSpStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct m3uaAspSpTable_data *StorageTmp = NULL;
	static struct m3uaAspSpTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspSpTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaAspSpTableStorage, NULL, &name[sizeof(m3uaAspSpTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspSpStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspSpIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(m3uaAspSpTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(m3uaAspSpTable_data);
			StorageNew->m3uaAspSpIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->m3uaAspSpStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				m3uaAspSpTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->m3uaAspSpStatus;
			StorageTmp->m3uaAspSpStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(m3uaAspSpTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspSpTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaAspSpTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspSpTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			m3uaAspSpTable_add(StorageDel);
		} else {
			StorageTmp->m3uaAspSpStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->m3uaAspSpStatus == RS_CREATEANDGO) {
				StorageTmp->m3uaAspSpStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->m3uaAspSpStatus == RS_CREATEANDWAIT) {
				StorageTmp->m3uaAspSpStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspMtStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct m3uaAspMtTable_data *StorageTmp = NULL;
	static struct m3uaAspMtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspMtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaAspMtTableStorage, NULL, &name[sizeof(m3uaAspMtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspMtStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0,, NULL, 0);	/* m3uaAspMtIndex */

			if (header_complex_parse_oid(&(name[sizeof(m3uaAspMtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(m3uaAspMtTable_data);
			StorageNew->m3uaAspSpIndex = *vp->val.integer;
			vp = vp->next_variable;

			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->m3uaAspMtAdministrativeState = locked(0);
			StorageNew->m3uaAspMtOperationalState = disabled(0);
			StorageNew->m3uaAspMtUsageState = idle(0);
			StorageNew->m3uaAspMtAsState = down(0);

			StorageNew->m3uaAspMtStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				m3uaAspMtTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->m3uaAspMtStatus;
			StorageTmp->m3uaAspMtStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(m3uaAspMtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspMtTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaAspMtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspMtTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			m3uaAspMtTable_add(StorageDel);
		} else {
			StorageTmp->m3uaAspMtStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->m3uaAspMtStatus == RS_CREATEANDGO) {
				StorageTmp->m3uaAspMtStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->m3uaAspMtStatus == RS_CREATEANDWAIT) {
				StorageTmp->m3uaAspMtStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRsStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct m3uaAspRsTable_data *StorageTmp = NULL;
	static struct m3uaAspRsTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspRsTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaAspRsTableStorage, NULL, &name[sizeof(m3uaAspRsTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRsStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspRsIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(m3uaAspRsTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(m3uaAspRsTable_data);
			StorageNew->m3uaAspSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspRsIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->m3uaAspRsStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				m3uaAspRsTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->m3uaAspRsStatus;
			StorageTmp->m3uaAspRsStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(m3uaAspRsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspRsTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaAspRsTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspRsTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			m3uaAspRsTable_add(StorageDel);
		} else {
			StorageTmp->m3uaAspRsStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->m3uaAspRsStatus == RS_CREATEANDGO) {
				StorageTmp->m3uaAspRsStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->m3uaAspRsStatus == RS_CREATEANDWAIT) {
				StorageTmp->m3uaAspRsStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRtStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct m3uaAspRtTable_data *StorageTmp = NULL;
	static struct m3uaAspRtTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspRtTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaAspRtTableStorage, NULL, &name[sizeof(m3uaAspRtTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRtStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspRsIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspAgIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspSgIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(m3uaAspRtTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(m3uaAspRtTable_data);
			StorageNew->m3uaAspSpIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspRsIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspAgIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspSgIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */
			StorageNew->m3uaAspRtTimerT6 = 80;
			StorageNew->m3uaAspRtTimerT10 = 6000;

			StorageNew->m3uaAspRtStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				m3uaAspRtTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->m3uaAspRtStatus;
			StorageTmp->m3uaAspRtStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(m3uaAspRtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspRtTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaAspRtTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspRtTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			m3uaAspRtTable_add(StorageDel);
		} else {
			StorageTmp->m3uaAspRtStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->m3uaAspRtStatus == RS_CREATEANDGO) {
				StorageTmp->m3uaAspRtStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->m3uaAspRtStatus == RS_CREATEANDWAIT) {
				StorageTmp->m3uaAspRtStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaAspRcStatus(int action, uint8_t *var_val, uint8_t var_val_type, size_t var_val_len, uint8_t *statP, oid * name, size_t name_len)
{
	struct m3uaAspRcTable_data *StorageTmp = NULL;
	static struct m3uaAspRcTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaAspRcTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaAspRcTableStorage, NULL, &name[sizeof(m3uaAspRcTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaAspRcStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((int *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		if (StorageTmp == NULL) {
			/* create the row now? */
			/* ditch illegal values now */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE)
				return SNMP_ERR_INCONSISTENTVALUE;
			/* destroying a non-existent row is actually legal */
			if (set_value == RS_DESTROY) {
				return SNMP_ERR_NOERROR;
			}
			/* illegal creation values */
			if (set_value == RS_ACTIVE || set_value == RS_NOTINSERVICE) {
				return SNMP_ERR_INCONSISTENTVALUE;
			}
		} else {
			/* row exists.  Check for a valid state change */
			if (set_value == RS_CREATEANDGO || set_value == RS_CREATEANDWAIT) {
				/* can't create a row that exists */
				return SNMP_ERR_INCONSISTENTVALUE;
			}
			/* XXX: interaction with row storage type needed */
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		if (StorageTmp == NULL) {
			/* creation */
			vars = NULL;
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspSpIndex 
												 */
			snmp_varlist_add_variable(&vars, NULL, 0,, NULL, 0);	/* m3uaAspMtIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);	/* m3uaAspAgIndex 
												 */

			if (header_complex_parse_oid(&(name[sizeof(m3uaAspRcTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			StorageNew = SNMP_MALLOC_STRUCT(m3uaAspRcTable_data);
			StorageNew->m3uaAspIndex = *vp->val.integer;
			vp = vp->next_variable;
			StorageNew->m3uaAspSpIndex = *vp->val.integer;
			vp = vp->next_variable;

			vp = vp->next_variable;
			StorageNew->m3uaAspAgIndex = *vp->val.integer;
			vp = vp->next_variable;

			/* XXX: fill in default row values here into StorageNew */

			StorageNew->m3uaAspRcStatus = set_value;
			/* XXX: free, zero vars, no longer needed? */
		}
		break;
	case FREE:
		/* XXX: free, zero vars */
		/* Release any resources that have been allocated */
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		if (StorageTmp == NULL) {
			/* row creation, so add it */
			if (StorageNew != NULL)
				m3uaAspRcTable_add(StorageNew);
			/* XXX: ack, and if it is NULL? */
		} else if (set_value != RS_DESTROY) {
			/* set the flag? */
			old_value = StorageTmp->m3uaAspRcStatus;
			StorageTmp->m3uaAspRcStatus = *((int *) var_val);
		} else {
			/* destroy...  extract it for now */
			hciptr = header_complex_find_entry(m3uaAspRcTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspRcTableStorage, hciptr);
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		if (StorageTmp == NULL) {
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaAspRcTableStorage, StorageTmp);
			StorageDel = header_complex_extract_entry(&m3uaAspRcTableStorage, hciptr);
			/* XXX: free it */
		} else if (StorageDel != NULL) {
			/* row deletion, so add it again */
			m3uaAspRcTable_add(StorageDel);
		} else {
			StorageTmp->m3uaAspRcStatus = old_value;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		if (StorageDel != NULL) {
			StorageDel = 0;
			/* XXX: free it, its dead */
		} else {
			if (StorageTmp && StorageTmp->m3uaAspRcStatus == RS_CREATEANDGO) {
				StorageTmp->m3uaAspRcStatus = RS_ACTIVE;
			} else if (StorageTmp && StorageTmp->m3uaAspRcStatus == RS_CREATEANDWAIT) {
				StorageTmp->m3uaAspRcStatus = RS_NOTINSERVICE;
			}
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
