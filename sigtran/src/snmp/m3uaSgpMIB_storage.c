/* This file was generated by mib2c and is intended for use as
   a mib module for the ucd-snmp snmpd agent. */
#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>
#include <ucd-snmp/callback.h>
#include <ucd-snmp/snmp-tc.h>
#include <ucd-snmp/default_store.h>
#include <ucd-snmp/snmp_alarm.h>
/* The following header files are mangled in most recent net-snmp releases so
 * the versions from UCD-SNMP 4.2.5 are included here.  */
#if defined HAVE_LIBNETSNMP
#else				/* defined HAVE_LIBNETSNMP */
#endif				/* defined HAVE_LIBNETSNMP */
/* These are messed up on both. */
#include "ds_agent.h"
#ifdef HAVE_UCD_SNMP_UTIL_FUNCS_H
#include <ucd-snmp/util_funcs.h>
/* Many recent net-snmp UCD compatible headers do not declard header_generic. */
int header_generic(struct variable *, oid *, size_t *, int, size_t *, WriteMethod **);
#else				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#include "util_funcs.h"
#endif				/* HAVE_UCD_SNMP_UTIL_FUNCS_H */
#ifdef HAVE_UCD_SNMP_HEADER_COMPLEX_H
#include <ucd-snmp/header_complex.h>
#else				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
#include "header_complex.h"
#endif				/* HAVE_UCD_SNMP_HEADER_COMPLEX_H */
/* This one is the other way around: it is just fine for net-snmp, but
 * ucd-snmp does not provide the header file at all.  */
#ifdef HAVE_UCD_SNMP_MIB_MODULES_H
#include <ucd-snmp/mib_modules.h>
#else				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#ifdef HAVE_NET_SNMP_AGENT_MIB_MODULES_H
#include <net-snmp/agent/mib_modules.h>
#else				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#include "mib_modules.h"
#endif				/* HAVE_NET_SNMP_AGENT_MIB_MODULES_H */
#endif				/* HAVE_UCD_SNMP_MIB_MODULES_H */
#include <stdint.h>
#include <signal.h>
#include <sys/stat.h>		/* for struct stat, fstat() */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <pwd.h>		/* for getpwuid() getpwnam() */
#include <grp.h>		/* for getgrgid() getgrnam() */
#include <libgen.h>		/* for basename() */
#include <fcntl.h>		/* for O_CREAT */
#include <sys/sysctl.h>		/* for sysctl */
#include <errno.h>
#include <string.h>
#ifdef _GNU_SOURCE
#include <getopt.h>
#endif
#include "m3uaSgpMIB_storage.h"
extern const char sa_program[];

#define MY_FACILITY(__pri)	(LOG_DAEMON|(__pri))
#if !defined MODULE
extern int sa_dump;			/* default packet dump */
extern int sa_debug;			/* default no debug */
extern int sa_nomead;			/* default daemon mode */
extern int sa_output;			/* default normal output */
extern int sa_agentx;			/* default agentx mode */
extern int sa_alarms;			/* default application alarms */
extern int sa_fclose;			/* default close files between requests */
extern int sa_logaddr;			/* log addresses */
extern int sa_logfillog;		/* log to sa_logfile */
extern int sa_logstderr;		/* log to standard error */
extern int sa_logstdout;		/* log to standard output */
extern int sa_logsyslog;		/* log to system logs */
extern int sa_logcallog;		/* log to callback logs */
extern int sa_appendlog;		/* append to log file without truncating */
extern char sa_logfile[256];
extern char sa_pidfile[256];
extern char sa_sysctlf[256];

/* file stream for log file */
extern FILE *stdlog;

/* file descriptor for MIB use */
extern int sa_fd;

/* indication to reread MIB configuration */
extern int sa_changed;

/* indications that statistics, the mib or its tables need to be refreshed */
extern int sa_stats_refresh;
#endif				/* !defined MODULE */
/* request number for per-request actions */
extern int sa_request;
volatile int m3uaSgpMIB_refresh = 1;
volatile int m3uaSgpAgTable_refresh = 1;
volatile int m3uaSgpSgTable_refresh = 1;
volatile int m3uaSgpAspTable_refresh = 1;
volatile int m3uaSgpTable_refresh = 1;

/*
 * m3uaSgpMIB_variables_oid: object identifier for m3uaSgpMIB
 * This is the top level oid that we want to register under.  This is essentially a prefix, with the
 * suffix appearing in the variable below.
 */
oid m3uaSgpMIB_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 321 };
oid m3uaSgpAgTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 321, 1, 2, 1, 2, 1 };
oid m3uaSgpSgTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 321, 1, 2, 2, 1, 1 };
oid m3uaSgpAspTable_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 321, 1, 2, 4, 1, 1 };

/*
 * variable7 m3uaSgpMIB_variables: tree for m3uaSgpMIB
 * This variable defines function callbacks and type return information for the m3uaSgpMIB mib section
 */
struct variable7 m3uaSgpMIB_variables[] = {
	/* magic number, variable type, ro/rw, callback fn, L, oidsuffix */
#define   M3UASGPAGNEXTINDEX    (1 % 256)
	{M3UASGPAGNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaSgpMIB, 4, {1, 2, 1, 1}},
#define   M3UASGPAGNAME         (5 % 256)
	{M3UASGPAGNAME, ASN_OCTET_STR, RWRITE, var_m3uaSgpAgTable, 6, {1, 2, 1, 2, 1, 2}},
#define   M3UASGPAGPROTOCOLVERSION  (6 % 256)
	{M3UASGPAGPROTOCOLVERSION, ASN_OBJECT_ID, RWRITE, var_m3uaSgpAgTable, 6, {1, 2, 1, 2, 1, 3}},
#define   M3UASGPAGOPTIONS      (7 % 256)
	{M3UASGPAGOPTIONS, ASN_BIT_STR, RWRITE, var_m3uaSgpAgTable, 6, {1, 2, 1, 2, 1, 4}},
#define   M3UASGPAGREGISTRATIONPOLICY  (8 % 256)
	{M3UASGPAGREGISTRATIONPOLICY, ASN_INTEGER, RWRITE, var_m3uaSgpAgTable, 6, {1, 2, 1, 2, 1, 5}},
#define   M3UASGPAGASPIDPOLICY  (9 % 256)
	{M3UASGPAGASPIDPOLICY, ASN_INTEGER, RWRITE, var_m3uaSgpAgTable, 6, {1, 2, 1, 2, 1, 6}},
#define   M3UASGPAGPROTOCOLPAYLOADID  (10 % 256)
	{M3UASGPAGPROTOCOLPAYLOADID, ASN_INTEGER, RWRITE, var_m3uaSgpAgTable, 6, {1, 2, 1, 2, 1, 7}},
#define   M3UASGPAGIPPORT       (11 % 256)
	{M3UASGPAGIPPORT, ASN_INTEGER, RWRITE, var_m3uaSgpAgTable, 6, {1, 2, 1, 2, 1, 8}},
#define   M3UASGPAGMINOSTREAMS  (12 % 256)
	{M3UASGPAGMINOSTREAMS, ASN_INTEGER, RWRITE, var_m3uaSgpAgTable, 6, {1, 2, 1, 2, 1, 9}},
#define   M3UASGPAGMAXISTREAMS  (13 % 256)
	{M3UASGPAGMAXISTREAMS, ASN_INTEGER, RWRITE, var_m3uaSgpAgTable, 6, {1, 2, 1, 2, 1, 10}},
#define   M3UASGPAGSTATUS       (14 % 256)
	{M3UASGPAGSTATUS, ASN_INTEGER, RWRITE, var_m3uaSgpAgTable, 6, {1, 2, 1, 2, 1, 11}},
#define   M3UASGPSGNAME         (19 % 256)
	{M3UASGPSGNAME, ASN_OCTET_STR, RWRITE, var_m3uaSgpSgTable, 6, {1, 2, 2, 1, 1, 2}},
#define   M3UASGPSGSTATUS       (20 % 256)
	{M3UASGPSGSTATUS, ASN_INTEGER, RWRITE, var_m3uaSgpSgTable, 6, {1, 2, 2, 1, 1, 3}},
#define   M3UASGPSCTPPROFILENEXTINDEX  (21 % 256)
	{M3UASGPSCTPPROFILENEXTINDEX,, RONLY, var_m3uaSgpMIB, 4, {1, 2, 3, 1}},
#define   M3UASGPSCTPPROFILETABLE  (22 % 256)
	{M3UASGPSCTPPROFILETABLE,, RONLY, var_m3uaSgpMIB, 4, {1, 2, 3, 2}},
#define   M3UASGPASPNAME        (26 % 256)
	{M3UASGPASPNAME, ASN_OCTET_STR, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 2}},
#define   M3UASGPASPOPERATIONALSTATE  (27 % 256)
	{M3UASGPASPOPERATIONALSTATE, ASN_INTEGER, RONLY, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 3}},
#define   M3UASGPASPUSAGESTATE  (28 % 256)
	{M3UASGPASPUSAGESTATE, ASN_INTEGER, RONLY, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 4}},
#define   M3UASGPASPADMINISTRATIVESTATE  (29 % 256)
	{M3UASGPASPADMINISTRATIVESTATE, ASN_INTEGER, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 5}},
#define   M3UASGPASPALARMSTATUS  (30 % 256)
	{M3UASGPASPALARMSTATUS, ASN_BIT_STR, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 6}},
#define   M3UASGPASPPROCEDURALSTATUS  (31 % 256)
	{M3UASGPASPPROCEDURALSTATUS, ASN_BIT_STR, RONLY, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 7}},
#define   M3UASGPASPAVAILABILITYSTATUS  (32 % 256)
	{M3UASGPASPAVAILABILITYSTATUS, ASN_BIT_STR, RONLY, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 8}},
#define   M3UASGPASPASPSTATE    (33 % 256)
	{M3UASGPASPASPSTATE, ASN_INTEGER, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 9}},
#define   M3UASGPASPSCTPPROFILE  (34 % 256)
	{M3UASGPASPSCTPPROFILE, ASN_OBJECT_ID, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 10}},
#define   M3UASGPASPSCTPPROFILE  (35 % 256)
	{M3UASGPASPSCTPPROFILE, ASN_OBJECT_ID, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 10}},
#define   M3UASGPASPMAXPATHRETRANS  (36 % 256)
	{M3UASGPASPMAXPATHRETRANS, ASN_UNSIGNED, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 11}},
#define   M3UASGPASPRTOMIN      (37 % 256)
	{M3UASGPASPRTOMIN, ASN_INTEGER, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 12}},
#define   M3UASGPASPRTOMIN      (38 % 256)
	{M3UASGPASPRTOMIN, ASN_INTEGER, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 12}},
#define   M3UASGPASPRTOMIN      (39 % 256)
	{M3UASGPASPRTOMIN, ASN_INTEGER, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 12}},
#define   M3UASGPASPMAXLIFETIME  (40 % 256)
	{M3UASGPASPMAXLIFETIME, ASN_INTEGER, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 13}},
#define   M3UASGPASPTIMERDIVERT  (41 % 256)
	{M3UASGPASPTIMERDIVERT, ASN_INTEGER, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 14}},
#define   M3UASGPASPSTATUS      (42 % 256)
	{M3UASGPASPSTATUS, ASN_INTEGER, RWRITE, var_m3uaSgpAspTable, 6, {1, 2, 4, 1, 1, 15}},
#define   M3UASGPNEXTINDEX      (43 % 256)
	{M3UASGPNEXTINDEX, ASN_UNSIGNED, RONLY, var_m3uaSgpMIB, 4, {1, 2, 5, 1}},
};

/* (L = length of the oidsuffix) */
struct m3uaSgpMIB_data *m3uaSgpMIBStorage = NULL;

/* global storage of our data, saved in and configured by header_complex() */
struct header_complex_index *m3uaSgpAgTableStorage = NULL;
struct header_complex_index *m3uaSgpSgTableStorage = NULL;
struct header_complex_index *m3uaSgpAspTableStorage = NULL;
struct header_complex_index *m3uaSgpTableStorage = NULL;

/*
 * init_m3uaSgpMIB(): Initialization routine.
 * This is called when the agent starts up.  At a minimum, registration of your variables should
 * take place here.
 */
void
init_m3uaSgpMIB(void)
{
	DEBUGMSGTL(("m3uaSgpMIB", "initializing...  "));
	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("m3uaSgpMIB", m3uaSgpMIB_variables, variable7, m3uaSgpMIB_variables_oid);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_SHUTDOWN, term_m3uaSgpMIB, NULL);
	/* register our config handler(s) to deal with registrations */
	snmpd_register_config_handler("m3uaSgpMIB", parse_m3uaSgpMIB, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaSgpAgTable", parse_m3uaSgpAgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaSgpSgTable", parse_m3uaSgpSgTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaSgpAspTable", parse_m3uaSgpAspTable, NULL, "HELP STRING");
	snmpd_register_config_handler("m3uaSgpTable", parse_m3uaSgpTable, NULL, "HELP STRING");

	/* we need to be called back later to store our data */
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaSgpMIB, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaSgpAgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaSgpSgTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaSgpAspTable, NULL);
	snmp_register_callback(SNMP_CALLBACK_LIBRARY, SNMP_CALLBACK_STORE_DATA, store_m3uaSgpTable, NULL);

	/* place any other initialization junk you need here */
	DEBUGMSGTL(("m3uaSgpMIB", "done.\n"));
}

/*
 * deinit_m3uaSgpMIB(): Deinitialization routine.
 * This is called before the agent is unloaded.  At a minimum, deregistration of your variables
 * should take place here.
 */
void
deinit_m3uaSgpMIB(void)
{
	DEBUGMSGTL(("m3uaSgpMIB", "deinitializating...  "));
	unregister_mib(m3uaSgpMIB_variables_oid, sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid));
	snmpd_unregister_config_handler("m3uaSgpMIB");
	snmpd_unregister_config_handler("m3uaSgpAgTable");
	snmpd_unregister_config_handler("m3uaSgpSgTable");
	snmpd_unregister_config_handler("m3uaSgpAspTable");
	snmpd_unregister_config_handler("m3uaSgpTable");

	/* place any other de-initialization junk you need here */
	DEBUGMSGTL(("m3uaSgpMIB", "done.\n"));
}

int
term_m3uaSgpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	deinit_m3uaSgpMIB();
	return 0;
}

/*
 * m3uaSgpMIB_add(): adds a structure node for scalars
 */
int
m3uaSgpMIB_add(struct m3uaSgpMIB_data *thedata)
{
	DEBUGMSGTL(("m3uaSgpMIB", "adding data...  "));
	m3uaSgpMIBStorage = thedata;
	DEBUGMSGTL(("m3uaSgpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaSgpMIB(): parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaSgpMIB(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaSgpMIB_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaSgpMIB_data);

	DEBUGMSGTL(("m3uaSgpMIB", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaSgpAgNextIndex, &tmpsize);
	line = read_config_read_data(, line, &StorageTmp->m3uaSgpSctpProfileNextIndex, &tmpsize);
	line = read_config_read_data(, line, &StorageTmp->m3uaSgpSctpProfileTable, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaSgpNextIndex, &tmpsize);
	m3uaSgpMIB_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaSgpMIB", "done.\n"));
}

/*
 * store_m3uaSgpMIB(): stores .conf file entries needed to configure the mib.
 */
int
store_m3uaSgpMIB(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaSgpMIB_data *StorageTmp;

	DEBUGMSGTL(("m3uaSgpMIB", "storing data...  "));
	refresh_m3uaSgpMIB();
	if ((StorageTmp = m3uaSgpMIBStorage) == NULL) {
		DEBUGMSGTL(("m3uaSgpMIB", "error.\n"));
		return SNMPERR_GENERR;
	}
	(void) tmpsize;
	/* XXX: if (StorageTmp->m3uaSgpMIBStorageType == ST_NONVOLATILE) */
	{
		memset(line, 0, sizeof(line));
		strcat(line, "m3uaSgpMIB ");
		cptr = line + strlen(line);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaSgpAgNextIndex, &tmpsize);
		cptr = read_config_store_data(, cptr, &StorageTmp->m3uaSgpSctpProfileNextIndex, &tmpsize);
		cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaSgpNextIndex, &tmpsize);
		snmpd_store_config(line);
	}
	DEBUGMSGTL(("m3uaSgpMIB", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_m3uaSgpMIB: refresh m3uaSgpMIB scalars
 *
 * Normally, the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread scalars and
 * tables from the STREAMS susbystem.  This function is used when the agent starts for the first
 * time, or after a SIGPOLL has been received (and a scalar has been requested).
 */
void
refresh_m3uaSgpMIB(void)
{
	if (m3uaSgpMIBStorage == NULL) {
		struct m3uaSgpMIB_data *StorageNew;

		if ((StorageNew = SNMP_MALLOC_STRUCT(m3uaSgpMIB_data)) == NULL)
			return;
		/* Update scalar defaults as required here... */
		m3uaSgpMIBStorage = StorageNew;
		m3uaSgpMIB_refresh = 1;
	}
	if (m3uaSgpMIB_refresh == 0)
		return;
	m3uaSgpMIB_refresh = 0;
	/* Update scalars as required here... */
}

/*
 * var_m3uaSgpMIB(): locate variables in m3uaSgpMIB
 *
 * This function is called every time the agent gets a request for a scalar variable that might be
 * found within your mib section registered above.  It is up to you to do the right thing and return
 * the correct value.  You should also correct the value of "var_len" if necessary.
 *
 * Please see the documentation for more information about writing module extensions, and check out
 * the examples in the examples and mibII directories.
 */
u_char *
var_m3uaSgpMIB(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaSgpMIB_data *StorageTmp;

	if (header_generic(vp, name, length, exact, var_len, write_method) == MATCH_FAILED)
		return NULL;
	/* Refresh the MIB values if required. */
	refresh_m3uaSgpMIB();
	if ((StorageTmp = m3uaSgpMIBStorage) == NULL)
		return NULL;
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UASGPAGNEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaSgpAgNextIndex);
		return (u_char *) &StorageTmp->m3uaSgpAgNextIndex;
	case M3UASGPSCTPPROFILENEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaSgpSctpProfileNextIndex;
		return (u_char *) StorageTmp->m3uaSgpSctpProfileNextIndex;
	case M3UASGPSCTPPROFILETABLE:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaSgpSctpProfileTable;
		return (u_char *) StorageTmp->m3uaSgpSctpProfileTable;
	case M3UASGPNEXTINDEX:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaSgpNextIndex);
		return (u_char *) &StorageTmp->m3uaSgpNextIndex;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * m3uaSgpAgTable_add(): adds a structure node to our data set
 */
int
m3uaSgpAgTable_add(struct m3uaSgpAgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaSgpAgTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaSgpAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaSgpAgIndex, sizeof(thedata->m3uaSgpAgIndex));
	header_complex_add_data(&m3uaSgpAgTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaSgpAgTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaSgpAgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaSgpAgTable_del(): delete a structure
 */
int
m3uaSgpAgTable_del(struct m3uaSgpAgTable_data **thedata)
{
	struct m3uaSgpAgTable_data *StorageDel;

	DEBUGMSGTL(("m3uaSgpAgTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaSgpAgName);
		StorageDel->m3uaSgpAgNameLen = 0;
		SNMP_FREE(StorageDel->m3uaSgpAgProtocolVersion);
		StorageDel->m3uaSgpAgProtocolVersionLen = 0;
		SNMP_FREE(StorageDel->m3uaSgpAgOptions);
		StorageDel->m3uaSgpAgOptionsLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaSgpAgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaSgpAgTable(): parse configuration file for m3uaSgpAgTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaSgpAgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaSgpAgTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaSgpAgTable_data);

	DEBUGMSGTL(("m3uaSgpAgTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaSgpAgIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaSgpAgName, &tmpsize);
	StorageTmp->m3uaSgpAgNameLen = tmpsize;
	if (StorageTmp->m3uaSgpAgName == NULL) {
		config_perror("invalid specification for m3uaSgpAgName");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->m3uaSgpAgProtocolVersion, &tmpsize);
	StorageTmp->m3uaSgpAgProtocolVersionLen = tmpsize;
	if (StorageTmp->m3uaSgpAgProtocolVersion == NULL) {
		config_perror("invalid specification for m3uaSgpAgProtocolVersion");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaSgpAgOptions, &tmpsize);
	StorageTmp->m3uaSgpAgOptionsLen = tmpsize;
	if (StorageTmp->m3uaSgpAgOptions == NULL) {
		config_perror("invalid specification for m3uaSgpAgOptions");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAgRegistrationPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAgAspIdPolicy, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAgProtocolPayloadId, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAgIpPort, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAgMinOstreams, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAgMaxIstreams, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAgStatus, &tmpsize);
	m3uaSgpAgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaSgpAgTable", "done.\n"));
}

/*
 * store_m3uaSgpAgTable(): store configuraiton file for m3uaSgpAgTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaSgpAgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaSgpAgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaSgpAgTable", "storing data...  "));
	refresh_m3uaSgpAgTable();
	(void) tmpsize;
	for (hcindex = m3uaSgpAgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaSgpAgTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->m3uaSgpAgTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaSgpAgTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaSgpAgIndex, &tmpsize);
			tmpsize = StorageTmp->m3uaSgpAgNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaSgpAgName, &tmpsize);
			tmpsize = StorageTmp->m3uaSgpAgProtocolVersionLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->m3uaSgpAgProtocolVersion, &tmpsize);
			tmpsize = StorageTmp->m3uaSgpAgOptionsLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaSgpAgOptions, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAgRegistrationPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAgAspIdPolicy, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAgProtocolPayloadId, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAgIpPort, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAgMinOstreams, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAgMaxIstreams, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAgStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaSgpAgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaSgpSgTable_add(): adds a structure node to our data set
 */
int
m3uaSgpSgTable_add(struct m3uaSgpSgTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaSgpSgTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaSgpAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaSgpAgIndex, sizeof(thedata->m3uaSgpAgIndex));
	header_complex_add_data(&m3uaSgpSgTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaSgpSgTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaSgpSgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaSgpSgTable_del(): delete a structure
 */
int
m3uaSgpSgTable_del(struct m3uaSgpSgTable_data **thedata)
{
	struct m3uaSgpSgTable_data *StorageDel;

	DEBUGMSGTL(("m3uaSgpSgTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaSgpSgName);
		StorageDel->m3uaSgpSgNameLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaSgpSgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaSgpSgTable(): parse configuration file for m3uaSgpSgTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaSgpSgTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaSgpSgTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaSgpSgTable_data);

	DEBUGMSGTL(("m3uaSgpSgTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaSgpAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaSgpSgIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaSgpSgName, &tmpsize);
	StorageTmp->m3uaSgpSgNameLen = tmpsize;
	if (StorageTmp->m3uaSgpSgName == NULL) {
		config_perror("invalid specification for m3uaSgpSgName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpSgStatus, &tmpsize);
	m3uaSgpSgTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaSgpSgTable", "done.\n"));
}

/*
 * store_m3uaSgpSgTable(): store configuraiton file for m3uaSgpSgTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaSgpSgTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaSgpSgTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaSgpSgTable", "storing data...  "));
	refresh_m3uaSgpSgTable();
	(void) tmpsize;
	for (hcindex = m3uaSgpSgTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaSgpSgTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->m3uaSgpSgTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaSgpSgTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaSgpAgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaSgpSgIndex, &tmpsize);
			tmpsize = StorageTmp->m3uaSgpSgNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaSgpSgName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpSgStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaSgpSgTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaSgpAspTable_add(): adds a structure node to our data set
 */
int
m3uaSgpAspTable_add(struct m3uaSgpAspTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaSgpAspTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaSgpAspIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaSgpAspIndex, sizeof(thedata->m3uaSgpAspIndex));
	header_complex_add_data(&m3uaSgpAspTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaSgpAspTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaSgpAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaSgpAspTable_del(): delete a structure
 */
int
m3uaSgpAspTable_del(struct m3uaSgpAspTable_data **thedata)
{
	struct m3uaSgpAspTable_data *StorageDel;

	DEBUGMSGTL(("m3uaSgpAspTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {
		SNMP_FREE(StorageDel->m3uaSgpAspName);
		StorageDel->m3uaSgpAspNameLen = 0;
		SNMP_FREE(StorageDel->m3uaSgpAspAlarmStatus);
		StorageDel->m3uaSgpAspAlarmStatusLen = 0;
		SNMP_FREE(StorageDel->m3uaSgpAspProceduralStatus);
		StorageDel->m3uaSgpAspProceduralStatusLen = 0;
		SNMP_FREE(StorageDel->m3uaSgpAspAvailabilityStatus);
		StorageDel->m3uaSgpAspAvailabilityStatusLen = 0;
		SNMP_FREE(StorageDel->m3uaSgpAspSctpProfile);
		StorageDel->m3uaSgpAspSctpProfileLen = 0;
		SNMP_FREE(StorageDel->m3uaSgpAspSctpProfile);
		StorageDel->m3uaSgpAspSctpProfileLen = 0;
		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaSgpAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaSgpAspTable(): parse configuration file for m3uaSgpAspTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaSgpAspTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaSgpAspTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaSgpAspTable_data);

	DEBUGMSGTL(("m3uaSgpAspTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaSgpAspIndex, &tmpsize);
	line = read_config_read_data(ASN_OCTET_STR, line, &StorageTmp->m3uaSgpAspName, &tmpsize);
	StorageTmp->m3uaSgpAspNameLen = tmpsize;
	if (StorageTmp->m3uaSgpAspName == NULL) {
		config_perror("invalid specification for m3uaSgpAspName");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAspOperationalState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAspUsageState, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAspAdministrativeState, &tmpsize);
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaSgpAspAlarmStatus, &tmpsize);
	StorageTmp->m3uaSgpAspAlarmStatusLen = tmpsize;
	if (StorageTmp->m3uaSgpAspAlarmStatus == NULL) {
		config_perror("invalid specification for m3uaSgpAspAlarmStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaSgpAspProceduralStatus, &tmpsize);
	StorageTmp->m3uaSgpAspProceduralStatusLen = tmpsize;
	if (StorageTmp->m3uaSgpAspProceduralStatus == NULL) {
		config_perror("invalid specification for m3uaSgpAspProceduralStatus");
		return;
	}
	line = read_config_read_data(ASN_BIT_STR, line, &StorageTmp->m3uaSgpAspAvailabilityStatus, &tmpsize);
	StorageTmp->m3uaSgpAspAvailabilityStatusLen = tmpsize;
	if (StorageTmp->m3uaSgpAspAvailabilityStatus == NULL) {
		config_perror("invalid specification for m3uaSgpAspAvailabilityStatus");
		return;
	}
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAspAspState, &tmpsize);
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->m3uaSgpAspSctpProfile, &tmpsize);
	StorageTmp->m3uaSgpAspSctpProfileLen = tmpsize;
	if (StorageTmp->m3uaSgpAspSctpProfile == NULL) {
		config_perror("invalid specification for m3uaSgpAspSctpProfile");
		return;
	}
	line = read_config_read_data(ASN_OBJECT_ID, line, &StorageTmp->m3uaSgpAspSctpProfile, &tmpsize);
	StorageTmp->m3uaSgpAspSctpProfileLen = tmpsize;
	if (StorageTmp->m3uaSgpAspSctpProfile == NULL) {
		config_perror("invalid specification for m3uaSgpAspSctpProfile");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaSgpAspMaxPathRetrans, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAspRtoMin, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAspRtoMin, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAspRtoMin, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAspMaxLifeTime, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAspTimerDivert, &tmpsize);
	line = read_config_read_data(ASN_INTEGER, line, &StorageTmp->m3uaSgpAspStatus, &tmpsize);
	m3uaSgpAspTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaSgpAspTable", "done.\n"));
}

/*
 * store_m3uaSgpAspTable(): store configuraiton file for m3uaSgpAspTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaSgpAspTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaSgpAspTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaSgpAspTable", "storing data...  "));
	refresh_m3uaSgpAspTable();
	(void) tmpsize;
	for (hcindex = m3uaSgpAspTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaSgpAspTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->m3uaSgpAspTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaSgpAspTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaSgpAspIndex, &tmpsize);
			tmpsize = StorageTmp->m3uaSgpAspNameLen;
			cptr = read_config_store_data(ASN_OCTET_STR, cptr, &StorageTmp->m3uaSgpAspName, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAspOperationalState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAspUsageState, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAspAdministrativeState, &tmpsize);
			tmpsize = StorageTmp->m3uaSgpAspAlarmStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaSgpAspAlarmStatus, &tmpsize);
			tmpsize = StorageTmp->m3uaSgpAspProceduralStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaSgpAspProceduralStatus, &tmpsize);
			tmpsize = StorageTmp->m3uaSgpAspAvailabilityStatusLen;
			cptr = read_config_store_data(ASN_BIT_STR, cptr, &StorageTmp->m3uaSgpAspAvailabilityStatus, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAspAspState, &tmpsize);
			tmpsize = StorageTmp->m3uaSgpAspSctpProfileLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->m3uaSgpAspSctpProfile, &tmpsize);
			tmpsize = StorageTmp->m3uaSgpAspSctpProfileLen;
			cptr = read_config_store_data(ASN_OBJECT_ID, cptr, &StorageTmp->m3uaSgpAspSctpProfile, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaSgpAspMaxPathRetrans, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAspRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAspRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAspRtoMin, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAspMaxLifeTime, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAspTimerDivert, &tmpsize);
			cptr = read_config_store_data(ASN_INTEGER, cptr, &StorageTmp->m3uaSgpAspStatus, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaSgpAspTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaSgpTable_add(): adds a structure node to our data set
 */
int
m3uaSgpTable_add(struct m3uaSgpTable_data *thedata)
{
	struct variable_list *vars = NULL;

	DEBUGMSGTL(("m3uaSgpTable", "adding data...  "));
	/* add the index variables to the varbind list, which is used by header_complex to index
	   the data */
	/* m3uaSgpAgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaSgpAgIndex, sizeof(thedata->m3uaSgpAgIndex));
	/* m3uaSgpSgIndex */
	snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, (u_char *) &thedata->m3uaSgpSgIndex, sizeof(thedata->m3uaSgpSgIndex));
	header_complex_add_data(&m3uaSgpTableStorage, vars, thedata);
	DEBUGMSGTL(("m3uaSgpTable", "registered an entry\n"));
	DEBUGMSGTL(("m3uaSgpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * m3uaSgpTable_del(): delete a structure
 */
int
m3uaSgpTable_del(struct m3uaSgpTable_data **thedata)
{
	struct m3uaSgpTable_data *StorageDel;

	DEBUGMSGTL(("m3uaSgpTable", "deleting data...  "));
	if ((StorageDel = *thedata) != NULL) {

		SNMP_FREE(StorageDel);
		*thedata = StorageDel;
	}
	DEBUGMSGTL(("m3uaSgpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/*
 * parse_m3uaSgpTable(): parse configuration file for m3uaSgpTable
 * parses .conf file entries needed to configure the mib.
 */
void
parse_m3uaSgpTable(const char *token, char *line)
{
	size_t tmpsize;
	struct m3uaSgpTable_data *StorageTmp = SNMP_MALLOC_STRUCT(m3uaSgpTable_data);

	DEBUGMSGTL(("m3uaSgpTable", "parsing config...  "));
	if (StorageTmp == NULL) {
		config_perror("malloc failure");
		return;
	}
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaSgpAgIndex, &tmpsize);
	line = read_config_read_data(ASN_UNSIGNED, line, &StorageTmp->m3uaSgpSgIndex, &tmpsize);
	m3uaSgpTable_add(StorageTmp);
	(void) tmpsize;
	DEBUGMSGTL(("m3uaSgpTable", "done.\n"));
}

/*
 * store_m3uaSgpTable(): store configuraiton file for m3uaSgpTable
 * stores .conf file entries needed to configure the mib.
 */
int
store_m3uaSgpTable(int majorID, int minorID, void *serverarg, void *clientarg)
{
	char line[SNMP_MAXBUF];
	char *cptr;
	size_t tmpsize;
	struct m3uaSgpTable_data *StorageTmp;
	struct header_complex_index *hcindex;

	DEBUGMSGTL(("m3uaSgpTable", "storing data...  "));
	refresh_m3uaSgpTable();
	(void) tmpsize;
	for (hcindex = m3uaSgpTableStorage; hcindex != NULL; hcindex = hcindex->next) {
		StorageTmp = (struct m3uaSgpTable_data *) hcindex->data;
		/* XXX: if (StorageTmp->m3uaSgpTableStorageType == ST_NONVOLATILE) */
		{
			memset(line, 0, sizeof(line));
			strcat(line, "m3uaSgpTable ");
			cptr = line + strlen(line);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaSgpAgIndex, &tmpsize);
			cptr = read_config_store_data(ASN_UNSIGNED, cptr, &StorageTmp->m3uaSgpSgIndex, &tmpsize);
			snmpd_store_config(line);
		}
	}
	DEBUGMSGTL(("m3uaSgpTable", "done.\n"));
	return SNMPERR_SUCCESS;
}

/**
 * refresh_m3uaSgpAgTable(): refresh m3uaSgpAgTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaSgpAgTable(void)
{
	if (m3uaSgpAgTable_refresh == 0)
		return;
	m3uaSgpAgTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaSgpAgTable_row(): refresh m3uaSgpAgTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaSgpAgTable_row(struct m3uaSgpAgTable_data *StorageTmp)
{
	if (StorageTmp->m3uaSgpAgTable_request == sa_request)
		return;
	StorageTmp->m3uaSgpAgTable_request = sa_request;
}

/*
 * var_m3uaSgpAgTable(): locate variables in m3uaSgpAgTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaSgpMIB above.
 */
u_char *
var_m3uaSgpAgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaSgpAgTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "var_m3uaSgpAgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaSgpAgTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaSgpAgTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaSgpAgTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UASGPAGNAME:
		*write_method = write_m3uaSgpAgName;
		*var_len = StorageTmp->m3uaSgpAgNameLen;
		return (u_char *) StorageTmp->m3uaSgpAgName;
	case M3UASGPAGPROTOCOLVERSION:
		*write_method = write_m3uaSgpAgProtocolVersion;
		*var_len = StorageTmp->m3uaSgpAgProtocolVersionLen;
		return (u_char *) StorageTmp->m3uaSgpAgProtocolVersion;
	case M3UASGPAGOPTIONS:
		*write_method = write_m3uaSgpAgOptions;
		*var_len = StorageTmp->m3uaSgpAgOptionsLen;
		return (u_char *) StorageTmp->m3uaSgpAgOptions;
	case M3UASGPAGREGISTRATIONPOLICY:
		*write_method = write_m3uaSgpAgRegistrationPolicy;
		*var_len = sizeof(StorageTmp->m3uaSgpAgRegistrationPolicy);
		return (u_char *) &StorageTmp->m3uaSgpAgRegistrationPolicy;
	case M3UASGPAGASPIDPOLICY:
		*write_method = write_m3uaSgpAgAspIdPolicy;
		*var_len = sizeof(StorageTmp->m3uaSgpAgAspIdPolicy);
		return (u_char *) &StorageTmp->m3uaSgpAgAspIdPolicy;
	case M3UASGPAGPROTOCOLPAYLOADID:
		*write_method = write_m3uaSgpAgProtocolPayloadId;
		*var_len = sizeof(StorageTmp->m3uaSgpAgProtocolPayloadId);
		return (u_char *) &StorageTmp->m3uaSgpAgProtocolPayloadId;
	case M3UASGPAGIPPORT:
		*write_method = write_m3uaSgpAgIpPort;
		*var_len = sizeof(StorageTmp->m3uaSgpAgIpPort);
		return (u_char *) &StorageTmp->m3uaSgpAgIpPort;
	case M3UASGPAGMINOSTREAMS:
		*write_method = write_m3uaSgpAgMinOstreams;
		*var_len = sizeof(StorageTmp->m3uaSgpAgMinOstreams);
		return (u_char *) &StorageTmp->m3uaSgpAgMinOstreams;
	case M3UASGPAGMAXISTREAMS:
		*write_method = write_m3uaSgpAgMaxIstreams;
		*var_len = sizeof(StorageTmp->m3uaSgpAgMaxIstreams);
		return (u_char *) &StorageTmp->m3uaSgpAgMaxIstreams;
	case M3UASGPAGSTATUS:
		*write_method = write_m3uaSgpAgStatus;
		*var_len = sizeof(StorageTmp->m3uaSgpAgStatus);
		return (u_char *) &StorageTmp->m3uaSgpAgStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaSgpSgTable(): refresh m3uaSgpSgTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaSgpSgTable(void)
{
	if (m3uaSgpSgTable_refresh == 0)
		return;
	m3uaSgpSgTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaSgpSgTable_row(): refresh m3uaSgpSgTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaSgpSgTable_row(struct m3uaSgpSgTable_data *StorageTmp)
{
	if (StorageTmp->m3uaSgpSgTable_request == sa_request)
		return;
	StorageTmp->m3uaSgpSgTable_request = sa_request;
}

/*
 * var_m3uaSgpSgTable(): locate variables in m3uaSgpSgTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaSgpMIB above.
 */
u_char *
var_m3uaSgpSgTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaSgpSgTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "var_m3uaSgpSgTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaSgpSgTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaSgpSgTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaSgpSgTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UASGPSGNAME:
		*write_method = write_m3uaSgpSgName;
		*var_len = StorageTmp->m3uaSgpSgNameLen;
		return (u_char *) StorageTmp->m3uaSgpSgName;
	case M3UASGPSGSTATUS:
		*write_method = write_m3uaSgpSgStatus;
		*var_len = sizeof(StorageTmp->m3uaSgpSgStatus);
		return (u_char *) &StorageTmp->m3uaSgpSgStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaSgpAspTable(): refresh m3uaSgpAspTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaSgpAspTable(void)
{
	if (m3uaSgpAspTable_refresh == 0)
		return;
	m3uaSgpAspTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaSgpAspTable_row(): refresh m3uaSgpAspTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaSgpAspTable_row(struct m3uaSgpAspTable_data *StorageTmp)
{
	if (StorageTmp->m3uaSgpAspTable_request == sa_request)
		return;
	StorageTmp->m3uaSgpAspTable_request = sa_request;
}

/*
 * var_m3uaSgpAspTable(): locate variables in m3uaSgpAspTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaSgpMIB above.
 */
u_char *
var_m3uaSgpAspTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaSgpAspTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "var_m3uaSgpAspTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaSgpAspTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaSgpAspTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {
	case M3UASGPASPNAME:
		*write_method = write_m3uaSgpAspName;
		*var_len = StorageTmp->m3uaSgpAspNameLen;
		return (u_char *) StorageTmp->m3uaSgpAspName;
	case M3UASGPASPOPERATIONALSTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaSgpAspOperationalState);
		return (u_char *) &StorageTmp->m3uaSgpAspOperationalState;
	case M3UASGPASPUSAGESTATE:
		*write_method = NULL;	/* read-only */
		*var_len = sizeof(StorageTmp->m3uaSgpAspUsageState);
		return (u_char *) &StorageTmp->m3uaSgpAspUsageState;
	case M3UASGPASPADMINISTRATIVESTATE:
		*write_method = write_m3uaSgpAspAdministrativeState;
		*var_len = sizeof(StorageTmp->m3uaSgpAspAdministrativeState);
		return (u_char *) &StorageTmp->m3uaSgpAspAdministrativeState;
	case M3UASGPASPALARMSTATUS:
		*write_method = write_m3uaSgpAspAlarmStatus;
		*var_len = StorageTmp->m3uaSgpAspAlarmStatusLen;
		return (u_char *) StorageTmp->m3uaSgpAspAlarmStatus;
	case M3UASGPASPPROCEDURALSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaSgpAspProceduralStatusLen;
		return (u_char *) StorageTmp->m3uaSgpAspProceduralStatus;
	case M3UASGPASPAVAILABILITYSTATUS:
		*write_method = NULL;	/* read-only */
		*var_len = StorageTmp->m3uaSgpAspAvailabilityStatusLen;
		return (u_char *) StorageTmp->m3uaSgpAspAvailabilityStatus;
	case M3UASGPASPASPSTATE:
		*write_method = write_m3uaSgpAspAspState;
		*var_len = sizeof(StorageTmp->m3uaSgpAspAspState);
		return (u_char *) &StorageTmp->m3uaSgpAspAspState;
	case M3UASGPASPSCTPPROFILE:
		*write_method = write_m3uaSgpAspSctpProfile;
		*var_len = StorageTmp->m3uaSgpAspSctpProfileLen;
		return (u_char *) StorageTmp->m3uaSgpAspSctpProfile;
	case M3UASGPASPSCTPPROFILE:
		*write_method = write_m3uaSgpAspSctpProfile;
		*var_len = StorageTmp->m3uaSgpAspSctpProfileLen;
		return (u_char *) StorageTmp->m3uaSgpAspSctpProfile;
	case M3UASGPASPMAXPATHRETRANS:
		*write_method = write_m3uaSgpAspMaxPathRetrans;
		*var_len = sizeof(StorageTmp->m3uaSgpAspMaxPathRetrans);
		return (u_char *) &StorageTmp->m3uaSgpAspMaxPathRetrans;
	case M3UASGPASPRTOMIN:
		*write_method = write_m3uaSgpAspRtoMin;
		*var_len = sizeof(StorageTmp->m3uaSgpAspRtoMin);
		return (u_char *) &StorageTmp->m3uaSgpAspRtoMin;
	case M3UASGPASPRTOMIN:
		*write_method = write_m3uaSgpAspRtoMin;
		*var_len = sizeof(StorageTmp->m3uaSgpAspRtoMin);
		return (u_char *) &StorageTmp->m3uaSgpAspRtoMin;
	case M3UASGPASPRTOMIN:
		*write_method = write_m3uaSgpAspRtoMin;
		*var_len = sizeof(StorageTmp->m3uaSgpAspRtoMin);
		return (u_char *) &StorageTmp->m3uaSgpAspRtoMin;
	case M3UASGPASPMAXLIFETIME:
		*write_method = write_m3uaSgpAspMaxLifeTime;
		*var_len = sizeof(StorageTmp->m3uaSgpAspMaxLifeTime);
		return (u_char *) &StorageTmp->m3uaSgpAspMaxLifeTime;
	case M3UASGPASPTIMERDIVERT:
		*write_method = write_m3uaSgpAspTimerDivert;
		*var_len = sizeof(StorageTmp->m3uaSgpAspTimerDivert);
		return (u_char *) &StorageTmp->m3uaSgpAspTimerDivert;
	case M3UASGPASPSTATUS:
		*write_method = write_m3uaSgpAspStatus;
		*var_len = sizeof(StorageTmp->m3uaSgpAspStatus);
		return (u_char *) &StorageTmp->m3uaSgpAspStatus;
	default:
		ERROR_MSG("");
	}
	return NULL;
}

/**
 * refresh_m3uaSgpTable(): refresh m3uaSgpTable
 *
 * Normally the values retrieved from the operating system are cached.  When the agent receives a
 * SIGPOLL from an open STREAMS configuration or administrative driver Stream, the STREAMS subsystem
 * indicates to the agent that the cache has been invalidated and that it should reread tables from
 * the STREAMS subsystem.  This function is used when the agent start for the first time, or after a
 * SIGPOLL has been received (and a row or column has been requested).
 */
void
refresh_m3uaSgpTable(void)
{
	if (m3uaSgpTable_refresh == 0)
		return;
	m3uaSgpTable_refresh = 0;
	/* Here, update the table as required... */
}

/**
 * refresh_m3uaSgpTable_row(): refresh m3uaSgpTable row
 *
 * Normally the values retrieved from the operating system are cached.  However, if a row contains
 * temporal values, such as statistics counters, gauges, timestamps, or other transient columns, it
 * may be necessary to refresh the row on some other basis, but normally only once per request.
 */
void
refresh_m3uaSgpTable_row(struct m3uaSgpTable_data *StorageTmp)
{
	if (StorageTmp->m3uaSgpTable_request == sa_request)
		return;
	StorageTmp->m3uaSgpTable_request = sa_request;
}

/*
 * var_m3uaSgpTable(): locate variables in m3uaSgpTable
 * Handle this table separately from the scalar value case.  The workings of this are basically the
 * same as for var_m3uaSgpMIB above.
 */
u_char *
var_m3uaSgpTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{
	struct m3uaSgpTable_data *StorageTmp = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "var_m3uaSgpTable: Entering...  \n"));
	/* Make sure that the storage data does not need to be refreshed before checking the
	   header. */
	refresh_m3uaSgpTable();
	/* This assumes you have registered all your data properly with header_complex_add()
	   somewhere before this. */
	if ((StorageTmp = header_complex(m3uaSgpTableStorage, vp, name, length, exact, var_len, write_method)) == NULL)
		return NULL;
	refresh_m3uaSgpTable_row(StorageTmp);
	/* This is where we do the value assignments for the mib results. */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_m3uaSgpAgName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaSgpAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAgName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAgTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAgName;
		old_length = StorageTmp->m3uaSgpAgNameLen;
		StorageTmp->m3uaSgpAgName = string;
		StorageTmp->m3uaSgpAgNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAgName = old_value;
		StorageTmp->m3uaSgpAgNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAgProtocolVersion(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct m3uaSgpAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAgProtocolVersion entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAgTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgProtocolVersion not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgProtocolVersion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value interoperableProtocolVersion */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAgProtocolVersion;
		old_length = StorageTmp->m3uaSgpAgProtocolVersionLen;
		StorageTmp->m3uaSgpAgProtocolVersion = objid;
		StorageTmp->m3uaSgpAgProtocolVersionLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAgProtocolVersion = old_value;
		StorageTmp->m3uaSgpAgProtocolVersionLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAgOptions(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaSgpAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAgOptions entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAgTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgOptions not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgOptions: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAgOptions;
		old_length = StorageTmp->m3uaSgpAgOptionsLen;
		StorageTmp->m3uaSgpAgOptions = string;
		StorageTmp->m3uaSgpAgOptionsLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAgOptions = old_value;
		StorageTmp->m3uaSgpAgOptionsLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAgRegistrationPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAgRegistrationPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAgTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgRegistrationPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgRegistrationPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		switch (set_value) {
		case M3UASGPAGREGISTRATIONPOLICY_UNKNOWN:
		case M3UASGPAGREGISTRATIONPOLICY_FORBIDDEN:
		case M3UASGPAGREGISTRATIONPOLICY_PERMITTED:
		case M3UASGPAGREGISTRATIONPOLICY_REQUIRED:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgRegistrationPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAgRegistrationPolicy;
		StorageTmp->m3uaSgpAgRegistrationPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAgRegistrationPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAgAspIdPolicy(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAgAspIdPolicy entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAgTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgAspIdPolicy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgAspIdPolicy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 1 */
		switch (set_value) {
		case M3UASGPAGASPIDPOLICY_UNKNOWN:
		case M3UASGPAGASPIDPOLICY_PERMITTED:
		case M3UASGPAGASPIDPOLICY_REQUIRED:
		case M3UASGPAGASPIDPOLICY_FORBIDDEN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgAspIdPolicy: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAgAspIdPolicy;
		StorageTmp->m3uaSgpAgAspIdPolicy = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAgAspIdPolicy = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAgProtocolPayloadId(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAgProtocolPayloadId entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAgTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgProtocolPayloadId not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgProtocolPayloadId: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 3 */
		/* Note: ranges 0..0 3..3 */
		if (set_value != 0 && set_value != 3) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgProtocolPayloadId: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAgProtocolPayloadId;
		StorageTmp->m3uaSgpAgProtocolPayloadId = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAgProtocolPayloadId = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAgIpPort(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAgIpPort entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAgTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgIpPort not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgIpPort: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 2905 */
		/* Note: ranges 0..16383 */
		if ((0 > set_value || set_value > 16383)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgIpPort: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAgIpPort;
		StorageTmp->m3uaSgpAgIpPort = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAgIpPort = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAgMinOstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAgMinOstreams entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAgTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgMinOstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgMinOstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 33 */
		/* Note: ranges 2..16384 */
		if ((2 > set_value || set_value > 16384)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgMinOstreams: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAgMinOstreams;
		StorageTmp->m3uaSgpAgMinOstreams = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAgMinOstreams = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAgMaxIstreams(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAgMaxIstreams entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAgTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgMaxIstreams not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgMaxIstreams: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 33 */
		/* Note: ranges 2..16384 */
		if ((2 > set_value || set_value > 16384)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgMaxIstreams: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAgMaxIstreams;
		StorageTmp->m3uaSgpAgMaxIstreams = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAgMaxIstreams = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpSgName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaSgpSgTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpSgName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpSgTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpSgName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpSgName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpSgName;
		old_length = StorageTmp->m3uaSgpSgNameLen;
		StorageTmp->m3uaSgpSgName = string;
		StorageTmp->m3uaSgpSgNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpSgName = old_value;
		StorageTmp->m3uaSgpSgNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspName(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspName entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		/* Note: ranges 0..32 */
		if (var_val_len > SPRINT_MAX_LEN || ((0 > var_val_len || var_val_len > 32))) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspName;
		old_length = StorageTmp->m3uaSgpAspNameLen;
		StorageTmp->m3uaSgpAspName = string;
		StorageTmp->m3uaSgpAspNameLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspName = old_value;
		StorageTmp->m3uaSgpAspNameLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspAdministrativeState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspAdministrativeState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspAdministrativeState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspAdministrativeState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case M3UASGPASPADMINISTRATIVESTATE_LOCKED:
		case M3UASGPASPADMINISTRATIVESTATE_UNLOCKED:
		case M3UASGPASPADMINISTRATIVESTATE_SHUTTINGDOWN:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspAdministrativeState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspAdministrativeState;
		StorageTmp->m3uaSgpAspAdministrativeState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspAdministrativeState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspAlarmStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint8_t *old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static uint8_t *string = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspAlarmStatus entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_BIT_STR) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspAlarmStatus not ASN_BIT_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > SPRINT_MAX_LEN) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspAlarmStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value */
		/* XXX: check bits */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((string = malloc(var_val_len)) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		memcpy((void *) string, (void *) var_val, var_val_len);
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(string);
		break;
	case ACTION:		/* The variable has been stored in string for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspAlarmStatus;
		old_length = StorageTmp->m3uaSgpAspAlarmStatusLen;
		StorageTmp->m3uaSgpAspAlarmStatus = string;
		StorageTmp->m3uaSgpAspAlarmStatusLen = var_val_len;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspAlarmStatus = old_value;
		StorageTmp->m3uaSgpAspAlarmStatusLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		string = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspAspState(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspAspState entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspAspState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspAspState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value 0 */
		switch (set_value) {
		case M3UASGPASPASPSTATE_DOWN:
		case M3UASGPASPASPSTATE_INITIALIZING:
		case M3UASGPASPASPSTATE_TERMINATING:
		case M3UASGPASPASPSTATE_UP:
			break;
		default:
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspAspState: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspAspState;
		StorageTmp->m3uaSgpAspAspState = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspAspState = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspSctpProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspSctpProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspSctpProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspSctpProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspSctpProfile;
		old_length = StorageTmp->m3uaSgpAspSctpProfileLen;
		StorageTmp->m3uaSgpAspSctpProfile = objid;
		StorageTmp->m3uaSgpAspSctpProfileLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspSctpProfile = old_value;
		StorageTmp->m3uaSgpAspSctpProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspSctpProfile(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static oid *old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	static size_t old_length = 0;
	static oid *objid = NULL;

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspSctpProfile entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OBJECT_ID) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspSctpProfile not ASN_OBJECT_ID\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspSctpProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (MIN_OID_LEN * sizeof(oid) > var_val_len || var_val_len > MAX_OID_LEN * sizeof(oid)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspSctpProfile: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: default value zeroDotZero */
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		if ((objid = snmp_duplicate_objid((void *) var_val, var_val_len / sizeof(oid))) == NULL)
			return SNMP_ERR_RESOURCEUNAVAILABLE;
		break;
	case FREE:		/* Release any resources that have been allocated */
		SNMP_FREE(objid);
		break;
	case ACTION:		/* The variable has been stored in objid for you to use, and you
				   have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspSctpProfile;
		old_length = StorageTmp->m3uaSgpAspSctpProfileLen;
		StorageTmp->m3uaSgpAspSctpProfile = objid;
		StorageTmp->m3uaSgpAspSctpProfileLen = var_val_len / sizeof(oid);
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspSctpProfile = old_value;
		StorageTmp->m3uaSgpAspSctpProfileLen = old_length;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		SNMP_FREE(old_value);
		old_length = 0;
		objid = NULL;
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspMaxPathRetrans(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static uint32_t old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	ulong set_value = *((ulong *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspMaxPathRetrans entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspMaxPathRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(uint32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspMaxPathRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspMaxPathRetrans;
		StorageTmp->m3uaSgpAspMaxPathRetrans = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspMaxPathRetrans = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspRtoMin;
		StorageTmp->m3uaSgpAspRtoMin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspRtoMin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspRtoMin;
		StorageTmp->m3uaSgpAspRtoMin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspRtoMin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspRtoMin(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspRtoMin entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspRtoMin: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspRtoMin;
		StorageTmp->m3uaSgpAspRtoMin = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspRtoMin = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspMaxLifeTime(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspMaxLifeTime entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspMaxLifeTime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspMaxLifeTime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspMaxLifeTime: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspMaxLifeTime;
		StorageTmp->m3uaSgpAspMaxLifeTime = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspMaxLifeTime = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspTimerDivert(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	static int32_t old_value;
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	size_t newlen = name_len - (sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1);
	long set_value = *((long *) var_val);

	DEBUGMSGTL(("m3uaSgpMIB", "write_m3uaSgpAspTimerDivert entering action=%d...  \n", action));
	if ((StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpMIB_variables_oid) / sizeof(oid) + 7 - 1], &newlen, 1, NULL, NULL)) == NULL)
		return SNMP_ERR_NOSUCHNAME;	/* remove if you support creation here */
	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspTimerDivert not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(int32_t)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspTimerDivert: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		/* Note: ranges 0..2147483647 */
		if ((0 > set_value || set_value > 2147483647)) {
			snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspTimerDivert: bad value\n");
			return SNMP_ERR_WRONGVALUE;
		}
		break;
	case RESERVE2:		/* memory reseveration, final preparation... */
		break;
	case FREE:		/* Release any resources that have been allocated */
		break;
	case ACTION:		/* The variable has been stored in set_value for you to use, and
				   you have just been asked to do something with it.  Note that
				   anything done here must be reversable in the UNDO case */
		old_value = StorageTmp->m3uaSgpAspTimerDivert;
		StorageTmp->m3uaSgpAspTimerDivert = set_value;
		break;
	case UNDO:		/* Back out any changes made in the ACTION case */
		StorageTmp->m3uaSgpAspTimerDivert = old_value;
		break;
	case COMMIT:		/* Things are working well, so it's now safe to make the change
				   permanently.  Make sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAgStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaSgpAgTable_data *StorageTmp = NULL;
	static struct m3uaSgpAgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaSgpAgTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaSgpAgTableStorage, NULL, &name[sizeof(m3uaSgpAgTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAgStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaSgpAgStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaSgpAgTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaSgpAgTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaSgpAgIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaSgpAgTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(m3uaSgpAgTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaSgpAgIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->m3uaSgpAgProtocolVersion = interoperableProtocolVersion; */
			StorageNew->m3uaSgpAgRegistrationPolicy = 1;
			StorageNew->m3uaSgpAgAspIdPolicy = 1;
			StorageNew->m3uaSgpAgProtocolPayloadId = 3;
			StorageNew->m3uaSgpAgIpPort = 2905;
			StorageNew->m3uaSgpAgMinOstreams = 33;
			StorageNew->m3uaSgpAgMaxIstreams = 33;
			StorageNew->m3uaSgpAgStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaSgpAgTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaSgpAgTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaSgpAgStatus;
			StorageTmp->m3uaSgpAgStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(m3uaSgpAgTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&m3uaSgpAgTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaSgpAgTableStorage, StorageNew);
			header_complex_extract_entry(&m3uaSgpAgTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaSgpAgStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaSgpAgTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaSgpAgStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaSgpAgStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaSgpAgTable_del(&StorageDel);
			/* m3uaSgpAgTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpSgStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaSgpSgTable_data *StorageTmp = NULL;
	static struct m3uaSgpSgTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaSgpSgTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaSgpSgTableStorage, NULL, &name[sizeof(m3uaSgpSgTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpSgStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaSgpSgStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaSgpSgTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaSgpSgTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaSgpAgIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaSgpSgTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(m3uaSgpSgTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaSgpAgIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			StorageNew->m3uaSgpSgStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaSgpSgTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaSgpSgTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaSgpSgStatus;
			StorageTmp->m3uaSgpSgStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(m3uaSgpSgTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&m3uaSgpSgTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaSgpSgTableStorage, StorageNew);
			header_complex_extract_entry(&m3uaSgpSgTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaSgpSgStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaSgpSgTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaSgpSgStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaSgpSgStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaSgpSgTable_del(&StorageDel);
			/* m3uaSgpSgTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m3uaSgpAspStatus(int action, u_char *var_val, u_char var_val_type, size_t var_val_len, u_char *statP, oid * name, size_t name_len)
{
	struct m3uaSgpAspTable_data *StorageTmp = NULL;
	static struct m3uaSgpAspTable_data *StorageNew, *StorageDel;
	size_t newlen = name_len - (sizeof(m3uaSgpAspTable_variables_oid) / sizeof(oid) + 3 - 1);
	static int old_value;
	int set_value;
	static struct variable_list *vars, *vp;
	struct header_complex_index *hciptr;

	StorageTmp = header_complex(m3uaSgpAspTableStorage, NULL, &name[sizeof(m3uaSgpAspTable_variables_oid) / sizeof(oid) + 3 - 1], &newlen, 1, NULL, NULL);
	if (var_val_type != ASN_INTEGER || var_val == NULL) {
		snmp_log(MY_FACILITY(LOG_NOTICE), "write to m3uaSgpAspStatus not ASN_INTEGER\n");
		return SNMP_ERR_WRONGTYPE;
	}
	set_value = *((long *) var_val);
	/* check legal range, and notReady is reserved for us, not a user */
	if (set_value < 1 || set_value > 6 || set_value == RS_NOTREADY)
		return SNMP_ERR_INCONSISTENTVALUE;
	switch (action) {
	case RESERVE1:
		/* stage one: test validity */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			if (StorageTmp != NULL)
				/* cannot create existing row */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			if (StorageTmp == NULL)
				/* cannot change state of non-existent row */
				return SNMP_ERR_INCONSISTENTVALUE;
			if (StorageTmp->m3uaSgpAspStatus == RS_NOTREADY)
				/* cannot change state of row that is not ready */
				return SNMP_ERR_INCONSISTENTVALUE;
			/* XXX: interaction with row storage type needed */
			if (set_value == RS_NOTINSERVICE && StorageTmp->m3uaSgpAspTable_refs > 0)
				/* row is busy and cannot be moved to the RS_NOTINSERVICE state */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_DESTROY:
			/* destroying existent or non-existent row is ok */
			if (StorageTmp == NULL)
				break;
			/* XXX: interaction with row storage type needed */
			if (StorageTmp->m3uaSgpAspTable_refs > 0)
				/* row is busy and cannot be deleted */
				return SNMP_ERR_INCONSISTENTVALUE;
			break;
		case RS_NOTREADY:
			/* management station cannot set this, only agent can */
		default:
			return SNMP_ERR_INCONSISTENTVALUE;
		}
		break;
	case RESERVE2:
		/* memory reseveration, final preparation... */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			vars = NULL;
			/* m3uaSgpAspIndex */
			snmp_varlist_add_variable(&vars, NULL, 0, ASN_UNSIGNED, NULL, 0);
			if (header_complex_parse_oid(&(name[sizeof(m3uaSgpAspTable_variables_oid) / sizeof(oid) + 2]), newlen, vars) != SNMPERR_SUCCESS) {
				/* XXX: free, zero vars */
				return SNMP_ERR_INCONSISTENTNAME;
			}
			vp = vars;
			if ((StorageNew = SNMP_MALLOC_STRUCT(m3uaSgpAspTable_data)) == NULL) {
				/* XXX: free, zero vars */
				return SNMP_ERR_RESOURCEUNAVAILABLE;
			}
			StorageNew->m3uaSgpAspIndex = *vp->val.integer;
			vp = vp->next_variable;
			/* XXX: fill in default row values here into StorageNew */
			/* StorageNew->m3uaSgpAspSctpProfile = zeroDotZero; */
			/* StorageNew->m3uaSgpAspSctpProfile = zeroDotZero; */
			StorageNew->m3uaSgpAspStatus = RS_NOTREADY;
			/* XXX: free, zero vars, no longer needed? */
			break;
		}
		break;
	case FREE:
		/* Release any resources that have been allocated */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* creation */
			m3uaSgpAspTable_del(&StorageNew);
			/* XXX: free, zero vars */
			break;
		}
		break;
	case ACTION:
		/* The variable has been stored in set_value for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so add it */
			m3uaSgpAspTable_add(StorageNew);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* set the flag? */
			old_value = StorageTmp->m3uaSgpAspStatus;
			StorageTmp->m3uaSgpAspStatus = set_value;
			break;
		case RS_DESTROY:
			/* destroy */
			if (StorageTmp != NULL) {
				/* exists, extract it for now */
				hciptr = header_complex_find_entry(m3uaSgpAspTableStorage, StorageTmp);
				StorageDel = header_complex_extract_entry(&m3uaSgpAspTableStorage, hciptr);
			} else {
				StorageDel = NULL;
			}
			break;
		}
		break;
	case UNDO:
		/* Back out any changes made in the ACTION case */
		switch (set_value) {
		case RS_CREATEANDGO:
		case RS_CREATEANDWAIT:
			/* row creation, so remove it again */
			hciptr = header_complex_find_entry(m3uaSgpAspTableStorage, StorageNew);
			header_complex_extract_entry(&m3uaSgpAspTableStorage, hciptr);
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* restore state */
			StorageTmp->m3uaSgpAspStatus = old_value;
			break;
		case RS_DESTROY:
			/* row deletion, so add it again */
			m3uaSgpAspTable_add(StorageDel);
			break;
		}
		break;
	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		switch (set_value) {
		case RS_CREATEANDGO:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaSgpAspStatus = RS_ACTIVE;
			break;
		case RS_CREATEANDWAIT:
			/* row creation, set final state */
			/* XXX: check if row is ready, otherwise leave at RS_NOTREADY */
			StorageTmp->m3uaSgpAspStatus = RS_NOTINSERVICE;
			break;
		case RS_ACTIVE:
		case RS_NOTINSERVICE:
			/* state change already performed */
			break;
		case RS_DESTROY:
			/* row deletion, free it its dead */
			m3uaSgpAspTable_del(&StorageDel);
			/* m3uaSgpAspTable_del() can handle NULL pointers. */
			break;
		}
		break;
	}
	return SNMP_ERR_NOERROR;
}
