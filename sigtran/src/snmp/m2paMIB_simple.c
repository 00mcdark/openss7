/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */

/* This should always be included first before anything else */
#include <config.h>

/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"

#else				/* !IN_UCD_SNMP_SOURCE */

#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>

#endif				/* !IN_UCD_SNMP_SOURCE */

#include "m2paMIB_simple.h"

/* 
 * m2paMIB_simple_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid m2paMIB_simple_variables_oid[] = { 1, 3, 6, 1, 4, 1, 29591, 1, 202 };

/* 
 * variable7 m2paMIB_simple_variables:
 *   this variable defines function callbacks and type return information 
 *   for the m2paMIB_simple mib section 
 */

struct variable7 m2paMIB_simple_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   M2PAN1                4
	{M2PAN1, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 2}},
#define   M2PAPROVING           5
	{M2PAPROVING, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 3}},
#define   M2PAMANAGEMENTPROVINGSTATE  6
	{M2PAMANAGEMENTPROVINGSTATE, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 4}},
#define   M2PALOOPDELAYLOWER    7
	{M2PALOOPDELAYLOWER, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 5}},
#define   M2PALOOPDELAYUPPER    8
	{M2PALOOPDELAYUPPER, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 6}},
#define   M2PATRANSMISSIONRATEINTERVALLOWER  9
	{M2PATRANSMISSIONRATEINTERVALLOWER, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 7}},
#define   M2PATRANSMISSIONRATEINTERVALUPPER  10
	{M2PATRANSMISSIONRATEINTERVALUPPER, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 8}},
#define   M2PASCTPNODELAY       11
	{M2PASCTPNODELAY, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 9}},
#define   M2PASCTPMAXSEG        12
	{M2PASCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 10}},
#define   M2PASCTPHEARTBEATITVL  13
	{M2PASCTPHEARTBEATITVL, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 11}},
#define   M2PASCTPHEARTBEAT     14
	{M2PASCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 12}},
#define   M2PASCTPRTOINITIAL    15
	{M2PASCTPRTOINITIAL, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 13}},
#define   M2PASCTPRTOMIN        16
	{M2PASCTPRTOMIN, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 14}},
#define   M2PASCTPRTOMAX        17
	{M2PASCTPRTOMAX, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 15}},
#define   M2PASCTPPATHMAXRETRANS  18
	{M2PASCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 16}},
#define   M2PASCTPCOOKIELIFE    19
	{M2PASCTPCOOKIELIFE, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 17}},
#define   M2PASCTPCOOKIEINC     20
	{M2PASCTPCOOKIEINC, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 18}},
#define   M2PASCTPMAXINITRETRIES  21
	{M2PASCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 19}},
#define   M2PASCTPMAXBURST      22
	{M2PASCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 20}},
#define   M2PASCTPASSOCMAXRETRANS  23
	{M2PASCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 21}},
#define   M2PASCTPSACKDELAY     24
	{M2PASCTPSACKDELAY, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 22}},
#define   M2PASCTPLIFETIME      25
	{M2PASCTPLIFETIME, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 23}},
#define   M2PATIMERT1           26
	{M2PATIMERT1, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 24}},
#define   M2PATIMERT2           27
	{M2PATIMERT2, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 25}},
#define   M2PATIMERT2L          28
	{M2PATIMERT2L, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 26}},
#define   M2PATIMERT2H          29
	{M2PATIMERT2H, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 27}},
#define   M2PATIMERT3           30
	{M2PATIMERT3, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 28}},
#define   M2PATIMERT4N          31
	{M2PATIMERT4N, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 29}},
#define   M2PATIMERT4E          32
	{M2PATIMERT4E, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 30}},
#define   M2PATIMERT6           33
	{M2PATIMERT6, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 31}},
#define   M2PATIMERT7           34
	{M2PATIMERT7, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 32}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL1MESSAGES  35
	{M2PATRANSCONGTHRESHOLDABATEMENTL1MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 33}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL1OCTETS  36
	{M2PATRANSCONGTHRESHOLDABATEMENTL1OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 34}},
#define   M2PATRANSCONGTHRESHOLDONSETL1MESSAGES  37
	{M2PATRANSCONGTHRESHOLDONSETL1MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 35}},
#define   M2PATRANSCONGTHRESHOLDONSETL1OCTETS  38
	{M2PATRANSCONGTHRESHOLDONSETL1OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 36}},
#define   M2PAPROVINGATTEMPTS   39
	{M2PAPROVINGATTEMPTS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 37}},
#define   M2PANUMBEROFTHRESHOLDLEVELS  40
	{M2PANUMBEROFTHRESHOLDLEVELS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 38}},
#define   M2PACONGESTIONCOUNTING  41
	{M2PACONGESTIONCOUNTING, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 39}},
#define   M2PACONGESTIONREPORTINGBASEOBJECT  42
	{M2PACONGESTIONREPORTINGBASEOBJECT, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 40}},
#define   M2PATIMERTX           43
	{M2PATIMERTX, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 41}},
#define   M2PATIMERTY           44
	{M2PATIMERTY, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 42}},
#define   M2PANUMBEROFCONGESTIONSTATES  45
	{M2PANUMBEROFCONGESTIONSTATES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 43}},
#define   M2PAINITIALLEVELOFCONGESTION  46
	{M2PAINITIALLEVELOFCONGESTION, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 44}},
#define   M2PARECEIVECONGESTIONTHRESHOLDABATEMENT  47
	{M2PARECEIVECONGESTIONTHRESHOLDABATEMENT, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 45}},
#define   M2PARECEIVECONGESTIONTHRESHOLDONSET  48
	{M2PARECEIVECONGESTIONTHRESHOLDONSET, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 46}},
#define   M2PARECEIVECONGESTIONTHRESHOLDDISCARD  49
	{M2PARECEIVECONGESTIONTHRESHOLDDISCARD, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 47}},
#define   M2PAPROTOCOLPROFILENAME  50
	{M2PAPROTOCOLPROFILENAME, ASN_OCTET_STR, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 48}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL2MESSAGES  51
	{M2PATRANSCONGTHRESHOLDABATEMENTL2MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 49}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL2OCTETS  52
	{M2PATRANSCONGTHRESHOLDABATEMENTL2OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 50}},
#define   M2PATRANSCONGTHRESHOLDONSETL2MESSAGES  53
	{M2PATRANSCONGTHRESHOLDONSETL2MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 51}},
#define   M2PATRANSCONGTHRESHOLDONSETL2OCTETS  54
	{M2PATRANSCONGTHRESHOLDONSETL2OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 52}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL3MESSAGES  55
	{M2PATRANSCONGTHRESHOLDABATEMENTL3MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 53}},
#define   M2PATRANSCONGTHRESHOLDABATEMENTL3OCTETS  56
	{M2PATRANSCONGTHRESHOLDABATEMENTL3OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 54}},
#define   M2PATRANSCONGTHRESHOLDONSETL3MESSAGES  57
	{M2PATRANSCONGTHRESHOLDONSETL3MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 55}},
#define   M2PATRANSCONGTHRESHOLDONSETL3OCTETS  58
	{M2PATRANSCONGTHRESHOLDONSETL3OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 56}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL1MESSAGES  59
	{M2PATRANSCONGTHRESHOLDDISCARDL1MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 57}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL1OCTETS  60
	{M2PATRANSCONGTHRESHOLDDISCARDL1OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 58}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL2MESSAGES  61
	{M2PATRANSCONGTHRESHOLDDISCARDL2MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 59}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL2OCTETS  62
	{M2PATRANSCONGTHRESHOLDDISCARDL2OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 60}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL3MESSAGES  63
	{M2PATRANSCONGTHRESHOLDDISCARDL3MESSAGES, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 61}},
#define   M2PATRANSCONGTHRESHOLDDISCARDL3OCTETS  64
	{M2PATRANSCONGTHRESHOLDDISCARDL3OCTETS, ASN_UNSIGNED, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 62}},
#define   M2PAPROTOCOLPROFILEROWSTATUS  65
	{M2PAPROTOCOLPROFILEROWSTATUS, ASN_INTEGER, RWRITE, var_m2paProtocolProfileTable, 6, {1, 1, 1, 1, 1, 63}},
#define   M2PADEFAULTSCTPNODELAY  66
	{M2PADEFAULTSCTPNODELAY, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 1}},
#define   M2PADEFAULTSCTPMAXSEG  67
	{M2PADEFAULTSCTPMAXSEG, ASN_UNSIGNED, RWRITE, var_m2paMIB, 3, {1, 2, 2}},
#define   M2PADEFAULTSCTPHEARTBEATITVL  68
	{M2PADEFAULTSCTPHEARTBEATITVL, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 3}},
#define   M2PADEFAULTSCTPHEARTBEAT  69
	{M2PADEFAULTSCTPHEARTBEAT, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 4}},
#define   M2PADEFAULTSCTPRTOINITIAL  70
	{M2PADEFAULTSCTPRTOINITIAL, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 5}},
#define   M2PADEFAULTSCTPRTOMIN  71
	{M2PADEFAULTSCTPRTOMIN, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 6}},
#define   M2PADEFAULTSCTPRTOMAX  72
	{M2PADEFAULTSCTPRTOMAX, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 7}},
#define   M2PADEFAULTSCTPPATHMAXRETRANS  73
	{M2PADEFAULTSCTPPATHMAXRETRANS, ASN_UNSIGNED, RWRITE, var_m2paMIB, 3, {1, 2, 8}},
#define   M2PADEFAULTSCTPCOOKIELIFE  74
	{M2PADEFAULTSCTPCOOKIELIFE, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 9}},
#define   M2PADEFAULTSCTPCOOKIEINC  75
	{M2PADEFAULTSCTPCOOKIEINC, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 10}},
#define   M2PADEFAULTSCTPMAXINITRETRIES  76
	{M2PADEFAULTSCTPMAXINITRETRIES, ASN_UNSIGNED, RWRITE, var_m2paMIB, 3, {1, 2, 11}},
#define   M2PADEFAULTSCTPMAXBURST  77
	{M2PADEFAULTSCTPMAXBURST, ASN_UNSIGNED, RWRITE, var_m2paMIB, 3, {1, 2, 12}},
#define   M2PADEFAULTSCTPASSOCMAXRETRANS  78
	{M2PADEFAULTSCTPASSOCMAXRETRANS, ASN_UNSIGNED, RWRITE, var_m2paMIB, 3, {1, 2, 13}},
#define   M2PADEFAULTSCTPSACKDELAY  79
	{M2PADEFAULTSCTPSACKDELAY, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 14}},
#define   M2PADEFAULTSCTPLIFETIME  80
	{M2PADEFAULTSCTPLIFETIME, ASN_INTEGER, RWRITE, var_m2paMIB, 3, {1, 2, 15}},
};

/*    (L = length of the oidsuffix) */

/*
 * init_m2paMIB_simple():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void
init_m2paMIB_simple(void)
{

	/* register ourselves with the agent to handle our mib tree */
	REGISTER_MIB("m2paMIB_simple", m2paMIB_simple_variables, variable7, m2paMIB_simple_variables_oid);

	/* place any other initialization junk you need here */
}

/*
 * var_m2paMIB_simple():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_m2paMIB_simple(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	if (header_generic(vp, name, length, exact, var_len, write_method)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	default:
		ERROR_MSG("");
	}
	return NULL;
}

/*
 * var_m2paProtocolProfileTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_m2paMIB_simple above.
 */
unsigned char *
var_m2paProtocolProfileTable(struct variable *vp, oid * name, size_t *length, int exact, size_t *var_len, WriteMethod ** write_method)
{

	/* variables we may use later */
	static long long_ret;
	static u_long ulong_ret;
	static unsigned char string[SPRINT_MAX_LEN];
	static oid objid[MAX_OID_LEN];
	static struct counter64 c64;

	/* 
	 * This assumes that the table is a 'simple' table.
	 *    See the implementation documentation for the meaning of this.
	 *    You will need to provide the correct value for the TABLE_SIZE parameter
	 *
	 * If this table does not meet the requirements for a simple table,
	 *    you will need to provide the replacement code yourself.
	 *    Mib2c is not smart enough to write this for you.
	 *    Again, see the implementation documentation for what is required.
	 */
	if (header_simple_table(vp, name, length, exact, var_len, write_method, TABLE_SIZE)
	    == MATCH_FAILED)
		return NULL;

	/* 
	 * this is where we do the value assignments for the mib results.
	 */
	switch (vp->magic) {

	case M2PAN1:
		*write_method = write_m2paN1;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PAPROVING:
		*write_method = write_m2paProving;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PAMANAGEMENTPROVINGSTATE:
		*write_method = write_m2paManagementProvingState;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PALOOPDELAYLOWER:
		*write_method = write_m2paLoopDelayLower;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PALOOPDELAYUPPER:
		*write_method = write_m2paLoopDelayUpper;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATRANSMISSIONRATEINTERVALLOWER:
		*write_method = write_m2paTransmissionRateIntervalLower;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSMISSIONRATEINTERVALUPPER:
		*write_method = write_m2paTransmissionRateIntervalUpper;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PASCTPNODELAY:
		*write_method = write_m2paSctpNoDelay;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PASCTPMAXSEG:
		*write_method = write_m2paSctpMaxseg;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PASCTPHEARTBEATITVL:
		*write_method = write_m2paSctpHeartbeatItvl;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PASCTPHEARTBEAT:
		*write_method = write_m2paSctpHeartbeat;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PASCTPRTOINITIAL:
		*write_method = write_m2paSctpRtoInitial;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PASCTPRTOMIN:
		*write_method = write_m2paSctpRtoMin;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PASCTPRTOMAX:
		*write_method = write_m2paSctpRtoMax;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PASCTPPATHMAXRETRANS:
		*write_method = write_m2paSctpPathMaxRetrans;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PASCTPCOOKIELIFE:
		*write_method = write_m2paSctpCookieLife;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PASCTPCOOKIEINC:
		*write_method = write_m2paSctpCookieInc;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PASCTPMAXINITRETRIES:
		*write_method = write_m2paSctpMaxInitRetries;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PASCTPMAXBURST:
		*write_method = write_m2paSctpMaxBurst;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PASCTPASSOCMAXRETRANS:
		*write_method = write_m2paSctpAssocMaxRetrans;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PASCTPSACKDELAY:
		*write_method = write_m2paSctpSackDelay;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PASCTPLIFETIME:
		*write_method = write_m2paSctpLifetime;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERT1:
		*write_method = write_m2paTimerT1;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERT2:
		*write_method = write_m2paTimerT2;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERT2L:
		*write_method = write_m2paTimerT2L;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERT2H:
		*write_method = write_m2paTimerT2H;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERT3:
		*write_method = write_m2paTimerT3;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERT4N:
		*write_method = write_m2paTimerT4N;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERT4E:
		*write_method = write_m2paTimerT4E;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERT6:
		*write_method = write_m2paTimerT6;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERT7:
		*write_method = write_m2paTimerT7;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATRANSCONGTHRESHOLDABATEMENTL1MESSAGES:
		*write_method = write_m2paTransCongThresholdAbatementL1Messages;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDABATEMENTL1OCTETS:
		*write_method = write_m2paTransCongThresholdAbatementL1Octets;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDONSETL1MESSAGES:
		*write_method = write_m2paTransCongThresholdOnsetL1Messages;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDONSETL1OCTETS:
		*write_method = write_m2paTransCongThresholdOnsetL1Octets;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PAPROVINGATTEMPTS:
		*write_method = write_m2paProvingAttempts;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PANUMBEROFTHRESHOLDLEVELS:
		*write_method = write_m2paNumberOfThresholdLevels;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PACONGESTIONCOUNTING:
		*write_method = write_m2paCongestionCounting;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PACONGESTIONREPORTINGBASEOBJECT:
		*write_method = write_m2paCongestionReportingBaseObject;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERTX:
		*write_method = write_m2paTimerTx;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PATIMERTY:
		*write_method = write_m2paTimerTy;
		long_ret = 0;
		return (u_char *) &long_ret;
	case M2PANUMBEROFCONGESTIONSTATES:
		*write_method = write_m2paNumberOfCongestionStates;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PAINITIALLEVELOFCONGESTION:
		*write_method = write_m2paInitialLevelOfCongestion;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PARECEIVECONGESTIONTHRESHOLDABATEMENT:
		*write_method = write_m2paReceiveCongestionThresholdAbatement;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PARECEIVECONGESTIONTHRESHOLDONSET:
		*write_method = write_m2paReceiveCongestionThresholdOnset;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PARECEIVECONGESTIONTHRESHOLDDISCARD:
		*write_method = write_m2paReceiveCongestionThresholdDiscard;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PAPROTOCOLPROFILENAME:
		*write_method = write_m2paProtocolProfileName;
		*string = 0;
		*var_len = strlen(string);
		return (u_char *) string;
	case M2PATRANSCONGTHRESHOLDABATEMENTL2MESSAGES:
		*write_method = write_m2paTransCongThresholdAbatementL2Messages;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDABATEMENTL2OCTETS:
		*write_method = write_m2paTransCongThresholdAbatementL2Octets;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDONSETL2MESSAGES:
		*write_method = write_m2paTransCongThresholdOnsetL2Messages;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDONSETL2OCTETS:
		*write_method = write_m2paTransCongThresholdOnsetL2Octets;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDABATEMENTL3MESSAGES:
		*write_method = write_m2paTransCongThresholdAbatementL3Messages;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDABATEMENTL3OCTETS:
		*write_method = write_m2paTransCongThresholdAbatementL3Octets;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDONSETL3MESSAGES:
		*write_method = write_m2paTransCongThresholdOnsetL3Messages;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDONSETL3OCTETS:
		*write_method = write_m2paTransCongThresholdOnsetL3Octets;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDDISCARDL1MESSAGES:
		*write_method = write_m2paTransCongThresholdDiscardL1Messages;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDDISCARDL1OCTETS:
		*write_method = write_m2paTransCongThresholdDiscardL1Octets;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDDISCARDL2MESSAGES:
		*write_method = write_m2paTransCongThresholdDiscardL2Messages;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDDISCARDL2OCTETS:
		*write_method = write_m2paTransCongThresholdDiscardL2Octets;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDDISCARDL3MESSAGES:
		*write_method = write_m2paTransCongThresholdDiscardL3Messages;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PATRANSCONGTHRESHOLDDISCARDL3OCTETS:
		*write_method = write_m2paTransCongThresholdDiscardL3Octets;
		ulong_ret = 0;
		return (u_char *) &ulong_ret;
	case M2PAPROTOCOLPROFILEROWSTATUS:
		*write_method = write_m2paProtocolProfileRowStatus;
		long_ret = 0;
		return (u_char *) &long_ret;

	default:
		ERROR_MSG("");
	}
	return NULL;
}

int
write_m2paN1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paN1 not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paN1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paProving(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paProving not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paProving: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paManagementProvingState(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paManagementProvingState not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paManagementProvingState: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paLoopDelayLower(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paLoopDelayLower not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paLoopDelayLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paLoopDelayUpper(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paLoopDelayUpper not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paLoopDelayUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransmissionRateIntervalLower(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransmissionRateIntervalLower not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransmissionRateIntervalLower: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransmissionRateIntervalUpper(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransmissionRateIntervalUpper not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransmissionRateIntervalUpper: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpNoDelay(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpMaxseg(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpHeartbeatItvl(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paSctpHeartbeatItvl not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpHeartbeat(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpRtoInitial(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paSctpRtoInitial not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpRtoMin(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paSctpRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpRtoMax(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paSctpRtoMax not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpPathMaxRetrans(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpCookieLife(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paSctpCookieLife not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpCookieInc(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paSctpCookieInc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpMaxInitRetries(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpMaxBurst(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpAssocMaxRetrans(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpSackDelay(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paSctpSackDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paSctpLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paSctpLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT1(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerT1 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerT1: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT2(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerT2 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerT2: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT2L(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerT2L not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerT2L: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT2H(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerT2H not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerT2H: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT3(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerT3 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerT3: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT4N(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerT4N not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerT4N: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT4E(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerT4E not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerT4E: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT6(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerT6 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerT6: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerT7(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerT7 not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerT7: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL1Messages(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL1Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL1Messages: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL1Octets(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL1Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL1Octets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL1Messages(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL1Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL1Messages: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL1Octets(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL1Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL1Octets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paProvingAttempts(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paProvingAttempts not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paProvingAttempts: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paNumberOfThresholdLevels(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paNumberOfThresholdLevels not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paNumberOfThresholdLevels: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paCongestionCounting(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paCongestionCounting not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paCongestionCounting: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paCongestionReportingBaseObject(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paCongestionReportingBaseObject not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paCongestionReportingBaseObject: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerTx(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerTx not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerTx: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTimerTy(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paTimerTy not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paTimerTy: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paNumberOfCongestionStates(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paNumberOfCongestionStates not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paNumberOfCongestionStates: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paInitialLevelOfCongestion(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paInitialLevelOfCongestion not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paInitialLevelOfCongestion: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paReceiveCongestionThresholdAbatement(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paReceiveCongestionThresholdAbatement not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paReceiveCongestionThresholdAbatement: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paReceiveCongestionThresholdOnset(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paReceiveCongestionThresholdOnset not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paReceiveCongestionThresholdOnset: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paReceiveCongestionThresholdDiscard(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paReceiveCongestionThresholdDiscard not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paReceiveCongestionThresholdDiscard: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paProtocolProfileName(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static uint8_t string[SPRINT_MAX_LEN];
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_OCTET_STR) {
			fprintf(stderr, "write to m2paProtocolProfileName not ASN_OCTET_STR\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(string)) {
			fprintf(stderr, "write to m2paProtocolProfileName: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		string = (uint8_t *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in string for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL2Messages(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL2Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL2Messages: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL2Octets(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL2Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL2Octets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL2Messages(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL2Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL2Messages: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL2Octets(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL2Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL2Octets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL3Messages(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL3Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL3Messages: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdAbatementL3Octets(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL3Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdAbatementL3Octets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL3Messages(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL3Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL3Messages: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdOnsetL3Octets(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL3Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdOnsetL3Octets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL1Messages(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL1Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL1Messages: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL1Octets(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL1Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL1Octets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL2Messages(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL2Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL2Messages: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL2Octets(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL2Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL2Octets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL3Messages(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL3Messages not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL3Messages: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paTransCongThresholdDiscardL3Octets(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL3Octets not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paTransCongThresholdDiscardL3Octets: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paProtocolProfileRowStatus(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paProtocolProfileRowStatus not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paProtocolProfileRowStatus: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpNoDelay(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paDefaultSctpNoDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpNoDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpMaxseg(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paDefaultSctpMaxseg not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpMaxseg: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpHeartbeatItvl(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paDefaultSctpHeartbeatItvl not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpHeartbeatItvl: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpHeartbeat(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paDefaultSctpHeartbeat not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpHeartbeat: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpRtoInitial(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paDefaultSctpRtoInitial not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpRtoInitial: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpRtoMin(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paDefaultSctpRtoMin not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpRtoMin: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpRtoMax(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paDefaultSctpRtoMax not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpRtoMax: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpPathMaxRetrans(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paDefaultSctpPathMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpPathMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpCookieLife(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paDefaultSctpCookieLife not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpCookieLife: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpCookieInc(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paDefaultSctpCookieInc not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpCookieInc: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpMaxInitRetries(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paDefaultSctpMaxInitRetries not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpMaxInitRetries: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpMaxBurst(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paDefaultSctpMaxBurst not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpMaxBurst: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpAssocMaxRetrans(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static unsigned long *ulong_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_UNSIGNED) {
			fprintf(stderr, "write to m2paDefaultSctpAssocMaxRetrans not ASN_UNSIGNED\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(ulong_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpAssocMaxRetrans: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		ulong_ret = (unsigned long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in ulong_ret for you to use, and you have just been 
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpSackDelay(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paDefaultSctpSackDelay not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpSackDelay: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}

int
write_m2paDefaultSctpLifetime(int action, unsigned char *var_val, unsigned char var_val_type, size_t var_val_len, unsigned char *statP, oid * name, size_t name_len)
{
	static long *long_ret;
	int size;

	switch (action) {
	case RESERVE1:
		if (var_val_type != ASN_INTEGER) {
			fprintf(stderr, "write to m2paDefaultSctpLifetime not ASN_INTEGER\n");
			return SNMP_ERR_WRONGTYPE;
		}
		if (var_val_len > sizeof(long_ret)) {
			fprintf(stderr, "write to m2paDefaultSctpLifetime: bad length\n");
			return SNMP_ERR_WRONGLENGTH;
		}
		break;

	case RESERVE2:
		size = var_val_len;
		long_ret = (long *) var_val;

		break;

	case FREE:
		/* Release any resources that have been allocated */
		break;

	case ACTION:
		/* The variable has been stored in long_ret for you to use, and you have just been
		   asked to do something with it.  Note that anything done here must be reversable
		   in the UNDO case */
		break;

	case UNDO:
		/* Back out any changes made in the ACTION case */
		break;

	case COMMIT:
		/* Things are working well, so it's now safe to make the change permanently.  Make
		   sure that anything done here can't fail! */
		break;
	}
	return SNMP_ERR_NOERROR;
}
