/*                               -*- Mode: C -*- 
 * mod.c --- module mgmt
 * Author          : Francisco J. Ballesteros Camara
 * Created On      : Thu Jun 29 11:03:59 1995
 * Last Modified By: John A. Boyd Jr.
 * Purpose         : provide LiS STREAMS modules glue
 * ----------------______________________________________________
 *
 *    Copyright (C) 1995  Francisco J. Ballesteros, Denis Froschauer
 *    Copyright (C) 1997  David Grothe, Gcom, Inc <dave@gcom.com>
 *    Copyright (C) 1999  Ole Husgaard <sparre@login.dknet.dk>
 *    Copyright (C) 2000  John A. Boyd Jr.  protologos, LLC
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330, Cambridge,
 * MA 02139, USA.
 * 
 *
 *    You can reach us by email to any of
 *    nemo@ordago.uc3m.es, 100741.1151@compuserve.com
 */

#ident "@(#) LiS mod.c 2.22 11/22/03 23:01:43 "


/*  -------------------------------------------------------------------  */
/*				 Dependencies                            */

#if 0
#include <sys/strport.h>
#include <sys/strconfig.h>	/* config definitions	*/
#include <sys/stropts.h>	/* struct str_list	*/
#include <sys/LiS/share.h>	/* streams shared defs	*/
#include <sys/LiS/queue.h>	/* streams queues	*/
#include <sys/LiS/mod.h>	/* module interface	*/
#endif

#include <sys/stream.h>
#if defined(LINUX)		/* compiling for Linux kernel */
#include <linux/sched.h>
#include <linux/ioport.h>
#if defined(KERNEL_2_3)
#undef module_info		/* LiS definition */
#define module_info	kernel_module_info
#include <linux/module.h>
#undef module_info
#endif
#include <linux/ptrace.h>	/* for pt_regs */
#include <sys/osif.h>
#endif

/*  -------------------------------------------------------------------  */
/*				  Glob. vars                             */

struct fmodsw lis_fstr_sw[MAX_STRDEV];	/* streams devices */
struct fmodsw lis_fmod_sw[MAX_STRMOD];	/* streams modules */

extern struct file_operations lis_streams_fops;


/*  -------------------------------------------------------------------  */
/*				   Symbols                               */

int lis_fmodcnt; /* (largest module id used) + 1 */

/*
 *  Module autopush list
 */
typedef struct autopush_list {
	unsigned npush;
	modID_t mod[MAXAPUSH];
} autopush_list_t;

/*
 *  Module autopush entry
 *
 *  These form a chain for each major.
 *  The chain is sorted by the minor field.
 */
typedef struct autopush {
	struct autopush *next;
	unsigned cmd;
	minor_t minor;
	minor_t lastminor;
	autopush_list_t push;
} autopush_t;

lis_spin_lock_t	   lis_apush_lock ;		/* normal spin-lock */
static autopush_t *apush[MAX_STRDEV];
static unsigned *apush_nref[MAX_STRMOD];


/*  -------------------------------------------------------------------  */
/*		   Driver and module configuration                       */

/*
 *  The file head/<target>/modconf.c (generated by the strconf utility)
 *  used to be compiled as a seperate object file.
 *  But now it only needs to be known locally in this file.
 *  When we include it here instead, we can move the declarations for the
 *  types used in it from global scope in <sys/LiS/mod.h> to local scope in
 *  this file, reducing overall LiS complexity.
 *  To reflect this change, the name is changed from modconf.c to modconf.inc.
 */ 

/*
 * Module Configuration
 *
 * In order to initialize configured linked streams modules a table of the
 * following form must be linked into the streams code.
 * There is one entry per configured linked module.
 *
 * The fields are:
 *
 *      cnf_name        The ASCII string name of the module.
 *      cnf_str         A pointer to the streamtab entry for the module.
 *      		Loadable modules have NULL.
 *      cnf_objname	Non-empty means loadable
 * 
 * This table is used at initialization time to register all registered
 * linked modules with streams, thus inserting them into the fmod_sw table.
 * 
 * The final entry in the table consists of {"", NULL, ""}.
 *
 * The file modconf.c provides such a table and is automatically
 * generated by the strconf utility.  DO NOT EDIT modconf.c BY HAND.
 */
typedef struct module_config
{
    char               cnf_name[LIS_NAMESZ+1];
    struct streamtab  *cnf_str;
    char               cnf_objname[LIS_NAMESZ+1];

} module_config_t ;

/*
 * Driver Configuration
 *
 * In order to initialize configured linked streams drivers a table of the
 * following form must be linked into the streams code.
 * There is one entry per configured linked driver.
 *
 * The fields are as follows:
 *
 *      cnf_name        ASCII string name associated with the driver.
 *      cnf_str         Pointer to the driver's streamtab entry.
 *      cnf_major       The major device numbers to associate with the driver.
 *                      These must correspond with the major device number
 *                      used in a mknod() system call from user level
 *                      to make the devices corresponding to this driver.
 *      cnf_n_majors    The number of majors associated with the driver.
 *      cnf_n_minors    The number of minors associated with the driver.
 *      cnf_init        A pointer to the init routine of the driver.  NULL
 *                      if the driver has no init routine.
 *
 * This table is used at initialization time to register all configured
 * linked drivers with streams, thus getting them into the fstr_sw table.
 *
 * The final entry in the table is of the form:
 *
 *      {"", NULL, NULL, 0, 0, 0, NULL}
 * 
 * The file modconf.c provides such a table and is generated by the
 * strconf utility.  DO NOT EDIT modconf.c BY HAND.
 * 
 */
typedef struct driver_config
{
    char                 cnf_name[LIS_NAMESZ+1];  /* longer driver names */
    struct streamtab    *cnf_str;
    int                 *cnf_major;
    int                  cnf_n_majors;
    int                  cnf_n_minors;
    void                (*cnf_init)(void);
    void		(*cnf_term)(void);

} driver_config_t ;

#if !defined(LINUX) && !defined(_PPC_LIS_)
struct pt_regs { void	*nothing; } ;
#endif
typedef struct device_config
{
	char		*name;
	char 		*prefix;
	struct streamtab *strtb;
	void (*handler)(int,void *,struct pt_regs *);
	int		unit;
	long		port;
	int		nports;
	int		irq_share;
	int 		irq;
	long 		mem;
	long		mem_size;
	int		dma1;
	int		dma2;
	int 		major;
	int		minor;
} device_config_t;

#ifdef LIS_LOADABLE_SUPPORT

/*
 * Loadable driver object names
 *
 * This table contains the object names of all configured loadable drivers.
 * It is sorted on the driver major device number field.
 *
 * This tells LiS how to ask kerneld(8) to load the kernel module that
 * contains the streams driver.
 *
 * The file modconf.c provides such a table and is generated by the
 * strconf utility.  DO NOT EDIT modconf.c BY HAND.
 * 
 */
typedef struct driver_obj_name {
    const int          *major;   /* The driver major device number      */
    const int           nmajors;
    const char         *initname;/* The initialization function name    */
    const char         *objname; /* The kernel object name              */
} driver_obj_name_t;

#endif /* ifdef LIS_LOADABLE_SUPPORT */

/*
 * Autopush initialzation specification
 *
 * This table contains the initial autopush specification. This is the
 * autopush configuration that is done when streams is started.
 *
 */
typedef struct autopush_init {
    const int          major;
    const int          minor;
    const int          lastminor;
    const int	       npush;
    const char	       mods[MAXAPUSH][LIS_NAMESZ+1];
} autopush_init_t;

/*
 *  The include itself
 *
 *  It is not included when doing dependencies,
 *  but we have a manual dependency in the makefile.
 */
#ifndef DEP
#include "modconf.inc"
#endif

/*
 *  We know the size of the tables
 */
#define DRV_CONFIG_SIZE \
	( sizeof(lis_driver_config) / sizeof(driver_config_t) )

#define DEVICE_CONFIG_SIZE \
	( sizeof(lis_device_config) / sizeof(device_config_t) )

#define MOD_CONFIG_SIZE \
	( sizeof(lis_module_config) / sizeof(module_config_t) )

#define AP_CONFIG_SIZE \
	( sizeof(lis_apush_init) / sizeof(autopush_init_t) )

#ifdef LIS_LOADABLE_SUPPORT

#define DRV_OBJNAMES_SIZE \
	( sizeof(lis_drv_objnames) / sizeof(driver_obj_name_t) )

#define MOD_OBJNAMES_SIZE \
	( sizeof(lis_mod_objnames) / sizeof(module_obj_name_t) )

#endif

/*
 *  Return the index into lis_fmod_sw[] of a module name,
 *  or -1 if not found.
 */
static
int find_mod(const char *name)
{
	int i;

	for (i = 1; i <= lis_fmodcnt; ++i)
		if (!strcmp(name, lis_fmod_sw[i].f_name))
			return i;
	return -1;
}

#if defined(LINUX)
static
int find_dev_objname(const char *name)
{
	int i;

	for(i=0; i<DEVICE_CONFIG_SIZE; i++)
	{
	    if (strcmp(name,lis_device_config[i].name) == 0)
		return i;
	}
	return -1;
}

static
int find_dev_by_major(major_t major)
{
	int i;

	for(i=0; i<DEVICE_CONFIG_SIZE; i++)
	{
	    if (lis_device_config[i].major == major)
		return i;
	}
	return -1;
}
#endif

/*
 *  Return the index into lis_drv_objnames[] of a driver major,
 *  or -1 if not found.
 */
static
int find_drv_objname(major_t major)
{
#ifdef LIS_LOADABLE_SUPPORT
	int i,j;

	for (i = 0; i < DRV_OBJNAMES_SIZE; i++)
	    for (j = 0;  j < lis_drv_objnames[i].nmajors; j++)
		if (major == lis_drv_objnames[i].major[j])
			return i;
#endif
	return -1;
}


/*  -------------------------------------------------------------------  */
/*			   Local functions & macros                      */

/*
 *  Free an autopush entry
 */
static void apush_free(autopush_t *a)
{
	int i;

	ASSERT(a->push.npush >= 0);
	ASSERT(a->push.npush <= MAXAPUSH);

	for (i = 0; i < a->push.npush; ++i) {
		ASSERT(a->push.mod[i] > 0);
		ASSERT(a->push.mod[i] < MAX_STRMOD);
		ASSERT(apush_nref[a->push.mod[i]] > 0);

		--apush_nref[a->push.mod[i]];
	}

	FREE(a);
}

/*
 *  Clear the autopush configuration for a major device number
 */
static void apush_free_major(major_t major)
{
	autopush_t *a, *b;

	ASSERT(major < MAX_STRDEV);

	if ((a = apush[major]) == NULL)
		return;

	apush[major] = NULL;

	while (a != NULL) {
		b = a;
		a = a->next;
		apush_free(b);
	}
}

/*
 *  Clear the autopush configuration
 */
static void apush_free_all(void)
{
	int i;

	for (i = 0; i < MAX_STRDEV; ++i)
		apush_free_major(i);

	/* Pure paranoia: Can go away when we know this stuff works */
	for (i = 0; i < MAX_STRMOD; ++i)
		ASSERT(apush_nref[i] == 0);
}

/*
 *  Remove a module from all autopush lists
 */
static void apush_drop_mod(modID_t mod)
{
	int i;

	ASSERT(mod > 0);
	ASSERT(mod < MAX_STRMOD);

	if (apush_nref[mod] == 0)
		return;

	for (i = 0; i < MAX_STRDEV; ++i) {
		autopush_t *a;

		for (a = apush[i]; a != NULL; a = a->next) {
			int j = 0;

			while (j < a->push.npush) {
				if (a->push.mod[j] == mod) {
					int k;

					for (k = j + 1; k < a->push.npush; ++k)
					    a->push.mod[k-1] = a->push.mod[k];
					--a->push.npush;
					if (--apush_nref[mod] == 0)
						return;
				} else
					++j;
			}
		}
	}
}

/*
 *  Validate an autopush module list
 */
static int apush_validate(autopush_list_t *list)
{
	int i;

	if (list->npush < 0 || list->npush > MAXAPUSH)
		return -1;
	for (i = 0; i < list->npush; ++i) {
		modID_t mod = list->mod[i];

		if (lis_fmod_sw[mod].f_state & LIS_MODSTATE_INITED)
			continue; /* registered */
		return -1; /* not registered or configured */
	}
	return 0;
}

/*
 *  Do autopush configuration
 */
static int apush_conf(major_t major, autopush_t *a)
{
	autopush_t *ar, **ap;
	int i;

	if (major >= MAX_STRDEV)
		return -ENODEV;

	if (lis_fstr_sw[major].f_str == NULL) {
		/* Driver is not present */
#if defined(LIS_LOADABLE_SUPPORT)
		/* Is it a configured loadable? */
		if (find_drv_objname(major) < 0)
			return -ENODEV;
#else
		return -ENODEV;
#endif
	}

	/*
	 *  Check for conflicting entries and insert new entry.
	 *
	 *  This code may look a bit hairy. I have tried to state
	 *  inherited predicates in the form of ASSERT's to clarify.
	 */
	switch (a->cmd) {
	    case SAP_CLEAR:
		if (apush[major] == NULL) {
		        /* FREE(a); */
			return -ENODEV;
		}
		ap = &apush[major];
		if (a->minor == 0 && (*ap)->cmd == SAP_ALL) {
			ASSERT((*ap)->next == NULL);
			ar = *ap;
			*ap = (*ap)->next;
			apush_free(ar);
		        FREE(a);
			return 0;
		}
		for (;;) {
			ar = *ap;
			if (ar == NULL) {
				/* FREE(a); */
				return -ERANGE;
			}
			if (ar->minor > a->minor) {
				/* FREE(a); */
				return -ERANGE;
			}
			if (ar->minor == a->minor) {
				*ap = ar->next;
				apush_free(ar);
				FREE(a);
				return 0;
			}
			ap = &ar->next;
		}
		/*NOTREACHED*/
	   case SAP_ONE:
		ASSERT(apush_validate(&a->push) >= 0);
		ap = &apush[major];
		if (*ap != NULL) {
			if ((*ap)->cmd == SAP_ALL)
				return -EEXIST;
			for (;;) {
				ar = *ap;
				if (ar == NULL)
					break; /* insert at end of chain */
				if (ar->minor > a->minor)
					break; /* insert here */
				if (ar->cmd == SAP_ONE) {
					if (ar->minor == a->minor)
						return -EEXIST;
				} else {
					ASSERT(ar->cmd == SAP_RANGE);
					ASSERT(a->minor >= ar->minor);
					if (a->minor <= ar->lastminor)
						return -EEXIST;
				}
				ap = &ar->next;
			}
		}
		a->next = *ap;
		*ap = a;
		break;
	    case SAP_RANGE:
		ASSERT(apush_validate(&a->push) >= 0);
		if (a->minor >= a->lastminor)
			return -ERANGE;
		ap = &apush[major];
		if (*ap != NULL) {
			if ((*ap)->cmd == SAP_ALL)
				return -EEXIST;
			for (;;) {
				ar = *ap;
				if (ar == NULL)
					break; /* insert at end of chain */
				if (ar->minor > a->lastminor)
					break; /* insert here */
				if (ar->minor >= a->minor) {
					ASSERT(ar->minor <= a->lastminor);
					return -EEXIST;
				}
				if (ar->cmd != SAP_ONE) {
					ASSERT(ar->cmd == SAP_RANGE);
					ASSERT(ar->minor <= a->lastminor);
					ASSERT(ar->minor < a->minor);
					ASSERT(a->minor < a->lastminor);
					ASSERT(ar->minor < a->lastminor);
					if (ar->lastminor <= a->lastminor
					    || ar->lastminor >= a->minor)
						return -EEXIST;
				}
				ap = &ar->next;
			}
		}
		a->next = *ap;
		*ap = a;
		break;
	    case SAP_ALL:
		ASSERT(apush_validate(&a->push) >= 0);
		if (apush[major] != NULL)
			return -EEXIST;
		a->next = NULL;
		apush[major] = a;
		break;
	    default:
		return -EINVAL;
	}

	for (i = 0; i < a->push.npush; ++i)
		++apush_nref[a->push.mod[i]];

	return 0;
}

static struct autopush *find_apush_entry(major_t major, minor_t minor)
{
	struct autopush *a;

	ASSERT(major < MAX_STRDEV);

	for (a = apush[major]; a != NULL; a = a->next) {
		ASSERT(a->cmd==SAP_ALL || a->cmd==SAP_ONE || a->cmd==SAP_RANGE);

		if (a->cmd == SAP_ALL)
			break;
		if (a->minor > minor)
			return NULL;
		if (a->minor == minor)
			break;
		if (a->cmd == SAP_RANGE && a->lastminor <= minor)
			break;
	}

	ASSERT(a == NULL || a->minor <= minor);

	return a;
}


/*  -------------------------------------------------------------------  */
/*			Exported functions & macros                      */


/*  -------------------------------------------------------------------  */
/* register a new module
 */
modID_t
lis_register_strmod(struct streamtab *strtab, const char *name)
{
	modID_t id = LIS_NULL_MID;
	int	inx ;
	int	new_entry = 0 ;

	if (name == NULL)
		return LIS_NULL_MID;

	/* See if the module is already registered */
	if (strtab != NULL)
	{
	    for (id = 1; id < lis_fmodcnt; ++id)
		if (lis_fmod_sw[id].f_str == strtab)
		    return(id) ;	/* return existing slot number */
	}

	inx = find_mod(name) ;		/* find by name */
	if (inx > 0)
	    id = inx ;			/* found */
	else
	{				/* not in the table */
	    /* Find a free id */
	    for (id = 1; id < lis_fmodcnt; ++id)
		if (lis_fmod_sw[id].f_name[0] == 0)
		{
		    new_entry = 1 ;
		    break;
		}
	}

	if (id == lis_fmodcnt) {
		if (id == MAX_STRMOD) {
			printk("Unable to register module \"%s\", "
			       "all lis_fmod_sw slots in use.\n", name);
			return LIS_NULL_MID;
		}
		lis_fmodcnt++;
	}

	lis_fmod_sw[id].f_str = strtab;	/* always save strtab */

	if (!(lis_fmod_sw[id].f_state & LIS_MODSTATE_INITED))
	{				/* do this once */
	    lis_fmod_sw[id].f_count = 0;
	    strncpy(lis_fmod_sw[id].f_name, name, LIS_NAMESZ);
	    lis_sem_init(&lis_fmod_sw[id].f_sem, 1) ;
	    if (new_entry && strtab)	/* must be extl module, now loaded */
		lis_fmod_sw[id].f_state = LIS_MODSTATE_LOADED ;
	    lis_fmod_sw[id].f_state |= LIS_MODSTATE_INITED ;
	}

	printk("STREAMS module \"%s\" registered%s, id %d\n",
	       lis_fmod_sw[id].f_name,
	       strtab == NULL ? " (loadable)" : "",
	       id);

	return id;
} /* lis_register_strmod */

/*  -------------------------------------------------------------------  */
/* unregister this module
 */
static int unregister_module(fmodsw_t *slot)
{
    modID_t id;
    int	    err;
    char    name[LIS_NAMESZ + 1];

    if (!(slot->f_state & LIS_MODSTATE_INITED))
	return(0) ;			/* already done */

    if (slot->f_count)
    {
	printk("LiS: unregister module \"%s\" f_count=%d -- busy\n",
		slot->f_name, slot->f_count) ;
	return -EBUSY;
    }

    strncpy(name, slot->f_name, LIS_NAMESZ);
    id = slot - lis_fmod_sw;

    if ((err = lis_down(&slot->f_sem)) < 0)
    {
	printk("LiS: unregister module \"%s\" semaphore-error=%d\n",
		slot->f_name, err) ;
       return(err);
    }

    switch (slot->f_state & LIS_MODSTATE_MASK)
    {
    case LIS_MODSTATE_LINKED:
    case LIS_MODSTATE_LOADED:
	break ;

    case LIS_MODSTATE_LOADING:
	lis_up(&slot->f_sem) ;
	printk("LiS: unregister module \"%s\" -- loading\n", slot->f_name) ;
	return(-EBUSY) ;

    case LIS_MODSTATE_UNLOADED:
	slot->f_str = NULL;
	break ;
    }

    apush_drop_mod(id);
    lis_up(&slot->f_sem) ;
    lis_sem_destroy(&slot->f_sem) ;
    slot->f_state &= ~LIS_MODSTATE_INITED ;

    printk("STREAMS module \"%s\" unregistered, id %d\n", name, id);

    return 0;
}

int
lis_unregister_strmod(struct streamtab *strtab)
{
    fmodsw_t *slot;

    for (slot = lis_fmod_sw + lis_fmodcnt; 
	 slot != lis_fmod_sw + 1 && slot->f_str != strtab; slot--)
	    ;
    if (slot->f_str != strtab)
	    return -EINVAL;

    return(unregister_module(slot)) ;

} /* lis_unregister_strmod */

/*  -------------------------------------------------------------------  */
/* Find module by name in lis_fmod_sw[] 
 */
modID_t
lis_findmod(const char *name)
{
    int id;
    
    if (!name || !*name)
	return(LIS_NULL_MID) ;
    
    /* Look for the module */
    for (id = lis_fmodcnt; id > 0; id--)
	if (!strcmp(lis_fmod_sw[id].f_name, name))
	    break ;

    return (id > 0 ? id : LIS_NULL_MID);
} /* lis_findmod */

/*  -------------------------------------------------------------------  */
/* Load module by name into lis_fmod_sw[]
 */
modID_t
lis_loadmod(const char *name)
{
	int id = lis_findmod(name);
	int err;
	int configured;
	const char *objname;
#ifdef LIS_LOADABLE_SUPPORT
	char req[LIS_NAMESZ + 10];
#endif

	if (id == LIS_NULL_MID)
	    return LIS_NULL_MID;

	/* Find object name of this module */
	objname = name; /* default objname */
	configured = 0;
	if (lis_fmod_sw[id].f_objname[0])
	{
	    objname = lis_fmod_sw[id].f_objname ;
	    configured = 1;
	}

	if ((err = lis_down(&lis_fmod_sw[id].f_sem)) < 0)
	   return(LIS_NULL_MID);

	switch (lis_fmod_sw[id].f_state & LIS_MODSTATE_MASK)
	{
	case LIS_MODSTATE_LINKED:
	case LIS_MODSTATE_LOADED:
	    lis_up(&lis_fmod_sw[id].f_sem) ;
	    return id ;				/* found and loaded */

	case LIS_MODSTATE_UNLOADED:		/* needs loading */
	    break ;

	case LIS_MODSTATE_LOADING:
	    printk("Bad module state for %s (LOADING)\n", name) ;
	    lis_up(&lis_fmod_sw[id].f_sem) ;
	    return(LIS_NULL_MID);
	}

#ifdef LIS_LOADABLE_SUPPORT
	/* Ask kerneld to load the module.
	 * When the module loads it will call lis_register_strmod()
	 * to register itself and will then acquire an available
	 * slot in the fmod_sw table.  So if the module can now
	 * be found the load succeeded, otherwise not.
	 */
	sprintf(req, "streams-%s", objname);
	lis_fmod_sw[id].f_state &= ~LIS_MODSTATE_MASK ;
	lis_fmod_sw[id].f_state |= LIS_MODSTATE_LOADING ;
	if (request_module(req) < 0 || lis_fmod_sw[id].f_str == NULL)
	{
	    if (configured)
		printk("Unable to demand load LiS objname %s, "
		       "STREAMS module %s\n ",
				       objname, (name) ? name : "(null)");
	    else
		printk("Unable to demand load STREAMS module %s\n",
					       (name) ? name : "(null)");

	    lis_fmod_sw[id].f_state &= ~LIS_MODSTATE_MASK ;
	    lis_fmod_sw[id].f_state |= LIS_MODSTATE_UNLOADED ;
	    lis_up(&lis_fmod_sw[id].f_sem) ;
	    return LIS_NULL_MID;
	}

	lis_fmod_sw[id].f_state &= ~LIS_MODSTATE_MASK ;
	lis_fmod_sw[id].f_state |= LIS_MODSTATE_LOADED ;
#else
	printk("Cannot load %s, LIS_LOADABLE_SUPPORT not set\n", name) ;
	id = LIS_NULL_MID;
#endif

	lis_up(&lis_fmod_sw[id].f_sem) ;
	return id;
} /* lis_loadmod */

/*  -------------------------------------------------------------------  */
void
lis_enable_intr(struct streamtab *strtab, int major, const char *name)
{
#if defined(LINUX)
    int			 i = 0;
    device_config_t	*devptr;
    int			 retval;
    
    i = find_dev_objname(name);
    if (i < 0)
	return;

    devptr = &lis_device_config[i];
    if (devptr->irq <= 0)
	return ;

    retval =  request_irq(devptr->irq, devptr->handler, 0, name, NULL);
    if (retval)
    {
	printk("lis_enable_intr(%s): request_irq(%d) failed: %d\n",
		name, devptr->irq, retval);
	return;
    }

    if (devptr->port > 0 && devptr->nports > 0)
    {
	if (!(retval = check_region(devptr->port, devptr->nports)))
	    request_region(devptr->port, devptr->nports, name);

	if (retval)
	{
	    printk("lis_enable_intr(%s): "
		   "check_region(0x%lx,%d) failed: %d\n",
		    name, devptr->port, devptr->nports, retval);
	    return;
	}
    }

    printk("Registered IRQ %d for STREAMS driver %s\n", devptr->irq, name) ;
#endif
}

/*  -------------------------------------------------------------------  */
/* register a new streams device
 */
int 
lis_register_strdev(major_t major, 
		    struct streamtab *strtab, int nminor, const char *name)
{
	int rslt;
	fmodsw_t *slot;

	if (strtab == NULL)
	{
	    printk("STREAMS driver \"%s\" major %u not registered: "
		    "NULL strtab pointer\n",
		    (name != NULL) ? name : "", major) ;
	    return(-EINVAL) ;		/* invalid parameters */
	}

	(void)nminor; /* ignore minor count, compiler happiness */

	rslt = register_chrdev(major, name, &lis_streams_fops);
	if (rslt < 0) {
		printk("Unable to get major %lu "
		       "for stream driver \"%s\", errno=%d\n",
		       major, (name != NULL) ? name : "", rslt);
		return -EIO;
	}

	if (major == 0)			/* register routine assigned it */
		major = rslt;

	slot = &lis_fstr_sw[major];

	if (slot->f_str != strtab && slot->f_str != NULL) {
		printk("Unable to register major %lu "
		       "for stream driver \"%s\": In use for driver \"%s\".\n",
		       major, (name != NULL) ? name : "", slot->f_name);
		return -EBUSY;
	}

	lis_enable_intr(strtab,major,name);

	slot->f_str = strtab;
	slot->f_count = 0;
	if (name)
		strncpy(slot->f_name, name, LIS_NAMESZ);
	else
		*slot->f_name = '\0';

	printk("STREAMS driver \"%s\" registered, major %lu\n",
	       slot->f_name, major);

	return major;
} /* lis_register_strdev */

/*  -------------------------------------------------------------------  */
/* unregister a streams device
 */
int 
lis_unregister_strdev(major_t major)
{
	if (major >= MAX_STRDEV || lis_fstr_sw[major].f_str == NULL) {
		printk("STREAMS driver not registered, "
		       "cannot unregister major %lu\n", major);
		return -ENODEV;
	}

	if (lis_fstr_sw[major].f_count) {
		printk("STREAMS driver \"%s\" has open count %d, "
		       "cannot unregister major %lu\n",
		       lis_fstr_sw[major].f_name, lis_fstr_sw[major].f_count,
		       major);
		return -EBUSY;
	}

	apush_free_major(major);

#if defined(LINUX)			/* linux kernel */
	{
	    int	 	 	 i ;
	    device_config_t	*devptr ;

	    i = find_dev_by_major(major) ;
	    if (i >= 0)
	    {
		devptr = &lis_device_config[i] ;
		if (devptr->irq > 0)
		{
		    free_irq(devptr->irq, NULL) ;
		
		    if (devptr->port > 0 && devptr->nports > 0)
			release_region(devptr->port, devptr->nports);
		}
	    }
	}
#endif
	lis_fstr_sw[major].f_str = NULL;
	unregister_chrdev(major, lis_fstr_sw[major].f_name);

	printk("STREAMS driver \"%s\" unregistered, major %lu\n",
	       lis_fstr_sw[major].f_name, major);

	return 0;
} /* lis_unregister_strdev */

/*  -------------------------------------------------------------------  */
/* Find a driver by major device number and return a pointer to
 * its streamtab entry.
 */
streamtab_t *
lis_find_strdev(major_t major)
{
	if (major >= MAX_STRDEV)
		return NULL;

#ifdef LIS_LOADABLE_SUPPORT
	if (lis_fstr_sw[major].f_str == NULL) {
		const char *objname = NULL, *initname = NULL;
		char name[30];
		int i;

		/* Find object name of this driver */
		if ((i = find_drv_objname(major)) >= 0) {
			objname = lis_drv_objnames[i].objname;
			initname = lis_drv_objnames[i].initname;
		}
		if (objname == NULL)
			sprintf(name, "char-major-%lu", major);
		else
			sprintf(name, "streams-%s", objname);

		request_module(name);

		if (lis_fstr_sw[major].f_str == NULL) {
			if (objname != NULL) {
			    sprintf(name, "char-major-%lu", major);
			    request_module(name);
			    if (lis_fstr_sw[major].f_str == NULL) {
				printk("Unable to demand load "
				       "configured STREAMS object %s, "
				       "device major %lu\n",
				       objname, major);
				return NULL;
			    }
			} else {
				printk("Unable to demand load "
				       "unconfigured STREAMS "
				       "device major %lu\n",
				       major);
				return NULL;
			}
		}
		if (initname != NULL) { /* call initialization */
			void (* init)(void);
#if defined(KERNEL_2_3)
			init = inter_module_get_request(initname, name) ;
#else
			/*
			 *  get_module_symbol() author forgot to declare
			 *  untouched arguments as "const char *".
			 *  Avoid warning by declaring prototype here
			 *  instead of including <linux/module.h>.
			 *  This is a bit dirty, but I *did* check the
			 *  function source.
			 */
			extern void *get_module_symbol(const char *,
						       const char *);

			init = get_module_symbol(name, initname);
#endif
			if (init == NULL)
				printk("lis_find_strdev(): "
				       "Unable to resolve init function %s "
				       "in module %s for major %lu\n",
				       initname, objname, major);
			else
			{
				(* init)();
#if defined(KERNEL_2_3)
				inter_module_put(initname) ;
#endif
			}
		}
	}
#endif
	return lis_fstr_sw[major].f_str;
} /* lis_find_strdev */


/*  -------------------------------------------------------------------  */
/*				 Autopush                                */

/*
 *  Get list of autopush modules for a device
 */
int lis_apushm(dev_t dev, const char *mods[])
{
	int major = STR_MAJOR(dev);
	int minor = STR_MINOR(dev);
	struct autopush *a;
	int i;

	if (major < 0 || major >= MAX_STRDEV)
		return 0;

	lis_spin_lock(&lis_apush_lock) ;
	if ((a = find_apush_entry(major, minor)) == NULL) {
		lis_spin_unlock(&lis_apush_lock) ;
		return 0;
	}

	for (i = 0; i < a->push.npush; ++i) {
		modID_t mod = a->push.mod[i];

		ASSERT(mod > 0);
		ASSERT(mod < MAX_STRMOD);
		ASSERT(lis_fmod_sw[mod].f_str != NULL);
		mods[i] = lis_fmod_sw[mod].f_name;
	}
	lis_spin_unlock(&lis_apush_lock) ;

	return a->push.npush;
} /* lis_apushm */

int lis_apush_set(struct strapush *ap)
{
	int i, j, err;
	autopush_t *a;

	ASSERT(ap != NULL);

	if (lis_fstr_sw[ap->sap_major].f_str == NULL) {
		/* Is this a configured loadable driver? */
		if (find_drv_objname(ap->sap_major) < 0)
			return -ENOSTR;
	}

	if (ap->sap_npush > MAXAPUSH)
		return -EINVAL;

	if ((a = ALLOC(sizeof(autopush_t))) == NULL)
		return -ENOSR;

	a->cmd = ap->sap_cmd;
	a->minor = ap->sap_minor;
	a->lastminor = ap->sap_lastminor;
	a->push.npush = ap->sap_npush;

	/* Get module IDs
	 *
	 * This implies a load for loadable modules since that is the
	 * only way to obtain their module id.
	 */
	for (i = 0; i < ap->sap_npush; ++i) {
		j = lis_loadmod(ap->sap_list[i]) ;
		if (j <= 0) {
			/* Unknown module */
			FREE(a);
			return -EINVAL;
		}
		a->push.mod[i] = j;
	}

	lis_spin_lock(&lis_apush_lock) ;
	if (apush_validate(&a->push) < 0) {
		lis_spin_unlock(&lis_apush_lock) ;
		FREE(a);
		return -EINVAL;
	}
	if ((err = apush_conf(ap->sap_major, a)) < 0) {
		lis_spin_unlock(&lis_apush_lock) ;
		FREE(a);
		return err;
	}
	lis_spin_unlock(&lis_apush_lock) ;

	return 0;
} /* lis_apush_set */

int lis_apush_get(struct strapush *ap)
{
	autopush_t *a;
	int i;

	if (ap->sap_major >= MAX_STRDEV)
		return -EINVAL;

	if (lis_fstr_sw[ap->sap_major].f_str == NULL) {
		/* Is this a configured loadable driver? */
		if (find_drv_objname(ap->sap_major) < 0)
			return -ENOSTR;
	}

	lis_spin_lock(&lis_apush_lock) ;
	if ((a = find_apush_entry(ap->sap_major, ap->sap_minor)) == NULL) {
		lis_spin_unlock(&lis_apush_lock) ;
		return -ENODEV;
	}

	ap->sap_cmd = a->cmd;
	ASSERT(ap->sap_minor == a->minor);
	ap->sap_lastminor = a->lastminor;
	ap->sap_npush = a->push.npush;

	for (i = 0; i < a->push.npush; ++i) {
	    modID_t id = a->push.mod[i];

	    ASSERT(id > 0);
	    ASSERT(id < MAX_STRMOD);
	    ASSERT(lis_fmod_sw[id].f_str != NULL);
	    strncpy(ap->sap_list[i], lis_fmod_sw[id].f_name, LIS_NAMESZ + 1);
	}
	lis_spin_unlock(&lis_apush_lock) ;

	return 0;
} /* lis_apush_get */

int lis_valid_mod_list(struct str_list ml)
{
	int i, j;
	struct str_mlist *lp;

	if (ml.sl_nmods <= 0)
		return -EINVAL;

	for (i = 0, lp = ml.sl_modlist; i < ml.sl_nmods; ++i, ++lp) {
		/* Nope, is it registered? */
		for (j = lis_fmodcnt; j > 0; j--)
			if (!strcmp(lp->l_name, lis_fmod_sw[j].f_name))
				break;
		if (j == 0)
			return 1; /* Unknown module */
	}

	return 0;
} /* lis_validate_mod_list */


/*
 *  Initialization
 */
void lis_init_mod(void)
{
	int i, j;
	int modid ;

	lis_spin_lock_init(&lis_apush_lock, "AutoPush-Lock") ;
	memset(lis_fstr_sw, 0, sizeof lis_fstr_sw);
	memset(lis_fmod_sw, 0, sizeof lis_fmod_sw);
	memset(apush,       0, sizeof apush);
	memset(apush_nref,  0, sizeof apush_nref);

	lis_fmodcnt = 1;

	for (i = 0; i < MOD_CONFIG_SIZE; ++i) {
		ASSERT(lis_fmodcnt < MAX_STRMOD);

		if (!lis_module_config[i].cnf_name[0])
		    continue ;			/* no name */

		modid = lis_register_strmod(lis_module_config[i].cnf_str,
					    lis_module_config[i].cnf_name) ;
		if (modid == LIS_NULL_MID)
		{
		    printk("Failed to register module \"%s\".\n",
				       lis_module_config[i].cnf_name);
		    continue ;
		}

		/*
		 * If the module has an object file name then it is
		 * loadable, otherwise it is linked in with LiS.
		 */
		strncpy(lis_fmod_sw[modid].f_objname,
			lis_module_config[i].cnf_objname, LIS_NAMESZ) ;
		lis_fmod_sw[i].f_state &= ~LIS_MODSTATE_MASK ;
		if (lis_fmod_sw[modid].f_objname[0])
		    lis_fmod_sw[modid].f_state |= LIS_MODSTATE_UNLOADED ;
		else
		    lis_fmod_sw[modid].f_state |= LIS_MODSTATE_LINKED ;
	}

	for (i = 0; i < DRV_CONFIG_SIZE; ++i) {
	    for (j = 0;  j < lis_driver_config[i].cnf_n_majors;  j++) {
		if (lis_register_strdev(lis_driver_config[i].cnf_major[j],
					lis_driver_config[i].cnf_str,
					lis_driver_config[i].cnf_n_minors,
					lis_driver_config[i].cnf_name ) < 0) {
			printk("Failed to register driver \"%s\".\n",
			       lis_driver_config[i].cnf_name);
			continue;
		}
	    }
		if (lis_driver_config[i].cnf_init != NULL)
			(*lis_driver_config[i].cnf_init)();
	}

	for (i = 0; i < AP_CONFIG_SIZE; ++i) {
		autopush_t *a;
		int err;

		if ((a = ALLOC(sizeof(autopush_t))) == NULL) {
			printk("Failed to allocate autopush entry.\n");
			continue;
		}

		if (lis_apush_init[i].minor == -1)
			a->cmd = SAP_ALL;
		else if (lis_apush_init[i].lastminor == 0)
			a->cmd = SAP_ONE;
		else
			a->cmd = SAP_RANGE;
		if (a->cmd == SAP_ALL)
			a->minor = a->lastminor = 0;
		else {
			a->minor = lis_apush_init[i].minor;
			a->lastminor = lis_apush_init[i].lastminor;
		}
		a->push.npush = 0 ;
		for (j = 0; j < lis_apush_init[i].npush; j++)
		{
		    modid = find_mod(lis_apush_init[i].mods[j]) ;
		    if (modid < 0)
			printk("Auto-push init: no module \"%s\"\n",
				lis_apush_init[i].mods[j]) ;
		    else
			a->push.mod[a->push.npush++] = modid ;
		}

		if ((err = apush_conf(lis_apush_init[i].major, a)) < 0) {
			FREE(a);
			printk("Failed to add initial autopush entry, "
			       "error = %d.\n", -err);
			continue;
		}
	}
	if (AP_CONFIG_SIZE > 0)
		printk("Added initial autopush entries.\n");
}

/*
 *  Shutdown
 */
void lis_terminate_mod(void)
{
    int i, j;

    apush_free_all();

    for (i = 0; i < DRV_CONFIG_SIZE; ++i)
    {
	if (lis_driver_config[i].cnf_term != NULL)
			(*lis_driver_config[i].cnf_term)();
	for (j = 0;  j < lis_driver_config[i].cnf_n_majors;  j++) {
	    if (lis_unregister_strdev(lis_driver_config[i].cnf_major[j]) < 0)
		    printk("Failed to unregister driver \"%s\".\n",
			   lis_driver_config[i].cnf_name);
	}
    }

    /*
     * The above catches all the configured modules and drivers.
     * Now we need to unregister all the loadables as well.
     */
    for (i = 1; i < MAX_STRMOD; i++)
    {
	if (unregister_module(&lis_fmod_sw[i]) < 0)
	    printk("Failed to unregister module \"%s\".\n",
						lis_fmod_sw[i].f_name);
    }

    for (i = 0; i < MAX_STRDEV; i++)
    {
	if (   lis_fstr_sw[i].f_str
	    && lis_fstr_sw[i].f_count
	    && lis_unregister_strdev(i) < 0
	   )
	    printk("Failed to unregister driver \"%s\".\n",
					   lis_fmod_sw[i].f_name);
    }
}

