#!/bin/bash

Configure_version="2.72 6/10/03"

if [ "$1" = "invoked from main makefile" ]; then
    MAKE_INVOKED=1
    shift
else
    MAKE_INVOKED=0
fi

CONFIG=${1:-config.in}

#
# agument parsing
#
arg1()
{
    printf "%s" $1
}
arg2()
{
    printf "%s" $2
}
arg3()
{
    printf "%s" $3
}
arg4()
{
    printf "%s" $4
}
arg5()
{
    printf "%s" $5
}

#
# do_readstring  - Ask for a string
#
# Inputs:
# 	PROMPT has the string to prompt the user with.
#	DEFAULT is the default response to use for empty input
# Outputs:
#	RESULT has the response from the user
#
do_readstring()
{
    while true; do
	echo -en "\n$PROMPT "
	if [ "$DEFAULT..." != "..." ]; then
	    echo -n "[default: $DEFAULT] "
	fi

	read RESULT

	if [ "$RESULT..." != "..." ]; then
	    return
	else
	    if [ "$DEFAULT..." != "..." ]; then
		RESULT=$DEFAULT
	        return
	    fi
	fi
    done
}

#
# Write a message to the user and get a CR to continue
#
do_confirm()
{
    PROMPT="$1"
    if [ "$1..." != "..." ]; then
	PROMPT="$PROMPT  "
    fi
    PROMPT="${PROMPT}Press Enter to continue... "
    echo -en "\n$PROMPT"
    read DISCARD
}

#
# do_read_dir  - Ask for name of an existing directory
#
# Inputs:
# 	PROMPT has the string to prompt the user with.
#	DEFAULT is the default response to use for empty input
# Outputs:
#	RESULT has the response from the user
#
do_read_dir()
{
    n=4
    while :; do
	do_readstring
	if [ -d $RESULT ]; then
	    return 0
	fi
	n=`expr $n - 1`
	if [ $n -eq 0 ]; then
	    return 1
	fi
    done
}

#
# do_read_choice  - Ask for a choice
#
# Inputs:
# 	PROMPT has the string to prompt the user with.
#	RESPONSE has the responses that are valid
#	DEFAULT is the default response to use for empty input
# Outputs:
#	RESULT has the response from the user
#
do_read_choice()
{
    # Check that we have valid responses and default
    if [ "$RESPONSE..." = "..." ]; then
	echo "Internal error."
	exit 1;
    fi
    local VALID_DEFAULT=0
    for i in $RESPONSE; do
        if [ "$ALTERNATE_DEFAULT..." = "..." ]; then
	    local ALTERNATE_DEFAULT=$i
	fi
        if [ "$i" = "$DEFAULT" ]; then
    	    local VALID_DEFAULT=1
	    break
        fi
    done
    if [ "$VALID_DEFAULT" = "0" ]; then
	DEFAULT=
    fi
    if [ "$DEFAULT..." = "..." ]; then
	DEFAULT=$ALTERNATE_DEFAULT
    fi

    while :; do
	do_readstring
	for i in $RESPONSE; do
	    if [ "$i" = "$RESULT" ]; then
		return
	    fi
	done
	echo "Unexpected response"
    done
}

#
# default_ksrc
#
# Figure out a good default for kernel source directory
# Do not retain any "../" isms in the path name.
#
default_ksrc()
{
    ksrc=/lib/modules/`uname -r`/build
    if [ -L $ksrc ]; then
	ksrc=`ls -l $ksrc | sed -e 's/^.*-> //' -e 's/\.\.\//\//g'`
        if [ -d "$ksrc" -o -L "$ksrc" ]; then
	    echo $ksrc
	else
	    echo "Unknown"
	fi
    elif [ -d /usr/src/linux -o -L /usr/src/linux ]; then
        echo "/usr/src/linux"
    else
        echo "Unknown"
    fi
}

#
# check_ksrc
#
# Check to see if the directory $KSRC is present.  If it is set to
# /usr/src/linux and that directory is not present then feel around
# a bit for a substitute to which a symbolic link can be constructed.
#
check_ksrc()
{
    if [ -d $KSRC ]; then
	return 0				# present
    fi

    if [ -L $KSRC ]; then
	return 0			# symbolic link, presume present
    fi

    if [ "$KSRC" != "/usr/src/linux" ]; then
	return 1				# not present
    fi

    #
    # pick up version string.  It might be like "2.4.2" or it
    # might be like "2.4.2-21smp".
    #
    vers=`cat /proc/version`
    vers=`arg3 $vers`
    trunc_vers=`echo $vers | sed -e 's/-.*//'`
    num_vers=`echo $vers | sed -e 's/[a-zA-Z][a-zA-Z]*//'`
    if [ -d /usr/src/$vers ]; then
	KSRC=/usr/src/$vers
    elif [ -d /usr/src/linux-$vers ]; then
	KSRC=/usr/src/linux-$vers
    elif [ -d /usr/src/linux$trunc_vers ]; then
	KSRC=/usr/src/linux$trunc_vers
    elif [ -d /usr/src/linux-$trunc_vers ]; then
	KSRC=/usr/src/linux-$trunc_vers
    elif [ -d /usr/src/linux$num_vers ]; then
	KSRC=/usr/src/linux$num_vers
    elif [ -d /usr/src/linux-$num_vers ]; then
	KSRC=/usr/src/linux-$num_vers
    else
	return 1				# not present
    fi

    return 0					# present
}

#
# Get config variable from config.h/autoconf.h.  If config.h is not present
# or does not have the config variable, try the "include/config" 
# subdirectory.
#
# $1 is the name of the variable to find.
#
# Return via stdout a "y" if defined or "" if not.
#
ac_get_config()
{
    if [ -f $KSRC/include/linux/config.h ]; then
	cc -I$KSRC/include -E -dM \
		-include $KSRC/include/linux/config.h dummy.c >kconfig
	x=`grep $1 kconfig 2>&1`
	if [ $? -eq 0 ]; then			# found it
	    if expr "$x" : "#define" >/dev/null 2>/dev/null; then
		echo -n "y"			# option selected
		return 0			# found
	    fi
	    if expr "$x" : "#undef" >/dev/null 2>/dev/null; then
		return 0			# found, but empty
	    fi
	fi
	#
	# If autoconf.h is present but our option is not mentioned
	# in a #define, then it must be in a #undef.  So assume
	# that the option is "found" but not set.
	#
	return 0				# found, but empty
    fi
						# no autoconf.h
    return 1					# not found
}

#
# Get config variable from .config
#
# $1 is the name of the variable to find, of the form "VAR=y".
#
# Return via stdout a "y" if defined or "" if not.
#
dc_get_config()
{
    x=`grep $1 $KSRC/.config 2>&1`
    if [ $? -ne 0 ]; then
	return 1
    fi
    echo -n "y"
    return 0			# found
}

#
# Get System.map file name on a Red Hat system
# 5.2 has one of them in /boot, 6.0 has several with a symbolic
# link from System.map to the one that is in use.
#
# This is only meaningful if the user intends to run LiS on the
# machine on which he is installing it.  So ask first.
#
# Return 0 (true) if found
#
rh_get_system_map()
{
    if [ "$BEEN_HERE_DONE_THIS..." = "1..." ]; then
	if [ "$SMAP..." = "..." ]; then
	    return 1
	fi
	return 0
    fi

    SMAP=
    PROMPT="\
Is it your intent to run LiS on the same machine on which\n\
you are installing it?  Or are you intending to cross compile\n\
for another machine?\n\
    y = I am going to run it on this machine\n\
    n = I am not going to run it on this machine\n\
Please enter y or n"
    RESPONSE="y n"
    DEFAULT=y
    do_read_choice
    BEEN_HERE_DONE_THIS=1
    if [ "$RESULT..." = "n..." ]; then
	echo
	echo "You really should load your kernel source and build"
	echo "your kernel before installing LiS."
	echo
	do_confirm
	return 1
    fi

    if [ ! -d /boot ]; then
	return 1
    fi
    if [ ! -L /boot/System.map ]; then
	files=`ls /boot/System.map*`
	if [ $? -ne 0 ]; then
	    return 1
	fi
	nfiles=0
	for i in $files; do
	    nfiles=`expr $nfiles + 1`
	done
	if [ $nfiles -ne 1 ]; then	# need just one of them
	    return 1
	fi

	SMAP=$i				# save file name
    else				# it's a symbolic link
	SMAP=/boot/System.map
    fi
    return 0
}

#
# Check for places that version.h may be hiding.  Try to establish it
# in the kernel source tree where it belongs.
#
check_kver()
{
    #
    # SuSE 7.2 lacks a version.h in the kernel source tree but has one
    # in /boot -- presumably paired with the running kernel version.
    # We will attempt to copy it if it is there and not care whether or
    # not the copy fails.  If we need a version.h in kernel source and
    # it isn't there then we will just write a message and terminate the
    # install.
    #
    if [    ! -f $KSRC/include/linux/version.h \
    	 -a -f /boot/vmlinuz.version.h \
	 -a -d $KSRC/include/linux \
       ]
    then
	cp /boot/vmlinuz.version.h $KSRC/include/linux/version.h \
		>/dev/null 2>/dev/null
    fi
}

#
# Try to extract the kernel version info from the version.h file
# The argument is the full pathname of the version.h file to extract
# from.
#
get_vers_h()
{
    if [ -f $1 ]; then
	cc -I$KSRC/include -E -dM \
	    -include $1 dummy.c >kver
	KVER_H=`grep UTS_RELEASE kver | \
	     sed -e 's/^.*UTS_RELEASE.//' -e's/"//g' -e's/  *$//'`
	NKVER_H=`echo $KVER_H | sed -e 's/-.*//'`
    fi
}

#
# Figure out kernel version
# Return the version string in KVER (e.g. 2.2.6)
#
get_kver()
{
    check_kver
    get_vers_h $KSRC/include/linux/version.h
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	KVER=`uname -r`
    elif [ -f $KSRC/include/linux/version.h ]; then
	KVER=$KVER_H
    elif [ -f $KSRC/vmlinux ]; then
	KVDEC=`nm -g $KSRC/vmlinux | grep Version_ | sed -e 's/^.*_//'`
	KMAJ=`expr $KVDEC / 65536`
	KMIN=`expr $KVDEC / 256`
	KMIN=`expr $KMIN % 256`
	KPCH=`expr $KVDEC % 256`
	KVER="$KMAJ.$KMIN.$KPCH"
    elif grep -q "Red Hat" /etc/issue && rh_get_system_map; then
	KVDEC=`grep Version_ $SMAP | sed -e 's/^.*_//'`
	KMAJ=`expr $KVDEC / 65536`
	KMIN=`expr $KVDEC / 256`
	KMIN=`expr $KMIN % 256`
	KPCH=`expr $KVDEC % 256`
	KVER="$KMAJ.$KMIN.$KPCH"
    else
        echo "The file $KSRC/include/linux/version.h is not present."
        echo "LiS installation cannot proceed without it.  Please fix"
        echo "this problem and then try the installation again."
        exit 1
    fi
    # Remove the extra version glarf from the end of kernel version
    NKVER=`echo $KVER | sed -e 's/-.*//'`
}


#
# Having dug out the kernel version from the kernel source info, now
# verify that the currently running kernel has the same settings.
#
kver_h_err_msg()
{
    echo
    echo "Your kernel source is for kernel version $KVER_H, but"
    echo "your running kernel is version $PKVER.  Installation"
    echo "will proceed by may encounter problems later."
    echo
    do_confirm
}

verify_kver()
{
    if [ ! -f /proc/sys/kernel/osrelease ]; then
	echo
	echo "The kernel version cannot be verified because there"
	echo "is no /proc/sys/kernel/osrelease present on the system."
	echo "Chances are that you will experience some kind of problem in"
	echo "loading or running LiS.  This problem really should"
	echo "be rectified before continuing with the installation."
	echo
	do_confirm
	return
    fi

    PKVER=`cat /proc/sys/kernel/osrelease`
    NPKVER=`echo $PKVER | sed -e 's/-.*//'`
    if [ "$NKVER" != "$NPKVER" ]; then
	echo
	echo "Your kernel source is for kernel version $NKVER, but"
	echo "your running kernel is version $NPKVER.  This is a"
	echo "good indication that you are not running on the kernel"
	echo "represented by the kernel source.  Please make the"
	echo "running kernel the same as the one in kernel source and"
	echo "then install LiS again."
	echo
	do_confirm
	exit 1
    fi

    if [ "$KVER_H..." = "..." ]; then
	echo
	echo "The file $KSRC/include/linux/versin.h is missing"
	echo "LiS needs thie file in order to build properly."
	echo "This may be an indication that there is no kernel"
	echo "source on this machine, or only partial kernel source."
	echo
	do_confirm
	exit 1
    fi

    if [ "$NKVER_H..." != "$NPKVER..." ]; then
	echo
	echo "Your kernel source is for kernel version $NKVER_H, but"
	echo "your running kernel is version $NPKVER.  This is a"
	echo "good indication that you are not running on the kernel"
	echo "represented by the kernel source.  Please make the"
	echo "running kernel the same as the one in kernel source and"
	echo "then install LiS again."
	echo
	do_confirm
	exit 1
    fi

    if [ "$KVER_H..." != "$PKVER..." ]; then
	if [ -f /boot/vmlinuz.version.h ]; then
	    OKVER_H=$KVER_H
	    get_vers_h /boot/vmlinuz.version.h
	    if [ "$KVER_H..." = "$PKVER..." ]; then
		echo
		echo "Your kernel source is for kernel version $OKVER_H, but"
		echo "your running kernel is version $PKVER.  However,"
		echo "the file /boot/vmlinuz.version.h has the correct"
		echo "information it it.  Installation will proceed by"
		echo "copying this file to $KSRC/include/linux/version.h."
		echo
		do_confirm
		if [ ! -f $KSRC/include/linux/version.h.orig ]; then
		    mv  $KSRC/include/linux/version.h \
			$KSRC/include/linux/version.h.orig
		fi
		cp -f /boot/vmlinuz.version.h $KSRC/include/linux/version.h
	    else
		kver_h_err_msg
	    fi
	else
	    kver_h_err_msg
	fi
    else
	echo "Kernel version verified between kernel source and running kernel"
    fi
}

#
# Red Hat helper for getting SMP info
#
# Return 0 (true) if found, 1 (false) if not
#
rh_get_smp()
{
    if ! grep -q "Red Hat" /etc/issue || ! rh_get_system_map; then
	return 1
    fi

    if grep -w -q cpu_online_map $SMAP; then
	NEED_KSMP=0
	KSMP=y			# SMP kernel
    else
	KSMP=			# non-SMP kernel
    fi
    return 0			# got info
}

#
# Get SMP or not
# Return result in KSMP
#
get_smp()
{
    NEED_KSMP=0				# default is "found"
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	if grep -q cpu_online_map /proc/ksyms; then
	    KSMP=y
	else
	    KSMP=
	fi
    else
	KSMP=`ac_get_config CONFIG_SMP`	# check autoconf.h
	if [ $? -eq 0 ]; then		# found
	    : OK
	elif [ -f $KSRC/vmlinux ]; then	# compiled kernel?
	    if nm -g $KSRC/vmlinux |grep -w -q cpu_online_map; then
		KSMP=y			# SMP kernel
	    else
		KSMP=			# non-SMP kernel
	    fi
	elif [ -f $KSRC/.config ]; then	# kernel .config file?
	    KSMP=`dc_get_config "CONFIG_SMP=y"`
	else
	    NEED_KSMP=1			# still need the option
	fi
    fi

    if [ "$KSMP..." = "y..." ]; then
	echo "Kernel support for SMP detected."
    else
	echo "No kernel support for SMP detected."
    fi
}

#
# Helper routine for Red Hat systems.  This is invoked when there
# is no vmlinux available.  If the system is Red Hat we look at the
# System.map file in /boot for some of our information.
#
# Return 0 (true) if found, 1 (false) if not
#
rh_get_modules()
{
    if ! grep -q "Red Hat" /etc/issue || ! rh_get_system_map; then
	return 1
    fi

    if grep -q init_modules $SMAP; then
	NEED_KMODULES=0
	KMODULES=y			# Module support
	if grep -q unregister_chrdev_R /proc/ksyms; then
	    KMODVERS=y
	else
	    KMODVERS=
	fi
    else
	KMODULES=			# No module support
    fi
    return 0
}

#
# Get Modules or not
# Return result in KMODULES
#
get_modules()
{
    NEED_KMODULES=0				# default is "found"
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	KMODULES=y
	if grep -q schedule_R /proc/ksyms; then
	    KMODVERS=y
	else
	    KMODVERS=
	fi

    else
	KMODULES=`ac_get_config CONFIG_MODULES`	# check autoconf.h
	if [ $? -eq 0 ]; then		# found
	    KMODVERS=`ac_get_config CONFIG_MODVERSIONS`
	elif [ -f $KSRC/vmlinux ]; then	# compiled kernel?
	    if nm -g $KSRC/vmlinux |grep -w -q init_modules; then
		KMODULES=y			# module support
		if strings $KSRC/vmlinux |grep -q Using_Versions; then
		    KMODVERS=y
		else
		    KMODVERS=
		fi
	    else
		KMODULES=			# non-module support
	    fi
	elif [ -f $KSRC/.config ]; then	# kernel .config file?
	    KMODULES=`dc_get_config "CONFIG_MODULES=y"`
	    if [ "$KMODULES..." = "y..." ]; then
		KMODVERS=`dc_get_config "CONFIG_MODVERSIONS=y"`
	    fi
	else
	    NEED_KMODULES=1			# still need the option
	fi
    fi

    if [ "$KMODVERS..." = "y..." ]; then
	echo "Kernel support for mod-versions detected."
    else
	echo "No kernel support for mod-versions detected."
    fi
}



#
# From /proc/ksyms, generate a C header file with defines for all
# of the version-mangled symbol names.
#
generate_symbol_names()
{
    grep _R /proc/ksyms | sed -e 's/^.........//' -e 's/[ 	].*//' |
    	sed 's/\(.*\)_R\(.*\)/#define \1 \1_R\2/'
}

#
# From what LiS has gleaned from /proc, generate a little autoconf.h
# file that has the correct settings for MODULES, MODVERSIONS and SMP.
#
generate_autoconf()
{
    acf="include/sys/autoconf.h"
    echo '/* FILE AUTOMATICALLY GENERATED BY LIS CONFIGURE.' >$acf
    echo ' * DO NOT EDIT BY HAND' >>$acf
    echo ' */' >>$acf

    if [ "$KSMP" = "y" ]; then
	echo "#define CONFIG_SMP 1" >>$acf
    else
	echo "#undef CONFIG_SMP" >>$acf
    fi
    if [ "$KMODULES" = "y" ]; then
	echo "#define CONFIG_MODULES 1" >>$acf
    else
	echo "#undef CONFIG_MODULES" >>$acf
    fi
    if [ "$KMODVERS" = "y" ]; then
	echo "#define CONFIG_MODVERSIONS 1" >>$acf
    else
	echo "#undef CONFIG_MODVERSIONS" >>$acf
    fi
    LISAUTOCONF=y
}

#
# get_empty_inode_option
#
# Try to find out whether or not the routine that gets an empty inode
# is still called "get_empty_inode" or "new_inode".
#
# This must be done after it is known whether we are going to install
# on the running kernel and whether there is kernel source available.
#
get_empty_inode_option()
{
    if [ "$TARGET" != "l" ]; then
	return				# not relevant unless Linux kernel
    fi

    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	if grep -q new_inode /proc/ksyms; then
	    GET_EMPTY_INODE="new_inode(LIS_SB)"
	elif grep -q get_empty_inode /proc/ksyms; then
	    GET_EMPTY_INODE="get_empty_inode()"
	else
	    GET_EMPTY_INODE="get_empty_inode()"
	    echo "Your running kernel exports neither the symbol"
	    echo "get_empty_inode nor new_inode.  The compilation of"
	    echo "LiS will probably print warnings related to"
	    echo "these symbols, and LiS will probably fail to"
	    echo "load as a module."
	    do_confirm
	fi
	return
    elif [ -f $KSRC/kernel/ksyms.c ]; then
	if grep -q new_inode $KSRC/kernel/ksyms.c; then
	    GET_EMPTY_INODE="new_inode(LIS_SB)"
	elif grep -q get_empty_inode $KSRC/kernel/ksyms.c; then
	    GET_EMPTY_INODE="get_empty_inode()"
	else
	    GET_EMPTY_INODE="get_empty_inode()"
	    echo "Your kernel source exports neither the symbol"
	    echo "get_empty_inode nor new_inode.  The compilation of"
	    echo "LiS will probably print warnings related to"
	    echo "these symbols, and LiS will probably fail to"
	    echo "load as a module."
	    do_confirm
	fi
	return
    else
	GET_EMPTY_INODE="get_empty_inode()"
	echo "You have told the LiS installation that you do not"
	echo "intend to run LiS on the running kernel and we cannot"
	echo "find the file $KSRC/kernel/ksyms.c"
	echo "One or the other is necessary to determine whether"
	echo "to use get_empty_inode or new_inode.  The compilation of"
	echo "LiS will probably print warnings related to"
	echo "these symbols, and LiS will probably fail to"
	echo "load as a module."
	do_confirm
    fi
}

#
# check the compiler version used to compile the kernel against
# the version info of various C compilers that are available.
#
C_compiler_version()
{
    if [ ! -x /usr/bin/$1 ]; then
	return 1
    fi

    CC_VERS=`/usr/bin/$1 -v 2>&1 | \
    	    grep 'gcc version' | \
	    sed -e 's/^.*gcc version // ' -e 's/ .*//' -e 's/^.*-//'`

    echo $CC_VERS
}

kernel_cc_version()
{
    V=`cat /proc/version | \
    	    grep 'gcc version' | \
	    sed -e 's/^.*gcc version // ' -e 's/ .*//' -e 's/^.*-//'`
    echo $V
}

pick_a_c_compiler()
{
    KERN_CC_VERS=`kernel_cc_version`
    if [ "$KERN_CC_VERS..." = "..." ]; then
	return 1
    fi

    CC_VERS=`C_compiler_version kgcc`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo kgcc
	return 0
    fi

    CC_VERS=`C_compiler_version gcc`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo gcc
	return 0
    fi

    CC_VERS=`C_compiler_version gcc3`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo gcc3
	return 0
    fi

    CC_VERS=`C_compiler_version cc`
    if [ "$CC_VERS..." = "$KERN_CC_VERS..." ]; then
	echo cc
	return 0
    fi

    return 1
}



#
# Establish defaults
#
echo "LiS Configure script version $Configure_version"
echo

if [ -f $CONFIG ]; then
. $CONFIG
else
    USING_DEFAULTS=y
    CROSS_COMPILING=n
    TARGET=l
    CONFIG_STREAMS=m
    MOD_INSTALL=y
    KSRC=`default_ksrc`
    check_ksrc
    CONFIG_MK_KERNEL=n
    STRMS_QUEUES=t
    DBG_OPT=D
    LIS_SHLIB=y
    MACHINE=`uname -m`
    INT_PSW=y
fi

#
# LIS_HOME
#
# Plant a symbolic link from /usr/src/LiS to whereever this directory is.
# Remember our directory name as either its real name or as /usr/src/LiS
# if /usr/src/LiS is symbolically linked to this directory.
#
LIS_HOME=`pwd`

if [ -L /usr/src/LiS ]; then
    usr_src_lis=`ls -l /usr/src/LiS | sed -e 's/^.* //' | sed -e 's/\/$//'`
else
    usr_src_lis=
fi
if [ "$LIS_HOME" = "$usr_src_lis" ]; then
    LIS_HOME="/usr/src/LiS"
elif [ `id -u` -eq 0 ]; then
    if [ -L /usr/src/LiS ]; then
	rm /usr/src/LiS
	if [ $? -ne 0 ]; then
	    echo "Error removing symbolic link /usr/src/LiS"
	fi
    fi
    if [ "$LIS_HOME" = "/usr/src/LiS" ]; then
	LIS_HOME=$usr_src_lis
    fi
    if [ $LIS_HOME != "/usr/src/LiS" ]; then
	ln -s $LIS_HOME /usr/src/LiS
	if [ $? -ne 0 ]; then
	    echo "Error making symbolic link from /usr/src/LiS to $LIS_HOME."
	    echo "Please fix this problem and try again."
	    exit 1
	fi
    fi
    LIS_HOME="/usr/src/LiS"
fi

#
# TARGET
#
PROMPT="\
How do you want to configure STREAMS?\n\
    l = to run in the Linux kernel\n\
    u = to run in user level\n\
    q = to run under QNX (may not work)\n\
Please enter your choice"
RESPONSE="l u q"
DEFAULT="$TARGET"
do_read_choice
TARGET=$RESULT

if [ "$TARGET" = "l" ]; then
    #
    # The linux target needs some special handling
    #
    PROMPT="\
Are you using the native Linux C compiler (y) or\n\
are you cross-compiling using a different compiler (n)?\n\
Native C (y) or cross-compile (n)?"
        RESPONSE="y n"
        do_read_choice
        case $RESULT in
	    y)
		    CROSS_COMPILING=n
		    ;;
	    n)
		    CROSS_COMPILING=y
		    echo
		    echo "You should create a file named \"cross-compile\""
		    echo "which contains \"make\" assignments for the name"
		    echo "of your cross compiler.  See the file config.mk"
		    echo "for more information on this."
		    echo
		    do_confirm
		    ;;
        esac

    #
    # See if the GNU Libc stropts.h is an old version.  If so, substitute
    # the new 2.2 version.
    #
    if grep -w -q RDNORM /usr/include/sys/bits/stropts.h 2>/dev/null; then
	mv /usr/include/sys/bits/stropts.h /usr/include/sys/bits/stropts.h.orig
	cp -f ./include/sys/gnu.stropts.h /usr/include/sys/bits/stropts.h
	echo "Updated version of stropts.h installed in /usr/include/sys/bits"
    fi

    #
    # Verify kernel version, SMP and mod versions against the running
    # kernel if the user says that he/she intends to install on the
    # running kernel.
    #
    PROMPT="\
Do you intend to run LiS on this machine with\n\
the currently running kernel?"
    RESPONSE="y n"
    do_read_choice
    case $RESULT in
	y) USE_RUNNING_KERNEL=y ;;
	n) USE_RUNNING_KERNEL= ;;
    esac

    #
    # Kernel source location
    #
    if [ "$USE_RUNNING_KERNEL..." = "..." ]; then
	PROMPT="Enter directory location of your kernel source\n          "
	DEFAULT=$KSRC
	if [ "$KSRC..." = "..." ]; then
	    DEFAULT="/usr/src/linux"
	fi
	if [ ! -d $KSRC ]; then
	    DEFAULT="/usr/src/linux"
	    check_ksrc
	fi
	if do_read_dir; then
	    KSRC=$RESULT
	    NOKSRC=0
	else
	    echo "Cannot locate kernel source."
	    echo "Will use /usr/include for header files."
	    KSRC=/usr
	    NOKSRC=1
	fi
    else
	NOKSRC=0
	if [ -d $KSRC ]; then
	    : Retain default setting
	elif [ -d /usr/src/linux ]; then
	    KSRC=/usr/src/linux
	else
	    echo
	    echo "No apparent kernel source directory.  LiS compilation"
	    echo "may very well fail.  If this should happen, load your"
	    echo "kernel source, or reinstall your kernel with source"
	    echo "and install LiS again."
	    echo
	    do_confirm
	    KSRC=/usr
	    NOKSRC=1		# act as though no kernel source
	fi
	echo "Will use $KSRC/include for header files."
    fi

    #
    # Try to dig some info out of the kernel binary "vmlinux".  If we
    # can find out this stuff from the binary then we don't need the
    # .config file
    #
    get_kver
    get_smp
    get_modules
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	verify_kver
    fi
    if [ $NEED_KSMP -eq 1 -o $NEED_KMODULES -eq 1 ]; then
	if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	    echo "Could not figure out whether or not your running kernel"
	    echo "was compiled with SMP or MODULES set.  Installation aborted."
	    exit 1
	fi
	NEED_KCONFIG=1		# couldn't access kernel binary
    else
	NEED_KCONFIG=0		# have info from kernel binary
    fi

    #
    # See if the kernel's .config file is there.  If not then the user
    # has not done a "make menuconfig" yet.
    #
    if [ $NOKSRC -eq 0 -a $NEED_KCONFIG -eq 1 -a ! -f $KSRC/.config ]; then
        PROMPT="\
It appears that you have not done a 'make menuconfig' on\n\
your kernel in $KSRC yet.  You should do that now to avoid\n\
problems with the installation.\n\
Do you want to do that now?"
        RESPONSE="y n"
        do_read_choice
        case $RESULT in
	    y)
		    if ! make -C $KSRC menuconfig; then
		        echo "Menuconfig failed.  LiS installation aborted."
		        exit 1
		    fi
		    echo "Make menuconfig was successful."
		    echo "Continuing with LiS installation."
		    ;;
	    n)
		    echo "OK, but this may cause problems with the installation."
		    ;;
        esac
    fi

    #
    # If we have a kernel configuration now, source it.
    #
    if [ $NEED_KCONFIG -eq 1 -a -f $KSRC/.config ]; then
        . $KSRC/.config
    fi

    #
    # See if version.h is there.  It may not be if the user just unpacked
    # a fresh version of Linux and has not done a "make dep" yet.
    #
    if [ $NEED_KCONFIG -eq 1 ]; then
	check_kver
    fi
    #
    # Now see if there is one present.
    #
    if [ $NEED_KCONFIG -eq 1 -a ! -f $KSRC/include/linux/version.h ]; then
        PROMPT="\
It appears that you have not done a 'make dep' on your kernel yet.\n\
You will have to do this to proceed.\n\
Do you want to do that now?"
        RESPONSE="y n"
        do_read_choice
        case $RESULT in
	    y)
	        if ! make -C $KSRC dep; then
	            echo "Make dep failed.  LiS installation aborted."
	            exit 1
	        fi
	        echo "Make dep was successful."
		echo "Continuing with LiS installation."
	        ;;
	    n)
		echo "LiS installation cannot proceed until this is done."
		echo "Please fix the problem and then try again."
		exit 1
		;;
        esac
    fi

    #
    # Kernel version
    #
    if [ "$USE_RUNNING_KERNEL..." = "y..." ]; then
	echo "Running kernel is version $KVER"
    else
	DEFAULT=$KVER
	PROMPT="Which version of the kernel are you building for?"
	do_readstring
	KVER=$RESULT
    fi
    
    KVER_PATCH=`echo ${KVER}|sed -e "s/[^\.]\.[^\.]\.//"`
    KVER_PATCHNO=`echo $KVER_PATCH | sed -e 's/-.*//' -e 's/[^0-9].*//'`
    KVER_MAJORMINOR=`echo ${KVER}|sed -e "s/\.${KVER_PATCH}//"`
    KVER_MINOR=`echo ${KVER_MAJORMINOR}|sed -e "s/[^\.]\.//"`
    KVER_MAJOR=`echo ${KVER}|sed -e "s/\.${KVER_MINOR}\.${KVER_PATCH}//"`

    if [ "$KVER_MAJORMINOR" = "2.0" ]; then
	echo
	echo "LiS no longer supports 2.0 vintage kernels. Try LiS-2.8"
	echo
	exit 1
    fi

    

    #
    # CONFIG_STREAMS
    #
    # If we have concluded that the kernel does not support modules
    # then we need to inform the user of what is going on.  It is
    # next to impossible for a kernel not to support modules these
    # days.
    #
    if [ "$KMODULES" != "y" ]; then
	echo
	echo "Analysis of your kernel configuration suggests that your kernel"
	echo "does not support loadable modules.  This is extremely rare and"
	echo "is likely a result of mis-analysis of the kernel configuration"
	echo "files.  Installation will proceed as if the kernel supports"
	echo "loadable modules."
	echo 
    fi

    CONFIG_STREAMS=m

    #
    # See if the user wants STREAMS kernel loadable modules installed for
    # easy running.  Leaving the module for later loading is what is
    # needed for cross compiling.
    #
    PROMPT="\
After building STREAMS, do you want kernel loadable modules installed?\n\
This allows you to load it by typing in \"insmod streams\".\n\
    y = install it for module loading\n\
    n = just leave modules for later \"make modules_install\"\n\
Please enter y or n "
    RESPONSE="y n"
    DEFAULT="$MOD_INSTALL"
    do_read_choice
    MOD_INSTALL=$RESULT

    #
    # MOD_INST_DIR
    #
    PROMPT="Enter location of your kernel module directory\n"
    PROMPT="$PROMPT              "
    if [ "$MOD_INST_DIR..." = "..." ]; then
	DEFAULT=/lib/modules/$KVER/misc
	if [ ! -d $DEFAULT ]; then
	    DEFAULT=/lib/modules/$KVER/misc
	    if [ ! -d $DEFAULT ]; then
		DEFAULT=/lib/modules/preferred/misc
		if [ ! -d $DEFAULT ]; then
		    if [ `id -u` -eq 0 ]; then
			DEFAULT=/lib/modules/$KVER/misc
			if ! mkdir -p $DEFAULT 2>/dev/null; then
			    DEFAULT=/lib/modules/preferred/misc
			    if ! mkdir -p $DEFAULT 2>/dev/null; then
				DEFAULT=
			    fi
			fi
		    else
		    DEFAULT=
		    fi
		fi
	    fi
	fi
    else
	DEFAULT=$MOD_INST_DIR
    fi
    if [ "$USE_RUNNING_KERNEL..." = "y..." -a "$DEFAULT..." != "..." ]; then
	if [ -d $DEFAULT ]; then
	    MOD_INST_DIR=$DEFAULT
	else
	    do_read_dir
	    MOD_INST_DIR=$RESULT
	fi
    else
	do_read_dir
	MOD_INST_DIR=$RESULT
    fi
    echo "Module installation directory is $MOD_INST_DIR"

    #
    # STRMS_QUEUES
    #
    # Streams queues are always run as tasklets these days.
    #
    STRMS_QUEUES="t"

    if [ $NOKSRC -eq 1 -a "$KMODVERS..." = "y..." ]; then
	echo "Generating $LIS_HOME/include/sys/modversions.h."
	rm -f include/sys/modversions.h
	generate_symbol_names >include/sys/modversions.h
	LISMODVERS=y
    fi


else # Not a Linux kernel target
    # These configuration items only make sense in the Linux kernel
    KSRC=
    KVER=
    CONFIG_MK_KERNEL=
    STRMS_QUEUES=
    MOD_INST_DIR=
    MOD_INSTALL=
    KSMP=
    KMODULES=
    CONFIG_STREAMS=
fi # Not a Linux kernel target

#
# LIS_OLD_CONSTS
#
if [ "$LIS_OLD_CONSTS..." = "..." ]; then
    LIS_OLD_CONSTS=n
fi
PROMPT="\
When you make STREAMS, do you want to use backward compatible constants\n\
in the file stropts.h?  If you answer No (the default) you will get\n\
constants that are compatible with UnixWare and Solaris, but which\n\
differ somewhat from previous versions of LiS.  If you answer Yes\n\
you will get constants that are compatible with previous versions of\n\
LiS but somewhat incompatible with UnixWare and Solaris.  If you\n\
intend to run application programs that were compiled with LiS-2.6\n\
or earlier then they have the old constants compiled into them and\n\
you should answer Yes to this question.\n\
    y = LiS backward compatible constants in stropts.h\n\
    n = UnixWare/Solaris compatible constants in stropts.h\n\
Please enter y or n"
RESPONSE="y n"
DEFAULT=$LIS_OLD_CONSTS
do_read_choice
LIS_OLD_CONSTS=$RESULT
if [ "$LIS_OLD_CONSTS..." = "y..." ]; then
    echo
    echo "When you compile your application programs you must include"
    echo "-DUSE_OLD_CONSTS on the command line so that your program"
    echo "uses the same values as LiS is being compiled with.  If you"
    echo "have an application program that was compiled with LiS-2.6"
    echo "or earlier then it has the old constants built into it."
    echo "It is to be preferred to use the new UnixWare/Solaris"
    echo "compatible constants as soon as it is practicable for you."
    echo
    do_confirm
fi

#
# SOLARIS_STYLE_CMN_ERR
#
if [ "$SOLARIS_STYLE_CMN_ERR..." = "..." ]; then
    SOLARIS_STYLE_CMN_ERR=n
fi
PROMPT="\
When you make STREAMS, do you want to use Solaris style cmn_err?\n\
In Solaris the newline goes on the end of the message.  For SVR4\n\
style cmn_err the newline goes on the beginning.\n\
    y = Solaris style cmn_err\n\
    n = SVR4 style cmn_err\n\
Please enter y or n"
RESPONSE="n y"
DEFAULT=$SOLARIS_STYLE_CMN_ERR
do_read_choice
SOLARIS_STYLE_CMN_ERR=$RESULT

#
# DBG_OPT
#
# Defaults to y for user build and to n for others
#
if [ "$DBG_OPT" = "D" ]; then
    if [ "$TARGET" = "u" ]; then
	DBG_OPT=y
    else
	DBG_OPT=n
    fi
fi
PROMPT="\
When you make STREAMS, do you want to compile for source level debugging?\n\
This is most useful when STREAMS is linked into the kernel and the\n\
gdbstub patch is installed in the kernel for kernel source level debugging.\n\
    y = set up for source level debugging\n\
    n = no source level debugging\n\
Please enter y or n"
RESPONSE="y n"
DEFAULT=$DBG_OPT
do_read_choice
DBG_OPT=$RESULT


#
# LIS_SHLIB
#
if [ "$TARGET" = "l" ]; then
    PROMPT="\
Do you want to use shared libraries?
If you select static linking, you will get larger binaries that run by
themselves. If you select dynamic linking, the binaries will be smaller but
you will have to install the shared libraries in a directory that is in your
LD_LIBRARY_PATH environment variable.
    y = use dynamic linking with shared libraries\n\
    n = use static linking\n\
Please enter y or n"
    RESPONSE="y n"
    DEFAULT=$LIS_SHLIB
    do_read_choice
    LIS_SHLIB=$RESULT
else
    LIS_SHLIB=n
fi

#
# INT_PSW
#
if [ "$INT_PSW..." = "..." ]; then
    INT_PSW=y
fi
PROMPT="\
When you make STREAMS, do you want to use int type for CPU flags?\n\
Responding 'n' is more portable but may cause warnings when you\n\
compile your driver code.\n\
    y = int type for CPU flags\n\
    n = unsigned long type for CPU flags\n\
Please enter y or n"
RESPONSE="y n"
DEFAULT=$INT_PSW
do_read_choice
INT_PSW=$RESULT

#
# Some systems don't have a /usr/local/sbin directory.  Make one
# if necessary.  We keep some LiS utilities in that directory.
#
if [ `id -u` -eq 0 ]; then			# must be root to do this
    if [ ! -d /usr/local/sbin ]; then
	mkdir -p /usr/local/sbin
    fi
fi

#
# Red Hat 7.1 needs a kludge related to including highmem.h from vmalloc.h.
#
if [ "$TARGET" = "l" ]; then
    if [ -f $KSRC/include/linux/vmalloc.h ]; then
	if grep -q "Red Hat Linux 7.1" /proc/version &&
	   grep -q 'highmem\.h' $KSRC/include/linux/vmalloc.h; then
	    RH_71_KLUDGE=y
	fi
    fi
fi

#
# 2.4.20 (or thereabouts) changed the location of the signal mask lock
#
if [ "$TARGET" = "l" ]; then
    if [ -f $KSRC/include/linux/sched.h ]; then
	if grep -q 'sigmask_lock' $KSRC/include/linux/sched.h; then
	    SIGMASKLOCK=y
	fi
    elif [ "$KVER_MAJORMINOR" = "2.4" -a $KVER_PATCHNO -ge 20 ]; then
	    SIGMASKLOCK=y
    elif [ "$KVER_MAJORMINOR" = "2.5" ]; then
	    SIGMASKLOCK=y
    elif [ "$KVER_MAJORMINOR" = "2.6" ]; then
	    SIGMASKLOCK=y
    fi
fi

#
# Red Hat changed the number of arguments in recalc_sigpending
#
if [ "$TARGET" = "l" ]; then
    if [ -f $KSRC/include/linux/sched.h ]; then
	if grep -q 'recalc_sigpending(void)' $KSRC/include/linux/sched.h; then
	    RCVOID=y
	fi
    elif [ -f /usr/src/linux/include/linux/sched.h ]; then
	if grep -q 'recalc_sigpending(void)' \
		/usr/src/linux/include/linux/sched.h; then
	    RCVOID=y
	fi
    fi
fi


#
# Decide which C compiler to use.  gcc 2.96 is buggy, so try to use
# something better if it is present.
#
# The default is plain old gcc with -O2.
#
get_cc_from_makefile()
{
    make --no-print-directory -C $KSRC script 'SCRIPT=@echo $(CC)' | \
        sed -e 's/ .*//'
}

if   [ "$TARGET" = "l"  ]; then
    export KERN_CC_VERS=`kernel_cc_version`
    if [ "$KERN_CC_VERS..." = "..." ]; then
	echo
	echo "Could not determine the version of C compiler that was used"
	echo "to build your kernel.  Installation will proceed using the"
	echo "standard gcc compiler version `C_compiler_version gcc`, but"
	echo "there may be problems when you try to run LiS."
	echo
	do_confirm
	CC_NAME=gcc
	CC_VERS=`C_compiler_version gcc`
    else
	export CC_NAME=`pick_a_c_compiler`
	if [ "$CC_NAME..." = "..." ]; then
	    echo
	    echo "Could not identify a C compiler of version $KERN_CC_VERS."
	    echo "This compiler was used to compile your kernel and should"
	    echo "be used to compile LiS.  Installation will proceed using"
	    echo "the standard gcc compiler version `C_compiler_version gcc`,"
	    echo "but there may be problems when you try to run LiS."
	    echo
	    do_confirm
	    CC_NAME=gcc
	    CC_VERS=`C_compiler_version gcc`
	else
	    CC_VERS=`C_compiler_version cc`
	fi
    fi

    case $CC_NAME in
    kgcc)	CC_OPTIMIZE=-O3;;
    egcs)	CC_OPTIMIZE=-O3;;
    gcc3)	CC_OPTIMIZE=-O3;;
    gcc)	CC_OPTIMIZE=-O2;;
    cc)		CC_OPTIMIZE=-O2;;
    *)		CC_OPTIMIZE=-O2;;
    esac
else
    echo
    echo "Non-Linux install.  Using cc as default C compiler."
    echo
    CC_NAME=cc
    CC_OPTIMIZE=-O
    CC_VERS=`C_compiler_version cc`
fi

if [ "$CC_VERS..." = "3.0.2..." ]; then
    echo
    echo "Compiler $CC_NAME $GCC_VERS is known to be buggy when"
    echo "compiling kernel code such as LiS.  You will probably"
    echo "experience problems, and perhaps crashes, when running LiS."
    echo
    do_confirm
fi

echo "Using \"$CC_NAME $CC_OPTIMIZE\" $CC_VERS as the C compiler"

#
# Figure out which routine name to use for "get_empty_inode".
#
get_empty_inode_option

#
# Some architectures need an additional include directory
# When installing with no kernel source we will use /usr/src/linux anyway
# and just hope that this stuff got installed even though the rest of the
# source is not there.
#
case $MACHINE in
i?86)	MACHINE_INCL="-I$KSRC/arch/i386/mach-generic" ;;
esac

#
# Finally output configuration file
#

cfg_out()
{
    if [ $# = 2 ]; then
        echo "$1=$2" >>$CONFIG
    else
        echo "# $1 is not set" >>$CONFIG
    fi
}

cfg_out_str()
{
    if [ $# = 2 ]; then
        echo "$1=\"$2\"" >>$CONFIG
    else
        echo "# $1 is not set" >>$CONFIG
    fi
}

echo "" >$CONFIG
echo "# This file is generated from the Configure script" >>$CONFIG
echo "# Do not edit manually." >>$CONFIG
echo "" >>$CONFIG
cfg_out LIS_HOME $LIS_HOME
cfg_out CONFIG_STREAMS $CONFIG_STREAMS
cfg_out TARGET $TARGET
if [ "$TARGET" = "l" ]; then
    cfg_out CROSS_COMPILING $CROSS_COMPILING
    cfg_out KSRC $KSRC
    cfg_out NOKSRC $NOKSRC
    cfg_out USE_RUNNING_KERNEL $USE_RUNNING_KERNEL
    cfg_out NKVER $NKVER
    cfg_out KVER $KVER
    cfg_out KVER_MAJOR $KVER_MAJOR
    cfg_out KVER_MINOR $KVER_MINOR
    cfg_out KVER_PATCH $KVER_PATCH
    cfg_out KVER_PATCHNO $KVER_PATCHNO
    cfg_out KVER_MAJORMINOR $KVER_MAJORMINOR
    cfg_out KVER_H $KVER_H
    cfg_out NKVER_H $NKVER_H
    cfg_out KSMP $KSMP
    cfg_out KMODULES $KMODULES
    cfg_out KMODVERS $KMODVERS
    cfg_out LISMODVERS $LISMODVERS
    cfg_out LISAUTOCONF $LISAUTOCONF
    cfg_out CONFIG_MK_KERNEL $CONFIG_MK_KERNEL 
    cfg_out STRMS_QUEUES $STRMS_QUEUES
    cfg_out MOD_INST_DIR $MOD_INST_DIR
    cfg_out MOD_INSTALL $MOD_INSTALL
    cfg_out RH_71_KLUDGE $RH_71_KLUDGE
    cfg_out SIGMASKLOCK $SIGMASKLOCK
    cfg_out RCVOID $RCVOID
    cfg_out MACHINE $MACHINE
    cfg_out CC_NAME $CC_NAME
    cfg_out CC_VERS $CC_VERS
    cfg_out CC_OPTIMIZE $CC_OPTIMIZE
    cfg_out MACHINE_INCL $MACHINE_INCL
    cfg_out_str GET_EMPTY_INODE $GET_EMPTY_INODE 
    #cfg_out REGISTER_SYSCALLS $REGISTER_SYSCALLS
    cfg_out INT_PSW $INT_PSW
fi
cfg_out LIS_OLD_CONSTS $LIS_OLD_CONSTS
cfg_out SOLARIS_STYLE_CMN_ERR $SOLARIS_STYLE_CMN_ERR
cfg_out DBG_OPT $DBG_OPT
cfg_out LIS_SHLIB $LIS_SHLIB

if [ "$MAKE_INVOKED" != "1" ]; then
    echo
    echo "Warning:"
    echo "You did not use \"make configure\" to run this configuration."
    echo "Please do \"make clean && make dep\" first to get a clean build."
fi
